import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type RequireFields<T, K extends keyof T> = { [X in Exclude<keyof T, K>]?: T[X] } & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A location in a connection that can be used for resuming pagination. */
  Cursor: any;
  /** The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf). */
  JSON: any;
  /** A point in time as described by the [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone. */
  Datetime: any;
  /** The day, does not include a time. */
  Date: any;
  /** A signed eight-byte integer. The upper big integer values are greater than the max value for a JavaScript number. Therefore all big integers will be output as strings and not numbers. */
  BigInt: any;
};

export type ActionPlugin = Node & {
  __typename?: 'ActionPlugin';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  code: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  functionName?: Maybe<Scalars['String']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']>>>;
  outputProperties?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/**
 * A condition to be used against `ActionPlugin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ActionPluginCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `path` field. */
  path?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `functionName` field. */
  functionName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `requiredParameters` field. */
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `outputProperties` field. */
  outputProperties?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** A filter to be used against `ActionPlugin` object types. All fields are combined with a logical ‘and.’ */
export type ActionPluginFilter = {
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `path` field. */
  path?: Maybe<StringFilter>;
  /** Filter by the object’s `functionName` field. */
  functionName?: Maybe<StringFilter>;
  /** Filter by the object’s `requiredParameters` field. */
  requiredParameters?: Maybe<StringListFilter>;
  /** Filter by the object’s `outputProperties` field. */
  outputProperties?: Maybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ActionPluginFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ActionPluginFilter>>;
  /** Negates the expression. */
  not?: Maybe<ActionPluginFilter>;
};

/** An input for mutations affecting `ActionPlugin` */
export type ActionPluginInput = {
  code: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  functionName?: Maybe<Scalars['String']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']>>>;
  outputProperties?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** Represents an update to a `ActionPlugin`. Fields that are set will be updated. */
export type ActionPluginPatch = {
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  functionName?: Maybe<Scalars['String']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']>>>;
  outputProperties?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** A connection to a list of `ActionPlugin` values. */
export type ActionPluginsConnection = {
  __typename?: 'ActionPluginsConnection';
  /** A list of `ActionPlugin` objects. */
  nodes: Array<Maybe<ActionPlugin>>;
  /** A list of edges which contains the `ActionPlugin` and cursor to aid in pagination. */
  edges: Array<ActionPluginsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActionPlugin` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ActionPlugin` edge in the connection. */
export type ActionPluginsEdge = {
  __typename?: 'ActionPluginsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ActionPlugin` at the end of the edge. */
  node?: Maybe<ActionPlugin>;
};

/** Methods to use when ordering `ActionPlugin`. */
export enum ActionPluginsOrderBy {
  Natural = 'NATURAL',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  FunctionNameAsc = 'FUNCTION_NAME_ASC',
  FunctionNameDesc = 'FUNCTION_NAME_DESC',
  RequiredParametersAsc = 'REQUIRED_PARAMETERS_ASC',
  RequiredParametersDesc = 'REQUIRED_PARAMETERS_DESC',
  OutputPropertiesAsc = 'OUTPUT_PROPERTIES_ASC',
  OutputPropertiesDesc = 'OUTPUT_PROPERTIES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ActionQueue = Node & {
  __typename?: 'ActionQueue';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  triggerEvent?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  sequence?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  applicationData?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  parametersEvaluated?: Maybe<Scalars['JSON']>;
  status?: Maybe<ActionQueueStatus>;
  output?: Maybe<Scalars['JSON']>;
  timeQueued?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeScheduled?: Maybe<Scalars['Datetime']>;
  errorLog?: Maybe<Scalars['String']>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
};

/** The fields on `actionQueue` to look up the row to connect. */
export type ActionQueueActionQueuePkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `actionQueue` to look up the row to delete. */
export type ActionQueueActionQueuePkeyDelete = {
  id: Scalars['Int'];
};

/**
 * A condition to be used against `ActionQueue` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ActionQueueCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triggerEvent` field. */
  triggerEvent?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sequence` field. */
  sequence?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `actionCode` field. */
  actionCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `applicationData` field. */
  applicationData?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `parameterQueries` field. */
  parameterQueries?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `parametersEvaluated` field. */
  parametersEvaluated?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ActionQueueStatus>;
  /** Checks for equality with the object’s `output` field. */
  output?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `timeQueued` field. */
  timeQueued?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeCompleted` field. */
  timeCompleted?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `timeScheduled` field. */
  timeScheduled?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `errorLog` field. */
  errorLog?: Maybe<Scalars['String']>;
};

/** A filter to be used against `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type ActionQueueFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `triggerEvent` field. */
  triggerEvent?: Maybe<IntFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `sequence` field. */
  sequence?: Maybe<IntFilter>;
  /** Filter by the object’s `actionCode` field. */
  actionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `applicationData` field. */
  applicationData?: Maybe<JsonFilter>;
  /** Filter by the object’s `parameterQueries` field. */
  parameterQueries?: Maybe<JsonFilter>;
  /** Filter by the object’s `parametersEvaluated` field. */
  parametersEvaluated?: Maybe<JsonFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ActionQueueStatusFilter>;
  /** Filter by the object’s `output` field. */
  output?: Maybe<JsonFilter>;
  /** Filter by the object’s `timeQueued` field. */
  timeQueued?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeCompleted` field. */
  timeCompleted?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `timeScheduled` field. */
  timeScheduled?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `errorLog` field. */
  errorLog?: Maybe<StringFilter>;
  /** Filter by the object’s `triggerQueueByTriggerEvent` relation. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueueFilter>;
  /** A related `triggerQueueByTriggerEvent` exists. */
  triggerQueueByTriggerEventExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `template` relation. */
  template?: Maybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ActionQueueFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ActionQueueFilter>>;
  /** Negates the expression. */
  not?: Maybe<ActionQueueFilter>;
};

/** An input for mutations affecting `ActionQueue` */
export type ActionQueueInput = {
  id?: Maybe<Scalars['Int']>;
  triggerEvent?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  sequence?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  applicationData?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  parametersEvaluated?: Maybe<Scalars['JSON']>;
  status?: Maybe<ActionQueueStatus>;
  output?: Maybe<Scalars['JSON']>;
  timeQueued?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeScheduled?: Maybe<Scalars['Datetime']>;
  errorLog?: Maybe<Scalars['String']>;
  triggerQueueToTriggerEvent?: Maybe<ActionQueueTriggerEventFkeyInput>;
  templateToTemplateId?: Maybe<ActionQueueTemplateIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ActionQueueNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ActionQueueNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `actionQueue` to look up the row to update. */
export type ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate = {
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** The fields on `actionQueue` to look up the row to update. */
export type ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate = {
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `ActionQueue`. Fields that are set will be updated. */
export type ActionQueuePatch = {
  id?: Maybe<Scalars['Int']>;
  triggerEvent?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  sequence?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  applicationData?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  parametersEvaluated?: Maybe<Scalars['JSON']>;
  status?: Maybe<ActionQueueStatus>;
  output?: Maybe<Scalars['JSON']>;
  timeQueued?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeScheduled?: Maybe<Scalars['Datetime']>;
  errorLog?: Maybe<Scalars['String']>;
  triggerQueueToTriggerEvent?: Maybe<ActionQueueTriggerEventFkeyInput>;
  templateToTemplateId?: Maybe<ActionQueueTemplateIdFkeyInput>;
};

/** A connection to a list of `ActionQueue` values. */
export type ActionQueuesConnection = {
  __typename?: 'ActionQueuesConnection';
  /** A list of `ActionQueue` objects. */
  nodes: Array<Maybe<ActionQueue>>;
  /** A list of edges which contains the `ActionQueue` and cursor to aid in pagination. */
  edges: Array<ActionQueuesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActionQueue` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ActionQueue` edge in the connection. */
export type ActionQueuesEdge = {
  __typename?: 'ActionQueuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ActionQueue` at the end of the edge. */
  node?: Maybe<ActionQueue>;
};

/** Methods to use when ordering `ActionQueue`. */
export enum ActionQueuesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TriggerEventAsc = 'TRIGGER_EVENT_ASC',
  TriggerEventDesc = 'TRIGGER_EVENT_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  SequenceAsc = 'SEQUENCE_ASC',
  SequenceDesc = 'SEQUENCE_DESC',
  ActionCodeAsc = 'ACTION_CODE_ASC',
  ActionCodeDesc = 'ACTION_CODE_DESC',
  ApplicationDataAsc = 'APPLICATION_DATA_ASC',
  ApplicationDataDesc = 'APPLICATION_DATA_DESC',
  ParameterQueriesAsc = 'PARAMETER_QUERIES_ASC',
  ParameterQueriesDesc = 'PARAMETER_QUERIES_DESC',
  ParametersEvaluatedAsc = 'PARAMETERS_EVALUATED_ASC',
  ParametersEvaluatedDesc = 'PARAMETERS_EVALUATED_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  OutputAsc = 'OUTPUT_ASC',
  OutputDesc = 'OUTPUT_DESC',
  TimeQueuedAsc = 'TIME_QUEUED_ASC',
  TimeQueuedDesc = 'TIME_QUEUED_DESC',
  TimeCompletedAsc = 'TIME_COMPLETED_ASC',
  TimeCompletedDesc = 'TIME_COMPLETED_DESC',
  TimeScheduledAsc = 'TIME_SCHEDULED_ASC',
  TimeScheduledDesc = 'TIME_SCHEDULED_DESC',
  ErrorLogAsc = 'ERROR_LOG_ASC',
  ErrorLogDesc = 'ERROR_LOG_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export enum ActionQueueStatus {
  Scheduled = 'SCHEDULED',
  Queued = 'QUEUED',
  Processing = 'PROCESSING',
  Success = 'SUCCESS',
  Fail = 'FAIL'
}

/** A filter to be used against ActionQueueStatus fields. All fields are combined with a logical ‘and.’ */
export type ActionQueueStatusFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ActionQueueStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ActionQueueStatus>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ActionQueueStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ActionQueueStatus>;
  /** Included in the specified list. */
  in?: Maybe<Array<ActionQueueStatus>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ActionQueueStatus>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ActionQueueStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ActionQueueStatus>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ActionQueueStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ActionQueueStatus>;
};

/** The `actionQueue` to be created by this mutation. */
export type ActionQueueTemplateIdFkeyActionQueueCreateInput = {
  id?: Maybe<Scalars['Int']>;
  triggerEvent?: Maybe<Scalars['Int']>;
  sequence?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  applicationData?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  parametersEvaluated?: Maybe<Scalars['JSON']>;
  status?: Maybe<ActionQueueStatus>;
  output?: Maybe<Scalars['JSON']>;
  timeQueued?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeScheduled?: Maybe<Scalars['Datetime']>;
  errorLog?: Maybe<Scalars['String']>;
  triggerQueueToTriggerEvent?: Maybe<ActionQueueTriggerEventFkeyInput>;
  templateToTemplateId?: Maybe<ActionQueueTemplateIdFkeyInput>;
};

/** Input for the nested mutation of `template` in the `ActionQueueInput` mutation. */
export type ActionQueueTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: Maybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateNodeIdConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: Maybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: Maybe<TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: Maybe<ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: Maybe<ActionQueueTemplateIdFkeyTemplateCreateInput>;
};

/** Input for the nested mutation of `actionQueue` in the `TemplateInput` mutation. */
export type ActionQueueTemplateIdFkeyInverseInput = {
  /** Flag indicating whether all other `actionQueue` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectById?: Maybe<Array<ActionQueueActionQueuePkeyConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ActionQueueNodeIdConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteById?: Maybe<Array<ActionQueueActionQueuePkeyDelete>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ActionQueueNodeIdDelete>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateById?: Maybe<Array<ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate>>;
  /** A `ActionQueueInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ActionQueueTemplateIdFkeyActionQueueCreateInput>>;
};

/** The `template` to be created by this mutation. */
export type ActionQueueTemplateIdFkeyTemplateCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** The `actionQueue` to be created by this mutation. */
export type ActionQueueTriggerEventFkeyActionQueueCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  sequence?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  applicationData?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  parametersEvaluated?: Maybe<Scalars['JSON']>;
  status?: Maybe<ActionQueueStatus>;
  output?: Maybe<Scalars['JSON']>;
  timeQueued?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeScheduled?: Maybe<Scalars['Datetime']>;
  errorLog?: Maybe<Scalars['String']>;
  triggerQueueToTriggerEvent?: Maybe<ActionQueueTriggerEventFkeyInput>;
  templateToTemplateId?: Maybe<ActionQueueTemplateIdFkeyInput>;
};

/** Input for the nested mutation of `triggerQueue` in the `ActionQueueInput` mutation. */
export type ActionQueueTriggerEventFkeyInput = {
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectById?: Maybe<TriggerQueueTriggerQueuePkeyConnect>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectByNodeId?: Maybe<TriggerQueueNodeIdConnect>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteById?: Maybe<TriggerQueueTriggerQueuePkeyDelete>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TriggerQueueNodeIdDelete>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateById?: Maybe<TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateByNodeId?: Maybe<ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate>;
  /** A `TriggerQueueInput` object that will be created and connected to this object. */
  create?: Maybe<ActionQueueTriggerEventFkeyTriggerQueueCreateInput>;
};

/** Input for the nested mutation of `actionQueue` in the `TriggerQueueInput` mutation. */
export type ActionQueueTriggerEventFkeyInverseInput = {
  /** Flag indicating whether all other `actionQueue` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectById?: Maybe<Array<ActionQueueActionQueuePkeyConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ActionQueueNodeIdConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteById?: Maybe<Array<ActionQueueActionQueuePkeyDelete>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ActionQueueNodeIdDelete>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateById?: Maybe<Array<ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate>>;
  /** A `ActionQueueInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ActionQueueTriggerEventFkeyActionQueueCreateInput>>;
};

/** The `triggerQueue` to be created by this mutation. */
export type ActionQueueTriggerEventFkeyTriggerQueueCreateInput = {
  id?: Maybe<Scalars['Int']>;
  triggerType?: Maybe<Trigger>;
  table?: Maybe<Scalars['String']>;
  recordId?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Datetime']>;
  status?: Maybe<TriggerQueueStatus>;
  log?: Maybe<Scalars['JSON']>;
  actionQueuesUsingId?: Maybe<ActionQueueTriggerEventFkeyInverseInput>;
};

export type AllPermission = {
  __typename?: 'AllPermission';
  permissionType?: Maybe<PermissionPolicyType>;
  permissionPolicyId?: Maybe<Scalars['Int']>;
  permissionPolicyRules?: Maybe<Scalars['JSON']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  templatePermissionId?: Maybe<Scalars['Int']>;
  templatePermissionRestrictions?: Maybe<Scalars['JSON']>;
  templateId?: Maybe<Scalars['Int']>;
  templateCode?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['Int']>;
  username?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `AllPermission` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type AllPermissionCondition = {
  /** Checks for equality with the object’s `permissionType` field. */
  permissionType?: Maybe<PermissionPolicyType>;
  /** Checks for equality with the object’s `permissionPolicyId` field. */
  permissionPolicyId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `permissionPolicyRules` field. */
  permissionPolicyRules?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templatePermissionId` field. */
  templatePermissionId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templatePermissionRestrictions` field. */
  templatePermissionRestrictions?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>;
};

/** A filter to be used against `AllPermission` object types. All fields are combined with a logical ‘and.’ */
export type AllPermissionFilter = {
  /** Filter by the object’s `permissionType` field. */
  permissionType?: Maybe<PermissionPolicyTypeFilter>;
  /** Filter by the object’s `permissionPolicyId` field. */
  permissionPolicyId?: Maybe<IntFilter>;
  /** Filter by the object’s `permissionPolicyRules` field. */
  permissionPolicyRules?: Maybe<JsonFilter>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: Maybe<IntFilter>;
  /** Filter by the object’s `templatePermissionId` field. */
  templatePermissionId?: Maybe<IntFilter>;
  /** Filter by the object’s `templatePermissionRestrictions` field. */
  templatePermissionRestrictions?: Maybe<JsonFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: Maybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<AllPermissionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<AllPermissionFilter>>;
  /** Negates the expression. */
  not?: Maybe<AllPermissionFilter>;
};

/** A connection to a list of `AllPermission` values. */
export type AllPermissionsConnection = {
  __typename?: 'AllPermissionsConnection';
  /** A list of `AllPermission` objects. */
  nodes: Array<Maybe<AllPermission>>;
  /** A list of edges which contains the `AllPermission` and cursor to aid in pagination. */
  edges: Array<AllPermissionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AllPermission` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `AllPermission` edge in the connection. */
export type AllPermissionsEdge = {
  __typename?: 'AllPermissionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `AllPermission` at the end of the edge. */
  node?: Maybe<AllPermission>;
};

/** Methods to use when ordering `AllPermission`. */
export enum AllPermissionsOrderBy {
  Natural = 'NATURAL',
  PermissionTypeAsc = 'PERMISSION_TYPE_ASC',
  PermissionTypeDesc = 'PERMISSION_TYPE_DESC',
  PermissionPolicyIdAsc = 'PERMISSION_POLICY_ID_ASC',
  PermissionPolicyIdDesc = 'PERMISSION_POLICY_ID_DESC',
  PermissionPolicyRulesAsc = 'PERMISSION_POLICY_RULES_ASC',
  PermissionPolicyRulesDesc = 'PERMISSION_POLICY_RULES_DESC',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  TemplatePermissionIdAsc = 'TEMPLATE_PERMISSION_ID_ASC',
  TemplatePermissionIdDesc = 'TEMPLATE_PERMISSION_ID_DESC',
  TemplatePermissionRestrictionsAsc = 'TEMPLATE_PERMISSION_RESTRICTIONS_ASC',
  TemplatePermissionRestrictionsDesc = 'TEMPLATE_PERMISSION_RESTRICTIONS_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC'
}

export type Application = Node & {
  __typename?: 'Application';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `Application`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** Reads and enables pagination through a set of `ApplicationSection`. */
  applicationSections: ApplicationSectionsConnection;
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistories: ApplicationStageHistoriesConnection;
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses: ApplicationResponsesConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments: ReviewAssignmentsConnection;
  /** Reads and enables pagination through a set of `Review`. */
  reviews: ReviewsConnection;
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  /** Reads and enables pagination through a set of `Notification`. */
  notifications: NotificationsConnection;
  stage?: Maybe<Scalars['String']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ApplicationStatus>;
};


export type ApplicationApplicationSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationSectionsOrderBy>>;
  condition?: Maybe<ApplicationSectionCondition>;
  filter?: Maybe<ApplicationSectionFilter>;
};


export type ApplicationApplicationStageHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationStageHistoriesOrderBy>>;
  condition?: Maybe<ApplicationStageHistoryCondition>;
  filter?: Maybe<ApplicationStageHistoryFilter>;
};


export type ApplicationApplicationResponsesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationResponsesOrderBy>>;
  condition?: Maybe<ApplicationResponseCondition>;
  filter?: Maybe<ApplicationResponseFilter>;
};


export type ApplicationReviewAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
  condition?: Maybe<ReviewAssignmentCondition>;
  filter?: Maybe<ReviewAssignmentFilter>;
};


export type ApplicationReviewsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewsOrderBy>>;
  condition?: Maybe<ReviewCondition>;
  filter?: Maybe<ReviewFilter>;
};


export type ApplicationFilesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FilesOrderBy>>;
  condition?: Maybe<FileCondition>;
  filter?: Maybe<FileFilter>;
};


export type ApplicationNotificationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
};

/** The fields on `application` to look up the row to connect. */
export type ApplicationApplicationPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to delete. */
export type ApplicationApplicationPkeyDelete = {
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to connect. */
export type ApplicationApplicationSerialKeyConnect = {
  serial: Scalars['String'];
};

/** The fields on `application` to look up the row to delete. */
export type ApplicationApplicationSerialKeyDelete = {
  serial: Scalars['String'];
};

/**
 * A condition to be used against `Application` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ApplicationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: Maybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: Maybe<Trigger>;
};

/** A filter to be used against `Application` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `orgId` field. */
  orgId?: Maybe<IntFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: Maybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: Maybe<BooleanFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: Maybe<TriggerFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: Maybe<StringFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: Maybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ApplicationStatusFilter>;
  /** Filter by the object’s `applicationSections` relation. */
  applicationSections?: Maybe<ApplicationToManyApplicationSectionFilter>;
  /** Some related `applicationSections` exist. */
  applicationSectionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `applicationStageHistories` relation. */
  applicationStageHistories?: Maybe<ApplicationToManyApplicationStageHistoryFilter>;
  /** Some related `applicationStageHistories` exist. */
  applicationStageHistoriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `applicationResponses` relation. */
  applicationResponses?: Maybe<ApplicationToManyApplicationResponseFilter>;
  /** Some related `applicationResponses` exist. */
  applicationResponsesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewAssignments` relation. */
  reviewAssignments?: Maybe<ApplicationToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignments` exist. */
  reviewAssignmentsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviews` relation. */
  reviews?: Maybe<ApplicationToManyReviewFilter>;
  /** Some related `reviews` exist. */
  reviewsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `files` relation. */
  files?: Maybe<ApplicationToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `notifications` relation. */
  notifications?: Maybe<ApplicationToManyNotificationFilter>;
  /** Some related `notifications` exist. */
  notificationsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `template` relation. */
  template?: Maybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `org` relation. */
  org?: Maybe<OrganisationFilter>;
  /** A related `org` exists. */
  orgExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationFilter>;
};

/** An input for mutations affecting `Application` */
export type ApplicationInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

export type ApplicationList = {
  __typename?: 'ApplicationList';
  id?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  templateCode?: Maybe<Scalars['String']>;
  templateName?: Maybe<Scalars['String']>;
  applicantUsername?: Maybe<Scalars['String']>;
  applicantFirstName?: Maybe<Scalars['String']>;
  applicantLastName?: Maybe<Scalars['String']>;
  applicant?: Maybe<Scalars['String']>;
  orgName?: Maybe<Scalars['String']>;
  stage?: Maybe<Scalars['String']>;
  status?: Maybe<ApplicationStatus>;
  outcome?: Maybe<ApplicationOutcome>;
  lastActiveDate?: Maybe<Scalars['Datetime']>;
  isFullyAssignedLevel1?: Maybe<Scalars['Boolean']>;
};

/**
 * A condition to be used against `ApplicationList` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ApplicationListCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `templateName` field. */
  templateName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `applicantUsername` field. */
  applicantUsername?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `applicantFirstName` field. */
  applicantFirstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `applicantLastName` field. */
  applicantLastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `applicant` field. */
  applicant?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ApplicationStatus>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: Maybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `lastActiveDate` field. */
  lastActiveDate?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `isFullyAssignedLevel1` field. */
  isFullyAssignedLevel1?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `ApplicationList` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationListFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: Maybe<StringFilter>;
  /** Filter by the object’s `templateName` field. */
  templateName?: Maybe<StringFilter>;
  /** Filter by the object’s `applicantUsername` field. */
  applicantUsername?: Maybe<StringFilter>;
  /** Filter by the object’s `applicantFirstName` field. */
  applicantFirstName?: Maybe<StringFilter>;
  /** Filter by the object’s `applicantLastName` field. */
  applicantLastName?: Maybe<StringFilter>;
  /** Filter by the object’s `applicant` field. */
  applicant?: Maybe<StringFilter>;
  /** Filter by the object’s `orgName` field. */
  orgName?: Maybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: Maybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ApplicationStatusFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: Maybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `lastActiveDate` field. */
  lastActiveDate?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `isFullyAssignedLevel1` field. */
  isFullyAssignedLevel1?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationListFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationListFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationListFilter>;
};

/** A connection to a list of `ApplicationList` values. */
export type ApplicationListsConnection = {
  __typename?: 'ApplicationListsConnection';
  /** A list of `ApplicationList` objects. */
  nodes: Array<Maybe<ApplicationList>>;
  /** A list of edges which contains the `ApplicationList` and cursor to aid in pagination. */
  edges: Array<ApplicationListsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationList` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ApplicationList` edge in the connection. */
export type ApplicationListsEdge = {
  __typename?: 'ApplicationListsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ApplicationList` at the end of the edge. */
  node?: Maybe<ApplicationList>;
};

/** Methods to use when ordering `ApplicationList`. */
export enum ApplicationListsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateNameAsc = 'TEMPLATE_NAME_ASC',
  TemplateNameDesc = 'TEMPLATE_NAME_DESC',
  ApplicantUsernameAsc = 'APPLICANT_USERNAME_ASC',
  ApplicantUsernameDesc = 'APPLICANT_USERNAME_DESC',
  ApplicantFirstNameAsc = 'APPLICANT_FIRST_NAME_ASC',
  ApplicantFirstNameDesc = 'APPLICANT_FIRST_NAME_DESC',
  ApplicantLastNameAsc = 'APPLICANT_LAST_NAME_ASC',
  ApplicantLastNameDesc = 'APPLICANT_LAST_NAME_DESC',
  ApplicantAsc = 'APPLICANT_ASC',
  ApplicantDesc = 'APPLICANT_DESC',
  OrgNameAsc = 'ORG_NAME_ASC',
  OrgNameDesc = 'ORG_NAME_DESC',
  StageAsc = 'STAGE_ASC',
  StageDesc = 'STAGE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  LastActiveDateAsc = 'LAST_ACTIVE_DATE_ASC',
  LastActiveDateDesc = 'LAST_ACTIVE_DATE_DESC',
  IsFullyAssignedLevel_1Asc = 'IS_FULLY_ASSIGNED_LEVEL_1_ASC',
  IsFullyAssignedLevel_1Desc = 'IS_FULLY_ASSIGNED_LEVEL_1_DESC'
}

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `application` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationForApplicationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationSection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationSection` being updated. */
  patch: ApplicationSectionPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnFileForFileApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnFileForFileApplicationIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnFileForFileApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnFileForFileApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnFileForFileApplicationIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  serial: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
  serial: Scalars['String'];
};

/** The `application` to be created by this mutation. */
export type ApplicationOrgIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `organisation` in the `ApplicationInput` mutation. */
export type ApplicationOrgIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: Maybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: Maybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: Maybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: Maybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: Maybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: Maybe<OrganisationNodeIdDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: Maybe<OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: Maybe<OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationOrgIdFkeyOrganisationCreateInput>;
};

/** Input for the nested mutation of `application` in the `OrganisationInput` mutation. */
export type ApplicationOrgIdFkeyInverseInput = {
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<Array<ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationOrgIdFkeyApplicationCreateInput>>;
};

/** The `organisation` to be created by this mutation. */
export type ApplicationOrgIdFkeyOrganisationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

export enum ApplicationOutcome {
  Pending = 'PENDING',
  Approved = 'APPROVED',
  Rejected = 'REJECTED'
}

/** A filter to be used against ApplicationOutcome fields. All fields are combined with a logical ‘and.’ */
export type ApplicationOutcomeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ApplicationOutcome>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ApplicationOutcome>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ApplicationOutcome>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ApplicationOutcome>;
  /** Included in the specified list. */
  in?: Maybe<Array<ApplicationOutcome>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ApplicationOutcome>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ApplicationOutcome>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ApplicationOutcome>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ApplicationOutcome>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ApplicationOutcome>;
};

/** Represents an update to a `Application`. Fields that are set will be updated. */
export type ApplicationPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

export type ApplicationResponse = Node & {
  __typename?: 'ApplicationResponse';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  templateElementId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
};


export type ApplicationResponseReviewResponsesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
  condition?: Maybe<ReviewResponseCondition>;
  filter?: Maybe<ReviewResponseFilter>;
};


export type ApplicationResponseFilesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FilesOrderBy>>;
  condition?: Maybe<FileCondition>;
  filter?: Maybe<FileFilter>;
};

/** The `application` to be created by this mutation. */
export type ApplicationResponseApplicationIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** The `applicationResponse` to be created by this mutation. */
export type ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ApplicationResponseInput` mutation. */
export type ApplicationResponseApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<ApplicationApplicationSerialKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationNodeIdDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationResponseApplicationIdFkeyApplicationCreateInput>;
};

/** Input for the nested mutation of `applicationResponse` in the `ApplicationInput` mutation. */
export type ApplicationResponseApplicationIdFkeyInverseInput = {
  /** Flag indicating whether all other `applicationResponse` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationResponseApplicationResponsePkeyConnect>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationResponseNodeIdConnect>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationResponseApplicationResponsePkeyDelete>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationResponseNodeIdDelete>>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate>>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput>>;
};

/** The fields on `applicationResponse` to look up the row to connect. */
export type ApplicationResponseApplicationResponsePkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `applicationResponse` to look up the row to delete. */
export type ApplicationResponseApplicationResponsePkeyDelete = {
  id: Scalars['Int'];
};

/**
 * A condition to be used against `ApplicationResponse` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationResponseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateElementId` field. */
  templateElementId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `value` field. */
  value?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `isValid` field. */
  isValid?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `templateElementId` field. */
  templateElementId?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `value` field. */
  value?: Maybe<JsonFilter>;
  /** Filter by the object’s `isValid` field. */
  isValid?: Maybe<BooleanFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: Maybe<ApplicationResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `files` relation. */
  files?: Maybe<ApplicationResponseToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `templateElement` relation. */
  templateElement?: Maybe<TemplateElementFilter>;
  /** A related `templateElement` exists. */
  templateElementExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `application` relation. */
  application?: Maybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationResponseFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationResponseFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationResponseFilter>;
};

/** An input for mutations affecting `ApplicationResponse` */
export type ApplicationResponseInput = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationResponseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationResponseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `ApplicationResponse`. Fields that are set will be updated. */
export type ApplicationResponsePatch = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** A connection to a list of `ApplicationResponse` values. */
export type ApplicationResponsesConnection = {
  __typename?: 'ApplicationResponsesConnection';
  /** A list of `ApplicationResponse` objects. */
  nodes: Array<Maybe<ApplicationResponse>>;
  /** A list of edges which contains the `ApplicationResponse` and cursor to aid in pagination. */
  edges: Array<ApplicationResponsesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationResponse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ApplicationResponse` edge in the connection. */
export type ApplicationResponsesEdge = {
  __typename?: 'ApplicationResponsesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ApplicationResponse` at the end of the edge. */
  node?: Maybe<ApplicationResponse>;
};

/** Methods to use when ordering `ApplicationResponse`. */
export enum ApplicationResponsesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TemplateElementIdAsc = 'TEMPLATE_ELEMENT_ID_ASC',
  TemplateElementIdDesc = 'TEMPLATE_ELEMENT_ID_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC',
  IsValidAsc = 'IS_VALID_ASC',
  IsValidDesc = 'IS_VALID_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The `applicationResponse` to be created by this mutation. */
export type ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** Input for the nested mutation of `templateElement` in the `ApplicationResponseInput` mutation. */
export type ApplicationResponseTemplateElementIdFkeyInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: Maybe<TemplateElementTemplateElementPkeyConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateElementNodeIdConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: Maybe<TemplateElementTemplateElementPkeyDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateElementNodeIdDelete>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: Maybe<TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput>;
};

/** Input for the nested mutation of `applicationResponse` in the `TemplateElementInput` mutation. */
export type ApplicationResponseTemplateElementIdFkeyInverseInput = {
  /** Flag indicating whether all other `applicationResponse` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationResponseApplicationResponsePkeyConnect>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationResponseNodeIdConnect>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationResponseApplicationResponsePkeyDelete>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationResponseNodeIdDelete>>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate>>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput>>;
};

/** The `templateElement` to be created by this mutation. */
export type ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput = {
  id?: Maybe<Scalars['Int']>;
  sectionId?: Maybe<Scalars['Int']>;
  code: Scalars['String'];
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<FileFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewResponseFilter>;
};

/** A connection to a list of `Application` values. */
export type ApplicationsConnection = {
  __typename?: 'ApplicationsConnection';
  /** A list of `Application` objects. */
  nodes: Array<Maybe<Application>>;
  /** A list of edges which contains the `Application` and cursor to aid in pagination. */
  edges: Array<ApplicationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Application` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type ApplicationSection = Node & {
  __typename?: 'ApplicationSection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionId?: Maybe<Scalars['Int']>;
  /** Reads a single `Application` that is related to this `ApplicationSection`. */
  application?: Maybe<Application>;
  /** Reads a single `TemplateSection` that is related to this `ApplicationSection`. */
  templateSection?: Maybe<TemplateSection>;
};

/** The `application` to be created by this mutation. */
export type ApplicationSectionApplicationIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** The `applicationSection` to be created by this mutation. */
export type ApplicationSectionApplicationIdFkeyApplicationSectionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateSectionId?: Maybe<Scalars['Int']>;
  applicationToApplicationId?: Maybe<ApplicationSectionApplicationIdFkeyInput>;
  templateSectionToTemplateSectionId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInput>;
};

/** Input for the nested mutation of `application` in the `ApplicationSectionInput` mutation. */
export type ApplicationSectionApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<ApplicationApplicationSerialKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationNodeIdDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationSectionApplicationIdFkeyApplicationCreateInput>;
};

/** Input for the nested mutation of `applicationSection` in the `ApplicationInput` mutation. */
export type ApplicationSectionApplicationIdFkeyInverseInput = {
  /** Flag indicating whether all other `applicationSection` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `applicationSection` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationSectionApplicationSectionPkeyConnect>>;
  /** The primary key(s) for `applicationSection` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationSectionNodeIdConnect>>;
  /** The primary key(s) for `applicationSection` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationSectionApplicationSectionPkeyDelete>>;
  /** The primary key(s) for `applicationSection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationSectionNodeIdDelete>>;
  /** The primary key(s) and patch data for `applicationSection` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSectionPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationSection` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate>>;
  /** A `ApplicationSectionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationSectionApplicationIdFkeyApplicationSectionCreateInput>>;
};

/** The fields on `applicationSection` to look up the row to connect. */
export type ApplicationSectionApplicationSectionPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `applicationSection` to look up the row to delete. */
export type ApplicationSectionApplicationSectionPkeyDelete = {
  id: Scalars['Int'];
};

/**
 * A condition to be used against `ApplicationSection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ApplicationSectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateSectionId` field. */
  templateSectionId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `ApplicationSection` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationSectionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `templateSectionId` field. */
  templateSectionId?: Maybe<IntFilter>;
  /** Filter by the object’s `application` relation. */
  application?: Maybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `templateSection` relation. */
  templateSection?: Maybe<TemplateSectionFilter>;
  /** A related `templateSection` exists. */
  templateSectionExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationSectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationSectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationSectionFilter>;
};

/** An input for mutations affecting `ApplicationSection` */
export type ApplicationSectionInput = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionId?: Maybe<Scalars['Int']>;
  applicationToApplicationId?: Maybe<ApplicationSectionApplicationIdFkeyInput>;
  templateSectionToTemplateSectionId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationSectionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationSection` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationSectionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationSection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationSection` to look up the row to update. */
export type ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationSection` being updated. */
  patch: UpdateApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** The fields on `applicationSection` to look up the row to update. */
export type ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingApplicationSectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationSection` being updated. */
  patch: UpdateApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `ApplicationSection`. Fields that are set will be updated. */
export type ApplicationSectionPatch = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionId?: Maybe<Scalars['Int']>;
  applicationToApplicationId?: Maybe<ApplicationSectionApplicationIdFkeyInput>;
  templateSectionToTemplateSectionId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInput>;
};

/** A connection to a list of `ApplicationSection` values. */
export type ApplicationSectionsConnection = {
  __typename?: 'ApplicationSectionsConnection';
  /** A list of `ApplicationSection` objects. */
  nodes: Array<Maybe<ApplicationSection>>;
  /** A list of edges which contains the `ApplicationSection` and cursor to aid in pagination. */
  edges: Array<ApplicationSectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationSection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ApplicationSection` edge in the connection. */
export type ApplicationSectionsEdge = {
  __typename?: 'ApplicationSectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ApplicationSection` at the end of the edge. */
  node?: Maybe<ApplicationSection>;
};

/** Methods to use when ordering `ApplicationSection`. */
export enum ApplicationSectionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  TemplateSectionIdAsc = 'TEMPLATE_SECTION_ID_ASC',
  TemplateSectionIdDesc = 'TEMPLATE_SECTION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The `applicationSection` to be created by this mutation. */
export type ApplicationSectionTemplateSectionIdFkeyApplicationSectionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationToApplicationId?: Maybe<ApplicationSectionApplicationIdFkeyInput>;
  templateSectionToTemplateSectionId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInput>;
};

/** Input for the nested mutation of `templateSection` in the `ApplicationSectionInput` mutation. */
export type ApplicationSectionTemplateSectionIdFkeyInput = {
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectById?: Maybe<TemplateSectionTemplateSectionPkeyConnect>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateSectionNodeIdConnect>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteById?: Maybe<TemplateSectionTemplateSectionPkeyDelete>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateSectionNodeIdDelete>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateById?: Maybe<TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingTemplateSectionPkeyUpdate>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate>;
  /** A `TemplateSectionInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationSectionTemplateSectionIdFkeyTemplateSectionCreateInput>;
};

/** Input for the nested mutation of `applicationSection` in the `TemplateSectionInput` mutation. */
export type ApplicationSectionTemplateSectionIdFkeyInverseInput = {
  /** Flag indicating whether all other `applicationSection` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `applicationSection` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationSectionApplicationSectionPkeyConnect>>;
  /** The primary key(s) for `applicationSection` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationSectionNodeIdConnect>>;
  /** The primary key(s) for `applicationSection` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationSectionApplicationSectionPkeyDelete>>;
  /** The primary key(s) for `applicationSection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationSectionNodeIdDelete>>;
  /** The primary key(s) and patch data for `applicationSection` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingApplicationSectionPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationSection` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate>>;
  /** A `ApplicationSectionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationSectionTemplateSectionIdFkeyApplicationSectionCreateInput>>;
};

/** The `templateSection` to be created by this mutation. */
export type ApplicationSectionTemplateSectionIdFkeyTemplateSectionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateSectionTemplateIdFkeyInput>;
  templateElementsUsingId?: Maybe<TemplateElementSectionIdFkeyInverseInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInverseInput>;
};

/** A `Application` edge in the connection. */
export type ApplicationsEdge = {
  __typename?: 'ApplicationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Application` at the end of the edge. */
  node?: Maybe<Application>;
};

/** Methods to use when ordering `Application`. */
export enum ApplicationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `ApplicationStageHistory` values. */
export type ApplicationStageHistoriesConnection = {
  __typename?: 'ApplicationStageHistoriesConnection';
  /** A list of `ApplicationStageHistory` objects. */
  nodes: Array<Maybe<ApplicationStageHistory>>;
  /** A list of edges which contains the `ApplicationStageHistory` and cursor to aid in pagination. */
  edges: Array<ApplicationStageHistoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageHistory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ApplicationStageHistory` edge in the connection. */
export type ApplicationStageHistoriesEdge = {
  __typename?: 'ApplicationStageHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ApplicationStageHistory` at the end of the edge. */
  node?: Maybe<ApplicationStageHistory>;
};

/** Methods to use when ordering `ApplicationStageHistory`. */
export enum ApplicationStageHistoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ApplicationStageHistory = Node & {
  __typename?: 'ApplicationStageHistory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  applicationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
  /** Reads and enables pagination through a set of `ApplicationStatusHistory`. */
  applicationStatusHistories: ApplicationStatusHistoriesConnection;
};


export type ApplicationStageHistoryApplicationStatusHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationStatusHistoriesOrderBy>>;
  condition?: Maybe<ApplicationStatusHistoryCondition>;
  filter?: Maybe<ApplicationStatusHistoryFilter>;
};

/** The `application` to be created by this mutation. */
export type ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput = {
  id?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationToApplicationId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  templateStageToStageId?: Maybe<ApplicationStageHistoryStageIdFkeyInput>;
  applicationStatusHistoriesUsingId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStageHistoryApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<ApplicationApplicationSerialKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationNodeIdDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `ApplicationInput` mutation. */
export type ApplicationStageHistoryApplicationIdFkeyInverseInput = {
  /** Flag indicating whether all other `applicationStageHistory` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationStageHistoryNodeIdConnect>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationStageHistoryNodeIdDelete>>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate>>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput>>;
};

/** The fields on `applicationStageHistory` to look up the row to connect. */
export type ApplicationStageHistoryApplicationStageHistoryPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `applicationStageHistory` to look up the row to delete. */
export type ApplicationStageHistoryApplicationStageHistoryPkeyDelete = {
  id: Scalars['Int'];
};

/**
 * A condition to be used against `ApplicationStageHistory` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationStageHistoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageHistoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: Maybe<IntFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: Maybe<BooleanFilter>;
  /** Filter by the object’s `applicationStatusHistories` relation. */
  applicationStatusHistories?: Maybe<ApplicationStageHistoryToManyApplicationStatusHistoryFilter>;
  /** Some related `applicationStatusHistories` exist. */
  applicationStatusHistoriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `application` relation. */
  application?: Maybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `stage` relation. */
  stage?: Maybe<TemplateStageFilter>;
  /** A related `stage` exists. */
  stageExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationStageHistoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationStageHistoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationStageHistoryFilter>;
};

/** An input for mutations affecting `ApplicationStageHistory` */
export type ApplicationStageHistoryInput = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationToApplicationId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  templateStageToStageId?: Maybe<ApplicationStageHistoryStageIdFkeyInput>;
  applicationStatusHistoriesUsingId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationStageHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationStageHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `ApplicationStageHistory`. Fields that are set will be updated. */
export type ApplicationStageHistoryPatch = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationToApplicationId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  templateStageToStageId?: Maybe<ApplicationStageHistoryStageIdFkeyInput>;
  applicationStatusHistoriesUsingId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationToApplicationId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  templateStageToStageId?: Maybe<ApplicationStageHistoryStageIdFkeyInput>;
  applicationStatusHistoriesUsingId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
};

/** Input for the nested mutation of `templateStage` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStageHistoryStageIdFkeyInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: Maybe<TemplateStageTemplateStagePkeyConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateStageNodeIdConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: Maybe<TemplateStageTemplateStagePkeyDelete>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateStageNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: Maybe<TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `TemplateStageInput` mutation. */
export type ApplicationStageHistoryStageIdFkeyInverseInput = {
  /** Flag indicating whether all other `applicationStageHistory` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationStageHistoryNodeIdConnect>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationStageHistoryNodeIdDelete>>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate>>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput>>;
};

/** The `templateStage` to be created by this mutation. */
export type ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput = {
  id?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateId?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateStageTemplateIdFkeyInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentStageIdFkeyInverseInput>;
};

/** A filter to be used against many `ApplicationStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageHistoryToManyApplicationStatusHistoryFilter = {
  /** Every related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationStatusHistoryFilter>;
  /** Some related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationStatusHistoryFilter>;
  /** No related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationStatusHistoryFilter>;
};

export type ApplicationStageStatusAll = {
  __typename?: 'ApplicationStageStatusAll';
  applicationId?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  stage?: Maybe<Scalars['String']>;
  stageHistoryId?: Maybe<Scalars['Int']>;
  stageHistoryTimeCreated?: Maybe<Scalars['Datetime']>;
  stageIsCurrent?: Maybe<Scalars['Boolean']>;
  statusHistoryId?: Maybe<Scalars['Int']>;
  status?: Maybe<ApplicationStatus>;
  statusHistoryTimeCreated?: Maybe<Scalars['Datetime']>;
  statusIsCurrent?: Maybe<Scalars['Boolean']>;
};

/**
 * A condition to be used against `ApplicationStageStatusAll` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationStageStatusAllCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stageHistoryId` field. */
  stageHistoryId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `stageIsCurrent` field. */
  stageIsCurrent?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `statusHistoryId` field. */
  statusHistoryId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ApplicationStatus>;
  /** Checks for equality with the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `statusIsCurrent` field. */
  statusIsCurrent?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `ApplicationStageStatusAll` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageStatusAllFilter = {
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `orgId` field. */
  orgId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: Maybe<IntFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: Maybe<StringFilter>;
  /** Filter by the object’s `stageHistoryId` field. */
  stageHistoryId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `stageIsCurrent` field. */
  stageIsCurrent?: Maybe<BooleanFilter>;
  /** Filter by the object’s `statusHistoryId` field. */
  statusHistoryId?: Maybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ApplicationStatusFilter>;
  /** Filter by the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `statusIsCurrent` field. */
  statusIsCurrent?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationStageStatusAllFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationStageStatusAllFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationStageStatusAllFilter>;
};

/** A connection to a list of `ApplicationStageStatusAll` values. */
export type ApplicationStageStatusAllsConnection = {
  __typename?: 'ApplicationStageStatusAllsConnection';
  /** A list of `ApplicationStageStatusAll` objects. */
  nodes: Array<Maybe<ApplicationStageStatusAll>>;
  /** A list of edges which contains the `ApplicationStageStatusAll` and cursor to aid in pagination. */
  edges: Array<ApplicationStageStatusAllsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageStatusAll` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ApplicationStageStatusAll` edge in the connection. */
export type ApplicationStageStatusAllsEdge = {
  __typename?: 'ApplicationStageStatusAllsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ApplicationStageStatusAll` at the end of the edge. */
  node?: Maybe<ApplicationStageStatusAll>;
};

/** Methods to use when ordering `ApplicationStageStatusAll`. */
export enum ApplicationStageStatusAllsOrderBy {
  Natural = 'NATURAL',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StageAsc = 'STAGE_ASC',
  StageDesc = 'STAGE_DESC',
  StageHistoryIdAsc = 'STAGE_HISTORY_ID_ASC',
  StageHistoryIdDesc = 'STAGE_HISTORY_ID_DESC',
  StageHistoryTimeCreatedAsc = 'STAGE_HISTORY_TIME_CREATED_ASC',
  StageHistoryTimeCreatedDesc = 'STAGE_HISTORY_TIME_CREATED_DESC',
  StageIsCurrentAsc = 'STAGE_IS_CURRENT_ASC',
  StageIsCurrentDesc = 'STAGE_IS_CURRENT_DESC',
  StatusHistoryIdAsc = 'STATUS_HISTORY_ID_ASC',
  StatusHistoryIdDesc = 'STATUS_HISTORY_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StatusHistoryTimeCreatedAsc = 'STATUS_HISTORY_TIME_CREATED_ASC',
  StatusHistoryTimeCreatedDesc = 'STATUS_HISTORY_TIME_CREATED_DESC',
  StatusIsCurrentAsc = 'STATUS_IS_CURRENT_ASC',
  StatusIsCurrentDesc = 'STATUS_IS_CURRENT_DESC'
}

export type ApplicationStageStatusLatest = {
  __typename?: 'ApplicationStageStatusLatest';
  applicationId?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  stage?: Maybe<Scalars['String']>;
  stageHistoryId?: Maybe<Scalars['Int']>;
  stageHistoryTimeCreated?: Maybe<Scalars['Datetime']>;
  stageIsCurrent?: Maybe<Scalars['Boolean']>;
  statusHistoryId?: Maybe<Scalars['Int']>;
  status?: Maybe<ApplicationStatus>;
  statusHistoryTimeCreated?: Maybe<Scalars['Datetime']>;
  statusIsCurrent?: Maybe<Scalars['Boolean']>;
};

/**
 * A condition to be used against `ApplicationStageStatusLatest` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationStageStatusLatestCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `stageHistoryId` field. */
  stageHistoryId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `stageIsCurrent` field. */
  stageIsCurrent?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `statusHistoryId` field. */
  statusHistoryId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ApplicationStatus>;
  /** Checks for equality with the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `statusIsCurrent` field. */
  statusIsCurrent?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `ApplicationStageStatusLatest` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageStatusLatestFilter = {
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `orgId` field. */
  orgId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: Maybe<IntFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: Maybe<StringFilter>;
  /** Filter by the object’s `stageHistoryId` field. */
  stageHistoryId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `stageIsCurrent` field. */
  stageIsCurrent?: Maybe<BooleanFilter>;
  /** Filter by the object’s `statusHistoryId` field. */
  statusHistoryId?: Maybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ApplicationStatusFilter>;
  /** Filter by the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `statusIsCurrent` field. */
  statusIsCurrent?: Maybe<BooleanFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationStageStatusLatestFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationStageStatusLatestFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationStageStatusLatestFilter>;
};

/** A connection to a list of `ApplicationStageStatusLatest` values. */
export type ApplicationStageStatusLatestsConnection = {
  __typename?: 'ApplicationStageStatusLatestsConnection';
  /** A list of `ApplicationStageStatusLatest` objects. */
  nodes: Array<Maybe<ApplicationStageStatusLatest>>;
  /** A list of edges which contains the `ApplicationStageStatusLatest` and cursor to aid in pagination. */
  edges: Array<ApplicationStageStatusLatestsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageStatusLatest` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ApplicationStageStatusLatest` edge in the connection. */
export type ApplicationStageStatusLatestsEdge = {
  __typename?: 'ApplicationStageStatusLatestsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ApplicationStageStatusLatest` at the end of the edge. */
  node?: Maybe<ApplicationStageStatusLatest>;
};

/** Methods to use when ordering `ApplicationStageStatusLatest`. */
export enum ApplicationStageStatusLatestsOrderBy {
  Natural = 'NATURAL',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StageAsc = 'STAGE_ASC',
  StageDesc = 'STAGE_DESC',
  StageHistoryIdAsc = 'STAGE_HISTORY_ID_ASC',
  StageHistoryIdDesc = 'STAGE_HISTORY_ID_DESC',
  StageHistoryTimeCreatedAsc = 'STAGE_HISTORY_TIME_CREATED_ASC',
  StageHistoryTimeCreatedDesc = 'STAGE_HISTORY_TIME_CREATED_DESC',
  StageIsCurrentAsc = 'STAGE_IS_CURRENT_ASC',
  StageIsCurrentDesc = 'STAGE_IS_CURRENT_DESC',
  StatusHistoryIdAsc = 'STATUS_HISTORY_ID_ASC',
  StatusHistoryIdDesc = 'STATUS_HISTORY_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StatusHistoryTimeCreatedAsc = 'STATUS_HISTORY_TIME_CREATED_ASC',
  StatusHistoryTimeCreatedDesc = 'STATUS_HISTORY_TIME_CREATED_DESC',
  StatusIsCurrentAsc = 'STATUS_IS_CURRENT_ASC',
  StatusIsCurrentDesc = 'STATUS_IS_CURRENT_DESC'
}

export enum ApplicationStatus {
  Draft = 'DRAFT',
  Withdrawn = 'WITHDRAWN',
  Submitted = 'SUBMITTED',
  ChangesRequired = 'CHANGES_REQUIRED',
  ReSubmitted = 'RE_SUBMITTED',
  Completed = 'COMPLETED',
  Expired = 'EXPIRED'
}

/** A filter to be used against ApplicationStatus fields. All fields are combined with a logical ‘and.’ */
export type ApplicationStatusFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ApplicationStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ApplicationStatus>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ApplicationStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ApplicationStatus>;
  /** Included in the specified list. */
  in?: Maybe<Array<ApplicationStatus>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ApplicationStatus>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ApplicationStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ApplicationStatus>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ApplicationStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ApplicationStatus>;
};

/** A connection to a list of `ApplicationStatusHistory` values. */
export type ApplicationStatusHistoriesConnection = {
  __typename?: 'ApplicationStatusHistoriesConnection';
  /** A list of `ApplicationStatusHistory` objects. */
  nodes: Array<Maybe<ApplicationStatusHistory>>;
  /** A list of edges which contains the `ApplicationStatusHistory` and cursor to aid in pagination. */
  edges: Array<ApplicationStatusHistoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStatusHistory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ApplicationStatusHistory` edge in the connection. */
export type ApplicationStatusHistoriesEdge = {
  __typename?: 'ApplicationStatusHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ApplicationStatusHistory` at the end of the edge. */
  node?: Maybe<ApplicationStatusHistory>;
};

/** Methods to use when ordering `ApplicationStatusHistory`. */
export enum ApplicationStatusHistoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ApplicationStageHistoryIdAsc = 'APPLICATION_STAGE_HISTORY_ID_ASC',
  ApplicationStageHistoryIdDesc = 'APPLICATION_STAGE_HISTORY_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ApplicationStatusHistory = Node & {
  __typename?: 'ApplicationStatusHistory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  applicationStageHistoryId?: Maybe<Scalars['Int']>;
  status?: Maybe<ApplicationStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationId?: Maybe<Scalars['Int']>;
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationToApplicationId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  templateStageToStageId?: Maybe<ApplicationStageHistoryStageIdFkeyInput>;
  applicationStatusHistoriesUsingId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
};

/** The `applicationStatusHistory` to be created by this mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput = {
  id?: Maybe<Scalars['Int']>;
  status?: Maybe<ApplicationStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationStageHistoryToApplicationStageHistoryId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `ApplicationStatusHistoryInput` mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput = {
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: Maybe<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationStageHistoryNodeIdConnect>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationStageHistoryNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: Maybe<ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput>;
};

/** Input for the nested mutation of `applicationStatusHistory` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput = {
  /** Flag indicating whether all other `applicationStatusHistory` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationStatusHistoryNodeIdConnect>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationStatusHistoryNodeIdDelete>>;
  /** The primary key(s) and patch data for `applicationStatusHistory` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStatusHistory` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate>>;
  /** A `ApplicationStatusHistoryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput>>;
};

/** The fields on `applicationStatusHistory` to look up the row to connect. */
export type ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `applicationStatusHistory` to look up the row to delete. */
export type ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete = {
  id: Scalars['Int'];
};

/**
 * A condition to be used against `ApplicationStatusHistory` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationStatusHistoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `applicationStageHistoryId` field. */
  applicationStageHistoryId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ApplicationStatus>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `ApplicationStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStatusHistoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationStageHistoryId` field. */
  applicationStageHistoryId?: Maybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ApplicationStatusFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: Maybe<BooleanFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationStageHistory` relation. */
  applicationStageHistory?: Maybe<ApplicationStageHistoryFilter>;
  /** A related `applicationStageHistory` exists. */
  applicationStageHistoryExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationStatusHistoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationStatusHistoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationStatusHistoryFilter>;
};

/** An input for mutations affecting `ApplicationStatusHistory` */
export type ApplicationStatusHistoryInput = {
  id?: Maybe<Scalars['Int']>;
  applicationStageHistoryId?: Maybe<Scalars['Int']>;
  status?: Maybe<ApplicationStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationStageHistoryToApplicationStageHistoryId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationStatusHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationStatusHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `applicationStatusHistory` to look up the row to update. */
export type ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate = {
  /** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
  patch: UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `ApplicationStatusHistory`. Fields that are set will be updated. */
export type ApplicationStatusHistoryPatch = {
  id?: Maybe<Scalars['Int']>;
  applicationStageHistoryId?: Maybe<Scalars['Int']>;
  status?: Maybe<ApplicationStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationStageHistoryToApplicationStageHistoryId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
};

/** The `application` to be created by this mutation. */
export type ApplicationTemplateIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `template` in the `ApplicationInput` mutation. */
export type ApplicationTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: Maybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateNodeIdConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: Maybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: Maybe<TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationTemplateIdFkeyTemplateCreateInput>;
};

/** Input for the nested mutation of `application` in the `TemplateInput` mutation. */
export type ApplicationTemplateIdFkeyInverseInput = {
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<Array<ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationTemplateIdFkeyApplicationCreateInput>>;
};

/** The `template` to be created by this mutation. */
export type ApplicationTemplateIdFkeyTemplateCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** A filter to be used against many `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationResponseFilter = {
  /** Every related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationResponseFilter>;
  /** Some related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationResponseFilter>;
  /** No related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationResponseFilter>;
};

/** A filter to be used against many `ApplicationSection` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationSectionFilter = {
  /** Every related `ApplicationSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationSectionFilter>;
  /** Some related `ApplicationSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationSectionFilter>;
  /** No related `ApplicationSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationSectionFilter>;
};

/** A filter to be used against many `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationStageHistoryFilter = {
  /** Every related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationStageHistoryFilter>;
  /** Some related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationStageHistoryFilter>;
  /** No related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationStageHistoryFilter>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<FileFilter>;
};

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<NotificationFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `Review` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyReviewFilter = {
  /** Every related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewFilter>;
  /** Some related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewFilter>;
  /** No related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewFilter>;
};

export type ApplicationTriggerState = {
  __typename?: 'ApplicationTriggerState';
  serial?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationTrigger?: Maybe<Trigger>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  reviewAssignmentTrigger?: Maybe<Trigger>;
  reviewId?: Maybe<Scalars['Int']>;
  reviewTrigger?: Maybe<Trigger>;
};

/**
 * A condition to be used against `ApplicationTriggerState` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationTriggerStateCondition = {
  /** Checks for equality with the object’s `serial` field. */
  serial?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `applicationTrigger` field. */
  applicationTrigger?: Maybe<Trigger>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewAssignmentTrigger` field. */
  reviewAssignmentTrigger?: Maybe<Trigger>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewTrigger` field. */
  reviewTrigger?: Maybe<Trigger>;
};

/** A filter to be used against `ApplicationTriggerState` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationTriggerStateFilter = {
  /** Filter by the object’s `serial` field. */
  serial?: Maybe<StringFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationTrigger` field. */
  applicationTrigger?: Maybe<TriggerFilter>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewAssignmentTrigger` field. */
  reviewAssignmentTrigger?: Maybe<TriggerFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewTrigger` field. */
  reviewTrigger?: Maybe<TriggerFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ApplicationTriggerStateFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ApplicationTriggerStateFilter>>;
  /** Negates the expression. */
  not?: Maybe<ApplicationTriggerStateFilter>;
};

/** A connection to a list of `ApplicationTriggerState` values. */
export type ApplicationTriggerStatesConnection = {
  __typename?: 'ApplicationTriggerStatesConnection';
  /** A list of `ApplicationTriggerState` objects. */
  nodes: Array<Maybe<ApplicationTriggerState>>;
  /** A list of edges which contains the `ApplicationTriggerState` and cursor to aid in pagination. */
  edges: Array<ApplicationTriggerStatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationTriggerState` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ApplicationTriggerState` edge in the connection. */
export type ApplicationTriggerStatesEdge = {
  __typename?: 'ApplicationTriggerStatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ApplicationTriggerState` at the end of the edge. */
  node?: Maybe<ApplicationTriggerState>;
};

/** Methods to use when ordering `ApplicationTriggerState`. */
export enum ApplicationTriggerStatesOrderBy {
  Natural = 'NATURAL',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ApplicationTriggerAsc = 'APPLICATION_TRIGGER_ASC',
  ApplicationTriggerDesc = 'APPLICATION_TRIGGER_DESC',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC',
  ReviewAssignmentTriggerAsc = 'REVIEW_ASSIGNMENT_TRIGGER_ASC',
  ReviewAssignmentTriggerDesc = 'REVIEW_ASSIGNMENT_TRIGGER_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  ReviewTriggerAsc = 'REVIEW_TRIGGER_ASC',
  ReviewTriggerDesc = 'REVIEW_TRIGGER_DESC'
}

/** The `application` to be created by this mutation. */
export type ApplicationUserIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `user` in the `ApplicationInput` mutation. */
export type ApplicationUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: Maybe<UserUserUsernameKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: Maybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnApplicationForApplicationUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: Maybe<UserOnApplicationForApplicationUserIdFkeyUsingUserUsernameKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<ApplicationOnApplicationForApplicationUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<ApplicationUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `application` in the `UserInput` mutation. */
export type ApplicationUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<Array<ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<Array<ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationSerialKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnApplicationForApplicationUserIdFkeyNodeIdUpdate>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ApplicationUserIdFkeyApplicationCreateInput>>;
};

/** The `user` to be created by this mutation. */
export type ApplicationUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};


/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Boolean']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Boolean']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Boolean']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Boolean']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Boolean']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Boolean']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Boolean']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Boolean']>;
};

/** All input for the create `ActionPlugin` mutation. */
export type CreateActionPluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ActionPlugin` to be created by this mutation. */
  actionPlugin: ActionPluginInput;
};

/** The output of our create `ActionPlugin` mutation. */
export type CreateActionPluginPayload = {
  __typename?: 'CreateActionPluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ActionPlugin` that was created by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
};


/** The output of our create `ActionPlugin` mutation. */
export type CreateActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: Maybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the create `ActionQueue` mutation. */
export type CreateActionQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ActionQueue` to be created by this mutation. */
  actionQueue: ActionQueueInput;
};

/** The output of our create `ActionQueue` mutation. */
export type CreateActionQueuePayload = {
  __typename?: 'CreateActionQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ActionQueue` that was created by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
};


/** The output of our create `ActionQueue` mutation. */
export type CreateActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: Maybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the create `Application` mutation. */
export type CreateApplicationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Application` to be created by this mutation. */
  application: ApplicationInput;
};

/** The output of our create `Application` mutation. */
export type CreateApplicationPayload = {
  __typename?: 'CreateApplicationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Application` that was created by this mutation. */
  application?: Maybe<Application>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `Application`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
};


/** The output of our create `Application` mutation. */
export type CreateApplicationPayloadApplicationEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationsOrderBy>>;
};

/** All input for the create `ApplicationResponse` mutation. */
export type CreateApplicationResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationResponse` to be created by this mutation. */
  applicationResponse: ApplicationResponseInput;
};

/** The output of our create `ApplicationResponse` mutation. */
export type CreateApplicationResponsePayload = {
  __typename?: 'CreateApplicationResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationResponse` that was created by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
};


/** The output of our create `ApplicationResponse` mutation. */
export type CreateApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the create `ApplicationSection` mutation. */
export type CreateApplicationSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationSection` to be created by this mutation. */
  applicationSection: ApplicationSectionInput;
};

/** The output of our create `ApplicationSection` mutation. */
export type CreateApplicationSectionPayload = {
  __typename?: 'CreateApplicationSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationSection` that was created by this mutation. */
  applicationSection?: Maybe<ApplicationSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Application` that is related to this `ApplicationSection`. */
  application?: Maybe<Application>;
  /** Reads a single `TemplateSection` that is related to this `ApplicationSection`. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `ApplicationSection`. May be used by Relay 1. */
  applicationSectionEdge?: Maybe<ApplicationSectionsEdge>;
};


/** The output of our create `ApplicationSection` mutation. */
export type CreateApplicationSectionPayloadApplicationSectionEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationSectionsOrderBy>>;
};

/** All input for the create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationStageHistory` to be created by this mutation. */
  applicationStageHistory: ApplicationStageHistoryInput;
};

/** The output of our create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryPayload = {
  __typename?: 'CreateApplicationStageHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationStageHistory` that was created by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
};


/** The output of our create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationStatusHistory` to be created by this mutation. */
  applicationStatusHistory: ApplicationStatusHistoryInput;
};

/** The output of our create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryPayload = {
  __typename?: 'CreateApplicationStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationStatusHistory` that was created by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
};


/** The output of our create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ElementTypePlugin` to be created by this mutation. */
  elementTypePlugin: ElementTypePluginInput;
};

/** The output of our create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginPayload = {
  __typename?: 'CreateElementTypePluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ElementTypePlugin` that was created by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
};


/** The output of our create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: Maybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the create `File` mutation. */
export type CreateFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `File` to be created by this mutation. */
  file: FileInput;
};

/** The output of our create `File` mutation. */
export type CreateFilePayload = {
  __typename?: 'CreateFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `File` that was created by this mutation. */
  file?: Maybe<File>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `File`. */
  user?: Maybe<User>;
  /** Reads a single `Application` that is related to this `File`. */
  application?: Maybe<Application>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
};


/** The output of our create `File` mutation. */
export type CreateFilePayloadFileEdgeArgs = {
  orderBy?: Maybe<Array<FilesOrderBy>>;
};

/** All input for the create `Notification` mutation. */
export type CreateNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` to be created by this mutation. */
  notification: NotificationInput;
};

/** The output of our create `Notification` mutation. */
export type CreateNotificationPayload = {
  __typename?: 'CreateNotificationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was created by this mutation. */
  notification?: Maybe<Notification>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Notification`. */
  user?: Maybe<User>;
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  /** Reads a single `File` that is related to this `Notification`. */
  document?: Maybe<File>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
};


/** The output of our create `Notification` mutation. */
export type CreateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** All input for the create `Organisation` mutation. */
export type CreateOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Organisation` to be created by this mutation. */
  organisation: OrganisationInput;
};

/** The output of our create `Organisation` mutation. */
export type CreateOrganisationPayload = {
  __typename?: 'CreateOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Organisation` that was created by this mutation. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
};


/** The output of our create `Organisation` mutation. */
export type CreateOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: Maybe<Array<OrganisationsOrderBy>>;
};

/** All input for the create `PermissionJoin` mutation. */
export type CreatePermissionJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionJoin` to be created by this mutation. */
  permissionJoin: PermissionJoinInput;
};

/** The output of our create `PermissionJoin` mutation. */
export type CreatePermissionJoinPayload = {
  __typename?: 'CreatePermissionJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionJoin` that was created by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PermissionJoin`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
};


/** The output of our create `PermissionJoin` mutation. */
export type CreatePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: Maybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the create `PermissionName` mutation. */
export type CreatePermissionNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionName` to be created by this mutation. */
  permissionName: PermissionNameInput;
};

/** The output of our create `PermissionName` mutation. */
export type CreatePermissionNamePayload = {
  __typename?: 'CreatePermissionNamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionName` that was created by this mutation. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
};


/** The output of our create `PermissionName` mutation. */
export type CreatePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: Maybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionPolicy` to be created by this mutation. */
  permissionPolicy: PermissionPolicyInput;
};

/** The output of our create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyPayload = {
  __typename?: 'CreatePermissionPolicyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionPolicy` that was created by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
};


/** The output of our create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: Maybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewAssignment` to be created by this mutation. */
  reviewAssignment: ReviewAssignmentInput;
};

/** The output of our create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentPayload = {
  __typename?: 'CreateReviewAssignmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewAssignment` that was created by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<User>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
};


/** The output of our create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the create `ReviewDecision` mutation. */
export type CreateReviewDecisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewDecision` to be created by this mutation. */
  reviewDecision: ReviewDecisionInput;
};

/** The output of our create `ReviewDecision` mutation. */
export type CreateReviewDecisionPayload = {
  __typename?: 'CreateReviewDecisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewDecision` that was created by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our create `ReviewDecision` mutation. */
export type CreateReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: Maybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the create `Review` mutation. */
export type CreateReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` to be created by this mutation. */
  review: ReviewInput;
};

/** The output of our create `Review` mutation. */
export type CreateReviewPayload = {
  __typename?: 'CreateReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was created by this mutation. */
  review?: Maybe<Review>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /** Reads a single `User` that is related to this `Review`. */
  reviewer?: Maybe<User>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our create `Review` mutation. */
export type CreateReviewPayloadReviewEdgeArgs = {
  orderBy?: Maybe<Array<ReviewsOrderBy>>;
};

/** All input for the create `ReviewQuestionAssignment` mutation. */
export type CreateReviewQuestionAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewQuestionAssignment` to be created by this mutation. */
  reviewQuestionAssignment: ReviewQuestionAssignmentInput;
};

/** The output of our create `ReviewQuestionAssignment` mutation. */
export type CreateReviewQuestionAssignmentPayload = {
  __typename?: 'CreateReviewQuestionAssignmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewQuestionAssignment` that was created by this mutation. */
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ReviewQuestionAssignment`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewQuestionAssignment`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewQuestionAssignment`. May be used by Relay 1. */
  reviewQuestionAssignmentEdge?: Maybe<ReviewQuestionAssignmentsEdge>;
};


/** The output of our create `ReviewQuestionAssignment` mutation. */
export type CreateReviewQuestionAssignmentPayloadReviewQuestionAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<ReviewQuestionAssignmentsOrderBy>>;
};

/** All input for the create `ReviewResponse` mutation. */
export type CreateReviewResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewResponse` to be created by this mutation. */
  reviewResponse: ReviewResponseInput;
};

/** The output of our create `ReviewResponse` mutation. */
export type CreateReviewResponsePayload = {
  __typename?: 'CreateReviewResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewResponse` that was created by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewQuestionAssignment` that is related to this `ReviewResponse`. */
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignment>;
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
};


/** The output of our create `ReviewResponse` mutation. */
export type CreateReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewStatusHistory` to be created by this mutation. */
  reviewStatusHistory: ReviewStatusHistoryInput;
};

/** The output of our create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryPayload = {
  __typename?: 'CreateReviewStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewStatusHistory` that was created by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the create `TemplateAction` mutation. */
export type CreateTemplateActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateAction` to be created by this mutation. */
  templateAction: TemplateActionInput;
};

/** The output of our create `TemplateAction` mutation. */
export type CreateTemplateActionPayload = {
  __typename?: 'CreateTemplateActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateAction` that was created by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our create `TemplateAction` mutation. */
export type CreateTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: Maybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the create `TemplateElement` mutation. */
export type CreateTemplateElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateElement` to be created by this mutation. */
  templateElement: TemplateElementInput;
};

/** The output of our create `TemplateElement` mutation. */
export type CreateTemplateElementPayload = {
  __typename?: 'CreateTemplateElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateElement` that was created by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our create `TemplateElement` mutation. */
export type CreateTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: Maybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the create `Template` mutation. */
export type CreateTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` to be created by this mutation. */
  template: TemplateInput;
};

/** The output of our create `Template` mutation. */
export type CreateTemplatePayload = {
  __typename?: 'CreateTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was created by this mutation. */
  template?: Maybe<Template>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our create `Template` mutation. */
export type CreateTemplatePayloadTemplateEdgeArgs = {
  orderBy?: Maybe<Array<TemplatesOrderBy>>;
};

/** All input for the create `TemplatePermission` mutation. */
export type CreateTemplatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplatePermission` to be created by this mutation. */
  templatePermission: TemplatePermissionInput;
};

/** The output of our create `TemplatePermission` mutation. */
export type CreateTemplatePermissionPayload = {
  __typename?: 'CreateTemplatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplatePermission` that was created by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our create `TemplatePermission` mutation. */
export type CreateTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: Maybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the create `TemplateSection` mutation. */
export type CreateTemplateSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateSection` to be created by this mutation. */
  templateSection: TemplateSectionInput;
};

/** The output of our create `TemplateSection` mutation. */
export type CreateTemplateSectionPayload = {
  __typename?: 'CreateTemplateSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateSection` that was created by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our create `TemplateSection` mutation. */
export type CreateTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: Maybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the create `TemplateStage` mutation. */
export type CreateTemplateStageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateStage` to be created by this mutation. */
  templateStage: TemplateStageInput;
};

/** The output of our create `TemplateStage` mutation. */
export type CreateTemplateStagePayload = {
  __typename?: 'CreateTemplateStagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateStage` that was created by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our create `TemplateStage` mutation. */
export type CreateTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: Maybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the create `TriggerQueue` mutation. */
export type CreateTriggerQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TriggerQueue` to be created by this mutation. */
  triggerQueue: TriggerQueueInput;
};

/** The output of our create `TriggerQueue` mutation. */
export type CreateTriggerQueuePayload = {
  __typename?: 'CreateTriggerQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TriggerQueue` that was created by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our create `TriggerQueue` mutation. */
export type CreateTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: Maybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** All input for the create `UserOrganisation` mutation. */
export type CreateUserOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserOrganisation` to be created by this mutation. */
  userOrganisation: UserOrganisationInput;
};

/** The output of our create `UserOrganisation` mutation. */
export type CreateUserOrganisationPayload = {
  __typename?: 'CreateUserOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserOrganisation` that was created by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our create `UserOrganisation` mutation. */
export type CreateUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: Maybe<Array<UserOrganisationsOrderBy>>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};



/** A filter to be used against Date fields. All fields are combined with a logical ‘and.’ */
export type DateFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Date']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Date']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Date']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Date']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Date']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Date']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Date']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Date']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Date']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Date']>;
};


/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Datetime']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Datetime']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Datetime']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Datetime']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Datetime']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Datetime']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Datetime']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Datetime']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Datetime']>;
};

export enum Decision {
  ListOfQuestions = 'LIST_OF_QUESTIONS',
  Conform = 'CONFORM',
  NonConform = 'NON_CONFORM',
  ChangesRequested = 'CHANGES_REQUESTED',
  NoDecision = 'NO_DECISION'
}

/** A filter to be used against Decision fields. All fields are combined with a logical ‘and.’ */
export type DecisionFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Decision>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Decision>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Decision>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Decision>;
  /** Included in the specified list. */
  in?: Maybe<Array<Decision>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Decision>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Decision>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Decision>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Decision>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Decision>;
};

/** All input for the `deleteActionPluginByNodeId` mutation. */
export type DeleteActionPluginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ActionPlugin` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteActionPlugin` mutation. */
export type DeleteActionPluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  code: Scalars['String'];
};

/** The output of our delete `ActionPlugin` mutation. */
export type DeleteActionPluginPayload = {
  __typename?: 'DeleteActionPluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ActionPlugin` that was deleted by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  deletedActionPluginNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
};


/** The output of our delete `ActionPlugin` mutation. */
export type DeleteActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: Maybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the `deleteActionQueueByNodeId` mutation. */
export type DeleteActionQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ActionQueue` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteActionQueue` mutation. */
export type DeleteActionQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ActionQueue` mutation. */
export type DeleteActionQueuePayload = {
  __typename?: 'DeleteActionQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ActionQueue` that was deleted by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  deletedActionQueueNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
};


/** The output of our delete `ActionQueue` mutation. */
export type DeleteActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: Maybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the `deleteApplicationByNodeId` mutation. */
export type DeleteApplicationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Application` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteApplicationBySerial` mutation. */
export type DeleteApplicationBySerialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  serial: Scalars['String'];
};

/** All input for the `deleteApplication` mutation. */
export type DeleteApplicationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Application` mutation. */
export type DeleteApplicationPayload = {
  __typename?: 'DeleteApplicationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Application` that was deleted by this mutation. */
  application?: Maybe<Application>;
  deletedApplicationNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `Application`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
};


/** The output of our delete `Application` mutation. */
export type DeleteApplicationPayloadApplicationEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationsOrderBy>>;
};

/** All input for the `deleteApplicationResponseByNodeId` mutation. */
export type DeleteApplicationResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ApplicationResponse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteApplicationResponse` mutation. */
export type DeleteApplicationResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ApplicationResponse` mutation. */
export type DeleteApplicationResponsePayload = {
  __typename?: 'DeleteApplicationResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationResponse` that was deleted by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  deletedApplicationResponseNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
};


/** The output of our delete `ApplicationResponse` mutation. */
export type DeleteApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the `deleteApplicationSectionByNodeId` mutation. */
export type DeleteApplicationSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ApplicationSection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteApplicationSection` mutation. */
export type DeleteApplicationSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ApplicationSection` mutation. */
export type DeleteApplicationSectionPayload = {
  __typename?: 'DeleteApplicationSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationSection` that was deleted by this mutation. */
  applicationSection?: Maybe<ApplicationSection>;
  deletedApplicationSectionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Application` that is related to this `ApplicationSection`. */
  application?: Maybe<Application>;
  /** Reads a single `TemplateSection` that is related to this `ApplicationSection`. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `ApplicationSection`. May be used by Relay 1. */
  applicationSectionEdge?: Maybe<ApplicationSectionsEdge>;
};


/** The output of our delete `ApplicationSection` mutation. */
export type DeleteApplicationSectionPayloadApplicationSectionEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationSectionsOrderBy>>;
};

/** All input for the `deleteApplicationStageHistoryByNodeId` mutation. */
export type DeleteApplicationStageHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ApplicationStageHistory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryPayload = {
  __typename?: 'DeleteApplicationStageHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationStageHistory` that was deleted by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  deletedApplicationStageHistoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
};


/** The output of our delete `ApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the `deleteApplicationStatusHistoryByNodeId` mutation. */
export type DeleteApplicationStatusHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ApplicationStatusHistory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryPayload = {
  __typename?: 'DeleteApplicationStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationStatusHistory` that was deleted by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  deletedApplicationStatusHistoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
};


/** The output of our delete `ApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the `deleteElementTypePluginByNodeId` mutation. */
export type DeleteElementTypePluginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ElementTypePlugin` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteElementTypePlugin` mutation. */
export type DeleteElementTypePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  code: Scalars['String'];
};

/** The output of our delete `ElementTypePlugin` mutation. */
export type DeleteElementTypePluginPayload = {
  __typename?: 'DeleteElementTypePluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ElementTypePlugin` that was deleted by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  deletedElementTypePluginNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
};


/** The output of our delete `ElementTypePlugin` mutation. */
export type DeleteElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: Maybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the `deleteFileByNodeId` mutation. */
export type DeleteFileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `File` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteFile` mutation. */
export type DeleteFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `File` mutation. */
export type DeleteFilePayload = {
  __typename?: 'DeleteFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `File` that was deleted by this mutation. */
  file?: Maybe<File>;
  deletedFileNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `File`. */
  user?: Maybe<User>;
  /** Reads a single `Application` that is related to this `File`. */
  application?: Maybe<Application>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
};


/** The output of our delete `File` mutation. */
export type DeleteFilePayloadFileEdgeArgs = {
  orderBy?: Maybe<Array<FilesOrderBy>>;
};

/** All input for the `deleteNotificationByNodeId` mutation. */
export type DeleteNotificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Notification` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteNotification` mutation. */
export type DeleteNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayload = {
  __typename?: 'DeleteNotificationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was deleted by this mutation. */
  notification?: Maybe<Notification>;
  deletedNotificationNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Notification`. */
  user?: Maybe<User>;
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  /** Reads a single `File` that is related to this `Notification`. */
  document?: Maybe<File>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
};


/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayloadNotificationEdgeArgs = {
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** All input for the `deleteOrganisationByName` mutation. */
export type DeleteOrganisationByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deleteOrganisationByNodeId` mutation. */
export type DeleteOrganisationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Organisation` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteOrganisation` mutation. */
export type DeleteOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Organisation` mutation. */
export type DeleteOrganisationPayload = {
  __typename?: 'DeleteOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Organisation` that was deleted by this mutation. */
  organisation?: Maybe<Organisation>;
  deletedOrganisationNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
};


/** The output of our delete `Organisation` mutation. */
export type DeleteOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: Maybe<Array<OrganisationsOrderBy>>;
};

/** All input for the `deletePermissionJoinByNodeId` mutation. */
export type DeletePermissionJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PermissionJoin` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePermissionJoin` mutation. */
export type DeletePermissionJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PermissionJoin` mutation. */
export type DeletePermissionJoinPayload = {
  __typename?: 'DeletePermissionJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionJoin` that was deleted by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  deletedPermissionJoinNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PermissionJoin`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
};


/** The output of our delete `PermissionJoin` mutation. */
export type DeletePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: Maybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the `deletePermissionNameByName` mutation. */
export type DeletePermissionNameByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  name: Scalars['String'];
};

/** All input for the `deletePermissionNameByNodeId` mutation. */
export type DeletePermissionNameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PermissionName` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePermissionName` mutation. */
export type DeletePermissionNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PermissionName` mutation. */
export type DeletePermissionNamePayload = {
  __typename?: 'DeletePermissionNamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionName` that was deleted by this mutation. */
  permissionName?: Maybe<PermissionName>;
  deletedPermissionNameNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
};


/** The output of our delete `PermissionName` mutation. */
export type DeletePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: Maybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the `deletePermissionPolicyByNodeId` mutation. */
export type DeletePermissionPolicyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PermissionPolicy` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deletePermissionPolicy` mutation. */
export type DeletePermissionPolicyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `PermissionPolicy` mutation. */
export type DeletePermissionPolicyPayload = {
  __typename?: 'DeletePermissionPolicyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionPolicy` that was deleted by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  deletedPermissionPolicyNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
};


/** The output of our delete `PermissionPolicy` mutation. */
export type DeletePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: Maybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the `deleteReviewAssignmentByNodeId` mutation. */
export type DeleteReviewAssignmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReviewAssignment` mutation. */
export type DeleteReviewAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ReviewAssignment` mutation. */
export type DeleteReviewAssignmentPayload = {
  __typename?: 'DeleteReviewAssignmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewAssignment` that was deleted by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  deletedReviewAssignmentNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<User>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
};


/** The output of our delete `ReviewAssignment` mutation. */
export type DeleteReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the `deleteReviewByNodeId` mutation. */
export type DeleteReviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Review` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReviewDecisionByNodeId` mutation. */
export type DeleteReviewDecisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewDecision` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReviewDecision` mutation. */
export type DeleteReviewDecisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ReviewDecision` mutation. */
export type DeleteReviewDecisionPayload = {
  __typename?: 'DeleteReviewDecisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewDecision` that was deleted by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  deletedReviewDecisionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our delete `ReviewDecision` mutation. */
export type DeleteReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: Maybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the `deleteReview` mutation. */
export type DeleteReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Review` mutation. */
export type DeleteReviewPayload = {
  __typename?: 'DeleteReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was deleted by this mutation. */
  review?: Maybe<Review>;
  deletedReviewNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /** Reads a single `User` that is related to this `Review`. */
  reviewer?: Maybe<User>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our delete `Review` mutation. */
export type DeleteReviewPayloadReviewEdgeArgs = {
  orderBy?: Maybe<Array<ReviewsOrderBy>>;
};

/** All input for the `deleteReviewQuestionAssignmentByNodeId` mutation. */
export type DeleteReviewQuestionAssignmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewQuestionAssignment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReviewQuestionAssignment` mutation. */
export type DeleteReviewQuestionAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ReviewQuestionAssignment` mutation. */
export type DeleteReviewQuestionAssignmentPayload = {
  __typename?: 'DeleteReviewQuestionAssignmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewQuestionAssignment` that was deleted by this mutation. */
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignment>;
  deletedReviewQuestionAssignmentNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ReviewQuestionAssignment`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewQuestionAssignment`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewQuestionAssignment`. May be used by Relay 1. */
  reviewQuestionAssignmentEdge?: Maybe<ReviewQuestionAssignmentsEdge>;
};


/** The output of our delete `ReviewQuestionAssignment` mutation. */
export type DeleteReviewQuestionAssignmentPayloadReviewQuestionAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<ReviewQuestionAssignmentsOrderBy>>;
};

/** All input for the `deleteReviewResponseByNodeId` mutation. */
export type DeleteReviewResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewResponse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReviewResponse` mutation. */
export type DeleteReviewResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ReviewResponse` mutation. */
export type DeleteReviewResponsePayload = {
  __typename?: 'DeleteReviewResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewResponse` that was deleted by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  deletedReviewResponseNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewQuestionAssignment` that is related to this `ReviewResponse`. */
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignment>;
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
};


/** The output of our delete `ReviewResponse` mutation. */
export type DeleteReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the `deleteReviewStatusHistoryByNodeId` mutation. */
export type DeleteReviewStatusHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewStatusHistory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `ReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryPayload = {
  __typename?: 'DeleteReviewStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewStatusHistory` that was deleted by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  deletedReviewStatusHistoryNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our delete `ReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the `deleteTemplateActionByNodeId` mutation. */
export type DeleteTemplateActionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplateAction` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTemplateAction` mutation. */
export type DeleteTemplateActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `TemplateAction` mutation. */
export type DeleteTemplateActionPayload = {
  __typename?: 'DeleteTemplateActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateAction` that was deleted by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  deletedTemplateActionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our delete `TemplateAction` mutation. */
export type DeleteTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: Maybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the `deleteTemplateByNodeId` mutation. */
export type DeleteTemplateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Template` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTemplateElementByNodeId` mutation. */
export type DeleteTemplateElementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplateElement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTemplateElement` mutation. */
export type DeleteTemplateElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `TemplateElement` mutation. */
export type DeleteTemplateElementPayload = {
  __typename?: 'DeleteTemplateElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateElement` that was deleted by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  deletedTemplateElementNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our delete `TemplateElement` mutation. */
export type DeleteTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: Maybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the `deleteTemplate` mutation. */
export type DeleteTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayload = {
  __typename?: 'DeleteTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was deleted by this mutation. */
  template?: Maybe<Template>;
  deletedTemplateNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayloadTemplateEdgeArgs = {
  orderBy?: Maybe<Array<TemplatesOrderBy>>;
};

/** All input for the `deleteTemplatePermissionByNodeId` mutation. */
export type DeleteTemplatePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplatePermission` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTemplatePermission` mutation. */
export type DeleteTemplatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `TemplatePermission` mutation. */
export type DeleteTemplatePermissionPayload = {
  __typename?: 'DeleteTemplatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplatePermission` that was deleted by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  deletedTemplatePermissionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our delete `TemplatePermission` mutation. */
export type DeleteTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: Maybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the `deleteTemplateSectionByNodeId` mutation. */
export type DeleteTemplateSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplateSection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTemplateSection` mutation. */
export type DeleteTemplateSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `TemplateSection` mutation. */
export type DeleteTemplateSectionPayload = {
  __typename?: 'DeleteTemplateSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateSection` that was deleted by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  deletedTemplateSectionNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our delete `TemplateSection` mutation. */
export type DeleteTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: Maybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the `deleteTemplateStageByNodeId` mutation. */
export type DeleteTemplateStageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplateStage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTemplateStage` mutation. */
export type DeleteTemplateStageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `TemplateStage` mutation. */
export type DeleteTemplateStagePayload = {
  __typename?: 'DeleteTemplateStagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateStage` that was deleted by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  deletedTemplateStageNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our delete `TemplateStage` mutation. */
export type DeleteTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: Maybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the `deleteTriggerQueueByNodeId` mutation. */
export type DeleteTriggerQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TriggerQueue` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteTriggerQueue` mutation. */
export type DeleteTriggerQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `TriggerQueue` mutation. */
export type DeleteTriggerQueuePayload = {
  __typename?: 'DeleteTriggerQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TriggerQueue` that was deleted by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  deletedTriggerQueueNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our delete `TriggerQueue` mutation. */
export type DeleteTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: Maybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the `deleteUserByNodeId` mutation. */
export type DeleteUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserByUsername` mutation. */
export type DeleteUserByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  username: Scalars['String'];
};

/** All input for the `deleteUser` mutation. */
export type DeleteUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** All input for the `deleteUserOrganisationByNodeId` mutation. */
export type DeleteUserOrganisationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserOrganisation` to be deleted. */
  nodeId: Scalars['ID'];
};

/** All input for the `deleteUserOrganisation` mutation. */
export type DeleteUserOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
};

/** The output of our delete `UserOrganisation` mutation. */
export type DeleteUserOrganisationPayload = {
  __typename?: 'DeleteUserOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserOrganisation` that was deleted by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  deletedUserOrganisationNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our delete `UserOrganisation` mutation. */
export type DeleteUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: Maybe<Array<UserOrganisationsOrderBy>>;
};

/** The output of our delete `User` mutation. */
export type DeleteUserPayload = {
  __typename?: 'DeleteUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was deleted by this mutation. */
  user?: Maybe<User>;
  deletedUserNodeId?: Maybe<Scalars['ID']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our delete `User` mutation. */
export type DeleteUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

export type ElementTypePlugin = Node & {
  __typename?: 'ElementTypePlugin';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  code: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  path?: Maybe<Scalars['String']>;
  displayComponentName?: Maybe<Scalars['String']>;
  configComponentName?: Maybe<Scalars['String']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/**
 * A condition to be used against `ElementTypePlugin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ElementTypePluginCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `category` field. */
  category?: Maybe<TemplateElementCategory>;
  /** Checks for equality with the object’s `path` field. */
  path?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `displayComponentName` field. */
  displayComponentName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `configComponentName` field. */
  configComponentName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `requiredParameters` field. */
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** A filter to be used against `ElementTypePlugin` object types. All fields are combined with a logical ‘and.’ */
export type ElementTypePluginFilter = {
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `category` field. */
  category?: Maybe<TemplateElementCategoryFilter>;
  /** Filter by the object’s `path` field. */
  path?: Maybe<StringFilter>;
  /** Filter by the object’s `displayComponentName` field. */
  displayComponentName?: Maybe<StringFilter>;
  /** Filter by the object’s `configComponentName` field. */
  configComponentName?: Maybe<StringFilter>;
  /** Filter by the object’s `requiredParameters` field. */
  requiredParameters?: Maybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ElementTypePluginFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ElementTypePluginFilter>>;
  /** Negates the expression. */
  not?: Maybe<ElementTypePluginFilter>;
};

/** An input for mutations affecting `ElementTypePlugin` */
export type ElementTypePluginInput = {
  code: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  path?: Maybe<Scalars['String']>;
  displayComponentName?: Maybe<Scalars['String']>;
  configComponentName?: Maybe<Scalars['String']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** Represents an update to a `ElementTypePlugin`. Fields that are set will be updated. */
export type ElementTypePluginPatch = {
  code?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  path?: Maybe<Scalars['String']>;
  displayComponentName?: Maybe<Scalars['String']>;
  configComponentName?: Maybe<Scalars['String']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']>>>;
};

/** A connection to a list of `ElementTypePlugin` values. */
export type ElementTypePluginsConnection = {
  __typename?: 'ElementTypePluginsConnection';
  /** A list of `ElementTypePlugin` objects. */
  nodes: Array<Maybe<ElementTypePlugin>>;
  /** A list of edges which contains the `ElementTypePlugin` and cursor to aid in pagination. */
  edges: Array<ElementTypePluginsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ElementTypePlugin` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ElementTypePlugin` edge in the connection. */
export type ElementTypePluginsEdge = {
  __typename?: 'ElementTypePluginsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ElementTypePlugin` at the end of the edge. */
  node?: Maybe<ElementTypePlugin>;
};

/** Methods to use when ordering `ElementTypePlugin`. */
export enum ElementTypePluginsOrderBy {
  Natural = 'NATURAL',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  DisplayComponentNameAsc = 'DISPLAY_COMPONENT_NAME_ASC',
  DisplayComponentNameDesc = 'DISPLAY_COMPONENT_NAME_DESC',
  ConfigComponentNameAsc = 'CONFIG_COMPONENT_NAME_ASC',
  ConfigComponentNameDesc = 'CONFIG_COMPONENT_NAME_DESC',
  RequiredParametersAsc = 'REQUIRED_PARAMETERS_ASC',
  RequiredParametersDesc = 'REQUIRED_PARAMETERS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type File = Node & {
  __typename?: 'File';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  /** Reads a single `User` that is related to this `File`. */
  user?: Maybe<User>;
  /** Reads a single `Application` that is related to this `File`. */
  application?: Maybe<Application>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Reads and enables pagination through a set of `Notification`. */
  notificationsByDocumentId: NotificationsConnection;
};


export type FileNotificationsByDocumentIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
};

/** The `application` to be created by this mutation. */
export type FileApplicationIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** The `file` to be created by this mutation. */
export type FileApplicationIdFkeyFileCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `FileInput` mutation. */
export type FileApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<ApplicationApplicationSerialKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationNodeIdDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<ApplicationOnFileForFileApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<ApplicationOnFileForFileApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<FileOnFileForFileApplicationIdFkeyNodeIdUpdate>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<FileApplicationIdFkeyApplicationCreateInput>;
};

/** Input for the nested mutation of `file` in the `ApplicationInput` mutation. */
export type FileApplicationIdFkeyInverseInput = {
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: Maybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: Maybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: Maybe<Array<FileOnFileForFileApplicationIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationOnFileForFileApplicationIdFkeyNodeIdUpdate>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FileApplicationIdFkeyFileCreateInput>>;
};

/** The `applicationResponse` to be created by this mutation. */
export type FileApplicationResponseIdFkeyApplicationResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** The `file` to be created by this mutation. */
export type FileApplicationResponseIdFkeyFileCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** Input for the nested mutation of `applicationResponse` in the `FileInput` mutation. */
export type FileApplicationResponseIdFkeyInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: Maybe<ApplicationResponseApplicationResponsePkeyConnect>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationResponseNodeIdConnect>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationResponseApplicationResponsePkeyDelete>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: Maybe<ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: Maybe<FileApplicationResponseIdFkeyApplicationResponseCreateInput>;
};

/** Input for the nested mutation of `file` in the `ApplicationResponseInput` mutation. */
export type FileApplicationResponseIdFkeyInverseInput = {
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: Maybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: Maybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: Maybe<Array<FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FileApplicationResponseIdFkeyFileCreateInput>>;
};

/** A condition to be used against `File` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FileCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `originalFilename` field. */
  originalFilename?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `path` field. */
  path?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `mimetype` field. */
  mimetype?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `applicationResponseId` field. */
  applicationResponseId?: Maybe<Scalars['Int']>;
};

/** The fields on `file` to look up the row to connect. */
export type FileFilePkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `file` to look up the row to delete. */
export type FileFilePkeyDelete = {
  id: Scalars['Int'];
};

/** A filter to be used against `File` object types. All fields are combined with a logical ‘and.’ */
export type FileFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `originalFilename` field. */
  originalFilename?: Maybe<StringFilter>;
  /** Filter by the object’s `path` field. */
  path?: Maybe<StringFilter>;
  /** Filter by the object’s `mimetype` field. */
  mimetype?: Maybe<StringFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationResponseId` field. */
  applicationResponseId?: Maybe<IntFilter>;
  /** Filter by the object’s `notificationsByDocumentId` relation. */
  notificationsByDocumentId?: Maybe<FileToManyNotificationFilter>;
  /** Some related `notificationsByDocumentId` exist. */
  notificationsByDocumentIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `application` relation. */
  application?: Maybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `applicationResponse` relation. */
  applicationResponse?: Maybe<ApplicationResponseFilter>;
  /** A related `applicationResponse` exists. */
  applicationResponseExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<FileFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<FileFilter>>;
  /** Negates the expression. */
  not?: Maybe<FileFilter>;
};

/** An input for mutations affecting `File` */
export type FileInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type FileNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FileNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `file` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationIdFkeyUsingFilePkeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileUserIdFkeyUsingFilePkeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnNotificationForNotificationDocumentIdFkeyUsingFilePkeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnNotificationForNotificationDocumentIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `File`. Fields that are set will be updated. */
export type FilePatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** A connection to a list of `File` values. */
export type FilesConnection = {
  __typename?: 'FilesConnection';
  /** A list of `File` objects. */
  nodes: Array<Maybe<File>>;
  /** A list of edges which contains the `File` and cursor to aid in pagination. */
  edges: Array<FilesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `File` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `File` edge in the connection. */
export type FilesEdge = {
  __typename?: 'FilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `File` at the end of the edge. */
  node?: Maybe<File>;
};

/** Methods to use when ordering `File`. */
export enum FilesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  OriginalFilenameAsc = 'ORIGINAL_FILENAME_ASC',
  OriginalFilenameDesc = 'ORIGINAL_FILENAME_DESC',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  MimetypeAsc = 'MIMETYPE_ASC',
  MimetypeDesc = 'MIMETYPE_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ApplicationResponseIdAsc = 'APPLICATION_RESPONSE_ID_ASC',
  ApplicationResponseIdDesc = 'APPLICATION_RESPONSE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type FileToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<NotificationFilter>;
};

/** The `file` to be created by this mutation. */
export type FileUserIdFkeyFileCreateInput = {
  id?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** Input for the nested mutation of `user` in the `FileInput` mutation. */
export type FileUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: Maybe<UserUserUsernameKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: Maybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnFileForFileUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: Maybe<UserOnFileForFileUserIdFkeyUsingUserUsernameKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<FileOnFileForFileUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<FileUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `file` in the `UserInput` mutation. */
export type FileUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: Maybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: Maybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: Maybe<Array<FileOnFileForFileUserIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnFileForFileUserIdFkeyNodeIdUpdate>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: Maybe<Array<FileUserIdFkeyFileCreateInput>>;
};

/** The `user` to be created by this mutation. */
export type FileUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['Int']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['Int']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['Int']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['Int']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['Int']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['Int']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['Int']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['Int']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['Int']>;
};


/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['JSON']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['JSON']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['JSON']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['JSON']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['JSON']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['JSON']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['JSON']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['JSON']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['JSON']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['JSON']>;
  /** Contains the specified JSON. */
  contains?: Maybe<Scalars['JSON']>;
  /** Contains the specified key. */
  containsKey?: Maybe<Scalars['String']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: Maybe<Array<Scalars['String']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: Maybe<Array<Scalars['String']>>;
  /** Contained by the specified JSON. */
  containedBy?: Maybe<Scalars['JSON']>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `ActionPlugin`. */
  createActionPlugin?: Maybe<CreateActionPluginPayload>;
  /** Creates a single `ActionQueue`. */
  createActionQueue?: Maybe<CreateActionQueuePayload>;
  /** Creates a single `Application`. */
  createApplication?: Maybe<CreateApplicationPayload>;
  /** Creates a single `ApplicationResponse`. */
  createApplicationResponse?: Maybe<CreateApplicationResponsePayload>;
  /** Creates a single `ApplicationSection`. */
  createApplicationSection?: Maybe<CreateApplicationSectionPayload>;
  /** Creates a single `ApplicationStageHistory`. */
  createApplicationStageHistory?: Maybe<CreateApplicationStageHistoryPayload>;
  /** Creates a single `ApplicationStatusHistory`. */
  createApplicationStatusHistory?: Maybe<CreateApplicationStatusHistoryPayload>;
  /** Creates a single `ElementTypePlugin`. */
  createElementTypePlugin?: Maybe<CreateElementTypePluginPayload>;
  /** Creates a single `File`. */
  createFile?: Maybe<CreateFilePayload>;
  /** Creates a single `Notification`. */
  createNotification?: Maybe<CreateNotificationPayload>;
  /** Creates a single `Organisation`. */
  createOrganisation?: Maybe<CreateOrganisationPayload>;
  /** Creates a single `PermissionJoin`. */
  createPermissionJoin?: Maybe<CreatePermissionJoinPayload>;
  /** Creates a single `PermissionName`. */
  createPermissionName?: Maybe<CreatePermissionNamePayload>;
  /** Creates a single `PermissionPolicy`. */
  createPermissionPolicy?: Maybe<CreatePermissionPolicyPayload>;
  /** Creates a single `Review`. */
  createReview?: Maybe<CreateReviewPayload>;
  /** Creates a single `ReviewAssignment`. */
  createReviewAssignment?: Maybe<CreateReviewAssignmentPayload>;
  /** Creates a single `ReviewDecision`. */
  createReviewDecision?: Maybe<CreateReviewDecisionPayload>;
  /** Creates a single `ReviewQuestionAssignment`. */
  createReviewQuestionAssignment?: Maybe<CreateReviewQuestionAssignmentPayload>;
  /** Creates a single `ReviewResponse`. */
  createReviewResponse?: Maybe<CreateReviewResponsePayload>;
  /** Creates a single `ReviewStatusHistory`. */
  createReviewStatusHistory?: Maybe<CreateReviewStatusHistoryPayload>;
  /** Creates a single `Template`. */
  createTemplate?: Maybe<CreateTemplatePayload>;
  /** Creates a single `TemplateAction`. */
  createTemplateAction?: Maybe<CreateTemplateActionPayload>;
  /** Creates a single `TemplateElement`. */
  createTemplateElement?: Maybe<CreateTemplateElementPayload>;
  /** Creates a single `TemplatePermission`. */
  createTemplatePermission?: Maybe<CreateTemplatePermissionPayload>;
  /** Creates a single `TemplateSection`. */
  createTemplateSection?: Maybe<CreateTemplateSectionPayload>;
  /** Creates a single `TemplateStage`. */
  createTemplateStage?: Maybe<CreateTemplateStagePayload>;
  /** Creates a single `TriggerQueue`. */
  createTriggerQueue?: Maybe<CreateTriggerQueuePayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserOrganisation`. */
  createUserOrganisation?: Maybe<CreateUserOrganisationPayload>;
  /** Updates a single `ActionPlugin` using its globally unique id and a patch. */
  updateActionPluginByNodeId?: Maybe<UpdateActionPluginPayload>;
  /** Updates a single `ActionPlugin` using a unique key and a patch. */
  updateActionPlugin?: Maybe<UpdateActionPluginPayload>;
  /** Updates a single `ActionQueue` using its globally unique id and a patch. */
  updateActionQueueByNodeId?: Maybe<UpdateActionQueuePayload>;
  /** Updates a single `ActionQueue` using a unique key and a patch. */
  updateActionQueue?: Maybe<UpdateActionQueuePayload>;
  /** Updates a single `Application` using its globally unique id and a patch. */
  updateApplicationByNodeId?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplication?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplicationBySerial?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `ApplicationResponse` using its globally unique id and a patch. */
  updateApplicationResponseByNodeId?: Maybe<UpdateApplicationResponsePayload>;
  /** Updates a single `ApplicationResponse` using a unique key and a patch. */
  updateApplicationResponse?: Maybe<UpdateApplicationResponsePayload>;
  /** Updates a single `ApplicationSection` using its globally unique id and a patch. */
  updateApplicationSectionByNodeId?: Maybe<UpdateApplicationSectionPayload>;
  /** Updates a single `ApplicationSection` using a unique key and a patch. */
  updateApplicationSection?: Maybe<UpdateApplicationSectionPayload>;
  /** Updates a single `ApplicationStageHistory` using its globally unique id and a patch. */
  updateApplicationStageHistoryByNodeId?: Maybe<UpdateApplicationStageHistoryPayload>;
  /** Updates a single `ApplicationStageHistory` using a unique key and a patch. */
  updateApplicationStageHistory?: Maybe<UpdateApplicationStageHistoryPayload>;
  /** Updates a single `ApplicationStatusHistory` using its globally unique id and a patch. */
  updateApplicationStatusHistoryByNodeId?: Maybe<UpdateApplicationStatusHistoryPayload>;
  /** Updates a single `ApplicationStatusHistory` using a unique key and a patch. */
  updateApplicationStatusHistory?: Maybe<UpdateApplicationStatusHistoryPayload>;
  /** Updates a single `ElementTypePlugin` using its globally unique id and a patch. */
  updateElementTypePluginByNodeId?: Maybe<UpdateElementTypePluginPayload>;
  /** Updates a single `ElementTypePlugin` using a unique key and a patch. */
  updateElementTypePlugin?: Maybe<UpdateElementTypePluginPayload>;
  /** Updates a single `File` using its globally unique id and a patch. */
  updateFileByNodeId?: Maybe<UpdateFilePayload>;
  /** Updates a single `File` using a unique key and a patch. */
  updateFile?: Maybe<UpdateFilePayload>;
  /** Updates a single `Notification` using its globally unique id and a patch. */
  updateNotificationByNodeId?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Notification` using a unique key and a patch. */
  updateNotification?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Organisation` using its globally unique id and a patch. */
  updateOrganisationByNodeId?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `Organisation` using a unique key and a patch. */
  updateOrganisation?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `Organisation` using a unique key and a patch. */
  updateOrganisationByName?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `PermissionJoin` using its globally unique id and a patch. */
  updatePermissionJoinByNodeId?: Maybe<UpdatePermissionJoinPayload>;
  /** Updates a single `PermissionJoin` using a unique key and a patch. */
  updatePermissionJoin?: Maybe<UpdatePermissionJoinPayload>;
  /** Updates a single `PermissionName` using its globally unique id and a patch. */
  updatePermissionNameByNodeId?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionName` using a unique key and a patch. */
  updatePermissionName?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionName` using a unique key and a patch. */
  updatePermissionNameByName?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionPolicy` using its globally unique id and a patch. */
  updatePermissionPolicyByNodeId?: Maybe<UpdatePermissionPolicyPayload>;
  /** Updates a single `PermissionPolicy` using a unique key and a patch. */
  updatePermissionPolicy?: Maybe<UpdatePermissionPolicyPayload>;
  /** Updates a single `Review` using its globally unique id and a patch. */
  updateReviewByNodeId?: Maybe<UpdateReviewPayload>;
  /** Updates a single `Review` using a unique key and a patch. */
  updateReview?: Maybe<UpdateReviewPayload>;
  /** Updates a single `ReviewAssignment` using its globally unique id and a patch. */
  updateReviewAssignmentByNodeId?: Maybe<UpdateReviewAssignmentPayload>;
  /** Updates a single `ReviewAssignment` using a unique key and a patch. */
  updateReviewAssignment?: Maybe<UpdateReviewAssignmentPayload>;
  /** Updates a single `ReviewDecision` using its globally unique id and a patch. */
  updateReviewDecisionByNodeId?: Maybe<UpdateReviewDecisionPayload>;
  /** Updates a single `ReviewDecision` using a unique key and a patch. */
  updateReviewDecision?: Maybe<UpdateReviewDecisionPayload>;
  /** Updates a single `ReviewQuestionAssignment` using its globally unique id and a patch. */
  updateReviewQuestionAssignmentByNodeId?: Maybe<UpdateReviewQuestionAssignmentPayload>;
  /** Updates a single `ReviewQuestionAssignment` using a unique key and a patch. */
  updateReviewQuestionAssignment?: Maybe<UpdateReviewQuestionAssignmentPayload>;
  /** Updates a single `ReviewResponse` using its globally unique id and a patch. */
  updateReviewResponseByNodeId?: Maybe<UpdateReviewResponsePayload>;
  /** Updates a single `ReviewResponse` using a unique key and a patch. */
  updateReviewResponse?: Maybe<UpdateReviewResponsePayload>;
  /** Updates a single `ReviewStatusHistory` using its globally unique id and a patch. */
  updateReviewStatusHistoryByNodeId?: Maybe<UpdateReviewStatusHistoryPayload>;
  /** Updates a single `ReviewStatusHistory` using a unique key and a patch. */
  updateReviewStatusHistory?: Maybe<UpdateReviewStatusHistoryPayload>;
  /** Updates a single `Template` using its globally unique id and a patch. */
  updateTemplateByNodeId?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `Template` using a unique key and a patch. */
  updateTemplate?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `TemplateAction` using its globally unique id and a patch. */
  updateTemplateActionByNodeId?: Maybe<UpdateTemplateActionPayload>;
  /** Updates a single `TemplateAction` using a unique key and a patch. */
  updateTemplateAction?: Maybe<UpdateTemplateActionPayload>;
  /** Updates a single `TemplateElement` using its globally unique id and a patch. */
  updateTemplateElementByNodeId?: Maybe<UpdateTemplateElementPayload>;
  /** Updates a single `TemplateElement` using a unique key and a patch. */
  updateTemplateElement?: Maybe<UpdateTemplateElementPayload>;
  /** Updates a single `TemplatePermission` using its globally unique id and a patch. */
  updateTemplatePermissionByNodeId?: Maybe<UpdateTemplatePermissionPayload>;
  /** Updates a single `TemplatePermission` using a unique key and a patch. */
  updateTemplatePermission?: Maybe<UpdateTemplatePermissionPayload>;
  /** Updates a single `TemplateSection` using its globally unique id and a patch. */
  updateTemplateSectionByNodeId?: Maybe<UpdateTemplateSectionPayload>;
  /** Updates a single `TemplateSection` using a unique key and a patch. */
  updateTemplateSection?: Maybe<UpdateTemplateSectionPayload>;
  /** Updates a single `TemplateStage` using its globally unique id and a patch. */
  updateTemplateStageByNodeId?: Maybe<UpdateTemplateStagePayload>;
  /** Updates a single `TemplateStage` using a unique key and a patch. */
  updateTemplateStage?: Maybe<UpdateTemplateStagePayload>;
  /** Updates a single `TriggerQueue` using its globally unique id and a patch. */
  updateTriggerQueueByNodeId?: Maybe<UpdateTriggerQueuePayload>;
  /** Updates a single `TriggerQueue` using a unique key and a patch. */
  updateTriggerQueue?: Maybe<UpdateTriggerQueuePayload>;
  /** Updates a single `User` using its globally unique id and a patch. */
  updateUserByNodeId?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUser?: Maybe<UpdateUserPayload>;
  /** Updates a single `User` using a unique key and a patch. */
  updateUserByUsername?: Maybe<UpdateUserPayload>;
  /** Updates a single `UserOrganisation` using its globally unique id and a patch. */
  updateUserOrganisationByNodeId?: Maybe<UpdateUserOrganisationPayload>;
  /** Updates a single `UserOrganisation` using a unique key and a patch. */
  updateUserOrganisation?: Maybe<UpdateUserOrganisationPayload>;
  /** Deletes a single `ActionPlugin` using its globally unique id. */
  deleteActionPluginByNodeId?: Maybe<DeleteActionPluginPayload>;
  /** Deletes a single `ActionPlugin` using a unique key. */
  deleteActionPlugin?: Maybe<DeleteActionPluginPayload>;
  /** Deletes a single `ActionQueue` using its globally unique id. */
  deleteActionQueueByNodeId?: Maybe<DeleteActionQueuePayload>;
  /** Deletes a single `ActionQueue` using a unique key. */
  deleteActionQueue?: Maybe<DeleteActionQueuePayload>;
  /** Deletes a single `Application` using its globally unique id. */
  deleteApplicationByNodeId?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplication?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplicationBySerial?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `ApplicationResponse` using its globally unique id. */
  deleteApplicationResponseByNodeId?: Maybe<DeleteApplicationResponsePayload>;
  /** Deletes a single `ApplicationResponse` using a unique key. */
  deleteApplicationResponse?: Maybe<DeleteApplicationResponsePayload>;
  /** Deletes a single `ApplicationSection` using its globally unique id. */
  deleteApplicationSectionByNodeId?: Maybe<DeleteApplicationSectionPayload>;
  /** Deletes a single `ApplicationSection` using a unique key. */
  deleteApplicationSection?: Maybe<DeleteApplicationSectionPayload>;
  /** Deletes a single `ApplicationStageHistory` using its globally unique id. */
  deleteApplicationStageHistoryByNodeId?: Maybe<DeleteApplicationStageHistoryPayload>;
  /** Deletes a single `ApplicationStageHistory` using a unique key. */
  deleteApplicationStageHistory?: Maybe<DeleteApplicationStageHistoryPayload>;
  /** Deletes a single `ApplicationStatusHistory` using its globally unique id. */
  deleteApplicationStatusHistoryByNodeId?: Maybe<DeleteApplicationStatusHistoryPayload>;
  /** Deletes a single `ApplicationStatusHistory` using a unique key. */
  deleteApplicationStatusHistory?: Maybe<DeleteApplicationStatusHistoryPayload>;
  /** Deletes a single `ElementTypePlugin` using its globally unique id. */
  deleteElementTypePluginByNodeId?: Maybe<DeleteElementTypePluginPayload>;
  /** Deletes a single `ElementTypePlugin` using a unique key. */
  deleteElementTypePlugin?: Maybe<DeleteElementTypePluginPayload>;
  /** Deletes a single `File` using its globally unique id. */
  deleteFileByNodeId?: Maybe<DeleteFilePayload>;
  /** Deletes a single `File` using a unique key. */
  deleteFile?: Maybe<DeleteFilePayload>;
  /** Deletes a single `Notification` using its globally unique id. */
  deleteNotificationByNodeId?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Notification` using a unique key. */
  deleteNotification?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Organisation` using its globally unique id. */
  deleteOrganisationByNodeId?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `Organisation` using a unique key. */
  deleteOrganisation?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `Organisation` using a unique key. */
  deleteOrganisationByName?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `PermissionJoin` using its globally unique id. */
  deletePermissionJoinByNodeId?: Maybe<DeletePermissionJoinPayload>;
  /** Deletes a single `PermissionJoin` using a unique key. */
  deletePermissionJoin?: Maybe<DeletePermissionJoinPayload>;
  /** Deletes a single `PermissionName` using its globally unique id. */
  deletePermissionNameByNodeId?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionName` using a unique key. */
  deletePermissionName?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionName` using a unique key. */
  deletePermissionNameByName?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionPolicy` using its globally unique id. */
  deletePermissionPolicyByNodeId?: Maybe<DeletePermissionPolicyPayload>;
  /** Deletes a single `PermissionPolicy` using a unique key. */
  deletePermissionPolicy?: Maybe<DeletePermissionPolicyPayload>;
  /** Deletes a single `Review` using its globally unique id. */
  deleteReviewByNodeId?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `Review` using a unique key. */
  deleteReview?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `ReviewAssignment` using its globally unique id. */
  deleteReviewAssignmentByNodeId?: Maybe<DeleteReviewAssignmentPayload>;
  /** Deletes a single `ReviewAssignment` using a unique key. */
  deleteReviewAssignment?: Maybe<DeleteReviewAssignmentPayload>;
  /** Deletes a single `ReviewDecision` using its globally unique id. */
  deleteReviewDecisionByNodeId?: Maybe<DeleteReviewDecisionPayload>;
  /** Deletes a single `ReviewDecision` using a unique key. */
  deleteReviewDecision?: Maybe<DeleteReviewDecisionPayload>;
  /** Deletes a single `ReviewQuestionAssignment` using its globally unique id. */
  deleteReviewQuestionAssignmentByNodeId?: Maybe<DeleteReviewQuestionAssignmentPayload>;
  /** Deletes a single `ReviewQuestionAssignment` using a unique key. */
  deleteReviewQuestionAssignment?: Maybe<DeleteReviewQuestionAssignmentPayload>;
  /** Deletes a single `ReviewResponse` using its globally unique id. */
  deleteReviewResponseByNodeId?: Maybe<DeleteReviewResponsePayload>;
  /** Deletes a single `ReviewResponse` using a unique key. */
  deleteReviewResponse?: Maybe<DeleteReviewResponsePayload>;
  /** Deletes a single `ReviewStatusHistory` using its globally unique id. */
  deleteReviewStatusHistoryByNodeId?: Maybe<DeleteReviewStatusHistoryPayload>;
  /** Deletes a single `ReviewStatusHistory` using a unique key. */
  deleteReviewStatusHistory?: Maybe<DeleteReviewStatusHistoryPayload>;
  /** Deletes a single `Template` using its globally unique id. */
  deleteTemplateByNodeId?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `Template` using a unique key. */
  deleteTemplate?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `TemplateAction` using its globally unique id. */
  deleteTemplateActionByNodeId?: Maybe<DeleteTemplateActionPayload>;
  /** Deletes a single `TemplateAction` using a unique key. */
  deleteTemplateAction?: Maybe<DeleteTemplateActionPayload>;
  /** Deletes a single `TemplateElement` using its globally unique id. */
  deleteTemplateElementByNodeId?: Maybe<DeleteTemplateElementPayload>;
  /** Deletes a single `TemplateElement` using a unique key. */
  deleteTemplateElement?: Maybe<DeleteTemplateElementPayload>;
  /** Deletes a single `TemplatePermission` using its globally unique id. */
  deleteTemplatePermissionByNodeId?: Maybe<DeleteTemplatePermissionPayload>;
  /** Deletes a single `TemplatePermission` using a unique key. */
  deleteTemplatePermission?: Maybe<DeleteTemplatePermissionPayload>;
  /** Deletes a single `TemplateSection` using its globally unique id. */
  deleteTemplateSectionByNodeId?: Maybe<DeleteTemplateSectionPayload>;
  /** Deletes a single `TemplateSection` using a unique key. */
  deleteTemplateSection?: Maybe<DeleteTemplateSectionPayload>;
  /** Deletes a single `TemplateStage` using its globally unique id. */
  deleteTemplateStageByNodeId?: Maybe<DeleteTemplateStagePayload>;
  /** Deletes a single `TemplateStage` using a unique key. */
  deleteTemplateStage?: Maybe<DeleteTemplateStagePayload>;
  /** Deletes a single `TriggerQueue` using its globally unique id. */
  deleteTriggerQueueByNodeId?: Maybe<DeleteTriggerQueuePayload>;
  /** Deletes a single `TriggerQueue` using a unique key. */
  deleteTriggerQueue?: Maybe<DeleteTriggerQueuePayload>;
  /** Deletes a single `User` using its globally unique id. */
  deleteUserByNodeId?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUser?: Maybe<DeleteUserPayload>;
  /** Deletes a single `User` using a unique key. */
  deleteUserByUsername?: Maybe<DeleteUserPayload>;
  /** Deletes a single `UserOrganisation` using its globally unique id. */
  deleteUserOrganisationByNodeId?: Maybe<DeleteUserOrganisationPayload>;
  /** Deletes a single `UserOrganisation` using a unique key. */
  deleteUserOrganisation?: Maybe<DeleteUserOrganisationPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActionPluginArgs = {
  input: CreateActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActionQueueArgs = {
  input: CreateActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationArgs = {
  input: CreateApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationResponseArgs = {
  input: CreateApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationSectionArgs = {
  input: CreateApplicationSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationStageHistoryArgs = {
  input: CreateApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationStatusHistoryArgs = {
  input: CreateApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateElementTypePluginArgs = {
  input: CreateElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFileArgs = {
  input: CreateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNotificationArgs = {
  input: CreateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganisationArgs = {
  input: CreateOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionJoinArgs = {
  input: CreatePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionNameArgs = {
  input: CreatePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionPolicyArgs = {
  input: CreatePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewArgs = {
  input: CreateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewAssignmentArgs = {
  input: CreateReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewDecisionArgs = {
  input: CreateReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewQuestionAssignmentArgs = {
  input: CreateReviewQuestionAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewResponseArgs = {
  input: CreateReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewStatusHistoryArgs = {
  input: CreateReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateArgs = {
  input: CreateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateActionArgs = {
  input: CreateTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateElementArgs = {
  input: CreateTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplatePermissionArgs = {
  input: CreateTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateSectionArgs = {
  input: CreateTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateStageArgs = {
  input: CreateTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTriggerQueueArgs = {
  input: CreateTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserOrganisationArgs = {
  input: CreateUserOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionPluginByNodeIdArgs = {
  input: UpdateActionPluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionPluginArgs = {
  input: UpdateActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionQueueByNodeIdArgs = {
  input: UpdateActionQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionQueueArgs = {
  input: UpdateActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationByNodeIdArgs = {
  input: UpdateApplicationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationArgs = {
  input: UpdateApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationBySerialArgs = {
  input: UpdateApplicationBySerialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationResponseByNodeIdArgs = {
  input: UpdateApplicationResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationResponseArgs = {
  input: UpdateApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationSectionByNodeIdArgs = {
  input: UpdateApplicationSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationSectionArgs = {
  input: UpdateApplicationSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStageHistoryByNodeIdArgs = {
  input: UpdateApplicationStageHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStageHistoryArgs = {
  input: UpdateApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStatusHistoryByNodeIdArgs = {
  input: UpdateApplicationStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStatusHistoryArgs = {
  input: UpdateApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElementTypePluginByNodeIdArgs = {
  input: UpdateElementTypePluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElementTypePluginArgs = {
  input: UpdateElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileByNodeIdArgs = {
  input: UpdateFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileArgs = {
  input: UpdateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationByNodeIdArgs = {
  input: UpdateNotificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationArgs = {
  input: UpdateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationByNodeIdArgs = {
  input: UpdateOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationArgs = {
  input: UpdateOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationByNameArgs = {
  input: UpdateOrganisationByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionJoinByNodeIdArgs = {
  input: UpdatePermissionJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionJoinArgs = {
  input: UpdatePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameByNodeIdArgs = {
  input: UpdatePermissionNameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameArgs = {
  input: UpdatePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameByNameArgs = {
  input: UpdatePermissionNameByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionPolicyByNodeIdArgs = {
  input: UpdatePermissionPolicyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionPolicyArgs = {
  input: UpdatePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewByNodeIdArgs = {
  input: UpdateReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewArgs = {
  input: UpdateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentByNodeIdArgs = {
  input: UpdateReviewAssignmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentArgs = {
  input: UpdateReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewDecisionByNodeIdArgs = {
  input: UpdateReviewDecisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewDecisionArgs = {
  input: UpdateReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewQuestionAssignmentByNodeIdArgs = {
  input: UpdateReviewQuestionAssignmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewQuestionAssignmentArgs = {
  input: UpdateReviewQuestionAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewResponseByNodeIdArgs = {
  input: UpdateReviewResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewResponseArgs = {
  input: UpdateReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewStatusHistoryByNodeIdArgs = {
  input: UpdateReviewStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewStatusHistoryArgs = {
  input: UpdateReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateByNodeIdArgs = {
  input: UpdateTemplateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateArgs = {
  input: UpdateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateActionByNodeIdArgs = {
  input: UpdateTemplateActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateActionArgs = {
  input: UpdateTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateElementByNodeIdArgs = {
  input: UpdateTemplateElementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateElementArgs = {
  input: UpdateTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplatePermissionByNodeIdArgs = {
  input: UpdateTemplatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplatePermissionArgs = {
  input: UpdateTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateSectionByNodeIdArgs = {
  input: UpdateTemplateSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateSectionArgs = {
  input: UpdateTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageByNodeIdArgs = {
  input: UpdateTemplateStageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageArgs = {
  input: UpdateTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerQueueByNodeIdArgs = {
  input: UpdateTriggerQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerQueueArgs = {
  input: UpdateTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByNodeIdArgs = {
  input: UpdateUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserByUsernameArgs = {
  input: UpdateUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationByNodeIdArgs = {
  input: UpdateUserOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationArgs = {
  input: UpdateUserOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionPluginByNodeIdArgs = {
  input: DeleteActionPluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionPluginArgs = {
  input: DeleteActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionQueueByNodeIdArgs = {
  input: DeleteActionQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionQueueArgs = {
  input: DeleteActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationByNodeIdArgs = {
  input: DeleteApplicationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationArgs = {
  input: DeleteApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationBySerialArgs = {
  input: DeleteApplicationBySerialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationResponseByNodeIdArgs = {
  input: DeleteApplicationResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationResponseArgs = {
  input: DeleteApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationSectionByNodeIdArgs = {
  input: DeleteApplicationSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationSectionArgs = {
  input: DeleteApplicationSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStageHistoryByNodeIdArgs = {
  input: DeleteApplicationStageHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStageHistoryArgs = {
  input: DeleteApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStatusHistoryByNodeIdArgs = {
  input: DeleteApplicationStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStatusHistoryArgs = {
  input: DeleteApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElementTypePluginByNodeIdArgs = {
  input: DeleteElementTypePluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElementTypePluginArgs = {
  input: DeleteElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileByNodeIdArgs = {
  input: DeleteFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileArgs = {
  input: DeleteFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationByNodeIdArgs = {
  input: DeleteNotificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationArgs = {
  input: DeleteNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationByNodeIdArgs = {
  input: DeleteOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationArgs = {
  input: DeleteOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationByNameArgs = {
  input: DeleteOrganisationByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionJoinByNodeIdArgs = {
  input: DeletePermissionJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionJoinArgs = {
  input: DeletePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameByNodeIdArgs = {
  input: DeletePermissionNameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameArgs = {
  input: DeletePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameByNameArgs = {
  input: DeletePermissionNameByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionPolicyByNodeIdArgs = {
  input: DeletePermissionPolicyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionPolicyArgs = {
  input: DeletePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewByNodeIdArgs = {
  input: DeleteReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewArgs = {
  input: DeleteReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentByNodeIdArgs = {
  input: DeleteReviewAssignmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentArgs = {
  input: DeleteReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewDecisionByNodeIdArgs = {
  input: DeleteReviewDecisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewDecisionArgs = {
  input: DeleteReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewQuestionAssignmentByNodeIdArgs = {
  input: DeleteReviewQuestionAssignmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewQuestionAssignmentArgs = {
  input: DeleteReviewQuestionAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewResponseByNodeIdArgs = {
  input: DeleteReviewResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewResponseArgs = {
  input: DeleteReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewStatusHistoryByNodeIdArgs = {
  input: DeleteReviewStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewStatusHistoryArgs = {
  input: DeleteReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateByNodeIdArgs = {
  input: DeleteTemplateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateArgs = {
  input: DeleteTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateActionByNodeIdArgs = {
  input: DeleteTemplateActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateActionArgs = {
  input: DeleteTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateElementByNodeIdArgs = {
  input: DeleteTemplateElementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateElementArgs = {
  input: DeleteTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplatePermissionByNodeIdArgs = {
  input: DeleteTemplatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplatePermissionArgs = {
  input: DeleteTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateSectionByNodeIdArgs = {
  input: DeleteTemplateSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateSectionArgs = {
  input: DeleteTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageByNodeIdArgs = {
  input: DeleteTemplateStageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageArgs = {
  input: DeleteTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerQueueByNodeIdArgs = {
  input: DeleteTriggerQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerQueueArgs = {
  input: DeleteTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByNodeIdArgs = {
  input: DeleteUserByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserArgs = {
  input: DeleteUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserByUsernameArgs = {
  input: DeleteUserByUsernameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationByNodeIdArgs = {
  input: DeleteUserOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationArgs = {
  input: DeleteUserOrganisationInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
};

export type Notification = Node & {
  __typename?: 'Notification';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  userId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  /** Reads a single `User` that is related to this `Notification`. */
  user?: Maybe<User>;
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  /** Reads a single `File` that is related to this `Notification`. */
  document?: Maybe<File>;
};

/** The `application` to be created by this mutation. */
export type NotificationApplicationIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `NotificationInput` mutation. */
export type NotificationApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<ApplicationApplicationSerialKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationNodeIdDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<NotificationApplicationIdFkeyApplicationCreateInput>;
};

/** Input for the nested mutation of `notification` in the `ApplicationInput` mutation. */
export type NotificationApplicationIdFkeyInverseInput = {
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: Maybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<NotificationNodeIdConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: Maybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<NotificationNodeIdDelete>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: Maybe<Array<NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<NotificationApplicationIdFkeyNotificationCreateInput>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationApplicationIdFkeyNotificationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/**
 * A condition to be used against `Notification` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type NotificationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `message` field. */
  message?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `documentId` field. */
  documentId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `isRead` field. */
  isRead?: Maybe<Scalars['Boolean']>;
};

/** The `file` to be created by this mutation. */
export type NotificationDocumentIdFkeyFileCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** Input for the nested mutation of `file` in the `NotificationInput` mutation. */
export type NotificationDocumentIdFkeyInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: Maybe<FileFilePkeyConnect>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: Maybe<FileNodeIdConnect>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: Maybe<FileFilePkeyDelete>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: Maybe<FileNodeIdDelete>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: Maybe<FileOnNotificationForNotificationDocumentIdFkeyUsingFilePkeyUpdate>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: Maybe<NotificationOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: Maybe<NotificationDocumentIdFkeyFileCreateInput>;
};

/** Input for the nested mutation of `notification` in the `FileInput` mutation. */
export type NotificationDocumentIdFkeyInverseInput = {
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: Maybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<NotificationNodeIdConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: Maybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<NotificationNodeIdDelete>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: Maybe<Array<NotificationOnNotificationForNotificationDocumentIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<FileOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<NotificationDocumentIdFkeyNotificationCreateInput>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationDocumentIdFkeyNotificationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** A filter to be used against `Notification` object types. All fields are combined with a logical ‘and.’ */
export type NotificationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: Maybe<IntFilter>;
  /** Filter by the object’s `subject` field. */
  subject?: Maybe<StringFilter>;
  /** Filter by the object’s `message` field. */
  message?: Maybe<StringFilter>;
  /** Filter by the object’s `documentId` field. */
  documentId?: Maybe<IntFilter>;
  /** Filter by the object’s `isRead` field. */
  isRead?: Maybe<BooleanFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `application` relation. */
  application?: Maybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `review` relation. */
  review?: Maybe<ReviewFilter>;
  /** A related `review` exists. */
  reviewExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `document` relation. */
  document?: Maybe<FileFilter>;
  /** A related `document` exists. */
  documentExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<NotificationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<NotificationFilter>>;
  /** Negates the expression. */
  not?: Maybe<NotificationFilter>;
};

/** An input for mutations affecting `Notification` */
export type NotificationInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type NotificationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type NotificationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `notification` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The fields on `notification` to look up the row to connect. */
export type NotificationNotificationPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `notification` to look up the row to delete. */
export type NotificationNotificationPkeyDelete = {
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate = {
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationDocumentIdFkeyUsingNotificationPkeyUpdate = {
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationDocumentIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate = {
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationUserIdFkeyUsingNotificationPkeyUpdate = {
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `Notification`. Fields that are set will be updated. */
export type NotificationPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** Input for the nested mutation of `review` in the `NotificationInput` mutation. */
export type NotificationReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: Maybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: Maybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewNodeIdDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: Maybe<ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: Maybe<NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: Maybe<NotificationReviewIdFkeyReviewCreateInput>;
};

/** Input for the nested mutation of `notification` in the `ReviewInput` mutation. */
export type NotificationReviewIdFkeyInverseInput = {
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: Maybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<NotificationNodeIdConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: Maybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<NotificationNodeIdDelete>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: Maybe<Array<NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<NotificationReviewIdFkeyNotificationCreateInput>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationReviewIdFkeyNotificationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** The `review` to be created by this mutation. */
export type NotificationReviewIdFkeyReviewCreateInput = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** A connection to a list of `Notification` values. */
export type NotificationsConnection = {
  __typename?: 'NotificationsConnection';
  /** A list of `Notification` objects. */
  nodes: Array<Maybe<Notification>>;
  /** A list of edges which contains the `Notification` and cursor to aid in pagination. */
  edges: Array<NotificationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Notification` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Notification` edge in the connection. */
export type NotificationsEdge = {
  __typename?: 'NotificationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Notification` at the end of the edge. */
  node?: Maybe<Notification>;
};

/** Methods to use when ordering `Notification`. */
export enum NotificationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  SubjectAsc = 'SUBJECT_ASC',
  SubjectDesc = 'SUBJECT_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  DocumentIdAsc = 'DOCUMENT_ID_ASC',
  DocumentIdDesc = 'DOCUMENT_ID_DESC',
  IsReadAsc = 'IS_READ_ASC',
  IsReadDesc = 'IS_READ_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `user` in the `NotificationInput` mutation. */
export type NotificationUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: Maybe<UserUserUsernameKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: Maybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnNotificationForNotificationUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: Maybe<UserOnNotificationForNotificationUserIdFkeyUsingUserUsernameKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<NotificationOnNotificationForNotificationUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<NotificationUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `notification` in the `UserInput` mutation. */
export type NotificationUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: Maybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<NotificationNodeIdConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: Maybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<NotificationNodeIdDelete>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: Maybe<Array<NotificationOnNotificationForNotificationUserIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnNotificationForNotificationUserIdFkeyNodeIdUpdate>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<NotificationUserIdFkeyNotificationCreateInput>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationUserIdFkeyNotificationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type NotificationUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

export type Organisation = Node & {
  __typename?: 'Organisation';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations: UserOrganisationsConnection;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins: PermissionJoinsConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applicationsByOrgId: ApplicationsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments: ReviewAssignmentsConnection;
};


export type OrganisationUserOrganisationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserOrganisationsOrderBy>>;
  condition?: Maybe<UserOrganisationCondition>;
  filter?: Maybe<UserOrganisationFilter>;
};


export type OrganisationPermissionJoinsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionJoinsOrderBy>>;
  condition?: Maybe<PermissionJoinCondition>;
  filter?: Maybe<PermissionJoinFilter>;
};


export type OrganisationApplicationsByOrgIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationsOrderBy>>;
  condition?: Maybe<ApplicationCondition>;
  filter?: Maybe<ApplicationFilter>;
};


export type OrganisationReviewAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
  condition?: Maybe<ReviewAssignmentCondition>;
  filter?: Maybe<ReviewAssignmentFilter>;
};

/**
 * A condition to be used against `Organisation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganisationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `licenceNumber` field. */
  licenceNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: Maybe<Scalars['String']>;
};

/** A filter to be used against `Organisation` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `licenceNumber` field. */
  licenceNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `address` field. */
  address?: Maybe<StringFilter>;
  /** Filter by the object’s `userOrganisations` relation. */
  userOrganisations?: Maybe<OrganisationToManyUserOrganisationFilter>;
  /** Some related `userOrganisations` exist. */
  userOrganisationsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `permissionJoins` relation. */
  permissionJoins?: Maybe<OrganisationToManyPermissionJoinFilter>;
  /** Some related `permissionJoins` exist. */
  permissionJoinsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `applicationsByOrgId` relation. */
  applicationsByOrgId?: Maybe<OrganisationToManyApplicationFilter>;
  /** Some related `applicationsByOrgId` exist. */
  applicationsByOrgIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewAssignments` relation. */
  reviewAssignments?: Maybe<OrganisationToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignments` exist. */
  reviewAssignmentsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<OrganisationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<OrganisationFilter>>;
  /** Negates the expression. */
  not?: Maybe<OrganisationFilter>;
};

/** An input for mutations affecting `Organisation` */
export type OrganisationInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OrganisationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OrganisationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `organisation` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `organisation` to look up the row to connect. */
export type OrganisationOrganisationNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `organisation` to look up the row to delete. */
export type OrganisationOrganisationNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `organisation` to look up the row to connect. */
export type OrganisationOrganisationPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `organisation` to look up the row to delete. */
export type OrganisationOrganisationPkeyDelete = {
  id: Scalars['Int'];
};

/** Represents an update to a `Organisation`. Fields that are set will be updated. */
export type OrganisationPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** A connection to a list of `Organisation` values. */
export type OrganisationsConnection = {
  __typename?: 'OrganisationsConnection';
  /** A list of `Organisation` objects. */
  nodes: Array<Maybe<Organisation>>;
  /** A list of edges which contains the `Organisation` and cursor to aid in pagination. */
  edges: Array<OrganisationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organisation` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Organisation` edge in the connection. */
export type OrganisationsEdge = {
  __typename?: 'OrganisationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Organisation` at the end of the edge. */
  node?: Maybe<Organisation>;
};

/** Methods to use when ordering `Organisation`. */
export enum OrganisationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  LicenceNumberAsc = 'LICENCE_NUMBER_ASC',
  LicenceNumberDesc = 'LICENCE_NUMBER_DESC',
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationFilter>;
};

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PermissionJoinFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyUserOrganisationFilter = {
  /** Every related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<UserOrganisationFilter>;
  /** Some related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<UserOrganisationFilter>;
  /** No related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<UserOrganisationFilter>;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
};

export type PermissionJoin = Node & {
  __typename?: 'PermissionJoin';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  userId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  /** Reads a single `User` that is related to this `PermissionJoin`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
};

/**
 * A condition to be used against `PermissionJoin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PermissionJoinCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type PermissionJoinFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: Maybe<IntFilter>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: Maybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: Maybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `permissionName` relation. */
  permissionName?: Maybe<PermissionNameFilter>;
  /** A related `permissionName` exists. */
  permissionNameExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PermissionJoinFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PermissionJoinFilter>>;
  /** Negates the expression. */
  not?: Maybe<PermissionJoinFilter>;
};

/** An input for mutations affecting `PermissionJoin` */
export type PermissionJoinInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<PermissionJoinUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: Maybe<PermissionJoinPermissionNameIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate = {
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate = {
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyUsingPermissionJoinPkeyUpdate = {
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** Input for the nested mutation of `organisation` in the `PermissionJoinInput` mutation. */
export type PermissionJoinOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: Maybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: Maybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: Maybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: Maybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: Maybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: Maybe<OrganisationNodeIdDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: Maybe<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: Maybe<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: Maybe<PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: Maybe<PermissionJoinOrganisationIdFkeyOrganisationCreateInput>;
};

/** Input for the nested mutation of `permissionJoin` in the `OrganisationInput` mutation. */
export type PermissionJoinOrganisationIdFkeyInverseInput = {
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: Maybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PermissionJoinNodeIdConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: Maybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PermissionJoinNodeIdDelete>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: Maybe<Array<PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput>>;
};

/** The `organisation` to be created by this mutation. */
export type PermissionJoinOrganisationIdFkeyOrganisationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** The `permissionJoin` to be created by this mutation. */
export type PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<PermissionJoinUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: Maybe<PermissionJoinPermissionNameIdFkeyInput>;
};

/** Represents an update to a `PermissionJoin`. Fields that are set will be updated. */
export type PermissionJoinPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<PermissionJoinUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: Maybe<PermissionJoinPermissionNameIdFkeyInput>;
};

/** The fields on `permissionJoin` to look up the row to connect. */
export type PermissionJoinPermissionJoinPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `permissionJoin` to look up the row to delete. */
export type PermissionJoinPermissionJoinPkeyDelete = {
  id: Scalars['Int'];
};

/** Input for the nested mutation of `permissionName` in the `PermissionJoinInput` mutation. */
export type PermissionJoinPermissionNameIdFkeyInput = {
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: Maybe<PermissionNamePermissionNamePkeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: Maybe<PermissionNamePermissionNameNameKeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: Maybe<PermissionNameNodeIdConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: Maybe<PermissionNamePermissionNamePkeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: Maybe<PermissionNamePermissionNameNameKeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PermissionNameNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: Maybe<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: Maybe<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: Maybe<PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: Maybe<PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput>;
};

/** Input for the nested mutation of `permissionJoin` in the `PermissionNameInput` mutation. */
export type PermissionJoinPermissionNameIdFkeyInverseInput = {
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: Maybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PermissionJoinNodeIdConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: Maybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PermissionJoinNodeIdDelete>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: Maybe<Array<PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput>>;
};

/** The `permissionJoin` to be created by this mutation. */
export type PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<PermissionJoinUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: Maybe<PermissionJoinPermissionNameIdFkeyInput>;
};

/** The `permissionName` to be created by this mutation. */
export type PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  permissionPolicyId?: Maybe<Scalars['Int']>;
  permissionPolicyToPermissionPolicyId?: Maybe<PermissionNamePermissionPolicyIdFkeyInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** A connection to a list of `PermissionJoin` values. */
export type PermissionJoinsConnection = {
  __typename?: 'PermissionJoinsConnection';
  /** A list of `PermissionJoin` objects. */
  nodes: Array<Maybe<PermissionJoin>>;
  /** A list of edges which contains the `PermissionJoin` and cursor to aid in pagination. */
  edges: Array<PermissionJoinsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionJoin` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PermissionJoin` edge in the connection. */
export type PermissionJoinsEdge = {
  __typename?: 'PermissionJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PermissionJoin` at the end of the edge. */
  node?: Maybe<PermissionJoin>;
};

/** Methods to use when ordering `PermissionJoin`. */
export enum PermissionJoinsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `user` in the `PermissionJoinInput` mutation. */
export type PermissionJoinUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: Maybe<UserUserUsernameKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: Maybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: Maybe<UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserUsernameKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<PermissionJoinUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `permissionJoin` in the `UserInput` mutation. */
export type PermissionJoinUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: Maybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PermissionJoinNodeIdConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: Maybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PermissionJoinNodeIdDelete>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: Maybe<Array<PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyUsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PermissionJoinUserIdFkeyPermissionJoinCreateInput>>;
};

/** The `permissionJoin` to be created by this mutation. */
export type PermissionJoinUserIdFkeyPermissionJoinCreateInput = {
  id?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<PermissionJoinUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: Maybe<PermissionJoinPermissionNameIdFkeyInput>;
};

/** The `user` to be created by this mutation. */
export type PermissionJoinUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

export type PermissionName = Node & {
  __typename?: 'PermissionName';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  permissionPolicyId?: Maybe<Scalars['Int']>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins: PermissionJoinsConnection;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions: TemplatePermissionsConnection;
};


export type PermissionNamePermissionJoinsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionJoinsOrderBy>>;
  condition?: Maybe<PermissionJoinCondition>;
  filter?: Maybe<PermissionJoinFilter>;
};


export type PermissionNameTemplatePermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplatePermissionsOrderBy>>;
  condition?: Maybe<TemplatePermissionCondition>;
  filter?: Maybe<TemplatePermissionFilter>;
};

/**
 * A condition to be used against `PermissionName` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PermissionNameCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `permissionPolicyId` field. */
  permissionPolicyId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `PermissionName` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `permissionPolicyId` field. */
  permissionPolicyId?: Maybe<IntFilter>;
  /** Filter by the object’s `permissionJoins` relation. */
  permissionJoins?: Maybe<PermissionNameToManyPermissionJoinFilter>;
  /** Some related `permissionJoins` exist. */
  permissionJoinsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `templatePermissions` relation. */
  templatePermissions?: Maybe<PermissionNameToManyTemplatePermissionFilter>;
  /** Some related `templatePermissions` exist. */
  templatePermissionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `permissionPolicy` relation. */
  permissionPolicy?: Maybe<PermissionPolicyFilter>;
  /** A related `permissionPolicy` exists. */
  permissionPolicyExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PermissionNameFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PermissionNameFilter>>;
  /** Negates the expression. */
  not?: Maybe<PermissionNameFilter>;
};

/** An input for mutations affecting `PermissionName` */
export type PermissionNameInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  permissionPolicyId?: Maybe<Scalars['Int']>;
  permissionPolicyToPermissionPolicyId?: Maybe<PermissionNamePermissionPolicyIdFkeyInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionNameNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionNameNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionName` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate = {
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate = {
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `permissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate = {
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate = {
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate = {
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  name: Scalars['String'];
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate = {
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `PermissionName`. Fields that are set will be updated. */
export type PermissionNamePatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  permissionPolicyId?: Maybe<Scalars['Int']>;
  permissionPolicyToPermissionPolicyId?: Maybe<PermissionNamePermissionPolicyIdFkeyInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The fields on `permissionName` to look up the row to connect. */
export type PermissionNamePermissionNameNameKeyConnect = {
  name: Scalars['String'];
};

/** The fields on `permissionName` to look up the row to delete. */
export type PermissionNamePermissionNameNameKeyDelete = {
  name: Scalars['String'];
};

/** The fields on `permissionName` to look up the row to connect. */
export type PermissionNamePermissionNamePkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `permissionName` to look up the row to delete. */
export type PermissionNamePermissionNamePkeyDelete = {
  id: Scalars['Int'];
};

/** Input for the nested mutation of `permissionPolicy` in the `PermissionNameInput` mutation. */
export type PermissionNamePermissionPolicyIdFkeyInput = {
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  connectById?: Maybe<PermissionPolicyPermissionPolicyPkeyConnect>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  connectByNodeId?: Maybe<PermissionPolicyNodeIdConnect>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  deleteById?: Maybe<PermissionPolicyPermissionPolicyPkeyDelete>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PermissionPolicyNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionPolicy` for the far side of the relationship. */
  updateById?: Maybe<PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate>;
  /** The primary key(s) and patch data for `permissionPolicy` for the far side of the relationship. */
  updateByNodeId?: Maybe<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate>;
  /** A `PermissionPolicyInput` object that will be created and connected to this object. */
  create?: Maybe<PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput>;
};

/** Input for the nested mutation of `permissionName` in the `PermissionPolicyInput` mutation. */
export type PermissionNamePermissionPolicyIdFkeyInverseInput = {
  /** Flag indicating whether all other `permissionName` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: Maybe<Array<PermissionNamePermissionNamePkeyConnect>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: Maybe<Array<PermissionNamePermissionNameNameKeyConnect>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<PermissionNameNodeIdConnect>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: Maybe<Array<PermissionNamePermissionNamePkeyDelete>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: Maybe<Array<PermissionNamePermissionNameNameKeyDelete>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<PermissionNameNodeIdDelete>>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: Maybe<Array<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: Maybe<Array<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate>>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate>>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: Maybe<Array<PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput>>;
};

/** The `permissionName` to be created by this mutation. */
export type PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  permissionPolicyToPermissionPolicyId?: Maybe<PermissionNamePermissionPolicyIdFkeyInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The `permissionPolicy` to be created by this mutation. */
export type PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  rules?: Maybe<Scalars['JSON']>;
  type?: Maybe<PermissionPolicyType>;
  defaultRestrictions?: Maybe<Scalars['JSON']>;
  permissionNamesUsingId?: Maybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
};

/** A connection to a list of `PermissionName` values. */
export type PermissionNamesConnection = {
  __typename?: 'PermissionNamesConnection';
  /** A list of `PermissionName` objects. */
  nodes: Array<Maybe<PermissionName>>;
  /** A list of edges which contains the `PermissionName` and cursor to aid in pagination. */
  edges: Array<PermissionNamesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionName` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PermissionName` edge in the connection. */
export type PermissionNamesEdge = {
  __typename?: 'PermissionNamesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PermissionName` at the end of the edge. */
  node?: Maybe<PermissionName>;
};

/** Methods to use when ordering `PermissionName`. */
export enum PermissionNamesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  PermissionPolicyIdAsc = 'PERMISSION_POLICY_ID_ASC',
  PermissionPolicyIdDesc = 'PERMISSION_POLICY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PermissionJoinFilter>;
};

/** A filter to be used against many `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameToManyTemplatePermissionFilter = {
  /** Every related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TemplatePermissionFilter>;
  /** Some related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TemplatePermissionFilter>;
  /** No related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TemplatePermissionFilter>;
};

/** A connection to a list of `PermissionPolicy` values. */
export type PermissionPoliciesConnection = {
  __typename?: 'PermissionPoliciesConnection';
  /** A list of `PermissionPolicy` objects. */
  nodes: Array<Maybe<PermissionPolicy>>;
  /** A list of edges which contains the `PermissionPolicy` and cursor to aid in pagination. */
  edges: Array<PermissionPoliciesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionPolicy` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `PermissionPolicy` edge in the connection. */
export type PermissionPoliciesEdge = {
  __typename?: 'PermissionPoliciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `PermissionPolicy` at the end of the edge. */
  node?: Maybe<PermissionPolicy>;
};

/** Methods to use when ordering `PermissionPolicy`. */
export enum PermissionPoliciesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  RulesAsc = 'RULES_ASC',
  RulesDesc = 'RULES_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  DefaultRestrictionsAsc = 'DEFAULT_RESTRICTIONS_ASC',
  DefaultRestrictionsDesc = 'DEFAULT_RESTRICTIONS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type PermissionPolicy = Node & {
  __typename?: 'PermissionPolicy';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  rules?: Maybe<Scalars['JSON']>;
  type?: Maybe<PermissionPolicyType>;
  defaultRestrictions?: Maybe<Scalars['JSON']>;
  /** Reads and enables pagination through a set of `PermissionName`. */
  permissionNames: PermissionNamesConnection;
};


export type PermissionPolicyPermissionNamesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionNamesOrderBy>>;
  condition?: Maybe<PermissionNameCondition>;
  filter?: Maybe<PermissionNameFilter>;
};

/**
 * A condition to be used against `PermissionPolicy` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PermissionPolicyCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `rules` field. */
  rules?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `type` field. */
  type?: Maybe<PermissionPolicyType>;
  /** Checks for equality with the object’s `defaultRestrictions` field. */
  defaultRestrictions?: Maybe<Scalars['JSON']>;
};

/** A filter to be used against `PermissionPolicy` object types. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `rules` field. */
  rules?: Maybe<JsonFilter>;
  /** Filter by the object’s `type` field. */
  type?: Maybe<PermissionPolicyTypeFilter>;
  /** Filter by the object’s `defaultRestrictions` field. */
  defaultRestrictions?: Maybe<JsonFilter>;
  /** Filter by the object’s `permissionNames` relation. */
  permissionNames?: Maybe<PermissionPolicyToManyPermissionNameFilter>;
  /** Some related `permissionNames` exist. */
  permissionNamesExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<PermissionPolicyFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<PermissionPolicyFilter>>;
  /** Negates the expression. */
  not?: Maybe<PermissionPolicyFilter>;
};

/** An input for mutations affecting `PermissionPolicy` */
export type PermissionPolicyInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  rules?: Maybe<Scalars['JSON']>;
  type?: Maybe<PermissionPolicyType>;
  defaultRestrictions?: Maybe<Scalars['JSON']>;
  permissionNamesUsingId?: Maybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionPolicyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionPolicyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `permissionPolicy` to look up the row to update. */
export type PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate = {
  /** An object where the defined keys will be set on the `permissionPolicy` being updated. */
  patch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `PermissionPolicy`. Fields that are set will be updated. */
export type PermissionPolicyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  rules?: Maybe<Scalars['JSON']>;
  type?: Maybe<PermissionPolicyType>;
  defaultRestrictions?: Maybe<Scalars['JSON']>;
  permissionNamesUsingId?: Maybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
};

/** The fields on `permissionPolicy` to look up the row to connect. */
export type PermissionPolicyPermissionPolicyPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `permissionPolicy` to look up the row to delete. */
export type PermissionPolicyPermissionPolicyPkeyDelete = {
  id: Scalars['Int'];
};

/** A filter to be used against many `PermissionName` object types. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyToManyPermissionNameFilter = {
  /** Every related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PermissionNameFilter>;
  /** Some related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PermissionNameFilter>;
  /** No related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PermissionNameFilter>;
};

export enum PermissionPolicyType {
  Review = 'REVIEW',
  Apply = 'APPLY',
  Assign = 'ASSIGN'
}

/** A filter to be used against PermissionPolicyType fields. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyTypeFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<PermissionPolicyType>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<PermissionPolicyType>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<PermissionPolicyType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<PermissionPolicyType>;
  /** Included in the specified list. */
  in?: Maybe<Array<PermissionPolicyType>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<PermissionPolicyType>>;
  /** Less than the specified value. */
  lessThan?: Maybe<PermissionPolicyType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<PermissionPolicyType>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<PermissionPolicyType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<PermissionPolicyType>;
};

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID'];
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** Reads and enables pagination through a set of `ActionPlugin`. */
  actionPlugins?: Maybe<ActionPluginsConnection>;
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueues?: Maybe<ActionQueuesConnection>;
  /** Reads and enables pagination through a set of `AllPermission`. */
  allPermissions?: Maybe<AllPermissionsConnection>;
  /** Reads and enables pagination through a set of `Application`. */
  applications?: Maybe<ApplicationsConnection>;
  /** Reads and enables pagination through a set of `ApplicationList`. */
  applicationLists?: Maybe<ApplicationListsConnection>;
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses?: Maybe<ApplicationResponsesConnection>;
  /** Reads and enables pagination through a set of `ApplicationSection`. */
  applicationSections?: Maybe<ApplicationSectionsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistories?: Maybe<ApplicationStageHistoriesConnection>;
  /** Reads and enables pagination through a set of `ApplicationStageStatusAll`. */
  applicationStageStatusAlls?: Maybe<ApplicationStageStatusAllsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStageStatusLatest`. */
  applicationStageStatusLatests?: Maybe<ApplicationStageStatusLatestsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStatusHistory`. */
  applicationStatusHistories?: Maybe<ApplicationStatusHistoriesConnection>;
  /** Reads and enables pagination through a set of `ApplicationTriggerState`. */
  applicationTriggerStates?: Maybe<ApplicationTriggerStatesConnection>;
  /** Reads and enables pagination through a set of `ElementTypePlugin`. */
  elementTypePlugins?: Maybe<ElementTypePluginsConnection>;
  /** Reads and enables pagination through a set of `File`. */
  files?: Maybe<FilesConnection>;
  /** Reads and enables pagination through a set of `Notification`. */
  notifications?: Maybe<NotificationsConnection>;
  /** Reads and enables pagination through a set of `Organisation`. */
  organisations?: Maybe<OrganisationsConnection>;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins?: Maybe<PermissionJoinsConnection>;
  /** Reads and enables pagination through a set of `PermissionName`. */
  permissionNames?: Maybe<PermissionNamesConnection>;
  /** Reads and enables pagination through a set of `PermissionPolicy`. */
  permissionPolicies?: Maybe<PermissionPoliciesConnection>;
  /** Reads and enables pagination through a set of `Review`. */
  reviews?: Maybe<ReviewsConnection>;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments?: Maybe<ReviewAssignmentsConnection>;
  /** Reads and enables pagination through a set of `ReviewDecision`. */
  reviewDecisions?: Maybe<ReviewDecisionsConnection>;
  /** Reads and enables pagination through a set of `ReviewQuestionAssignment`. */
  reviewQuestionAssignments?: Maybe<ReviewQuestionAssignmentsConnection>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses?: Maybe<ReviewResponsesConnection>;
  /** Reads and enables pagination through a set of `ReviewStatusHistory`. */
  reviewStatusHistories?: Maybe<ReviewStatusHistoriesConnection>;
  /** Reads and enables pagination through a set of `Template`. */
  templates?: Maybe<TemplatesConnection>;
  /** Reads and enables pagination through a set of `TemplateAction`. */
  templateActions?: Maybe<TemplateActionsConnection>;
  /** Reads and enables pagination through a set of `TemplateElement`. */
  templateElements?: Maybe<TemplateElementsConnection>;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions?: Maybe<TemplatePermissionsConnection>;
  /** Reads and enables pagination through a set of `TemplateSection`. */
  templateSections?: Maybe<TemplateSectionsConnection>;
  /** Reads and enables pagination through a set of `TemplateStage`. */
  templateStages?: Maybe<TemplateStagesConnection>;
  /** Reads and enables pagination through a set of `TriggerQueue`. */
  triggerQueues?: Maybe<TriggerQueuesConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  /** Reads and enables pagination through a set of `UserOrgJoin`. */
  userOrgJoins?: Maybe<UserOrgJoinsConnection>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations?: Maybe<UserOrganisationsConnection>;
  actionPlugin?: Maybe<ActionPlugin>;
  actionQueue?: Maybe<ActionQueue>;
  application?: Maybe<Application>;
  applicationBySerial?: Maybe<Application>;
  applicationResponse?: Maybe<ApplicationResponse>;
  applicationSection?: Maybe<ApplicationSection>;
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  file?: Maybe<File>;
  notification?: Maybe<Notification>;
  organisation?: Maybe<Organisation>;
  organisationByName?: Maybe<Organisation>;
  permissionJoin?: Maybe<PermissionJoin>;
  permissionName?: Maybe<PermissionName>;
  permissionNameByName?: Maybe<PermissionName>;
  permissionPolicy?: Maybe<PermissionPolicy>;
  review?: Maybe<Review>;
  reviewAssignment?: Maybe<ReviewAssignment>;
  reviewDecision?: Maybe<ReviewDecision>;
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignment>;
  reviewResponse?: Maybe<ReviewResponse>;
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  template?: Maybe<Template>;
  templateAction?: Maybe<TemplateAction>;
  templateElement?: Maybe<TemplateElement>;
  templatePermission?: Maybe<TemplatePermission>;
  templateSection?: Maybe<TemplateSection>;
  templateStage?: Maybe<TemplateStage>;
  triggerQueue?: Maybe<TriggerQueue>;
  user?: Maybe<User>;
  userByUsername?: Maybe<User>;
  userOrganisation?: Maybe<UserOrganisation>;
  applicationStatusHistoryApplicationId?: Maybe<Scalars['Int']>;
  jwtGetBigint?: Maybe<Scalars['BigInt']>;
  jwtGetBoolean?: Maybe<Scalars['Boolean']>;
  jwtGetText?: Maybe<Scalars['String']>;
  reviewApplicationId?: Maybe<Scalars['Int']>;
  reviewIsLastLevel?: Maybe<Scalars['Boolean']>;
  reviewLevel?: Maybe<Scalars['Int']>;
  reviewReviewerId?: Maybe<Scalars['Int']>;
  /** Reads a single `ActionPlugin` using its globally unique `ID`. */
  actionPluginByNodeId?: Maybe<ActionPlugin>;
  /** Reads a single `ActionQueue` using its globally unique `ID`. */
  actionQueueByNodeId?: Maybe<ActionQueue>;
  /** Reads a single `Application` using its globally unique `ID`. */
  applicationByNodeId?: Maybe<Application>;
  /** Reads a single `ApplicationResponse` using its globally unique `ID`. */
  applicationResponseByNodeId?: Maybe<ApplicationResponse>;
  /** Reads a single `ApplicationSection` using its globally unique `ID`. */
  applicationSectionByNodeId?: Maybe<ApplicationSection>;
  /** Reads a single `ApplicationStageHistory` using its globally unique `ID`. */
  applicationStageHistoryByNodeId?: Maybe<ApplicationStageHistory>;
  /** Reads a single `ApplicationStatusHistory` using its globally unique `ID`. */
  applicationStatusHistoryByNodeId?: Maybe<ApplicationStatusHistory>;
  /** Reads a single `ElementTypePlugin` using its globally unique `ID`. */
  elementTypePluginByNodeId?: Maybe<ElementTypePlugin>;
  /** Reads a single `File` using its globally unique `ID`. */
  fileByNodeId?: Maybe<File>;
  /** Reads a single `Notification` using its globally unique `ID`. */
  notificationByNodeId?: Maybe<Notification>;
  /** Reads a single `Organisation` using its globally unique `ID`. */
  organisationByNodeId?: Maybe<Organisation>;
  /** Reads a single `PermissionJoin` using its globally unique `ID`. */
  permissionJoinByNodeId?: Maybe<PermissionJoin>;
  /** Reads a single `PermissionName` using its globally unique `ID`. */
  permissionNameByNodeId?: Maybe<PermissionName>;
  /** Reads a single `PermissionPolicy` using its globally unique `ID`. */
  permissionPolicyByNodeId?: Maybe<PermissionPolicy>;
  /** Reads a single `Review` using its globally unique `ID`. */
  reviewByNodeId?: Maybe<Review>;
  /** Reads a single `ReviewAssignment` using its globally unique `ID`. */
  reviewAssignmentByNodeId?: Maybe<ReviewAssignment>;
  /** Reads a single `ReviewDecision` using its globally unique `ID`. */
  reviewDecisionByNodeId?: Maybe<ReviewDecision>;
  /** Reads a single `ReviewQuestionAssignment` using its globally unique `ID`. */
  reviewQuestionAssignmentByNodeId?: Maybe<ReviewQuestionAssignment>;
  /** Reads a single `ReviewResponse` using its globally unique `ID`. */
  reviewResponseByNodeId?: Maybe<ReviewResponse>;
  /** Reads a single `ReviewStatusHistory` using its globally unique `ID`. */
  reviewStatusHistoryByNodeId?: Maybe<ReviewStatusHistory>;
  /** Reads a single `Template` using its globally unique `ID`. */
  templateByNodeId?: Maybe<Template>;
  /** Reads a single `TemplateAction` using its globally unique `ID`. */
  templateActionByNodeId?: Maybe<TemplateAction>;
  /** Reads a single `TemplateElement` using its globally unique `ID`. */
  templateElementByNodeId?: Maybe<TemplateElement>;
  /** Reads a single `TemplatePermission` using its globally unique `ID`. */
  templatePermissionByNodeId?: Maybe<TemplatePermission>;
  /** Reads a single `TemplateSection` using its globally unique `ID`. */
  templateSectionByNodeId?: Maybe<TemplateSection>;
  /** Reads a single `TemplateStage` using its globally unique `ID`. */
  templateStageByNodeId?: Maybe<TemplateStage>;
  /** Reads a single `TriggerQueue` using its globally unique `ID`. */
  triggerQueueByNodeId?: Maybe<TriggerQueue>;
  /** Reads a single `User` using its globally unique `ID`. */
  userByNodeId?: Maybe<User>;
  /** Reads a single `UserOrganisation` using its globally unique `ID`. */
  userOrganisationByNodeId?: Maybe<UserOrganisation>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ActionPluginsOrderBy>>;
  condition?: Maybe<ActionPluginCondition>;
  filter?: Maybe<ActionPluginFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ActionQueuesOrderBy>>;
  condition?: Maybe<ActionQueueCondition>;
  filter?: Maybe<ActionQueueFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllPermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<AllPermissionsOrderBy>>;
  condition?: Maybe<AllPermissionCondition>;
  filter?: Maybe<AllPermissionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationsOrderBy>>;
  condition?: Maybe<ApplicationCondition>;
  filter?: Maybe<ApplicationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationListsOrderBy>>;
  condition?: Maybe<ApplicationListCondition>;
  filter?: Maybe<ApplicationListFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponsesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationResponsesOrderBy>>;
  condition?: Maybe<ApplicationResponseCondition>;
  filter?: Maybe<ApplicationResponseFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationSectionsOrderBy>>;
  condition?: Maybe<ApplicationSectionCondition>;
  filter?: Maybe<ApplicationSectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationStageHistoriesOrderBy>>;
  condition?: Maybe<ApplicationStageHistoryCondition>;
  filter?: Maybe<ApplicationStageHistoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageStatusAllsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationStageStatusAllsOrderBy>>;
  condition?: Maybe<ApplicationStageStatusAllCondition>;
  filter?: Maybe<ApplicationStageStatusAllFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageStatusLatestsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationStageStatusLatestsOrderBy>>;
  condition?: Maybe<ApplicationStageStatusLatestCondition>;
  filter?: Maybe<ApplicationStageStatusLatestFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationStatusHistoriesOrderBy>>;
  condition?: Maybe<ApplicationStatusHistoryCondition>;
  filter?: Maybe<ApplicationStatusHistoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationTriggerStatesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationTriggerStatesOrderBy>>;
  condition?: Maybe<ApplicationTriggerStateCondition>;
  filter?: Maybe<ApplicationTriggerStateFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ElementTypePluginsOrderBy>>;
  condition?: Maybe<ElementTypePluginCondition>;
  filter?: Maybe<ElementTypePluginFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFilesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FilesOrderBy>>;
  condition?: Maybe<FileCondition>;
  filter?: Maybe<FileFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<OrganisationsOrderBy>>;
  condition?: Maybe<OrganisationCondition>;
  filter?: Maybe<OrganisationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionJoinsOrderBy>>;
  condition?: Maybe<PermissionJoinCondition>;
  filter?: Maybe<PermissionJoinFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNamesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionNamesOrderBy>>;
  condition?: Maybe<PermissionNameCondition>;
  filter?: Maybe<PermissionNameFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPoliciesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionPoliciesOrderBy>>;
  condition?: Maybe<PermissionPolicyCondition>;
  filter?: Maybe<PermissionPolicyFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewsOrderBy>>;
  condition?: Maybe<ReviewCondition>;
  filter?: Maybe<ReviewFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
  condition?: Maybe<ReviewAssignmentCondition>;
  filter?: Maybe<ReviewAssignmentFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewDecisionsOrderBy>>;
  condition?: Maybe<ReviewDecisionCondition>;
  filter?: Maybe<ReviewDecisionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewQuestionAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewQuestionAssignmentsOrderBy>>;
  condition?: Maybe<ReviewQuestionAssignmentCondition>;
  filter?: Maybe<ReviewQuestionAssignmentFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponsesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
  condition?: Maybe<ReviewResponseCondition>;
  filter?: Maybe<ReviewResponseFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewStatusHistoriesOrderBy>>;
  condition?: Maybe<ReviewStatusHistoryCondition>;
  filter?: Maybe<ReviewStatusHistoryFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplatesOrderBy>>;
  condition?: Maybe<TemplateCondition>;
  filter?: Maybe<TemplateFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplateActionsOrderBy>>;
  condition?: Maybe<TemplateActionCondition>;
  filter?: Maybe<TemplateActionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplateElementsOrderBy>>;
  condition?: Maybe<TemplateElementCondition>;
  filter?: Maybe<TemplateElementFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplatePermissionsOrderBy>>;
  condition?: Maybe<TemplatePermissionCondition>;
  filter?: Maybe<TemplatePermissionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplateSectionsOrderBy>>;
  condition?: Maybe<TemplateSectionCondition>;
  filter?: Maybe<TemplateSectionFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplateStagesOrderBy>>;
  condition?: Maybe<TemplateStageCondition>;
  filter?: Maybe<TemplateStageFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TriggerQueuesOrderBy>>;
  condition?: Maybe<TriggerQueueCondition>;
  filter?: Maybe<TriggerQueueFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UsersOrderBy>>;
  condition?: Maybe<UserCondition>;
  filter?: Maybe<UserFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrgJoinsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserOrgJoinsOrderBy>>;
  condition?: Maybe<UserOrgJoinCondition>;
  filter?: Maybe<UserOrgJoinFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserOrganisationsOrderBy>>;
  condition?: Maybe<UserOrganisationCondition>;
  filter?: Maybe<UserOrganisationFilter>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginArgs = {
  code: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueueArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationBySerialArgs = {
  serial: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponseArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationSectionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoryArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoryArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginArgs = {
  code: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameByNameArgs = {
  name: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPolicyArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewQuestionAssignmentArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponseArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoryArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueueArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByUsernameArgs = {
  username: Scalars['String'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationArgs = {
  id: Scalars['Int'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoryApplicationIdArgs = {
  applicationStageHistoryId?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetBigintArgs = {
  jwtKey?: Maybe<Scalars['String']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetBooleanArgs = {
  jwtKey?: Maybe<Scalars['String']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetTextArgs = {
  jwtKey?: Maybe<Scalars['String']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewApplicationIdArgs = {
  reviewAssignmentId?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewIsLastLevelArgs = {
  reviewAssignmentId?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewLevelArgs = {
  reviewAssignmentId?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewReviewerIdArgs = {
  reviewAssignmentId?: Maybe<Scalars['Int']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueueByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponseByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationSectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPolicyByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewQuestionAssignmentByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponseByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoryByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueueByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserByNodeIdArgs = {
  nodeId: Scalars['ID'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationByNodeIdArgs = {
  nodeId: Scalars['ID'];
};

export type Review = Node & {
  __typename?: 'Review';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /** Reads a single `User` that is related to this `Review`. */
  reviewer?: Maybe<User>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
  /** Reads and enables pagination through a set of `ReviewDecision`. */
  reviewDecisions: ReviewDecisionsConnection;
  /** Reads and enables pagination through a set of `ReviewStatusHistory`. */
  reviewStatusHistories: ReviewStatusHistoriesConnection;
  /** Reads and enables pagination through a set of `Notification`. */
  notifications: NotificationsConnection;
  latestDecision?: Maybe<ReviewDecision>;
  status?: Maybe<ReviewStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
};


export type ReviewReviewResponsesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
  condition?: Maybe<ReviewResponseCondition>;
  filter?: Maybe<ReviewResponseFilter>;
};


export type ReviewReviewDecisionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewDecisionsOrderBy>>;
  condition?: Maybe<ReviewDecisionCondition>;
  filter?: Maybe<ReviewDecisionFilter>;
};


export type ReviewReviewStatusHistoriesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewStatusHistoriesOrderBy>>;
  condition?: Maybe<ReviewStatusHistoryCondition>;
  filter?: Maybe<ReviewStatusHistoryFilter>;
};


export type ReviewNotificationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
};

/** The `application` to be created by this mutation. */
export type ReviewApplicationIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ReviewInput` mutation. */
export type ReviewApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<ApplicationApplicationSerialKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationNodeIdDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewApplicationIdFkeyApplicationCreateInput>;
};

/** Input for the nested mutation of `review` in the `ApplicationInput` mutation. */
export type ReviewApplicationIdFkeyInverseInput = {
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewReviewPkeyConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewNodeIdConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewReviewPkeyDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewNodeIdDelete>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate>>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewApplicationIdFkeyReviewCreateInput>>;
};

/** The `review` to be created by this mutation. */
export type ReviewApplicationIdFkeyReviewCreateInput = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

export type ReviewAssignment = Node & {
  __typename?: 'ReviewAssignment';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<User>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** Reads and enables pagination through a set of `Review`. */
  reviews: ReviewsConnection;
  /** Reads and enables pagination through a set of `ReviewQuestionAssignment`. */
  reviewQuestionAssignments: ReviewQuestionAssignmentsConnection;
};


export type ReviewAssignmentReviewsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewsOrderBy>>;
  condition?: Maybe<ReviewCondition>;
  filter?: Maybe<ReviewFilter>;
};


export type ReviewAssignmentReviewQuestionAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewQuestionAssignmentsOrderBy>>;
  condition?: Maybe<ReviewQuestionAssignmentCondition>;
  filter?: Maybe<ReviewQuestionAssignmentFilter>;
};

/** The `application` to be created by this mutation. */
export type ReviewAssignmentApplicationIdFkeyApplicationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: Maybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: Maybe<ApplicationApplicationSerialKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: Maybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationNodeIdDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: Maybe<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: Maybe<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewAssignmentApplicationIdFkeyApplicationCreateInput>;
};

/** Input for the nested mutation of `reviewAssignment` in the `ApplicationInput` mutation. */
export type ReviewAssignmentApplicationIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** Input for the nested mutation of `user` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentAssignerIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: Maybe<UserUserUsernameKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: Maybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: Maybe<UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserUsernameKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewAssignmentAssignerIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `reviewAssignment` in the `UserInput` mutation. */
export type ReviewAssignmentAssignerIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewAssignmentAssignerIdFkeyReviewAssignmentCreateInput>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentAssignerIdFkeyReviewAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** The `user` to be created by this mutation. */
export type ReviewAssignmentAssignerIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/**
 * A condition to be used against `ReviewAssignment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ReviewAssignmentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `assignerId` field. */
  assignerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewerId` field. */
  reviewerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ReviewAssignmentStatus>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateSectionRestrictions` field. */
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: Maybe<Trigger>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `level` field. */
  level?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `isLastLevel` field. */
  isLastLevel?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `assignerId` field. */
  assignerId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewerId` field. */
  reviewerId?: Maybe<IntFilter>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: Maybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ReviewAssignmentStatusFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `templateSectionRestrictions` field. */
  templateSectionRestrictions?: Maybe<StringListFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: Maybe<TriggerFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `level` field. */
  level?: Maybe<IntFilter>;
  /** Filter by the object’s `isLastLevel` field. */
  isLastLevel?: Maybe<BooleanFilter>;
  /** Filter by the object’s `reviews` relation. */
  reviews?: Maybe<ReviewAssignmentToManyReviewFilter>;
  /** Some related `reviews` exist. */
  reviewsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewQuestionAssignments` relation. */
  reviewQuestionAssignments?: Maybe<ReviewAssignmentToManyReviewQuestionAssignmentFilter>;
  /** Some related `reviewQuestionAssignments` exist. */
  reviewQuestionAssignmentsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `assigner` relation. */
  assigner?: Maybe<UserFilter>;
  /** A related `assigner` exists. */
  assignerExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewer` relation. */
  reviewer?: Maybe<UserFilter>;
  /** A related `reviewer` exists. */
  reviewerExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: Maybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `stage` relation. */
  stage?: Maybe<TemplateStageFilter>;
  /** A related `stage` exists. */
  stageExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `application` relation. */
  application?: Maybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ReviewAssignmentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ReviewAssignmentFilter>>;
  /** Negates the expression. */
  not?: Maybe<ReviewAssignmentFilter>;
};

/** An input for mutations affecting `ReviewAssignment` */
export type ReviewAssignmentInput = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewAssignmentNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewAssignmentNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingReviewAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingReviewAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewQuestionAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
  patch: ReviewQuestionAssignmentPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch;
  id: Scalars['Int'];
};

/** Input for the nested mutation of `organisation` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: Maybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: Maybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: Maybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: Maybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: Maybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: Maybe<OrganisationNodeIdDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: Maybe<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: Maybe<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput>;
};

/** Input for the nested mutation of `reviewAssignment` in the `OrganisationInput` mutation. */
export type ReviewAssignmentOrganisationIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput>>;
};

/** The `organisation` to be created by this mutation. */
export type ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** Represents an update to a `ReviewAssignment`. Fields that are set will be updated. */
export type ReviewAssignmentPatch = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewAssignmentStatus>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** The fields on `reviewAssignment` to look up the row to connect. */
export type ReviewAssignmentReviewAssignmentPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `reviewAssignment` to look up the row to delete. */
export type ReviewAssignmentReviewAssignmentPkeyDelete = {
  id: Scalars['Int'];
};

/** Input for the nested mutation of `user` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentReviewerIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: Maybe<UserUserUsernameKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: Maybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: Maybe<UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserUsernameKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewAssignmentReviewerIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `reviewAssignment` in the `UserInput` mutation. */
export type ReviewAssignmentReviewerIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewAssignmentReviewerIdFkeyReviewAssignmentCreateInput>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentReviewerIdFkeyReviewAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** The `user` to be created by this mutation. */
export type ReviewAssignmentReviewerIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** A connection to a list of `ReviewAssignment` values. */
export type ReviewAssignmentsConnection = {
  __typename?: 'ReviewAssignmentsConnection';
  /** A list of `ReviewAssignment` objects. */
  nodes: Array<Maybe<ReviewAssignment>>;
  /** A list of edges which contains the `ReviewAssignment` and cursor to aid in pagination. */
  edges: Array<ReviewAssignmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewAssignment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ReviewAssignment` edge in the connection. */
export type ReviewAssignmentsEdge = {
  __typename?: 'ReviewAssignmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ReviewAssignment` at the end of the edge. */
  node?: Maybe<ReviewAssignment>;
};

/** Methods to use when ordering `ReviewAssignment`. */
export enum ReviewAssignmentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  AssignerIdAsc = 'ASSIGNER_ID_ASC',
  AssignerIdDesc = 'ASSIGNER_ID_DESC',
  ReviewerIdAsc = 'REVIEWER_ID_ASC',
  ReviewerIdDesc = 'REVIEWER_ID_DESC',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  TemplateSectionRestrictionsAsc = 'TEMPLATE_SECTION_RESTRICTIONS_ASC',
  TemplateSectionRestrictionsDesc = 'TEMPLATE_SECTION_RESTRICTIONS_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  LevelAsc = 'LEVEL_ASC',
  LevelDesc = 'LEVEL_DESC',
  IsLastLevelAsc = 'IS_LAST_LEVEL_ASC',
  IsLastLevelDesc = 'IS_LAST_LEVEL_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `templateStage` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentStageIdFkeyInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: Maybe<TemplateStageTemplateStagePkeyConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateStageNodeIdConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: Maybe<TemplateStageTemplateStagePkeyDelete>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateStageNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: Maybe<TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewAssignmentStageIdFkeyTemplateStageCreateInput>;
};

/** Input for the nested mutation of `reviewAssignment` in the `TemplateStageInput` mutation. */
export type ReviewAssignmentStageIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** The `templateStage` to be created by this mutation. */
export type ReviewAssignmentStageIdFkeyTemplateStageCreateInput = {
  id?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateId?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateStageTemplateIdFkeyInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentStageIdFkeyInverseInput>;
};

export enum ReviewAssignmentStatus {
  Available = 'AVAILABLE',
  SelfAssignedByAnother = 'SELF_ASSIGNED_BY_ANOTHER',
  Assigned = 'ASSIGNED',
  AvailableForSelfAssignment = 'AVAILABLE_FOR_SELF_ASSIGNMENT'
}

/** A filter to be used against ReviewAssignmentStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentStatusFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ReviewAssignmentStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ReviewAssignmentStatus>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ReviewAssignmentStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ReviewAssignmentStatus>;
  /** Included in the specified list. */
  in?: Maybe<Array<ReviewAssignmentStatus>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ReviewAssignmentStatus>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ReviewAssignmentStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ReviewAssignmentStatus>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ReviewAssignmentStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ReviewAssignmentStatus>;
};

/** A filter to be used against many `Review` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentToManyReviewFilter = {
  /** Every related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewFilter>;
  /** Some related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewFilter>;
  /** No related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewFilter>;
};

/** A filter to be used against many `ReviewQuestionAssignment` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentToManyReviewQuestionAssignmentFilter = {
  /** Every related `ReviewQuestionAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewQuestionAssignmentFilter>;
  /** Some related `ReviewQuestionAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewQuestionAssignmentFilter>;
  /** No related `ReviewQuestionAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewQuestionAssignmentFilter>;
};

/** A condition to be used against `Review` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: Maybe<Trigger>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewerId` field. */
  reviewerId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `level` field. */
  level?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `isLastLevel` field. */
  isLastLevel?: Maybe<Scalars['Boolean']>;
};

export type ReviewDecision = Node & {
  __typename?: 'ReviewDecision';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  reviewId?: Maybe<Scalars['Int']>;
  decision?: Maybe<Decision>;
  comment?: Maybe<Scalars['String']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
};

/**
 * A condition to be used against `ReviewDecision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ReviewDecisionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `decision` field. */
  decision?: Maybe<Decision>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<Scalars['Datetime']>;
};

/** A filter to be used against `ReviewDecision` object types. All fields are combined with a logical ‘and.’ */
export type ReviewDecisionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: Maybe<IntFilter>;
  /** Filter by the object’s `decision` field. */
  decision?: Maybe<DecisionFilter>;
  /** Filter by the object’s `comment` field. */
  comment?: Maybe<StringFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `review` relation. */
  review?: Maybe<ReviewFilter>;
  /** A related `review` exists. */
  reviewExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ReviewDecisionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ReviewDecisionFilter>>;
  /** Negates the expression. */
  not?: Maybe<ReviewDecisionFilter>;
};

/** An input for mutations affecting `ReviewDecision` */
export type ReviewDecisionInput = {
  id?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  decision?: Maybe<Decision>;
  comment?: Maybe<Scalars['String']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  reviewToReviewId?: Maybe<ReviewDecisionReviewIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewDecisionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewDecisionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewDecision` to look up the row to update. */
export type ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewDecision` being updated. */
  patch: UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `ReviewDecision`. Fields that are set will be updated. */
export type ReviewDecisionPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  decision?: Maybe<Decision>;
  comment?: Maybe<Scalars['String']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  reviewToReviewId?: Maybe<ReviewDecisionReviewIdFkeyInput>;
};

/** The fields on `reviewDecision` to look up the row to connect. */
export type ReviewDecisionReviewDecisionPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `reviewDecision` to look up the row to delete. */
export type ReviewDecisionReviewDecisionPkeyDelete = {
  id: Scalars['Int'];
};

/** Input for the nested mutation of `review` in the `ReviewDecisionInput` mutation. */
export type ReviewDecisionReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: Maybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: Maybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewNodeIdDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: Maybe<ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewDecisionReviewIdFkeyReviewCreateInput>;
};

/** Input for the nested mutation of `reviewDecision` in the `ReviewInput` mutation. */
export type ReviewDecisionReviewIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewDecision` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewDecisionReviewDecisionPkeyConnect>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewDecisionNodeIdConnect>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewDecisionReviewDecisionPkeyDelete>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewDecisionNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewDecision` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewDecision` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate>>;
  /** A `ReviewDecisionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewDecisionReviewIdFkeyReviewDecisionCreateInput>>;
};

/** The `review` to be created by this mutation. */
export type ReviewDecisionReviewIdFkeyReviewCreateInput = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** The `reviewDecision` to be created by this mutation. */
export type ReviewDecisionReviewIdFkeyReviewDecisionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  decision?: Maybe<Decision>;
  comment?: Maybe<Scalars['String']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  reviewToReviewId?: Maybe<ReviewDecisionReviewIdFkeyInput>;
};

/** A connection to a list of `ReviewDecision` values. */
export type ReviewDecisionsConnection = {
  __typename?: 'ReviewDecisionsConnection';
  /** A list of `ReviewDecision` objects. */
  nodes: Array<Maybe<ReviewDecision>>;
  /** A list of edges which contains the `ReviewDecision` and cursor to aid in pagination. */
  edges: Array<ReviewDecisionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewDecision` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ReviewDecision` edge in the connection. */
export type ReviewDecisionsEdge = {
  __typename?: 'ReviewDecisionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ReviewDecision` at the end of the edge. */
  node?: Maybe<ReviewDecision>;
};

/** Methods to use when ordering `ReviewDecision`. */
export enum ReviewDecisionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  DecisionAsc = 'DECISION_ASC',
  DecisionDesc = 'DECISION_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against `Review` object types. All fields are combined with a logical ‘and.’ */
export type ReviewFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: Maybe<IntFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: Maybe<TriggerFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewerId` field. */
  reviewerId?: Maybe<IntFilter>;
  /** Filter by the object’s `level` field. */
  level?: Maybe<IntFilter>;
  /** Filter by the object’s `isLastLevel` field. */
  isLastLevel?: Maybe<BooleanFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ReviewStatusFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: Maybe<ReviewToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewDecisions` relation. */
  reviewDecisions?: Maybe<ReviewToManyReviewDecisionFilter>;
  /** Some related `reviewDecisions` exist. */
  reviewDecisionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewStatusHistories` relation. */
  reviewStatusHistories?: Maybe<ReviewToManyReviewStatusHistoryFilter>;
  /** Some related `reviewStatusHistories` exist. */
  reviewStatusHistoriesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `notifications` relation. */
  notifications?: Maybe<ReviewToManyNotificationFilter>;
  /** Some related `notifications` exist. */
  notificationsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewAssignment` relation. */
  reviewAssignment?: Maybe<ReviewAssignmentFilter>;
  /** A related `reviewAssignment` exists. */
  reviewAssignmentExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `application` relation. */
  application?: Maybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewer` relation. */
  reviewer?: Maybe<UserFilter>;
  /** A related `reviewer` exists. */
  reviewerExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ReviewFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ReviewFilter>>;
  /** Negates the expression. */
  not?: Maybe<ReviewFilter>;
};

/** An input for mutations affecting `Review` */
export type ReviewInput = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `review` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewDecision` being updated. */
  patch: ReviewDecisionPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewForReviewReviewerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewReviewerIdFkeyUsingReviewPkeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewReviewerIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `Review`. Fields that are set will be updated. */
export type ReviewPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

export type ReviewQuestionAssignment = Node & {
  __typename?: 'ReviewQuestionAssignment';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  templateElementId?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  /** Reads a single `TemplateElement` that is related to this `ReviewQuestionAssignment`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewQuestionAssignment`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
};


export type ReviewQuestionAssignmentReviewResponsesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
  condition?: Maybe<ReviewResponseCondition>;
  filter?: Maybe<ReviewResponseFilter>;
};

/**
 * A condition to be used against `ReviewQuestionAssignment` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ReviewQuestionAssignmentCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateElementId` field. */
  templateElementId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `ReviewQuestionAssignment` object types. All fields are combined with a logical ‘and.’ */
export type ReviewQuestionAssignmentFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `templateElementId` field. */
  templateElementId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: Maybe<ReviewQuestionAssignmentToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `templateElement` relation. */
  templateElement?: Maybe<TemplateElementFilter>;
  /** A related `templateElement` exists. */
  templateElementExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewAssignment` relation. */
  reviewAssignment?: Maybe<ReviewAssignmentFilter>;
  /** A related `reviewAssignment` exists. */
  reviewAssignmentExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ReviewQuestionAssignmentFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ReviewQuestionAssignmentFilter>>;
  /** Negates the expression. */
  not?: Maybe<ReviewQuestionAssignmentFilter>;
};

/** An input for mutations affecting `ReviewQuestionAssignment` */
export type ReviewQuestionAssignmentInput = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  templateElementToTemplateElementId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewQuestionAssignmentNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewQuestionAssignment` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewQuestionAssignmentNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewQuestionAssignment` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `reviewQuestionAssignment` to look up the row to update. */
export type ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
  patch: UpdateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `reviewQuestionAssignment` to look up the row to update. */
export type ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingReviewQuestionAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
  patch: UpdateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `reviewQuestionAssignment` to look up the row to update. */
export type ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
  patch: UpdateReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `ReviewQuestionAssignment`. Fields that are set will be updated. */
export type ReviewQuestionAssignmentPatch = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  templateElementToTemplateElementId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput>;
};

/** Input for the nested mutation of `reviewAssignment` in the `ReviewQuestionAssignmentInput` mutation. */
export type ReviewQuestionAssignmentReviewAssignmentIdFkeyInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: Maybe<ReviewAssignmentReviewAssignmentPkeyConnect>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewAssignmentNodeIdConnect>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: Maybe<ReviewAssignmentReviewAssignmentPkeyDelete>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewAssignmentNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: Maybe<ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewAssignmentCreateInput>;
};

/** Input for the nested mutation of `reviewQuestionAssignment` in the `ReviewAssignmentInput` mutation. */
export type ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewQuestionAssignment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewQuestionAssignmentReviewQuestionAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewQuestionAssignmentNodeIdConnect>>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewQuestionAssignmentReviewQuestionAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewQuestionAssignmentNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewQuestionAssignment` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewQuestionAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate>>;
  /** A `ReviewQuestionAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewQuestionAssignmentCreateInput>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** The `reviewQuestionAssignment` to be created by this mutation. */
export type ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewQuestionAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  templateElementToTemplateElementId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput>;
};

/** The fields on `reviewQuestionAssignment` to look up the row to connect. */
export type ReviewQuestionAssignmentReviewQuestionAssignmentPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `reviewQuestionAssignment` to look up the row to delete. */
export type ReviewQuestionAssignmentReviewQuestionAssignmentPkeyDelete = {
  id: Scalars['Int'];
};

/** A connection to a list of `ReviewQuestionAssignment` values. */
export type ReviewQuestionAssignmentsConnection = {
  __typename?: 'ReviewQuestionAssignmentsConnection';
  /** A list of `ReviewQuestionAssignment` objects. */
  nodes: Array<Maybe<ReviewQuestionAssignment>>;
  /** A list of edges which contains the `ReviewQuestionAssignment` and cursor to aid in pagination. */
  edges: Array<ReviewQuestionAssignmentsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewQuestionAssignment` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ReviewQuestionAssignment` edge in the connection. */
export type ReviewQuestionAssignmentsEdge = {
  __typename?: 'ReviewQuestionAssignmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ReviewQuestionAssignment` at the end of the edge. */
  node?: Maybe<ReviewQuestionAssignment>;
};

/** Methods to use when ordering `ReviewQuestionAssignment`. */
export enum ReviewQuestionAssignmentsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TemplateElementIdAsc = 'TEMPLATE_ELEMENT_ID_ASC',
  TemplateElementIdDesc = 'TEMPLATE_ELEMENT_ID_DESC',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `templateElement` in the `ReviewQuestionAssignmentInput` mutation. */
export type ReviewQuestionAssignmentTemplateElementIdFkeyInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: Maybe<TemplateElementTemplateElementPkeyConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateElementNodeIdConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: Maybe<TemplateElementTemplateElementPkeyDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateElementNodeIdDelete>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: Maybe<TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingTemplateElementPkeyUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyTemplateElementCreateInput>;
};

/** Input for the nested mutation of `reviewQuestionAssignment` in the `TemplateElementInput` mutation. */
export type ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewQuestionAssignment` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewQuestionAssignmentReviewQuestionAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewQuestionAssignmentNodeIdConnect>>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewQuestionAssignmentReviewQuestionAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewQuestionAssignmentNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewQuestionAssignment` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingReviewQuestionAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewQuestionAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate>>;
  /** A `ReviewQuestionAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewQuestionAssignmentTemplateElementIdFkeyReviewQuestionAssignmentCreateInput>>;
};

/** The `reviewQuestionAssignment` to be created by this mutation. */
export type ReviewQuestionAssignmentTemplateElementIdFkeyReviewQuestionAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  templateElementToTemplateElementId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput>;
};

/** The `templateElement` to be created by this mutation. */
export type ReviewQuestionAssignmentTemplateElementIdFkeyTemplateElementCreateInput = {
  id?: Maybe<Scalars['Int']>;
  sectionId?: Maybe<Scalars['Int']>;
  code: Scalars['String'];
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewQuestionAssignmentToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewResponseFilter>;
};

export type ReviewResponse = Node & {
  __typename?: 'ReviewResponse';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  /** Reads a single `ReviewQuestionAssignment` that is related to this `ReviewResponse`. */
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignment>;
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponsesByReviewResponseLinkId: ReviewResponsesConnection;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponsesByOriginalReviewResponseId: ReviewResponsesConnection;
};


export type ReviewResponseReviewResponsesByReviewResponseLinkIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
  condition?: Maybe<ReviewResponseCondition>;
  filter?: Maybe<ReviewResponseFilter>;
};


export type ReviewResponseReviewResponsesByOriginalReviewResponseIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
  condition?: Maybe<ReviewResponseCondition>;
  filter?: Maybe<ReviewResponseFilter>;
};

/** The `applicationResponse` to be created by this mutation. */
export type ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** Input for the nested mutation of `applicationResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseApplicationResponseIdFkeyInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: Maybe<ApplicationResponseApplicationResponsePkeyConnect>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<ApplicationResponseNodeIdConnect>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: Maybe<ApplicationResponseApplicationResponsePkeyDelete>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ApplicationResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: Maybe<ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput>;
};

/** Input for the nested mutation of `reviewResponse` in the `ApplicationResponseInput` mutation. */
export type ReviewResponseApplicationResponseIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewResponseNodeIdConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewResponseNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput>>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/**
 * A condition to be used against `ReviewResponse` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ReviewResponseCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `decision` field. */
  decision?: Maybe<ReviewResponseDecision>;
  /** Checks for equality with the object’s `reviewQuestionAssignmentId` field. */
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `applicationResponseId` field. */
  applicationResponseId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewResponseLinkId` field. */
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `originalReviewResponseId` field. */
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `isVisibleToApplicant` field. */
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `templateElementId` field. */
  templateElementId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `recommendedApplicantVisibility` field. */
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ReviewResponseStatus>;
};

export enum ReviewResponseDecision {
  Approve = 'APPROVE',
  Decline = 'DECLINE',
  Agree = 'AGREE',
  Disagree = 'DISAGREE'
}

/** A filter to be used against ReviewResponseDecision fields. All fields are combined with a logical ‘and.’ */
export type ReviewResponseDecisionFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ReviewResponseDecision>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ReviewResponseDecision>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ReviewResponseDecision>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ReviewResponseDecision>;
  /** Included in the specified list. */
  in?: Maybe<Array<ReviewResponseDecision>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ReviewResponseDecision>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ReviewResponseDecision>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ReviewResponseDecision>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ReviewResponseDecision>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ReviewResponseDecision>;
};

/** A filter to be used against `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewResponseFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `comment` field. */
  comment?: Maybe<StringFilter>;
  /** Filter by the object’s `decision` field. */
  decision?: Maybe<ReviewResponseDecisionFilter>;
  /** Filter by the object’s `reviewQuestionAssignmentId` field. */
  reviewQuestionAssignmentId?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationResponseId` field. */
  applicationResponseId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewResponseLinkId` field. */
  reviewResponseLinkId?: Maybe<IntFilter>;
  /** Filter by the object’s `originalReviewResponseId` field. */
  originalReviewResponseId?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: Maybe<IntFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `isVisibleToApplicant` field. */
  isVisibleToApplicant?: Maybe<BooleanFilter>;
  /** Filter by the object’s `templateElementId` field. */
  templateElementId?: Maybe<IntFilter>;
  /** Filter by the object’s `recommendedApplicantVisibility` field. */
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibilityFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ReviewResponseStatusFilter>;
  /** Filter by the object’s `reviewResponsesByReviewResponseLinkId` relation. */
  reviewResponsesByReviewResponseLinkId?: Maybe<ReviewResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponsesByReviewResponseLinkId` exist. */
  reviewResponsesByReviewResponseLinkIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewResponsesByOriginalReviewResponseId` relation. */
  reviewResponsesByOriginalReviewResponseId?: Maybe<ReviewResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponsesByOriginalReviewResponseId` exist. */
  reviewResponsesByOriginalReviewResponseIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewQuestionAssignment` relation. */
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignmentFilter>;
  /** A related `reviewQuestionAssignment` exists. */
  reviewQuestionAssignmentExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `applicationResponse` relation. */
  applicationResponse?: Maybe<ApplicationResponseFilter>;
  /** A related `applicationResponse` exists. */
  applicationResponseExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewResponseLink` relation. */
  reviewResponseLink?: Maybe<ReviewResponseFilter>;
  /** A related `reviewResponseLink` exists. */
  reviewResponseLinkExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `originalReviewResponse` relation. */
  originalReviewResponse?: Maybe<ReviewResponseFilter>;
  /** A related `originalReviewResponse` exists. */
  originalReviewResponseExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `review` relation. */
  review?: Maybe<ReviewFilter>;
  /** A related `review` exists. */
  reviewExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `templateElement` relation. */
  templateElement?: Maybe<TemplateElementFilter>;
  /** A related `templateElement` exists. */
  templateElementExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ReviewResponseFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ReviewResponseFilter>>;
  /** Negates the expression. */
  not?: Maybe<ReviewResponseFilter>;
};

/** An input for mutations affecting `ReviewResponse` */
export type ReviewResponseInput = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewResponseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewResponseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewQuestionAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
  patch: ReviewQuestionAssignmentPatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  id: Scalars['Int'];
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseOriginalReviewResponseIdFkeyInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: Maybe<ReviewResponseReviewResponsePkeyConnect>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewResponseNodeIdConnect>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: Maybe<ReviewResponseReviewResponsePkeyDelete>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: Maybe<ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** Represents an update to a `ReviewResponse`. Fields that are set will be updated. */
export type ReviewResponsePatch = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

export enum ReviewResponseRecommendedApplicantVisibility {
  OriginalResponseVisibleToApplicant = 'ORIGINAL_RESPONSE_VISIBLE_TO_APPLICANT',
  OriginalResponseNotVisibleToApplicant = 'ORIGINAL_RESPONSE_NOT_VISIBLE_TO_APPLICANT'
}

/**
 * A filter to be used against ReviewResponseRecommendedApplicantVisibility fields.
 * All fields are combined with a logical ‘and.’
 */
export type ReviewResponseRecommendedApplicantVisibilityFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Included in the specified list. */
  in?: Maybe<Array<ReviewResponseRecommendedApplicantVisibility>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ReviewResponseRecommendedApplicantVisibility>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
};

/** Input for the nested mutation of `review` in the `ReviewResponseInput` mutation. */
export type ReviewResponseReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: Maybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: Maybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewNodeIdDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: Maybe<ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewResponseReviewIdFkeyReviewCreateInput>;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewInput` mutation. */
export type ReviewResponseReviewIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewResponseNodeIdConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewResponseNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewResponseReviewIdFkeyReviewResponseCreateInput>>;
};

/** The `review` to be created by this mutation. */
export type ReviewResponseReviewIdFkeyReviewCreateInput = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseReviewIdFkeyReviewResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** Input for the nested mutation of `reviewQuestionAssignment` in the `ReviewResponseInput` mutation. */
export type ReviewResponseReviewQuestionAssignmentIdFkeyInput = {
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  connectById?: Maybe<ReviewQuestionAssignmentReviewQuestionAssignmentPkeyConnect>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewQuestionAssignmentNodeIdConnect>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  deleteById?: Maybe<ReviewQuestionAssignmentReviewQuestionAssignmentPkeyDelete>;
  /** The primary key(s) for `reviewQuestionAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewQuestionAssignmentNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewQuestionAssignment` for the far side of the relationship. */
  updateById?: Maybe<ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate>;
  /** The primary key(s) and patch data for `reviewQuestionAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate>;
  /** A `ReviewQuestionAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyReviewQuestionAssignmentCreateInput>;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewQuestionAssignmentInput` mutation. */
export type ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewResponseNodeIdConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewResponseNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewResponseReviewQuestionAssignmentIdFkeyReviewResponseCreateInput>>;
};

/** The `reviewQuestionAssignment` to be created by this mutation. */
export type ReviewResponseReviewQuestionAssignmentIdFkeyReviewQuestionAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  templateElementToTemplateElementId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseReviewQuestionAssignmentIdFkeyReviewResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseReviewResponseLinkIdFkeyInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: Maybe<ReviewResponseReviewResponsePkeyConnect>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewResponseNodeIdConnect>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: Maybe<ReviewResponseReviewResponsePkeyDelete>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: Maybe<ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** The fields on `reviewResponse` to look up the row to connect. */
export type ReviewResponseReviewResponsePkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `reviewResponse` to look up the row to delete. */
export type ReviewResponseReviewResponsePkeyDelete = {
  id: Scalars['Int'];
};

/** A connection to a list of `ReviewResponse` values. */
export type ReviewResponsesConnection = {
  __typename?: 'ReviewResponsesConnection';
  /** A list of `ReviewResponse` objects. */
  nodes: Array<Maybe<ReviewResponse>>;
  /** A list of edges which contains the `ReviewResponse` and cursor to aid in pagination. */
  edges: Array<ReviewResponsesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewResponse` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ReviewResponse` edge in the connection. */
export type ReviewResponsesEdge = {
  __typename?: 'ReviewResponsesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ReviewResponse` at the end of the edge. */
  node?: Maybe<ReviewResponse>;
};

/** Methods to use when ordering `ReviewResponse`. */
export enum ReviewResponsesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  DecisionAsc = 'DECISION_ASC',
  DecisionDesc = 'DECISION_DESC',
  ReviewQuestionAssignmentIdAsc = 'REVIEW_QUESTION_ASSIGNMENT_ID_ASC',
  ReviewQuestionAssignmentIdDesc = 'REVIEW_QUESTION_ASSIGNMENT_ID_DESC',
  ApplicationResponseIdAsc = 'APPLICATION_RESPONSE_ID_ASC',
  ApplicationResponseIdDesc = 'APPLICATION_RESPONSE_ID_DESC',
  ReviewResponseLinkIdAsc = 'REVIEW_RESPONSE_LINK_ID_ASC',
  ReviewResponseLinkIdDesc = 'REVIEW_RESPONSE_LINK_ID_DESC',
  OriginalReviewResponseIdAsc = 'ORIGINAL_REVIEW_RESPONSE_ID_ASC',
  OriginalReviewResponseIdDesc = 'ORIGINAL_REVIEW_RESPONSE_ID_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC',
  IsVisibleToApplicantAsc = 'IS_VISIBLE_TO_APPLICANT_ASC',
  IsVisibleToApplicantDesc = 'IS_VISIBLE_TO_APPLICANT_DESC',
  TemplateElementIdAsc = 'TEMPLATE_ELEMENT_ID_ASC',
  TemplateElementIdDesc = 'TEMPLATE_ELEMENT_ID_DESC',
  RecommendedApplicantVisibilityAsc = 'RECOMMENDED_APPLICANT_VISIBILITY_ASC',
  RecommendedApplicantVisibilityDesc = 'RECOMMENDED_APPLICANT_VISIBILITY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export enum ReviewResponseStatus {
  Draft = 'DRAFT',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ReviewResponseStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewResponseStatusFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ReviewResponseStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ReviewResponseStatus>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ReviewResponseStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ReviewResponseStatus>;
  /** Included in the specified list. */
  in?: Maybe<Array<ReviewResponseStatus>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ReviewResponseStatus>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ReviewResponseStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ReviewResponseStatus>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ReviewResponseStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ReviewResponseStatus>;
};

/** Input for the nested mutation of `templateElement` in the `ReviewResponseInput` mutation. */
export type ReviewResponseTemplateElementIdFkeyInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: Maybe<TemplateElementTemplateElementPkeyConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateElementNodeIdConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: Maybe<TemplateElementTemplateElementPkeyDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateElementNodeIdDelete>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: Maybe<TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput>;
};

/** Input for the nested mutation of `reviewResponse` in the `TemplateElementInput` mutation. */
export type ReviewResponseTemplateElementIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewResponseNodeIdConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewResponseNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput>>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** The `templateElement` to be created by this mutation. */
export type ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput = {
  id?: Maybe<Scalars['Int']>;
  sectionId?: Maybe<Scalars['Int']>;
  code: Scalars['String'];
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewResponseToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewResponseFilter>;
};

/** Input for the nested mutation of `reviewAssignment` in the `ReviewInput` mutation. */
export type ReviewReviewAssignmentIdFkeyInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: Maybe<ReviewAssignmentReviewAssignmentPkeyConnect>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewAssignmentNodeIdConnect>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: Maybe<ReviewAssignmentReviewAssignmentPkeyDelete>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewAssignmentNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: Maybe<ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput>;
};

/** Input for the nested mutation of `review` in the `ReviewAssignmentInput` mutation. */
export type ReviewReviewAssignmentIdFkeyInverseInput = {
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewReviewPkeyConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewNodeIdConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewReviewPkeyDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewNodeIdDelete>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate>>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewReviewAssignmentIdFkeyReviewCreateInput>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status: ReviewAssignmentStatus;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** The `review` to be created by this mutation. */
export type ReviewReviewAssignmentIdFkeyReviewCreateInput = {
  id?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** Input for the nested mutation of `user` in the `ReviewInput` mutation. */
export type ReviewReviewerIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: Maybe<UserUserUsernameKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: Maybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnReviewForReviewReviewerIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: Maybe<UserOnReviewForReviewReviewerIdFkeyUsingUserUsernameKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewOnReviewForReviewReviewerIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewReviewerIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `review` in the `UserInput` mutation. */
export type ReviewReviewerIdFkeyInverseInput = {
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewReviewPkeyConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewNodeIdConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewReviewPkeyDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewNodeIdDelete>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewOnReviewForReviewReviewerIdFkeyUsingReviewPkeyUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnReviewForReviewReviewerIdFkeyNodeIdUpdate>>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewReviewerIdFkeyReviewCreateInput>>;
};

/** The `review` to be created by this mutation. */
export type ReviewReviewerIdFkeyReviewCreateInput = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** The `user` to be created by this mutation. */
export type ReviewReviewerIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** The fields on `review` to look up the row to connect. */
export type ReviewReviewPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `review` to look up the row to delete. */
export type ReviewReviewPkeyDelete = {
  id: Scalars['Int'];
};

/** A connection to a list of `Review` values. */
export type ReviewsConnection = {
  __typename?: 'ReviewsConnection';
  /** A list of `Review` objects. */
  nodes: Array<Maybe<Review>>;
  /** A list of edges which contains the `Review` and cursor to aid in pagination. */
  edges: Array<ReviewsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Review` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `Review` edge in the connection. */
export type ReviewsEdge = {
  __typename?: 'ReviewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Review` at the end of the edge. */
  node?: Maybe<Review>;
};

/** Methods to use when ordering `Review`. */
export enum ReviewsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ReviewerIdAsc = 'REVIEWER_ID_ASC',
  ReviewerIdDesc = 'REVIEWER_ID_DESC',
  LevelAsc = 'LEVEL_ASC',
  LevelDesc = 'LEVEL_DESC',
  IsLastLevelAsc = 'IS_LAST_LEVEL_ASC',
  IsLastLevelDesc = 'IS_LAST_LEVEL_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export enum ReviewStatus {
  Draft = 'DRAFT',
  Submitted = 'SUBMITTED',
  ChangesRequested = 'CHANGES_REQUESTED',
  Pending = 'PENDING',
  Locked = 'LOCKED'
}

/** A filter to be used against ReviewStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewStatusFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<ReviewStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<ReviewStatus>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<ReviewStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<ReviewStatus>;
  /** Included in the specified list. */
  in?: Maybe<Array<ReviewStatus>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<ReviewStatus>>;
  /** Less than the specified value. */
  lessThan?: Maybe<ReviewStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<ReviewStatus>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<ReviewStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<ReviewStatus>;
};

/** A connection to a list of `ReviewStatusHistory` values. */
export type ReviewStatusHistoriesConnection = {
  __typename?: 'ReviewStatusHistoriesConnection';
  /** A list of `ReviewStatusHistory` objects. */
  nodes: Array<Maybe<ReviewStatusHistory>>;
  /** A list of edges which contains the `ReviewStatusHistory` and cursor to aid in pagination. */
  edges: Array<ReviewStatusHistoriesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewStatusHistory` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `ReviewStatusHistory` edge in the connection. */
export type ReviewStatusHistoriesEdge = {
  __typename?: 'ReviewStatusHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `ReviewStatusHistory` at the end of the edge. */
  node?: Maybe<ReviewStatusHistory>;
};

/** Methods to use when ordering `ReviewStatusHistory`. */
export enum ReviewStatusHistoriesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type ReviewStatusHistory = Node & {
  __typename?: 'ReviewStatusHistory';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  reviewId?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
};

/**
 * A condition to be used against `ReviewStatusHistory` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ReviewStatusHistoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<ReviewStatus>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: Maybe<Scalars['Boolean']>;
};

/** A filter to be used against `ReviewStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ReviewStatusHistoryFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: Maybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<ReviewStatusFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: Maybe<BooleanFilter>;
  /** Filter by the object’s `review` relation. */
  review?: Maybe<ReviewFilter>;
  /** A related `review` exists. */
  reviewExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<ReviewStatusHistoryFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<ReviewStatusHistoryFilter>>;
  /** Negates the expression. */
  not?: Maybe<ReviewStatusHistoryFilter>;
};

/** An input for mutations affecting `ReviewStatusHistory` */
export type ReviewStatusHistoryInput = {
  id?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  reviewToReviewId?: Maybe<ReviewStatusHistoryReviewIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewStatusHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewStatusHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewStatusHistory` to look up the row to update. */
export type ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate = {
  /** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
  patch: UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `ReviewStatusHistory`. Fields that are set will be updated. */
export type ReviewStatusHistoryPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  reviewToReviewId?: Maybe<ReviewStatusHistoryReviewIdFkeyInput>;
};

/** Input for the nested mutation of `review` in the `ReviewStatusHistoryInput` mutation. */
export type ReviewStatusHistoryReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: Maybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: Maybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: Maybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: Maybe<ReviewNodeIdDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: Maybe<ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: Maybe<ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: Maybe<ReviewStatusHistoryReviewIdFkeyReviewCreateInput>;
};

/** Input for the nested mutation of `reviewStatusHistory` in the `ReviewInput` mutation. */
export type ReviewStatusHistoryReviewIdFkeyInverseInput = {
  /** Flag indicating whether all other `reviewStatusHistory` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  connectById?: Maybe<Array<ReviewStatusHistoryReviewStatusHistoryPkeyConnect>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<ReviewStatusHistoryNodeIdConnect>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  deleteById?: Maybe<Array<ReviewStatusHistoryReviewStatusHistoryPkeyDelete>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<ReviewStatusHistoryNodeIdDelete>>;
  /** The primary key(s) and patch data for `reviewStatusHistory` for the far side of the relationship. */
  updateById?: Maybe<Array<ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewStatusHistory` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate>>;
  /** A `ReviewStatusHistoryInput` object that will be created and connected to this object. */
  create?: Maybe<Array<ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput>>;
};

/** The `review` to be created by this mutation. */
export type ReviewStatusHistoryReviewIdFkeyReviewCreateInput = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** The `reviewStatusHistory` to be created by this mutation. */
export type ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput = {
  id?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  reviewToReviewId?: Maybe<ReviewStatusHistoryReviewIdFkeyInput>;
};

/** The fields on `reviewStatusHistory` to look up the row to connect. */
export type ReviewStatusHistoryReviewStatusHistoryPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `reviewStatusHistory` to look up the row to delete. */
export type ReviewStatusHistoryReviewStatusHistoryPkeyDelete = {
  id: Scalars['Int'];
};

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<NotificationFilter>;
};

/** A filter to be used against many `ReviewDecision` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewDecisionFilter = {
  /** Every related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewDecisionFilter>;
  /** Some related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewDecisionFilter>;
  /** No related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewDecisionFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewResponseFilter>;
};

/** A filter to be used against many `ReviewStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewStatusHistoryFilter = {
  /** Every related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewStatusHistoryFilter>;
  /** Some related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewStatusHistoryFilter>;
  /** No related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewStatusHistoryFilter>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Scalars['String']>;
  /** Included in the specified list. */
  in?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-sensitive). */
  includes?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: Maybe<Scalars['String']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: Maybe<Scalars['String']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: Maybe<Scalars['String']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: Maybe<Scalars['String']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: Maybe<Scalars['String']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: Maybe<Scalars['String']>;
  /**
   * Matches the specified pattern (case-sensitive). An underscore (_) matches any
   * single character; a percent sign (%) matches any sequence of zero or more characters.
   */
  like?: Maybe<Scalars['String']>;
  /**
   * Does not match the specified pattern (case-sensitive). An underscore (_)
   * matches any single character; a percent sign (%) matches any sequence of zero
   * or more characters.
   */
  notLike?: Maybe<Scalars['String']>;
  /**
   * Matches the specified pattern (case-insensitive). An underscore (_) matches
   * any single character; a percent sign (%) matches any sequence of zero or more characters.
   */
  likeInsensitive?: Maybe<Scalars['String']>;
  /**
   * Does not match the specified pattern (case-insensitive). An underscore (_)
   * matches any single character; a percent sign (%) matches any sequence of zero
   * or more characters.
   */
  notLikeInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: Maybe<Scalars['String']>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: Maybe<Array<Scalars['String']>>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: Maybe<Scalars['String']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: Maybe<Scalars['String']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: Maybe<Scalars['String']>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contains the specified list of values. */
  contains?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Contained by the specified list of values. */
  containedBy?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: Maybe<Array<Maybe<Scalars['String']>>>;
  /** Any array item is equal to the specified value. */
  anyEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: Maybe<Scalars['String']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: Maybe<Scalars['String']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: Maybe<Scalars['String']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: Maybe<Scalars['String']>;
};

export type Template = Node & {
  __typename?: 'Template';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  /** Reads and enables pagination through a set of `TemplateStage`. */
  templateStages: TemplateStagesConnection;
  /** Reads and enables pagination through a set of `TemplateSection`. */
  templateSections: TemplateSectionsConnection;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions: TemplatePermissionsConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applications: ApplicationsConnection;
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueues: ActionQueuesConnection;
  /** Reads and enables pagination through a set of `TemplateAction`. */
  templateActions: TemplateActionsConnection;
};


export type TemplateTemplateStagesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplateStagesOrderBy>>;
  condition?: Maybe<TemplateStageCondition>;
  filter?: Maybe<TemplateStageFilter>;
};


export type TemplateTemplateSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplateSectionsOrderBy>>;
  condition?: Maybe<TemplateSectionCondition>;
  filter?: Maybe<TemplateSectionFilter>;
};


export type TemplateTemplatePermissionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplatePermissionsOrderBy>>;
  condition?: Maybe<TemplatePermissionCondition>;
  filter?: Maybe<TemplatePermissionFilter>;
};


export type TemplateApplicationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationsOrderBy>>;
  condition?: Maybe<ApplicationCondition>;
  filter?: Maybe<ApplicationFilter>;
};


export type TemplateActionQueuesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ActionQueuesOrderBy>>;
  condition?: Maybe<ActionQueueCondition>;
  filter?: Maybe<ActionQueueFilter>;
};


export type TemplateTemplateActionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplateActionsOrderBy>>;
  condition?: Maybe<TemplateActionCondition>;
  filter?: Maybe<TemplateActionFilter>;
};

export type TemplateAction = Node & {
  __typename?: 'TemplateAction';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  templateId?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  trigger?: Maybe<Trigger>;
  sequence?: Maybe<Scalars['Int']>;
  condition?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
};

/**
 * A condition to be used against `TemplateAction` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateActionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `actionCode` field. */
  actionCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: Maybe<Trigger>;
  /** Checks for equality with the object’s `sequence` field. */
  sequence?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `condition` field. */
  condition?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `parameterQueries` field. */
  parameterQueries?: Maybe<Scalars['JSON']>;
};

/** A filter to be used against `TemplateAction` object types. All fields are combined with a logical ‘and.’ */
export type TemplateActionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `actionCode` field. */
  actionCode?: Maybe<StringFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: Maybe<TriggerFilter>;
  /** Filter by the object’s `sequence` field. */
  sequence?: Maybe<IntFilter>;
  /** Filter by the object’s `condition` field. */
  condition?: Maybe<JsonFilter>;
  /** Filter by the object’s `parameterQueries` field. */
  parameterQueries?: Maybe<JsonFilter>;
  /** Filter by the object’s `template` relation. */
  template?: Maybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TemplateActionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TemplateActionFilter>>;
  /** Negates the expression. */
  not?: Maybe<TemplateActionFilter>;
};

/** An input for mutations affecting `TemplateAction` */
export type TemplateActionInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  trigger?: Maybe<Trigger>;
  sequence?: Maybe<Scalars['Int']>;
  condition?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  templateToTemplateId?: Maybe<TemplateActionTemplateIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateActionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateAction` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateActionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateAction` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateAction` to look up the row to update. */
export type TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate = {
  /** An object where the defined keys will be set on the `templateAction` being updated. */
  patch: UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `TemplateAction`. Fields that are set will be updated. */
export type TemplateActionPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  trigger?: Maybe<Trigger>;
  sequence?: Maybe<Scalars['Int']>;
  condition?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  templateToTemplateId?: Maybe<TemplateActionTemplateIdFkeyInput>;
};

/** A connection to a list of `TemplateAction` values. */
export type TemplateActionsConnection = {
  __typename?: 'TemplateActionsConnection';
  /** A list of `TemplateAction` objects. */
  nodes: Array<Maybe<TemplateAction>>;
  /** A list of edges which contains the `TemplateAction` and cursor to aid in pagination. */
  edges: Array<TemplateActionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateAction` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TemplateAction` edge in the connection. */
export type TemplateActionsEdge = {
  __typename?: 'TemplateActionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TemplateAction` at the end of the edge. */
  node?: Maybe<TemplateAction>;
};

/** Methods to use when ordering `TemplateAction`. */
export enum TemplateActionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  ActionCodeAsc = 'ACTION_CODE_ASC',
  ActionCodeDesc = 'ACTION_CODE_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC',
  SequenceAsc = 'SEQUENCE_ASC',
  SequenceDesc = 'SEQUENCE_DESC',
  ConditionAsc = 'CONDITION_ASC',
  ConditionDesc = 'CONDITION_DESC',
  ParameterQueriesAsc = 'PARAMETER_QUERIES_ASC',
  ParameterQueriesDesc = 'PARAMETER_QUERIES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The fields on `templateAction` to look up the row to connect. */
export type TemplateActionTemplateActionPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `templateAction` to look up the row to delete. */
export type TemplateActionTemplateActionPkeyDelete = {
  id: Scalars['Int'];
};

/** Input for the nested mutation of `template` in the `TemplateActionInput` mutation. */
export type TemplateActionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: Maybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateNodeIdConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: Maybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: Maybe<TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: Maybe<TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: Maybe<TemplateActionTemplateIdFkeyTemplateCreateInput>;
};

/** Input for the nested mutation of `templateAction` in the `TemplateInput` mutation. */
export type TemplateActionTemplateIdFkeyInverseInput = {
  /** Flag indicating whether all other `templateAction` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  connectById?: Maybe<Array<TemplateActionTemplateActionPkeyConnect>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TemplateActionNodeIdConnect>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  deleteById?: Maybe<Array<TemplateActionTemplateActionPkeyDelete>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TemplateActionNodeIdDelete>>;
  /** The primary key(s) and patch data for `templateAction` for the far side of the relationship. */
  updateById?: Maybe<Array<TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateAction` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate>>;
  /** A `TemplateActionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TemplateActionTemplateIdFkeyTemplateActionCreateInput>>;
};

/** The `templateAction` to be created by this mutation. */
export type TemplateActionTemplateIdFkeyTemplateActionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  trigger?: Maybe<Trigger>;
  sequence?: Maybe<Scalars['Int']>;
  condition?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  templateToTemplateId?: Maybe<TemplateActionTemplateIdFkeyInput>;
};

/** The `template` to be created by this mutation. */
export type TemplateActionTemplateIdFkeyTemplateCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/**
 * A condition to be used against `Template` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TemplateCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `name` field. */
  name?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `isLinear` field. */
  isLinear?: Maybe<Scalars['Boolean']>;
  /** Checks for equality with the object’s `startMessage` field. */
  startMessage?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<TemplateStatus>;
  /** Checks for equality with the object’s `submissionMessage` field. */
  submissionMessage?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `versionTimestamp` field. */
  versionTimestamp?: Maybe<Scalars['Datetime']>;
};

export type TemplateElement = Node & {
  __typename?: 'TemplateElement';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  sectionId?: Maybe<Scalars['Int']>;
  code: Scalars['String'];
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses: ApplicationResponsesConnection;
  /** Reads and enables pagination through a set of `ReviewQuestionAssignment`. */
  reviewQuestionAssignments: ReviewQuestionAssignmentsConnection;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
};


export type TemplateElementApplicationResponsesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationResponsesOrderBy>>;
  condition?: Maybe<ApplicationResponseCondition>;
  filter?: Maybe<ApplicationResponseFilter>;
};


export type TemplateElementReviewQuestionAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewQuestionAssignmentsOrderBy>>;
  condition?: Maybe<ReviewQuestionAssignmentCondition>;
  filter?: Maybe<ReviewQuestionAssignmentFilter>;
};


export type TemplateElementReviewResponsesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
  condition?: Maybe<ReviewResponseCondition>;
  filter?: Maybe<ReviewResponseFilter>;
};

export enum TemplateElementCategory {
  Question = 'QUESTION',
  Information = 'INFORMATION'
}

/** A filter to be used against TemplateElementCategory fields. All fields are combined with a logical ‘and.’ */
export type TemplateElementCategoryFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<TemplateElementCategory>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<TemplateElementCategory>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<TemplateElementCategory>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<TemplateElementCategory>;
  /** Included in the specified list. */
  in?: Maybe<Array<TemplateElementCategory>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<TemplateElementCategory>>;
  /** Less than the specified value. */
  lessThan?: Maybe<TemplateElementCategory>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<TemplateElementCategory>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<TemplateElementCategory>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<TemplateElementCategory>;
};

/**
 * A condition to be used against `TemplateElement` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateElementCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `sectionId` field. */
  sectionId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `index` field. */
  index?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `category` field. */
  category?: Maybe<TemplateElementCategory>;
  /** Checks for equality with the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `visibilityCondition` field. */
  visibilityCondition?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `isRequired` field. */
  isRequired?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `isEditable` field. */
  isEditable?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `validation` field. */
  validation?: Maybe<Scalars['JSON']>;
  /** Checks for equality with the object’s `validationMessage` field. */
  validationMessage?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `parameters` field. */
  parameters?: Maybe<Scalars['JSON']>;
};

/** A filter to be used against `TemplateElement` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `sectionId` field. */
  sectionId?: Maybe<IntFilter>;
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>;
  /** Filter by the object’s `index` field. */
  index?: Maybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `category` field. */
  category?: Maybe<TemplateElementCategoryFilter>;
  /** Filter by the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: Maybe<StringFilter>;
  /** Filter by the object’s `visibilityCondition` field. */
  visibilityCondition?: Maybe<JsonFilter>;
  /** Filter by the object’s `isRequired` field. */
  isRequired?: Maybe<JsonFilter>;
  /** Filter by the object’s `isEditable` field. */
  isEditable?: Maybe<JsonFilter>;
  /** Filter by the object’s `validation` field. */
  validation?: Maybe<JsonFilter>;
  /** Filter by the object’s `validationMessage` field. */
  validationMessage?: Maybe<StringFilter>;
  /** Filter by the object’s `parameters` field. */
  parameters?: Maybe<JsonFilter>;
  /** Filter by the object’s `applicationResponses` relation. */
  applicationResponses?: Maybe<TemplateElementToManyApplicationResponseFilter>;
  /** Some related `applicationResponses` exist. */
  applicationResponsesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewQuestionAssignments` relation. */
  reviewQuestionAssignments?: Maybe<TemplateElementToManyReviewQuestionAssignmentFilter>;
  /** Some related `reviewQuestionAssignments` exist. */
  reviewQuestionAssignmentsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: Maybe<TemplateElementToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `section` relation. */
  section?: Maybe<TemplateSectionFilter>;
  /** A related `section` exists. */
  sectionExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TemplateElementFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TemplateElementFilter>>;
  /** Negates the expression. */
  not?: Maybe<TemplateElementFilter>;
};

/** An input for mutations affecting `TemplateElement` */
export type TemplateElementInput = {
  id?: Maybe<Scalars['Int']>;
  sectionId?: Maybe<Scalars['Int']>;
  code: Scalars['String'];
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateElementNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateElementNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateElement` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate = {
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewQuestionAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
  patch: ReviewQuestionAssignmentPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingTemplateElementPkeyUpdate = {
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate = {
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate = {
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `TemplateElement`. Fields that are set will be updated. */
export type TemplateElementPatch = {
  id?: Maybe<Scalars['Int']>;
  sectionId?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** A connection to a list of `TemplateElement` values. */
export type TemplateElementsConnection = {
  __typename?: 'TemplateElementsConnection';
  /** A list of `TemplateElement` objects. */
  nodes: Array<Maybe<TemplateElement>>;
  /** A list of edges which contains the `TemplateElement` and cursor to aid in pagination. */
  edges: Array<TemplateElementsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateElement` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** Input for the nested mutation of `templateSection` in the `TemplateElementInput` mutation. */
export type TemplateElementSectionIdFkeyInput = {
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectById?: Maybe<TemplateSectionTemplateSectionPkeyConnect>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateSectionNodeIdConnect>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteById?: Maybe<TemplateSectionTemplateSectionPkeyDelete>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateSectionNodeIdDelete>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateById?: Maybe<TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByNodeId?: Maybe<TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate>;
  /** A `TemplateSectionInput` object that will be created and connected to this object. */
  create?: Maybe<TemplateElementSectionIdFkeyTemplateSectionCreateInput>;
};

/** Input for the nested mutation of `templateElement` in the `TemplateSectionInput` mutation. */
export type TemplateElementSectionIdFkeyInverseInput = {
  /** Flag indicating whether all other `templateElement` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: Maybe<Array<TemplateElementTemplateElementPkeyConnect>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TemplateElementNodeIdConnect>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: Maybe<Array<TemplateElementTemplateElementPkeyDelete>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TemplateElementNodeIdDelete>>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: Maybe<Array<TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate>>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TemplateElementSectionIdFkeyTemplateElementCreateInput>>;
};

/** The `templateElement` to be created by this mutation. */
export type TemplateElementSectionIdFkeyTemplateElementCreateInput = {
  id?: Maybe<Scalars['Int']>;
  code: Scalars['String'];
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** The `templateSection` to be created by this mutation. */
export type TemplateElementSectionIdFkeyTemplateSectionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateSectionTemplateIdFkeyInput>;
  templateElementsUsingId?: Maybe<TemplateElementSectionIdFkeyInverseInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInverseInput>;
};

/** A `TemplateElement` edge in the connection. */
export type TemplateElementsEdge = {
  __typename?: 'TemplateElementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TemplateElement` at the end of the edge. */
  node?: Maybe<TemplateElement>;
};

/** Methods to use when ordering `TemplateElement`. */
export enum TemplateElementsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  SectionIdAsc = 'SECTION_ID_ASC',
  SectionIdDesc = 'SECTION_ID_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IndexAsc = 'INDEX_ASC',
  IndexDesc = 'INDEX_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  ElementTypePluginCodeAsc = 'ELEMENT_TYPE_PLUGIN_CODE_ASC',
  ElementTypePluginCodeDesc = 'ELEMENT_TYPE_PLUGIN_CODE_DESC',
  VisibilityConditionAsc = 'VISIBILITY_CONDITION_ASC',
  VisibilityConditionDesc = 'VISIBILITY_CONDITION_DESC',
  IsRequiredAsc = 'IS_REQUIRED_ASC',
  IsRequiredDesc = 'IS_REQUIRED_DESC',
  IsEditableAsc = 'IS_EDITABLE_ASC',
  IsEditableDesc = 'IS_EDITABLE_DESC',
  ValidationAsc = 'VALIDATION_ASC',
  ValidationDesc = 'VALIDATION_DESC',
  ValidationMessageAsc = 'VALIDATION_MESSAGE_ASC',
  ValidationMessageDesc = 'VALIDATION_MESSAGE_DESC',
  ParametersAsc = 'PARAMETERS_ASC',
  ParametersDesc = 'PARAMETERS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** The fields on `templateElement` to look up the row to connect. */
export type TemplateElementTemplateElementPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `templateElement` to look up the row to delete. */
export type TemplateElementTemplateElementPkeyDelete = {
  id: Scalars['Int'];
};

/** A filter to be used against many `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementToManyApplicationResponseFilter = {
  /** Every related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationResponseFilter>;
  /** Some related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationResponseFilter>;
  /** No related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationResponseFilter>;
};

/** A filter to be used against many `ReviewQuestionAssignment` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementToManyReviewQuestionAssignmentFilter = {
  /** Every related `ReviewQuestionAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewQuestionAssignmentFilter>;
  /** Some related `ReviewQuestionAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewQuestionAssignmentFilter>;
  /** No related `ReviewQuestionAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewQuestionAssignmentFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewResponseFilter>;
};

/** A filter to be used against `Template` object types. All fields are combined with a logical ‘and.’ */
export type TemplateFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: Maybe<StringFilter>;
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>;
  /** Filter by the object’s `isLinear` field. */
  isLinear?: Maybe<BooleanFilter>;
  /** Filter by the object’s `startMessage` field. */
  startMessage?: Maybe<JsonFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<TemplateStatusFilter>;
  /** Filter by the object’s `submissionMessage` field. */
  submissionMessage?: Maybe<JsonFilter>;
  /** Filter by the object’s `versionTimestamp` field. */
  versionTimestamp?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `templateStages` relation. */
  templateStages?: Maybe<TemplateToManyTemplateStageFilter>;
  /** Some related `templateStages` exist. */
  templateStagesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `templateSections` relation. */
  templateSections?: Maybe<TemplateToManyTemplateSectionFilter>;
  /** Some related `templateSections` exist. */
  templateSectionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `templatePermissions` relation. */
  templatePermissions?: Maybe<TemplateToManyTemplatePermissionFilter>;
  /** Some related `templatePermissions` exist. */
  templatePermissionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `applications` relation. */
  applications?: Maybe<TemplateToManyApplicationFilter>;
  /** Some related `applications` exist. */
  applicationsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `actionQueues` relation. */
  actionQueues?: Maybe<TemplateToManyActionQueueFilter>;
  /** Some related `actionQueues` exist. */
  actionQueuesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `templateActions` relation. */
  templateActions?: Maybe<TemplateToManyTemplateActionFilter>;
  /** Some related `templateActions` exist. */
  templateActionsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TemplateFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TemplateFilter>>;
  /** Negates the expression. */
  not?: Maybe<TemplateFilter>;
};

/** An input for mutations affecting `Template` */
export type TemplateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `template` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate = {
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate = {
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateAction` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateAction` being updated. */
  patch: TemplateActionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate = {
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `Template`. Fields that are set will be updated. */
export type TemplatePatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

export type TemplatePermission = Node & {
  __typename?: 'TemplatePermission';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  permissionNameId?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  restrictions?: Maybe<Scalars['JSON']>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
};

/**
 * A condition to be used against `TemplatePermission` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplatePermissionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `level` field. */
  level?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `restrictions` field. */
  restrictions?: Maybe<Scalars['JSON']>;
};

/** A filter to be used against `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type TemplatePermissionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: Maybe<IntFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: Maybe<IntFilter>;
  /** Filter by the object’s `level` field. */
  level?: Maybe<IntFilter>;
  /** Filter by the object’s `restrictions` field. */
  restrictions?: Maybe<JsonFilter>;
  /** Filter by the object’s `permissionName` relation. */
  permissionName?: Maybe<PermissionNameFilter>;
  /** A related `permissionName` exists. */
  permissionNameExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `template` relation. */
  template?: Maybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TemplatePermissionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TemplatePermissionFilter>>;
  /** Negates the expression. */
  not?: Maybe<TemplatePermissionFilter>;
};

/** An input for mutations affecting `TemplatePermission` */
export type TemplatePermissionInput = {
  id?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  restrictions?: Maybe<Scalars['JSON']>;
  permissionNameToPermissionNameId?: Maybe<TemplatePermissionPermissionNameIdFkeyInput>;
  templateToTemplateId?: Maybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplatePermissionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplatePermissionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `templatePermission` to look up the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate = {
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templatePermission` to look up the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate = {
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `TemplatePermission`. Fields that are set will be updated. */
export type TemplatePermissionPatch = {
  id?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  restrictions?: Maybe<Scalars['JSON']>;
  permissionNameToPermissionNameId?: Maybe<TemplatePermissionPermissionNameIdFkeyInput>;
  templateToTemplateId?: Maybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** Input for the nested mutation of `permissionName` in the `TemplatePermissionInput` mutation. */
export type TemplatePermissionPermissionNameIdFkeyInput = {
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: Maybe<PermissionNamePermissionNamePkeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: Maybe<PermissionNamePermissionNameNameKeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: Maybe<PermissionNameNodeIdConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: Maybe<PermissionNamePermissionNamePkeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: Maybe<PermissionNamePermissionNameNameKeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: Maybe<PermissionNameNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: Maybe<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: Maybe<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: Maybe<TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: Maybe<TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput>;
};

/** Input for the nested mutation of `templatePermission` in the `PermissionNameInput` mutation. */
export type TemplatePermissionPermissionNameIdFkeyInverseInput = {
  /** Flag indicating whether all other `templatePermission` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectById?: Maybe<Array<TemplatePermissionTemplatePermissionPkeyConnect>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TemplatePermissionNodeIdConnect>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteById?: Maybe<Array<TemplatePermissionTemplatePermissionPkeyDelete>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TemplatePermissionNodeIdDelete>>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateById?: Maybe<Array<TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate>>;
  /** A `TemplatePermissionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput>>;
};

/** The `permissionName` to be created by this mutation. */
export type TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  permissionPolicyId?: Maybe<Scalars['Int']>;
  permissionPolicyToPermissionPolicyId?: Maybe<PermissionNamePermissionPolicyIdFkeyInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The `templatePermission` to be created by this mutation. */
export type TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  restrictions?: Maybe<Scalars['JSON']>;
  permissionNameToPermissionNameId?: Maybe<TemplatePermissionPermissionNameIdFkeyInput>;
  templateToTemplateId?: Maybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** A connection to a list of `TemplatePermission` values. */
export type TemplatePermissionsConnection = {
  __typename?: 'TemplatePermissionsConnection';
  /** A list of `TemplatePermission` objects. */
  nodes: Array<Maybe<TemplatePermission>>;
  /** A list of edges which contains the `TemplatePermission` and cursor to aid in pagination. */
  edges: Array<TemplatePermissionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplatePermission` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TemplatePermission` edge in the connection. */
export type TemplatePermissionsEdge = {
  __typename?: 'TemplatePermissionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TemplatePermission` at the end of the edge. */
  node?: Maybe<TemplatePermission>;
};

/** Methods to use when ordering `TemplatePermission`. */
export enum TemplatePermissionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  LevelAsc = 'LEVEL_ASC',
  LevelDesc = 'LEVEL_DESC',
  RestrictionsAsc = 'RESTRICTIONS_ASC',
  RestrictionsDesc = 'RESTRICTIONS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `template` in the `TemplatePermissionInput` mutation. */
export type TemplatePermissionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: Maybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateNodeIdConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: Maybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: Maybe<TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: Maybe<TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: Maybe<TemplatePermissionTemplateIdFkeyTemplateCreateInput>;
};

/** Input for the nested mutation of `templatePermission` in the `TemplateInput` mutation. */
export type TemplatePermissionTemplateIdFkeyInverseInput = {
  /** Flag indicating whether all other `templatePermission` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectById?: Maybe<Array<TemplatePermissionTemplatePermissionPkeyConnect>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TemplatePermissionNodeIdConnect>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteById?: Maybe<Array<TemplatePermissionTemplatePermissionPkeyDelete>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TemplatePermissionNodeIdDelete>>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateById?: Maybe<Array<TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate>>;
  /** A `TemplatePermissionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput>>;
};

/** The `template` to be created by this mutation. */
export type TemplatePermissionTemplateIdFkeyTemplateCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** The `templatePermission` to be created by this mutation. */
export type TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  restrictions?: Maybe<Scalars['JSON']>;
  permissionNameToPermissionNameId?: Maybe<TemplatePermissionPermissionNameIdFkeyInput>;
  templateToTemplateId?: Maybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** The fields on `templatePermission` to look up the row to connect. */
export type TemplatePermissionTemplatePermissionPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `templatePermission` to look up the row to delete. */
export type TemplatePermissionTemplatePermissionPkeyDelete = {
  id: Scalars['Int'];
};

/** A connection to a list of `Template` values. */
export type TemplatesConnection = {
  __typename?: 'TemplatesConnection';
  /** A list of `Template` objects. */
  nodes: Array<Maybe<Template>>;
  /** A list of edges which contains the `Template` and cursor to aid in pagination. */
  edges: Array<TemplatesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Template` you could get from the connection. */
  totalCount: Scalars['Int'];
};

export type TemplateSection = Node & {
  __typename?: 'TemplateSection';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  templateId?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** Reads and enables pagination through a set of `TemplateElement`. */
  templateElementsBySectionId: TemplateElementsConnection;
  /** Reads and enables pagination through a set of `ApplicationSection`. */
  applicationSections: ApplicationSectionsConnection;
};


export type TemplateSectionTemplateElementsBySectionIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<TemplateElementsOrderBy>>;
  condition?: Maybe<TemplateElementCondition>;
  filter?: Maybe<TemplateElementFilter>;
};


export type TemplateSectionApplicationSectionsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationSectionsOrderBy>>;
  condition?: Maybe<ApplicationSectionCondition>;
  filter?: Maybe<ApplicationSectionFilter>;
};

/**
 * A condition to be used against `TemplateSection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateSectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `code` field. */
  code?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `index` field. */
  index?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `TemplateSection` object types. All fields are combined with a logical ‘and.’ */
export type TemplateSectionFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `code` field. */
  code?: Maybe<StringFilter>;
  /** Filter by the object’s `index` field. */
  index?: Maybe<IntFilter>;
  /** Filter by the object’s `templateElementsBySectionId` relation. */
  templateElementsBySectionId?: Maybe<TemplateSectionToManyTemplateElementFilter>;
  /** Some related `templateElementsBySectionId` exist. */
  templateElementsBySectionIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `applicationSections` relation. */
  applicationSections?: Maybe<TemplateSectionToManyApplicationSectionFilter>;
  /** Some related `applicationSections` exist. */
  applicationSectionsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `template` relation. */
  template?: Maybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TemplateSectionFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TemplateSectionFilter>>;
  /** Negates the expression. */
  not?: Maybe<TemplateSectionFilter>;
};

/** An input for mutations affecting `TemplateSection` */
export type TemplateSectionInput = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateSectionTemplateIdFkeyInput>;
  templateElementsUsingId?: Maybe<TemplateElementSectionIdFkeyInverseInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateSectionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateSectionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateSection` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationSection` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationSection` being updated. */
  patch: ApplicationSectionPatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingTemplateSectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate = {
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `TemplateSection`. Fields that are set will be updated. */
export type TemplateSectionPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateSectionTemplateIdFkeyInput>;
  templateElementsUsingId?: Maybe<TemplateElementSectionIdFkeyInverseInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInverseInput>;
};

/** A connection to a list of `TemplateSection` values. */
export type TemplateSectionsConnection = {
  __typename?: 'TemplateSectionsConnection';
  /** A list of `TemplateSection` objects. */
  nodes: Array<Maybe<TemplateSection>>;
  /** A list of edges which contains the `TemplateSection` and cursor to aid in pagination. */
  edges: Array<TemplateSectionsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateSection` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TemplateSection` edge in the connection. */
export type TemplateSectionsEdge = {
  __typename?: 'TemplateSectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TemplateSection` at the end of the edge. */
  node?: Maybe<TemplateSection>;
};

/** Methods to use when ordering `TemplateSection`. */
export enum TemplateSectionsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IndexAsc = 'INDEX_ASC',
  IndexDesc = 'INDEX_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `template` in the `TemplateSectionInput` mutation. */
export type TemplateSectionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: Maybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateNodeIdConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: Maybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: Maybe<TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: Maybe<TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: Maybe<TemplateSectionTemplateIdFkeyTemplateCreateInput>;
};

/** Input for the nested mutation of `templateSection` in the `TemplateInput` mutation. */
export type TemplateSectionTemplateIdFkeyInverseInput = {
  /** Flag indicating whether all other `templateSection` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectById?: Maybe<Array<TemplateSectionTemplateSectionPkeyConnect>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TemplateSectionNodeIdConnect>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteById?: Maybe<Array<TemplateSectionTemplateSectionPkeyDelete>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TemplateSectionNodeIdDelete>>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateById?: Maybe<Array<TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate>>;
  /** A `TemplateSectionInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TemplateSectionTemplateIdFkeyTemplateSectionCreateInput>>;
};

/** The `template` to be created by this mutation. */
export type TemplateSectionTemplateIdFkeyTemplateCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** The `templateSection` to be created by this mutation. */
export type TemplateSectionTemplateIdFkeyTemplateSectionCreateInput = {
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateSectionTemplateIdFkeyInput>;
  templateElementsUsingId?: Maybe<TemplateElementSectionIdFkeyInverseInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInverseInput>;
};

/** The fields on `templateSection` to look up the row to connect. */
export type TemplateSectionTemplateSectionPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `templateSection` to look up the row to delete. */
export type TemplateSectionTemplateSectionPkeyDelete = {
  id: Scalars['Int'];
};

/** A filter to be used against many `ApplicationSection` object types. All fields are combined with a logical ‘and.’ */
export type TemplateSectionToManyApplicationSectionFilter = {
  /** Every related `ApplicationSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationSectionFilter>;
  /** Some related `ApplicationSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationSectionFilter>;
  /** No related `ApplicationSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationSectionFilter>;
};

/** A filter to be used against many `TemplateElement` object types. All fields are combined with a logical ‘and.’ */
export type TemplateSectionToManyTemplateElementFilter = {
  /** Every related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TemplateElementFilter>;
  /** Some related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TemplateElementFilter>;
  /** No related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TemplateElementFilter>;
};

/** A `Template` edge in the connection. */
export type TemplatesEdge = {
  __typename?: 'TemplatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `Template` at the end of the edge. */
  node?: Maybe<Template>;
};

/** Methods to use when ordering `Template`. */
export enum TemplatesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IsLinearAsc = 'IS_LINEAR_ASC',
  IsLinearDesc = 'IS_LINEAR_DESC',
  StartMessageAsc = 'START_MESSAGE_ASC',
  StartMessageDesc = 'START_MESSAGE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SubmissionMessageAsc = 'SUBMISSION_MESSAGE_ASC',
  SubmissionMessageDesc = 'SUBMISSION_MESSAGE_DESC',
  VersionTimestampAsc = 'VERSION_TIMESTAMP_ASC',
  VersionTimestampDesc = 'VERSION_TIMESTAMP_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type TemplateStage = Node & {
  __typename?: 'TemplateStage';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateId?: Maybe<Scalars['Int']>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistoriesByStageId: ApplicationStageHistoriesConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignmentsByStageId: ReviewAssignmentsConnection;
};


export type TemplateStageApplicationStageHistoriesByStageIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationStageHistoriesOrderBy>>;
  condition?: Maybe<ApplicationStageHistoryCondition>;
  filter?: Maybe<ApplicationStageHistoryFilter>;
};


export type TemplateStageReviewAssignmentsByStageIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
  condition?: Maybe<ReviewAssignmentCondition>;
  filter?: Maybe<ReviewAssignmentFilter>;
};

/**
 * A condition to be used against `TemplateStage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateStageCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `number` field. */
  number?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `title` field. */
  title?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `description` field. */
  description?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: Maybe<Scalars['Int']>;
};

/** A filter to be used against `TemplateStage` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `number` field. */
  number?: Maybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: Maybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: Maybe<StringFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: Maybe<IntFilter>;
  /** Filter by the object’s `applicationStageHistoriesByStageId` relation. */
  applicationStageHistoriesByStageId?: Maybe<TemplateStageToManyApplicationStageHistoryFilter>;
  /** Some related `applicationStageHistoriesByStageId` exist. */
  applicationStageHistoriesByStageIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewAssignmentsByStageId` relation. */
  reviewAssignmentsByStageId?: Maybe<TemplateStageToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignmentsByStageId` exist. */
  reviewAssignmentsByStageIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `template` relation. */
  template?: Maybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TemplateStageFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TemplateStageFilter>>;
  /** Negates the expression. */
  not?: Maybe<TemplateStageFilter>;
};

/** An input for mutations affecting `TemplateStage` */
export type TemplateStageInput = {
  id?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateId?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateStageTemplateIdFkeyInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentStageIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateStageNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateStageNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateStage` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate = {
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate = {
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate = {
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `TemplateStage`. Fields that are set will be updated. */
export type TemplateStagePatch = {
  id?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateId?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateStageTemplateIdFkeyInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentStageIdFkeyInverseInput>;
};

/** A connection to a list of `TemplateStage` values. */
export type TemplateStagesConnection = {
  __typename?: 'TemplateStagesConnection';
  /** A list of `TemplateStage` objects. */
  nodes: Array<Maybe<TemplateStage>>;
  /** A list of edges which contains the `TemplateStage` and cursor to aid in pagination. */
  edges: Array<TemplateStagesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateStage` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TemplateStage` edge in the connection. */
export type TemplateStagesEdge = {
  __typename?: 'TemplateStagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TemplateStage` at the end of the edge. */
  node?: Maybe<TemplateStage>;
};

/** Methods to use when ordering `TemplateStage`. */
export enum TemplateStagesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `template` in the `TemplateStageInput` mutation. */
export type TemplateStageTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: Maybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: Maybe<TemplateNodeIdConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: Maybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: Maybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: Maybe<TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: Maybe<TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: Maybe<TemplateStageTemplateIdFkeyTemplateCreateInput>;
};

/** Input for the nested mutation of `templateStage` in the `TemplateInput` mutation. */
export type TemplateStageTemplateIdFkeyInverseInput = {
  /** Flag indicating whether all other `templateStage` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: Maybe<Array<TemplateStageTemplateStagePkeyConnect>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<TemplateStageNodeIdConnect>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: Maybe<Array<TemplateStageTemplateStagePkeyDelete>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<TemplateStageNodeIdDelete>>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: Maybe<Array<TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate>>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate>>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: Maybe<Array<TemplateStageTemplateIdFkeyTemplateStageCreateInput>>;
};

/** The `template` to be created by this mutation. */
export type TemplateStageTemplateIdFkeyTemplateCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code: Scalars['String'];
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** The `templateStage` to be created by this mutation. */
export type TemplateStageTemplateIdFkeyTemplateStageCreateInput = {
  id?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateToTemplateId?: Maybe<TemplateStageTemplateIdFkeyInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentStageIdFkeyInverseInput>;
};

/** The fields on `templateStage` to look up the row to connect. */
export type TemplateStageTemplateStagePkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `templateStage` to look up the row to delete. */
export type TemplateStageTemplateStagePkeyDelete = {
  id: Scalars['Int'];
};

/** A filter to be used against many `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageToManyApplicationStageHistoryFilter = {
  /** Every related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationStageHistoryFilter>;
  /** Some related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationStageHistoryFilter>;
  /** No related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationStageHistoryFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewAssignmentFilter>;
};

export enum TemplateStatus {
  Draft = 'DRAFT',
  Available = 'AVAILABLE',
  Disabled = 'DISABLED'
}

/** A filter to be used against TemplateStatus fields. All fields are combined with a logical ‘and.’ */
export type TemplateStatusFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<TemplateStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<TemplateStatus>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<TemplateStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<TemplateStatus>;
  /** Included in the specified list. */
  in?: Maybe<Array<TemplateStatus>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<TemplateStatus>>;
  /** Less than the specified value. */
  lessThan?: Maybe<TemplateStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<TemplateStatus>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<TemplateStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<TemplateStatus>;
};

/** The fields on `template` to look up the row to connect. */
export type TemplateTemplatePkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `template` to look up the row to delete. */
export type TemplateTemplatePkeyDelete = {
  id: Scalars['Int'];
};

/** A filter to be used against many `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyActionQueueFilter = {
  /** Every related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ActionQueueFilter>;
  /** Some related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ActionQueueFilter>;
  /** No related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ActionQueueFilter>;
};

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationFilter>;
};

/** A filter to be used against many `TemplateAction` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateActionFilter = {
  /** Every related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TemplateActionFilter>;
  /** Some related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TemplateActionFilter>;
  /** No related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TemplateActionFilter>;
};

/** A filter to be used against many `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplatePermissionFilter = {
  /** Every related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TemplatePermissionFilter>;
  /** Some related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TemplatePermissionFilter>;
  /** No related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TemplatePermissionFilter>;
};

/** A filter to be used against many `TemplateSection` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateSectionFilter = {
  /** Every related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TemplateSectionFilter>;
  /** Some related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TemplateSectionFilter>;
  /** No related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TemplateSectionFilter>;
};

/** A filter to be used against many `TemplateStage` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateStageFilter = {
  /** Every related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<TemplateStageFilter>;
  /** Some related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<TemplateStageFilter>;
  /** No related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<TemplateStageFilter>;
};

export enum Trigger {
  OnApplicationCreate = 'ON_APPLICATION_CREATE',
  OnApplicationSubmit = 'ON_APPLICATION_SUBMIT',
  OnApplicationSave = 'ON_APPLICATION_SAVE',
  OnApplicationWithdraw = 'ON_APPLICATION_WITHDRAW',
  OnReviewCreate = 'ON_REVIEW_CREATE',
  OnReviewSubmit = 'ON_REVIEW_SUBMIT',
  OnReviewStart = 'ON_REVIEW_START',
  OnReviewAssign = 'ON_REVIEW_ASSIGN',
  OnReviewSelfAssign = 'ON_REVIEW_SELF_ASSIGN',
  OnApprovalSubmit = 'ON_APPROVAL_SUBMIT',
  OnScheduleTime = 'ON_SCHEDULE_TIME',
  Processing = 'PROCESSING',
  Error = 'ERROR'
}

/** A filter to be used against Trigger fields. All fields are combined with a logical ‘and.’ */
export type TriggerFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<Trigger>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<Trigger>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<Trigger>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<Trigger>;
  /** Included in the specified list. */
  in?: Maybe<Array<Trigger>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<Trigger>>;
  /** Less than the specified value. */
  lessThan?: Maybe<Trigger>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<Trigger>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<Trigger>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<Trigger>;
};

export type TriggerQueue = Node & {
  __typename?: 'TriggerQueue';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  triggerType?: Maybe<Trigger>;
  table?: Maybe<Scalars['String']>;
  recordId?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Datetime']>;
  status?: Maybe<TriggerQueueStatus>;
  log?: Maybe<Scalars['JSON']>;
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueuesByTriggerEvent: ActionQueuesConnection;
};


export type TriggerQueueActionQueuesByTriggerEventArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ActionQueuesOrderBy>>;
  condition?: Maybe<ActionQueueCondition>;
  filter?: Maybe<ActionQueueFilter>;
};

/**
 * A condition to be used against `TriggerQueue` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TriggerQueueCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `triggerType` field. */
  triggerType?: Maybe<Trigger>;
  /** Checks for equality with the object’s `table` field. */
  table?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `recordId` field. */
  recordId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: Maybe<Scalars['Datetime']>;
  /** Checks for equality with the object’s `status` field. */
  status?: Maybe<TriggerQueueStatus>;
  /** Checks for equality with the object’s `log` field. */
  log?: Maybe<Scalars['JSON']>;
};

/** A filter to be used against `TriggerQueue` object types. All fields are combined with a logical ‘and.’ */
export type TriggerQueueFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `triggerType` field. */
  triggerType?: Maybe<TriggerFilter>;
  /** Filter by the object’s `table` field. */
  table?: Maybe<StringFilter>;
  /** Filter by the object’s `recordId` field. */
  recordId?: Maybe<IntFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: Maybe<DatetimeFilter>;
  /** Filter by the object’s `status` field. */
  status?: Maybe<TriggerQueueStatusFilter>;
  /** Filter by the object’s `log` field. */
  log?: Maybe<JsonFilter>;
  /** Filter by the object’s `actionQueuesByTriggerEvent` relation. */
  actionQueuesByTriggerEvent?: Maybe<TriggerQueueToManyActionQueueFilter>;
  /** Some related `actionQueuesByTriggerEvent` exist. */
  actionQueuesByTriggerEventExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<TriggerQueueFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<TriggerQueueFilter>>;
  /** Negates the expression. */
  not?: Maybe<TriggerQueueFilter>;
};

/** An input for mutations affecting `TriggerQueue` */
export type TriggerQueueInput = {
  id?: Maybe<Scalars['Int']>;
  triggerType?: Maybe<Trigger>;
  table?: Maybe<Scalars['String']>;
  recordId?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Datetime']>;
  status?: Maybe<TriggerQueueStatus>;
  log?: Maybe<Scalars['JSON']>;
  actionQueuesUsingId?: Maybe<ActionQueueTriggerEventFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TriggerQueueNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TriggerQueueNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The fields on `triggerQueue` to look up the row to update. */
export type TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate = {
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  id: Scalars['Int'];
};

/** Represents an update to a `TriggerQueue`. Fields that are set will be updated. */
export type TriggerQueuePatch = {
  id?: Maybe<Scalars['Int']>;
  triggerType?: Maybe<Trigger>;
  table?: Maybe<Scalars['String']>;
  recordId?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Datetime']>;
  status?: Maybe<TriggerQueueStatus>;
  log?: Maybe<Scalars['JSON']>;
  actionQueuesUsingId?: Maybe<ActionQueueTriggerEventFkeyInverseInput>;
};

/** A connection to a list of `TriggerQueue` values. */
export type TriggerQueuesConnection = {
  __typename?: 'TriggerQueuesConnection';
  /** A list of `TriggerQueue` objects. */
  nodes: Array<Maybe<TriggerQueue>>;
  /** A list of edges which contains the `TriggerQueue` and cursor to aid in pagination. */
  edges: Array<TriggerQueuesEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TriggerQueue` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `TriggerQueue` edge in the connection. */
export type TriggerQueuesEdge = {
  __typename?: 'TriggerQueuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `TriggerQueue` at the end of the edge. */
  node?: Maybe<TriggerQueue>;
};

/** Methods to use when ordering `TriggerQueue`. */
export enum TriggerQueuesOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  TriggerTypeAsc = 'TRIGGER_TYPE_ASC',
  TriggerTypeDesc = 'TRIGGER_TYPE_DESC',
  TableAsc = 'TABLE_ASC',
  TableDesc = 'TABLE_DESC',
  RecordIdAsc = 'RECORD_ID_ASC',
  RecordIdDesc = 'RECORD_ID_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  LogAsc = 'LOG_ASC',
  LogDesc = 'LOG_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export enum TriggerQueueStatus {
  Triggered = 'TRIGGERED',
  ActionsDispatched = 'ACTIONS_DISPATCHED',
  Error = 'ERROR'
}

/** A filter to be used against TriggerQueueStatus fields. All fields are combined with a logical ‘and.’ */
export type TriggerQueueStatusFilter = {
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: Maybe<Scalars['Boolean']>;
  /** Equal to the specified value. */
  equalTo?: Maybe<TriggerQueueStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: Maybe<TriggerQueueStatus>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: Maybe<TriggerQueueStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: Maybe<TriggerQueueStatus>;
  /** Included in the specified list. */
  in?: Maybe<Array<TriggerQueueStatus>>;
  /** Not included in the specified list. */
  notIn?: Maybe<Array<TriggerQueueStatus>>;
  /** Less than the specified value. */
  lessThan?: Maybe<TriggerQueueStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: Maybe<TriggerQueueStatus>;
  /** Greater than the specified value. */
  greaterThan?: Maybe<TriggerQueueStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: Maybe<TriggerQueueStatus>;
};

/** A filter to be used against many `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type TriggerQueueToManyActionQueueFilter = {
  /** Every related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ActionQueueFilter>;
  /** Some related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ActionQueueFilter>;
  /** No related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ActionQueueFilter>;
};

/** The fields on `triggerQueue` to look up the row to connect. */
export type TriggerQueueTriggerQueuePkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `triggerQueue` to look up the row to delete. */
export type TriggerQueueTriggerQueuePkeyDelete = {
  id: Scalars['Int'];
};

/** All input for the `updateActionPluginByNodeId` mutation. */
export type UpdateActionPluginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ActionPlugin` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ActionPlugin` being updated. */
  patch: ActionPluginPatch;
};

/** All input for the `updateActionPlugin` mutation. */
export type UpdateActionPluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ActionPlugin` being updated. */
  patch: ActionPluginPatch;
  code: Scalars['String'];
};

/** The output of our update `ActionPlugin` mutation. */
export type UpdateActionPluginPayload = {
  __typename?: 'UpdateActionPluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ActionPlugin` that was updated by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
};


/** The output of our update `ActionPlugin` mutation. */
export type UpdateActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: Maybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the `updateActionQueueByNodeId` mutation. */
export type UpdateActionQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ActionQueue` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ActionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** All input for the `updateActionQueue` mutation. */
export type UpdateActionQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ActionQueue` being updated. */
  patch: ActionQueuePatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `actionQueue` being updated. */
export type UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  triggerEvent?: Maybe<Scalars['Int']>;
  sequence?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  applicationData?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  parametersEvaluated?: Maybe<Scalars['JSON']>;
  status?: Maybe<ActionQueueStatus>;
  output?: Maybe<Scalars['JSON']>;
  timeQueued?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeScheduled?: Maybe<Scalars['Datetime']>;
  errorLog?: Maybe<Scalars['String']>;
  triggerQueueToTriggerEvent?: Maybe<ActionQueueTriggerEventFkeyInput>;
  templateToTemplateId?: Maybe<ActionQueueTemplateIdFkeyInput>;
};

/** An object where the defined keys will be set on the `actionQueue` being updated. */
export type UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  sequence?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  applicationData?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  parametersEvaluated?: Maybe<Scalars['JSON']>;
  status?: Maybe<ActionQueueStatus>;
  output?: Maybe<Scalars['JSON']>;
  timeQueued?: Maybe<Scalars['Datetime']>;
  timeCompleted?: Maybe<Scalars['Datetime']>;
  timeScheduled?: Maybe<Scalars['Datetime']>;
  errorLog?: Maybe<Scalars['String']>;
  triggerQueueToTriggerEvent?: Maybe<ActionQueueTriggerEventFkeyInput>;
  templateToTemplateId?: Maybe<ActionQueueTemplateIdFkeyInput>;
};

/** The output of our update `ActionQueue` mutation. */
export type UpdateActionQueuePayload = {
  __typename?: 'UpdateActionQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ActionQueue` that was updated by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
};


/** The output of our update `ActionQueue` mutation. */
export type UpdateActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: Maybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the `updateApplicationByNodeId` mutation. */
export type UpdateApplicationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Application` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
};

/** All input for the `updateApplicationBySerial` mutation. */
export type UpdateApplicationBySerialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
  serial: Scalars['String'];
};

/** All input for the `updateApplication` mutation. */
export type UpdateApplicationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnFileForFileApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  orgId?: Maybe<Scalars['Int']>;
  serial?: Maybe<Scalars['String']>;
  name?: Maybe<Scalars['String']>;
  outcome?: Maybe<ApplicationOutcome>;
  isActive?: Maybe<Scalars['Boolean']>;
  trigger?: Maybe<Trigger>;
  templateToTemplateId?: Maybe<ApplicationTemplateIdFkeyInput>;
  userToUserId?: Maybe<ApplicationUserIdFkeyInput>;
  organisationToOrgId?: Maybe<ApplicationOrgIdFkeyInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewApplicationIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationApplicationIdFkeyInverseInput>;
};

/** The output of our update `Application` mutation. */
export type UpdateApplicationPayload = {
  __typename?: 'UpdateApplicationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Application` that was updated by this mutation. */
  application?: Maybe<Application>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `User` that is related to this `Application`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
};


/** The output of our update `Application` mutation. */
export type UpdateApplicationPayloadApplicationEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationsOrderBy>>;
};

/** All input for the `updateApplicationResponseByNodeId` mutation. */
export type UpdateApplicationResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ApplicationResponse` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ApplicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** All input for the `updateApplicationResponse` mutation. */
export type UpdateApplicationResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ApplicationResponse` being updated. */
  patch: ApplicationResponsePatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  value?: Maybe<Scalars['JSON']>;
  isValid?: Maybe<Scalars['Boolean']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  templateElementToTemplateElementId?: Maybe<ApplicationResponseTemplateElementIdFkeyInput>;
  applicationToApplicationId?: Maybe<ApplicationResponseApplicationIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileApplicationResponseIdFkeyInverseInput>;
};

/** The output of our update `ApplicationResponse` mutation. */
export type UpdateApplicationResponsePayload = {
  __typename?: 'UpdateApplicationResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationResponse` that was updated by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
};


/** The output of our update `ApplicationResponse` mutation. */
export type UpdateApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the `updateApplicationSectionByNodeId` mutation. */
export type UpdateApplicationSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ApplicationSection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ApplicationSection` being updated. */
  patch: ApplicationSectionPatch;
};

/** All input for the `updateApplicationSection` mutation. */
export type UpdateApplicationSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ApplicationSection` being updated. */
  patch: ApplicationSectionPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `applicationSection` being updated. */
export type UpdateApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateSectionId?: Maybe<Scalars['Int']>;
  applicationToApplicationId?: Maybe<ApplicationSectionApplicationIdFkeyInput>;
  templateSectionToTemplateSectionId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInput>;
};

/** An object where the defined keys will be set on the `applicationSection` being updated. */
export type UpdateApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationToApplicationId?: Maybe<ApplicationSectionApplicationIdFkeyInput>;
  templateSectionToTemplateSectionId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInput>;
};

/** The output of our update `ApplicationSection` mutation. */
export type UpdateApplicationSectionPayload = {
  __typename?: 'UpdateApplicationSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationSection` that was updated by this mutation. */
  applicationSection?: Maybe<ApplicationSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Application` that is related to this `ApplicationSection`. */
  application?: Maybe<Application>;
  /** Reads a single `TemplateSection` that is related to this `ApplicationSection`. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `ApplicationSection`. May be used by Relay 1. */
  applicationSectionEdge?: Maybe<ApplicationSectionsEdge>;
};


/** The output of our update `ApplicationSection` mutation. */
export type UpdateApplicationSectionPayloadApplicationSectionEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationSectionsOrderBy>>;
};

/** All input for the `updateApplicationStageHistoryByNodeId` mutation. */
export type UpdateApplicationStageHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ApplicationStageHistory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ApplicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** All input for the `updateApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ApplicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationToApplicationId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  templateStageToStageId?: Maybe<ApplicationStageHistoryStageIdFkeyInput>;
  applicationStatusHistoriesUsingId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationToApplicationId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  templateStageToStageId?: Maybe<ApplicationStageHistoryStageIdFkeyInput>;
  applicationStatusHistoriesUsingId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationToApplicationId?: Maybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  templateStageToStageId?: Maybe<ApplicationStageHistoryStageIdFkeyInput>;
  applicationStatusHistoriesUsingId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
};

/** The output of our update `ApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryPayload = {
  __typename?: 'UpdateApplicationStageHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationStageHistory` that was updated by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
};


/** The output of our update `ApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the `updateApplicationStatusHistoryByNodeId` mutation. */
export type UpdateApplicationStatusHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ApplicationStatusHistory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ApplicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
};

/** All input for the `updateApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ApplicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
export type UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  status?: Maybe<ApplicationStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationStageHistoryToApplicationStageHistoryId?: Maybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
};

/** The output of our update `ApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryPayload = {
  __typename?: 'UpdateApplicationStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ApplicationStatusHistory` that was updated by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
};


/** The output of our update `ApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the `updateElementTypePluginByNodeId` mutation. */
export type UpdateElementTypePluginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ElementTypePlugin` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ElementTypePlugin` being updated. */
  patch: ElementTypePluginPatch;
};

/** All input for the `updateElementTypePlugin` mutation. */
export type UpdateElementTypePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ElementTypePlugin` being updated. */
  patch: ElementTypePluginPatch;
  code: Scalars['String'];
};

/** The output of our update `ElementTypePlugin` mutation. */
export type UpdateElementTypePluginPayload = {
  __typename?: 'UpdateElementTypePluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ElementTypePlugin` that was updated by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
};


/** The output of our update `ElementTypePlugin` mutation. */
export type UpdateElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: Maybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the `updateFileByNodeId` mutation. */
export type UpdateFileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `File` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
};

/** All input for the `updateFile` mutation. */
export type UpdateFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileApplicationResponseIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnNotificationForNotificationDocumentIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  originalFilename?: Maybe<Scalars['String']>;
  path?: Maybe<Scalars['String']>;
  mimetype?: Maybe<Scalars['String']>;
  applicationId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<FileUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<FileApplicationIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<FileApplicationResponseIdFkeyInput>;
  notificationsUsingId?: Maybe<NotificationDocumentIdFkeyInverseInput>;
};

/** The output of our update `File` mutation. */
export type UpdateFilePayload = {
  __typename?: 'UpdateFilePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `File` that was updated by this mutation. */
  file?: Maybe<File>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `File`. */
  user?: Maybe<User>;
  /** Reads a single `Application` that is related to this `File`. */
  application?: Maybe<Application>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
};


/** The output of our update `File` mutation. */
export type UpdateFilePayloadFileEdgeArgs = {
  orderBy?: Maybe<Array<FilesOrderBy>>;
};

/** All input for the `updateNotificationByNodeId` mutation. */
export type UpdateNotificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Notification` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
};

/** All input for the `updateNotification` mutation. */
export type UpdateNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationDocumentIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  subject?: Maybe<Scalars['String']>;
  message?: Maybe<Scalars['String']>;
  documentId?: Maybe<Scalars['Int']>;
  isRead?: Maybe<Scalars['Boolean']>;
  userToUserId?: Maybe<NotificationUserIdFkeyInput>;
  applicationToApplicationId?: Maybe<NotificationApplicationIdFkeyInput>;
  reviewToReviewId?: Maybe<NotificationReviewIdFkeyInput>;
  fileToDocumentId?: Maybe<NotificationDocumentIdFkeyInput>;
};

/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayload = {
  __typename?: 'UpdateNotificationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Notification` that was updated by this mutation. */
  notification?: Maybe<Notification>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `Notification`. */
  user?: Maybe<User>;
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  /** Reads a single `File` that is related to this `Notification`. */
  document?: Maybe<File>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
};


/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
};

/** All input for the `updateOrganisationByName` mutation. */
export type UpdateOrganisationByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
  name: Scalars['String'];
};

/** All input for the `updateOrganisationByNodeId` mutation. */
export type UpdateOrganisationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Organisation` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
};

/** All input for the `updateOrganisation` mutation. */
export type UpdateOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** The output of our update `Organisation` mutation. */
export type UpdateOrganisationPayload = {
  __typename?: 'UpdateOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Organisation` that was updated by this mutation. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
};


/** The output of our update `Organisation` mutation. */
export type UpdateOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: Maybe<Array<OrganisationsOrderBy>>;
};

/** All input for the `updatePermissionJoinByNodeId` mutation. */
export type UpdatePermissionJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PermissionJoin` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PermissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** All input for the `updatePermissionJoin` mutation. */
export type UpdatePermissionJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PermissionJoin` being updated. */
  patch: PermissionJoinPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<PermissionJoinUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: Maybe<PermissionJoinPermissionNameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<PermissionJoinUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: Maybe<PermissionJoinPermissionNameIdFkeyInput>;
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  userToUserId?: Maybe<PermissionJoinUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: Maybe<PermissionJoinPermissionNameIdFkeyInput>;
};

/** The output of our update `PermissionJoin` mutation. */
export type UpdatePermissionJoinPayload = {
  __typename?: 'UpdatePermissionJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionJoin` that was updated by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `PermissionJoin`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
};


/** The output of our update `PermissionJoin` mutation. */
export type UpdatePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: Maybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the `updatePermissionNameByName` mutation. */
export type UpdatePermissionNameByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
  name: Scalars['String'];
};

/** All input for the `updatePermissionNameByNodeId` mutation. */
export type UpdatePermissionNameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PermissionName` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
};

/** All input for the `updatePermissionName` mutation. */
export type UpdatePermissionNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  permissionPolicyId?: Maybe<Scalars['Int']>;
  permissionPolicyToPermissionPolicyId?: Maybe<PermissionNamePermissionPolicyIdFkeyInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  permissionPolicyToPermissionPolicyId?: Maybe<PermissionNamePermissionPolicyIdFkeyInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  permissionPolicyId?: Maybe<Scalars['Int']>;
  permissionPolicyToPermissionPolicyId?: Maybe<PermissionNamePermissionPolicyIdFkeyInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The output of our update `PermissionName` mutation. */
export type UpdatePermissionNamePayload = {
  __typename?: 'UpdatePermissionNamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionName` that was updated by this mutation. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
};


/** The output of our update `PermissionName` mutation. */
export type UpdatePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: Maybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the `updatePermissionPolicyByNodeId` mutation. */
export type UpdatePermissionPolicyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `PermissionPolicy` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `PermissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** All input for the `updatePermissionPolicy` mutation. */
export type UpdatePermissionPolicyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `PermissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `permissionPolicy` being updated. */
export type UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  rules?: Maybe<Scalars['JSON']>;
  type?: Maybe<PermissionPolicyType>;
  defaultRestrictions?: Maybe<Scalars['JSON']>;
  permissionNamesUsingId?: Maybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
};

/** The output of our update `PermissionPolicy` mutation. */
export type UpdatePermissionPolicyPayload = {
  __typename?: 'UpdatePermissionPolicyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `PermissionPolicy` that was updated by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
};


/** The output of our update `PermissionPolicy` mutation. */
export type UpdatePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: Maybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the `updateReviewAssignmentByNodeId` mutation. */
export type UpdateReviewAssignmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ReviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** All input for the `updateReviewAssignment` mutation. */
export type UpdateReviewAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ReviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewAssignmentStatus>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewAssignmentStatus>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewAssignmentStatus>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewAssignmentStatus>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewAssignmentStatus>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewAssignmentStatus>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  assignerId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  stageId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewAssignmentStatus>;
  applicationId?: Maybe<Scalars['Int']>;
  templateSectionRestrictions?: Maybe<Array<Maybe<Scalars['String']>>>;
  trigger?: Maybe<Trigger>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  userToAssignerId?: Maybe<ReviewAssignmentAssignerIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewAssignmentReviewerIdFkeyInput>;
  organisationToOrganisationId?: Maybe<ReviewAssignmentOrganisationIdFkeyInput>;
  templateStageToStageId?: Maybe<ReviewAssignmentStageIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewAssignmentApplicationIdFkeyInput>;
  reviewsUsingId?: Maybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput>;
};

/** The output of our update `ReviewAssignment` mutation. */
export type UpdateReviewAssignmentPayload = {
  __typename?: 'UpdateReviewAssignmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewAssignment` that was updated by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<User>;
  /** Reads a single `User` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
};


/** The output of our update `ReviewAssignment` mutation. */
export type UpdateReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the `updateReviewByNodeId` mutation. */
export type UpdateReviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Review` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Review` being updated. */
  patch: ReviewPatch;
};

/** All input for the `updateReviewDecisionByNodeId` mutation. */
export type UpdateReviewDecisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewDecision` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ReviewDecision` being updated. */
  patch: ReviewDecisionPatch;
};

/** All input for the `updateReviewDecision` mutation. */
export type UpdateReviewDecisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ReviewDecision` being updated. */
  patch: ReviewDecisionPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `reviewDecision` being updated. */
export type UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  decision?: Maybe<Decision>;
  comment?: Maybe<Scalars['String']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  reviewToReviewId?: Maybe<ReviewDecisionReviewIdFkeyInput>;
};

/** The output of our update `ReviewDecision` mutation. */
export type UpdateReviewDecisionPayload = {
  __typename?: 'UpdateReviewDecisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewDecision` that was updated by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our update `ReviewDecision` mutation. */
export type UpdateReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: Maybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the `updateReview` mutation. */
export type UpdateReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Review` being updated. */
  patch: ReviewPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForReviewApplicationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForReviewReviewerIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  trigger?: Maybe<Trigger>;
  applicationId?: Maybe<Scalars['Int']>;
  reviewerId?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  isLastLevel?: Maybe<Scalars['Boolean']>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewReviewAssignmentIdFkeyInput>;
  applicationToApplicationId?: Maybe<ReviewApplicationIdFkeyInput>;
  userToReviewerId?: Maybe<ReviewReviewerIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewDecisionsUsingId?: Maybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: Maybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationReviewIdFkeyInverseInput>;
};

/** The output of our update `Review` mutation. */
export type UpdateReviewPayload = {
  __typename?: 'UpdateReviewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Review` that was updated by this mutation. */
  review?: Maybe<Review>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /** Reads a single `User` that is related to this `Review`. */
  reviewer?: Maybe<User>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
};


/** The output of our update `Review` mutation. */
export type UpdateReviewPayloadReviewEdgeArgs = {
  orderBy?: Maybe<Array<ReviewsOrderBy>>;
};

/** All input for the `updateReviewQuestionAssignmentByNodeId` mutation. */
export type UpdateReviewQuestionAssignmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewQuestionAssignment` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ReviewQuestionAssignment` being updated. */
  patch: ReviewQuestionAssignmentPatch;
};

/** All input for the `updateReviewQuestionAssignment` mutation. */
export type UpdateReviewQuestionAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ReviewQuestionAssignment` being updated. */
  patch: ReviewQuestionAssignmentPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
export type UpdateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  templateElementToTemplateElementId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
export type UpdateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  templateElementToTemplateElementId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `reviewQuestionAssignment` being updated. */
export type UpdateReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateElementId?: Maybe<Scalars['Int']>;
  reviewAssignmentId?: Maybe<Scalars['Int']>;
  templateElementToTemplateElementId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: Maybe<ReviewQuestionAssignmentReviewAssignmentIdFkeyInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput>;
};

/** The output of our update `ReviewQuestionAssignment` mutation. */
export type UpdateReviewQuestionAssignmentPayload = {
  __typename?: 'UpdateReviewQuestionAssignmentPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewQuestionAssignment` that was updated by this mutation. */
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignment>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ReviewQuestionAssignment`. */
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewQuestionAssignment`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewQuestionAssignment`. May be used by Relay 1. */
  reviewQuestionAssignmentEdge?: Maybe<ReviewQuestionAssignmentsEdge>;
};


/** The output of our update `ReviewQuestionAssignment` mutation. */
export type UpdateReviewQuestionAssignmentPayloadReviewQuestionAssignmentEdgeArgs = {
  orderBy?: Maybe<Array<ReviewQuestionAssignmentsOrderBy>>;
};

/** All input for the `updateReviewResponseByNodeId` mutation. */
export type UpdateReviewResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewResponse` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ReviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** All input for the `updateReviewResponse` mutation. */
export type UpdateReviewResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ReviewResponse` being updated. */
  patch: ReviewResponsePatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  templateElementId?: Maybe<Scalars['Int']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  comment?: Maybe<Scalars['String']>;
  decision?: Maybe<ReviewResponseDecision>;
  reviewQuestionAssignmentId?: Maybe<Scalars['Int']>;
  applicationResponseId?: Maybe<Scalars['Int']>;
  reviewResponseLinkId?: Maybe<Scalars['Int']>;
  originalReviewResponseId?: Maybe<Scalars['Int']>;
  reviewId?: Maybe<Scalars['Int']>;
  timeUpdated?: Maybe<Scalars['Datetime']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  status?: Maybe<ReviewResponseStatus>;
  reviewQuestionAssignmentToReviewQuestionAssignmentId?: Maybe<ReviewResponseReviewQuestionAssignmentIdFkeyInput>;
  applicationResponseToApplicationResponseId?: Maybe<ReviewResponseApplicationResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: Maybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewResponseToOriginalReviewResponseId?: Maybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewToReviewId?: Maybe<ReviewResponseReviewIdFkeyInput>;
  templateElementToTemplateElementId?: Maybe<ReviewResponseTemplateElementIdFkeyInput>;
};

/** The output of our update `ReviewResponse` mutation. */
export type UpdateReviewResponsePayload = {
  __typename?: 'UpdateReviewResponsePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewResponse` that was updated by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewQuestionAssignment` that is related to this `ReviewResponse`. */
  reviewQuestionAssignment?: Maybe<ReviewQuestionAssignment>;
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
};


/** The output of our update `ReviewResponse` mutation. */
export type UpdateReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: Maybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the `updateReviewStatusHistoryByNodeId` mutation. */
export type UpdateReviewStatusHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `ReviewStatusHistory` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `ReviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
};

/** All input for the `updateReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `ReviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
export type UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  status?: Maybe<ReviewStatus>;
  timeCreated?: Maybe<Scalars['Datetime']>;
  isCurrent?: Maybe<Scalars['Boolean']>;
  reviewToReviewId?: Maybe<ReviewStatusHistoryReviewIdFkeyInput>;
};

/** The output of our update `ReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryPayload = {
  __typename?: 'UpdateReviewStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `ReviewStatusHistory` that was updated by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our update `ReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: Maybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the `updateTemplateActionByNodeId` mutation. */
export type UpdateTemplateActionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplateAction` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TemplateAction` being updated. */
  patch: TemplateActionPatch;
};

/** All input for the `updateTemplateAction` mutation. */
export type UpdateTemplateActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TemplateAction` being updated. */
  patch: TemplateActionPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `templateAction` being updated. */
export type UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  actionCode?: Maybe<Scalars['String']>;
  trigger?: Maybe<Trigger>;
  sequence?: Maybe<Scalars['Int']>;
  condition?: Maybe<Scalars['JSON']>;
  parameterQueries?: Maybe<Scalars['JSON']>;
  templateToTemplateId?: Maybe<TemplateActionTemplateIdFkeyInput>;
};

/** The output of our update `TemplateAction` mutation. */
export type UpdateTemplateActionPayload = {
  __typename?: 'UpdateTemplateActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateAction` that was updated by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our update `TemplateAction` mutation. */
export type UpdateTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: Maybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the `updateTemplateByNodeId` mutation. */
export type UpdateTemplateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `Template` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  patch: TemplatePatch;
};

/** All input for the `updateTemplateElementByNodeId` mutation. */
export type UpdateTemplateElementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplateElement` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TemplateElement` being updated. */
  patch: TemplateElementPatch;
};

/** All input for the `updateTemplateElement` mutation. */
export type UpdateTemplateElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TemplateElement` being updated. */
  patch: TemplateElementPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  sectionId?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  sectionId?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  sectionId?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  category?: Maybe<TemplateElementCategory>;
  elementTypePluginCode?: Maybe<Scalars['String']>;
  visibilityCondition?: Maybe<Scalars['JSON']>;
  isRequired?: Maybe<Scalars['JSON']>;
  isEditable?: Maybe<Scalars['JSON']>;
  validation?: Maybe<Scalars['JSON']>;
  validationMessage?: Maybe<Scalars['String']>;
  parameters?: Maybe<Scalars['JSON']>;
  templateSectionToSectionId?: Maybe<TemplateElementSectionIdFkeyInput>;
  applicationResponsesUsingId?: Maybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  reviewQuestionAssignmentsUsingId?: Maybe<ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput>;
  reviewResponsesUsingId?: Maybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
};

/** The output of our update `TemplateElement` mutation. */
export type UpdateTemplateElementPayload = {
  __typename?: 'UpdateTemplateElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateElement` that was updated by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our update `TemplateElement` mutation. */
export type UpdateTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: Maybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the `updateTemplate` mutation. */
export type UpdateTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `Template` being updated. */
  patch: TemplatePatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  isLinear?: Maybe<Scalars['Boolean']>;
  startMessage?: Maybe<Scalars['JSON']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']>;
  versionTimestamp?: Maybe<Scalars['Datetime']>;
  templateStagesUsingId?: Maybe<TemplateStageTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: Maybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: Maybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationTemplateIdFkeyInverseInput>;
  actionQueuesUsingId?: Maybe<ActionQueueTemplateIdFkeyInverseInput>;
  templateActionsUsingId?: Maybe<TemplateActionTemplateIdFkeyInverseInput>;
};

/** The output of our update `Template` mutation. */
export type UpdateTemplatePayload = {
  __typename?: 'UpdateTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `Template` that was updated by this mutation. */
  template?: Maybe<Template>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our update `Template` mutation. */
export type UpdateTemplatePayloadTemplateEdgeArgs = {
  orderBy?: Maybe<Array<TemplatesOrderBy>>;
};

/** All input for the `updateTemplatePermissionByNodeId` mutation. */
export type UpdateTemplatePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplatePermission` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TemplatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** All input for the `updateTemplatePermission` mutation. */
export type UpdateTemplatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TemplatePermission` being updated. */
  patch: TemplatePermissionPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `templatePermission` being updated. */
export type UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  restrictions?: Maybe<Scalars['JSON']>;
  permissionNameToPermissionNameId?: Maybe<TemplatePermissionPermissionNameIdFkeyInput>;
  templateToTemplateId?: Maybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** An object where the defined keys will be set on the `templatePermission` being updated. */
export type UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  permissionNameId?: Maybe<Scalars['Int']>;
  stageNumber?: Maybe<Scalars['Int']>;
  level?: Maybe<Scalars['Int']>;
  restrictions?: Maybe<Scalars['JSON']>;
  permissionNameToPermissionNameId?: Maybe<TemplatePermissionPermissionNameIdFkeyInput>;
  templateToTemplateId?: Maybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** The output of our update `TemplatePermission` mutation. */
export type UpdateTemplatePermissionPayload = {
  __typename?: 'UpdateTemplatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplatePermission` that was updated by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our update `TemplatePermission` mutation. */
export type UpdateTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: Maybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the `updateTemplateSectionByNodeId` mutation. */
export type UpdateTemplateSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplateSection` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TemplateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** All input for the `updateTemplateSection` mutation. */
export type UpdateTemplateSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TemplateSection` being updated. */
  patch: TemplateSectionPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `templateSection` being updated. */
export type UpdateTemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateSectionTemplateIdFkeyInput>;
  templateElementsUsingId?: Maybe<TemplateElementSectionIdFkeyInverseInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `templateSection` being updated. */
export type UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  templateId?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateSectionTemplateIdFkeyInput>;
  templateElementsUsingId?: Maybe<TemplateElementSectionIdFkeyInverseInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `templateSection` being updated. */
export type UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  code?: Maybe<Scalars['String']>;
  index?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateSectionTemplateIdFkeyInput>;
  templateElementsUsingId?: Maybe<TemplateElementSectionIdFkeyInverseInput>;
  applicationSectionsUsingId?: Maybe<ApplicationSectionTemplateSectionIdFkeyInverseInput>;
};

/** The output of our update `TemplateSection` mutation. */
export type UpdateTemplateSectionPayload = {
  __typename?: 'UpdateTemplateSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateSection` that was updated by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our update `TemplateSection` mutation. */
export type UpdateTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: Maybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the `updateTemplateStageByNodeId` mutation. */
export type UpdateTemplateStageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TemplateStage` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TemplateStage` being updated. */
  patch: TemplateStagePatch;
};

/** All input for the `updateTemplateStage` mutation. */
export type UpdateTemplateStageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TemplateStage` being updated. */
  patch: TemplateStagePatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateId?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateStageTemplateIdFkeyInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentStageIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateId?: Maybe<Scalars['Int']>;
  templateToTemplateId?: Maybe<TemplateStageTemplateIdFkeyInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentStageIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  number?: Maybe<Scalars['Int']>;
  title?: Maybe<Scalars['String']>;
  description?: Maybe<Scalars['String']>;
  templateToTemplateId?: Maybe<TemplateStageTemplateIdFkeyInput>;
  applicationStageHistoriesUsingId?: Maybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentStageIdFkeyInverseInput>;
};

/** The output of our update `TemplateStage` mutation. */
export type UpdateTemplateStagePayload = {
  __typename?: 'UpdateTemplateStagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TemplateStage` that was updated by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our update `TemplateStage` mutation. */
export type UpdateTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: Maybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the `updateTriggerQueueByNodeId` mutation. */
export type UpdateTriggerQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `TriggerQueue` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `TriggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** All input for the `updateTriggerQueue` mutation. */
export type UpdateTriggerQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `TriggerQueue` being updated. */
  patch: TriggerQueuePatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `triggerQueue` being updated. */
export type UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  triggerType?: Maybe<Trigger>;
  table?: Maybe<Scalars['String']>;
  recordId?: Maybe<Scalars['Int']>;
  timestamp?: Maybe<Scalars['Datetime']>;
  status?: Maybe<TriggerQueueStatus>;
  log?: Maybe<Scalars['JSON']>;
  actionQueuesUsingId?: Maybe<ActionQueueTriggerEventFkeyInverseInput>;
};

/** The output of our update `TriggerQueue` mutation. */
export type UpdateTriggerQueuePayload = {
  __typename?: 'UpdateTriggerQueuePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `TriggerQueue` that was updated by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our update `TriggerQueue` mutation. */
export type UpdateTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: Maybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the `updateUserByNodeId` mutation. */
export type UpdateUserByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `User` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
};

/** All input for the `updateUserByUsername` mutation. */
export type UpdateUserByUsernameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  username: Scalars['String'];
};

/** All input for the `updateUser` mutation. */
export type UpdateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `User` being updated. */
  patch: UserPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnApplicationForApplicationUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnFileForFileUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnNotificationForNotificationUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnReviewForReviewReviewerIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `user` being updated. */
export type UpdateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** All input for the `updateUserOrganisationByNodeId` mutation. */
export type UpdateUserOrganisationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The globally unique `ID` which will identify a single `UserOrganisation` to be updated. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `UserOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** All input for the `updateUserOrganisation` mutation. */
export type UpdateUserOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** An object where the defined keys will be set on the `UserOrganisation` being updated. */
  patch: UserOrganisationPatch;
  id: Scalars['Int'];
};

/** An object where the defined keys will be set on the `userOrganisation` being updated. */
export type UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  userRole?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<UserOrganisationUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<UserOrganisationOrganisationIdFkeyInput>;
};

/** An object where the defined keys will be set on the `userOrganisation` being updated. */
export type UpdateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch = {
  id?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  userRole?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<UserOrganisationUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<UserOrganisationOrganisationIdFkeyInput>;
};

/** The output of our update `UserOrganisation` mutation. */
export type UpdateUserOrganisationPayload = {
  __typename?: 'UpdateUserOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `UserOrganisation` that was updated by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our update `UserOrganisation` mutation. */
export type UpdateUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: Maybe<Array<UserOrganisationsOrderBy>>;
};

/** The output of our update `User` mutation. */
export type UpdateUserPayload = {
  __typename?: 'UpdateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']>;
  /** The `User` that was updated by this mutation. */
  user?: Maybe<User>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our update `User` mutation. */
export type UpdateUserPayloadUserEdgeArgs = {
  orderBy?: Maybe<Array<UsersOrderBy>>;
};

export type User = Node & {
  __typename?: 'User';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations: UserOrganisationsConnection;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins: PermissionJoinsConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applications: ApplicationsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignmentsByAssignerId: ReviewAssignmentsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewedReviewAssignments: ReviewAssignmentsConnection;
  /** Reads and enables pagination through a set of `Review`. */
  reviewedReviews: ReviewsConnection;
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  /** Reads and enables pagination through a set of `Notification`. */
  notifications: NotificationsConnection;
};


export type UserUserOrganisationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<UserOrganisationsOrderBy>>;
  condition?: Maybe<UserOrganisationCondition>;
  filter?: Maybe<UserOrganisationFilter>;
};


export type UserPermissionJoinsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<PermissionJoinsOrderBy>>;
  condition?: Maybe<PermissionJoinCondition>;
  filter?: Maybe<PermissionJoinFilter>;
};


export type UserApplicationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ApplicationsOrderBy>>;
  condition?: Maybe<ApplicationCondition>;
  filter?: Maybe<ApplicationFilter>;
};


export type UserReviewAssignmentsByAssignerIdArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
  condition?: Maybe<ReviewAssignmentCondition>;
  filter?: Maybe<ReviewAssignmentFilter>;
};


export type UserReviewedReviewAssignmentsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewAssignmentsOrderBy>>;
  condition?: Maybe<ReviewAssignmentCondition>;
  filter?: Maybe<ReviewAssignmentFilter>;
};


export type UserReviewedReviewsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<ReviewsOrderBy>>;
  condition?: Maybe<ReviewCondition>;
  filter?: Maybe<ReviewFilter>;
};


export type UserFilesArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<FilesOrderBy>>;
  condition?: Maybe<FileCondition>;
  filter?: Maybe<FileFilter>;
};


export type UserNotificationsArgs = {
  first?: Maybe<Scalars['Int']>;
  last?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  before?: Maybe<Scalars['Cursor']>;
  after?: Maybe<Scalars['Cursor']>;
  orderBy?: Maybe<Array<NotificationsOrderBy>>;
  condition?: Maybe<NotificationCondition>;
  filter?: Maybe<NotificationFilter>;
};

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `passwordHash` field. */
  passwordHash?: Maybe<Scalars['String']>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>;
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: Maybe<DateFilter>;
  /** Filter by the object’s `passwordHash` field. */
  passwordHash?: Maybe<StringFilter>;
  /** Filter by the object’s `userOrganisations` relation. */
  userOrganisations?: Maybe<UserToManyUserOrganisationFilter>;
  /** Some related `userOrganisations` exist. */
  userOrganisationsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `permissionJoins` relation. */
  permissionJoins?: Maybe<UserToManyPermissionJoinFilter>;
  /** Some related `permissionJoins` exist. */
  permissionJoinsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `applications` relation. */
  applications?: Maybe<UserToManyApplicationFilter>;
  /** Some related `applications` exist. */
  applicationsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewAssignmentsByAssignerId` relation. */
  reviewAssignmentsByAssignerId?: Maybe<UserToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignmentsByAssignerId` exist. */
  reviewAssignmentsByAssignerIdExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewedReviewAssignments` relation. */
  reviewedReviewAssignments?: Maybe<UserToManyReviewAssignmentFilter>;
  /** Some related `reviewedReviewAssignments` exist. */
  reviewedReviewAssignmentsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `reviewedReviews` relation. */
  reviewedReviews?: Maybe<UserToManyReviewFilter>;
  /** Some related `reviewedReviews` exist. */
  reviewedReviewsExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `files` relation. */
  files?: Maybe<UserToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `notifications` relation. */
  notifications?: Maybe<UserToManyNotificationFilter>;
  /** Some related `notifications` exist. */
  notificationsExist?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserFilter>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `user` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnApplicationForApplicationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnApplicationForApplicationUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnApplicationForApplicationUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnApplicationForApplicationUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnApplicationForApplicationUserIdFkeyPatch;
  username: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnFileForFileUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnFileForFileUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnFileForFileUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnFileForFileUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnFileForFileUserIdFkeyPatch;
  username: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnNotificationForNotificationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnNotificationForNotificationUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnNotificationForNotificationUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnNotificationForNotificationUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnNotificationForNotificationUserIdFkeyPatch;
  username: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
  username: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
  username: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
  username: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnReviewForReviewReviewerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewForReviewReviewerIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewForReviewReviewerIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnReviewForReviewReviewerIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnReviewForReviewReviewerIdFkeyPatch;
  username: Scalars['String'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserPkeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to update. */
export type UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserUsernameKeyUpdate = {
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UpdateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  username: Scalars['String'];
};

export type UserOrganisation = Node & {
  __typename?: 'UserOrganisation';
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID'];
  id: Scalars['Int'];
  userId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  userRole?: Maybe<Scalars['String']>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
};

/**
 * A condition to be used against `UserOrganisation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserOrganisationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: Maybe<Scalars['String']>;
};

/** A filter to be used against `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type UserOrganisationFilter = {
  /** Filter by the object’s `id` field. */
  id?: Maybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: Maybe<IntFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: Maybe<StringFilter>;
  /** Filter by the object’s `user` relation. */
  user?: Maybe<UserFilter>;
  /** A related `user` exists. */
  userExists?: Maybe<Scalars['Boolean']>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: Maybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: Maybe<Scalars['Boolean']>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserOrganisationFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserOrganisationFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserOrganisationFilter>;
};

/** An input for mutations affecting `UserOrganisation` */
export type UserOrganisationInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  userRole?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<UserOrganisationUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<UserOrganisationOrganisationIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserOrganisationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserOrganisationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be deleted. */
  nodeId: Scalars['ID'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate = {
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  id: Scalars['Int'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `user` to be connected. */
  nodeId: Scalars['ID'];
  /** An object where the defined keys will be set on the `user` being updated. */
  patch: UserPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationPkeyUpdate = {
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  id: Scalars['Int'];
};

/** Input for the nested mutation of `organisation` in the `UserOrganisationInput` mutation. */
export type UserOrganisationOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: Maybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: Maybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: Maybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: Maybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: Maybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: Maybe<OrganisationNodeIdDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: Maybe<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: Maybe<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: Maybe<UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: Maybe<UserOrganisationOrganisationIdFkeyOrganisationCreateInput>;
};

/** Input for the nested mutation of `userOrganisation` in the `OrganisationInput` mutation. */
export type UserOrganisationOrganisationIdFkeyInverseInput = {
  /** Flag indicating whether all other `userOrganisation` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectById?: Maybe<Array<UserOrganisationUserOrganisationPkeyConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<UserOrganisationNodeIdConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteById?: Maybe<Array<UserOrganisationUserOrganisationPkeyDelete>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<UserOrganisationNodeIdDelete>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateById?: Maybe<Array<UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate>>;
  /** A `UserOrganisationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput>>;
};

/** The `organisation` to be created by this mutation. */
export type UserOrganisationOrganisationIdFkeyOrganisationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  name?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationOrganisationIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationOrgIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: Maybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
};

/** The `userOrganisation` to be created by this mutation. */
export type UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  userRole?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<UserOrganisationUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<UserOrganisationOrganisationIdFkeyInput>;
};

/** Represents an update to a `UserOrganisation`. Fields that are set will be updated. */
export type UserOrganisationPatch = {
  id?: Maybe<Scalars['Int']>;
  userId?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  userRole?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<UserOrganisationUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<UserOrganisationOrganisationIdFkeyInput>;
};

/** A connection to a list of `UserOrganisation` values. */
export type UserOrganisationsConnection = {
  __typename?: 'UserOrganisationsConnection';
  /** A list of `UserOrganisation` objects. */
  nodes: Array<Maybe<UserOrganisation>>;
  /** A list of edges which contains the `UserOrganisation` and cursor to aid in pagination. */
  edges: Array<UserOrganisationsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserOrganisation` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserOrganisation` edge in the connection. */
export type UserOrganisationsEdge = {
  __typename?: 'UserOrganisationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserOrganisation` at the end of the edge. */
  node?: Maybe<UserOrganisation>;
};

/** Methods to use when ordering `UserOrganisation`. */
export enum UserOrganisationsOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Input for the nested mutation of `user` in the `UserOrganisationInput` mutation. */
export type UserOrganisationUserIdFkeyInput = {
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectById?: Maybe<UserUserPkeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByUsername?: Maybe<UserUserUsernameKeyConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  connectByNodeId?: Maybe<UserNodeIdConnect>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteById?: Maybe<UserUserPkeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByUsername?: Maybe<UserUserUsernameKeyDelete>;
  /** The primary key(s) for `user` for the far side of the relationship. */
  deleteByNodeId?: Maybe<UserNodeIdDelete>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateById?: Maybe<UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserPkeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByUsername?: Maybe<UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserUsernameKeyUpdate>;
  /** The primary key(s) and patch data for `user` for the far side of the relationship. */
  updateByNodeId?: Maybe<UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate>;
  /** A `UserInput` object that will be created and connected to this object. */
  create?: Maybe<UserOrganisationUserIdFkeyUserCreateInput>;
};

/** Input for the nested mutation of `userOrganisation` in the `UserInput` mutation. */
export type UserOrganisationUserIdFkeyInverseInput = {
  /** Flag indicating whether all other `userOrganisation` records that match this relationship should be removed. */
  deleteOthers?: Maybe<Scalars['Boolean']>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectById?: Maybe<Array<UserOrganisationUserOrganisationPkeyConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByNodeId?: Maybe<Array<UserOrganisationNodeIdConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteById?: Maybe<Array<UserOrganisationUserOrganisationPkeyDelete>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByNodeId?: Maybe<Array<UserOrganisationNodeIdDelete>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateById?: Maybe<Array<UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationPkeyUpdate>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByNodeId?: Maybe<Array<UserOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate>>;
  /** A `UserOrganisationInput` object that will be created and connected to this object. */
  create?: Maybe<Array<UserOrganisationUserIdFkeyUserOrganisationCreateInput>>;
};

/** The `user` to be created by this mutation. */
export type UserOrganisationUserIdFkeyUserCreateInput = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** The `userOrganisation` to be created by this mutation. */
export type UserOrganisationUserIdFkeyUserOrganisationCreateInput = {
  id?: Maybe<Scalars['Int']>;
  organisationId?: Maybe<Scalars['Int']>;
  userRole?: Maybe<Scalars['String']>;
  userToUserId?: Maybe<UserOrganisationUserIdFkeyInput>;
  organisationToOrganisationId?: Maybe<UserOrganisationOrganisationIdFkeyInput>;
};

/** The fields on `userOrganisation` to look up the row to connect. */
export type UserOrganisationUserOrganisationPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `userOrganisation` to look up the row to delete. */
export type UserOrganisationUserOrganisationPkeyDelete = {
  id: Scalars['Int'];
};

export type UserOrgJoin = {
  __typename?: 'UserOrgJoin';
  userId?: Maybe<Scalars['Int']>;
  username?: Maybe<Scalars['String']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  orgId?: Maybe<Scalars['Int']>;
  orgName?: Maybe<Scalars['String']>;
  userRole?: Maybe<Scalars['String']>;
  licenceNumber?: Maybe<Scalars['String']>;
  address?: Maybe<Scalars['String']>;
};

/**
 * A condition to be used against `UserOrgJoin` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserOrgJoinCondition = {
  /** Checks for equality with the object’s `userId` field. */
  userId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `username` field. */
  username?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `email` field. */
  email?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: Maybe<Scalars['Date']>;
  /** Checks for equality with the object’s `passwordHash` field. */
  passwordHash?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: Maybe<Scalars['Int']>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `licenceNumber` field. */
  licenceNumber?: Maybe<Scalars['String']>;
  /** Checks for equality with the object’s `address` field. */
  address?: Maybe<Scalars['String']>;
};

/** A filter to be used against `UserOrgJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserOrgJoinFilter = {
  /** Filter by the object’s `userId` field. */
  userId?: Maybe<IntFilter>;
  /** Filter by the object’s `username` field. */
  username?: Maybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: Maybe<StringFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: Maybe<StringFilter>;
  /** Filter by the object’s `email` field. */
  email?: Maybe<StringFilter>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: Maybe<DateFilter>;
  /** Filter by the object’s `passwordHash` field. */
  passwordHash?: Maybe<StringFilter>;
  /** Filter by the object’s `orgId` field. */
  orgId?: Maybe<IntFilter>;
  /** Filter by the object’s `orgName` field. */
  orgName?: Maybe<StringFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: Maybe<StringFilter>;
  /** Filter by the object’s `licenceNumber` field. */
  licenceNumber?: Maybe<StringFilter>;
  /** Filter by the object’s `address` field. */
  address?: Maybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: Maybe<Array<UserOrgJoinFilter>>;
  /** Checks for any expressions in this list. */
  or?: Maybe<Array<UserOrgJoinFilter>>;
  /** Negates the expression. */
  not?: Maybe<UserOrgJoinFilter>;
};

/** A connection to a list of `UserOrgJoin` values. */
export type UserOrgJoinsConnection = {
  __typename?: 'UserOrgJoinsConnection';
  /** A list of `UserOrgJoin` objects. */
  nodes: Array<Maybe<UserOrgJoin>>;
  /** A list of edges which contains the `UserOrgJoin` and cursor to aid in pagination. */
  edges: Array<UserOrgJoinsEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserOrgJoin` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `UserOrgJoin` edge in the connection. */
export type UserOrgJoinsEdge = {
  __typename?: 'UserOrgJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `UserOrgJoin` at the end of the edge. */
  node?: Maybe<UserOrgJoin>;
};

/** Methods to use when ordering `UserOrgJoin`. */
export enum UserOrgJoinsOrderBy {
  Natural = 'NATURAL',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  PasswordHashAsc = 'PASSWORD_HASH_ASC',
  PasswordHashDesc = 'PASSWORD_HASH_DESC',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OrgNameAsc = 'ORG_NAME_ASC',
  OrgNameDesc = 'ORG_NAME_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC',
  LicenceNumberAsc = 'LICENCE_NUMBER_ASC',
  LicenceNumberDesc = 'LICENCE_NUMBER_DESC',
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC'
}

/** Represents an update to a `User`. Fields that are set will be updated. */
export type UserPatch = {
  id?: Maybe<Scalars['Int']>;
  firstName?: Maybe<Scalars['String']>;
  lastName?: Maybe<Scalars['String']>;
  username?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  dateOfBirth?: Maybe<Scalars['Date']>;
  passwordHash?: Maybe<Scalars['String']>;
  userOrganisationsUsingId?: Maybe<UserOrganisationUserIdFkeyInverseInput>;
  permissionJoinsUsingId?: Maybe<PermissionJoinUserIdFkeyInverseInput>;
  applicationsUsingId?: Maybe<ApplicationUserIdFkeyInverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: Maybe<ReviewAssignmentAssignerIdFkeyInverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: Maybe<ReviewAssignmentReviewerIdFkeyInverseInput>;
  reviewsUsingId?: Maybe<ReviewReviewerIdFkeyInverseInput>;
  filesUsingId?: Maybe<FileUserIdFkeyInverseInput>;
  notificationsUsingId?: Maybe<NotificationUserIdFkeyInverseInput>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  Natural = 'NATURAL',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  PasswordHashAsc = 'PASSWORD_HASH_ASC',
  PasswordHashDesc = 'PASSWORD_HASH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ApplicationFilter>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<FileFilter>;
};

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<NotificationFilter>;
};

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<PermissionJoinFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `Review` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyReviewFilter = {
  /** Every related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<ReviewFilter>;
  /** Some related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<ReviewFilter>;
  /** No related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<ReviewFilter>;
};

/** A filter to be used against many `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserOrganisationFilter = {
  /** Every related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: Maybe<UserOrganisationFilter>;
  /** Some related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: Maybe<UserOrganisationFilter>;
  /** No related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: Maybe<UserOrganisationFilter>;
};

/** The fields on `user` to look up the row to connect. */
export type UserUserPkeyConnect = {
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to delete. */
export type UserUserPkeyDelete = {
  id: Scalars['Int'];
};

/** The fields on `user` to look up the row to connect. */
export type UserUserUsernameKeyConnect = {
  username: Scalars['String'];
};

/** The fields on `user` to look up the row to delete. */
export type UserUserUsernameKeyDelete = {
  username: Scalars['String'];
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type LegacyStitchingResolver<TResult, TParent, TContext, TArgs> = {
  fragment: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};

export type NewStitchingResolver<TResult, TParent, TContext, TArgs> = {
  selectionSet: string;
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type StitchingResolver<TResult, TParent, TContext, TArgs> = LegacyStitchingResolver<TResult, TParent, TContext, TArgs> | NewStitchingResolver<TResult, TParent, TContext, TArgs>;
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> =
  | ResolverFn<TResult, TParent, TContext, TArgs>
  | StitchingResolver<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterator<TResult> | Promise<AsyncIterator<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  Query: ResolverTypeWrapper<{}>;
  Node: ResolversTypes['Query'] | ResolversTypes['ActionPlugin'] | ResolversTypes['ActionQueue'] | ResolversTypes['TriggerQueue'] | ResolversTypes['Template'] | ResolversTypes['TemplateStage'] | ResolversTypes['ApplicationStageHistory'] | ResolversTypes['Application'] | ResolversTypes['User'] | ResolversTypes['UserOrganisation'] | ResolversTypes['Organisation'] | ResolversTypes['PermissionJoin'] | ResolversTypes['PermissionName'] | ResolversTypes['PermissionPolicy'] | ResolversTypes['TemplatePermission'] | ResolversTypes['ReviewAssignment'] | ResolversTypes['Review'] | ResolversTypes['ReviewResponse'] | ResolversTypes['ReviewQuestionAssignment'] | ResolversTypes['TemplateElement'] | ResolversTypes['TemplateSection'] | ResolversTypes['ApplicationSection'] | ResolversTypes['ApplicationResponse'] | ResolversTypes['File'] | ResolversTypes['Notification'] | ResolversTypes['ReviewDecision'] | ResolversTypes['ReviewStatusHistory'] | ResolversTypes['ApplicationStatusHistory'] | ResolversTypes['TemplateAction'] | ResolversTypes['ElementTypePlugin'];
  ID: ResolverTypeWrapper<Scalars['ID']>;
  Int: ResolverTypeWrapper<Scalars['Int']>;
  Cursor: ResolverTypeWrapper<Scalars['Cursor']>;
  ActionPluginsOrderBy: ActionPluginsOrderBy;
  ActionPluginCondition: ActionPluginCondition;
  String: ResolverTypeWrapper<Scalars['String']>;
  ActionPluginFilter: ActionPluginFilter;
  StringFilter: StringFilter;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']>;
  StringListFilter: StringListFilter;
  ActionPluginsConnection: ResolverTypeWrapper<ActionPluginsConnection>;
  ActionPlugin: ResolverTypeWrapper<ActionPlugin>;
  ActionPluginsEdge: ResolverTypeWrapper<ActionPluginsEdge>;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  ActionQueuesOrderBy: ActionQueuesOrderBy;
  ActionQueueCondition: ActionQueueCondition;
  JSON: ResolverTypeWrapper<Scalars['JSON']>;
  ActionQueueStatus: ActionQueueStatus;
  Datetime: ResolverTypeWrapper<Scalars['Datetime']>;
  ActionQueueFilter: ActionQueueFilter;
  IntFilter: IntFilter;
  JSONFilter: JsonFilter;
  ActionQueueStatusFilter: ActionQueueStatusFilter;
  DatetimeFilter: DatetimeFilter;
  TriggerQueueFilter: TriggerQueueFilter;
  TriggerFilter: TriggerFilter;
  Trigger: Trigger;
  TriggerQueueStatusFilter: TriggerQueueStatusFilter;
  TriggerQueueStatus: TriggerQueueStatus;
  TriggerQueueToManyActionQueueFilter: TriggerQueueToManyActionQueueFilter;
  TemplateFilter: TemplateFilter;
  BooleanFilter: BooleanFilter;
  TemplateStatusFilter: TemplateStatusFilter;
  TemplateStatus: TemplateStatus;
  TemplateToManyTemplateStageFilter: TemplateToManyTemplateStageFilter;
  TemplateStageFilter: TemplateStageFilter;
  TemplateStageToManyApplicationStageHistoryFilter: TemplateStageToManyApplicationStageHistoryFilter;
  ApplicationStageHistoryFilter: ApplicationStageHistoryFilter;
  ApplicationStageHistoryToManyApplicationStatusHistoryFilter: ApplicationStageHistoryToManyApplicationStatusHistoryFilter;
  ApplicationStatusHistoryFilter: ApplicationStatusHistoryFilter;
  ApplicationStatusFilter: ApplicationStatusFilter;
  ApplicationStatus: ApplicationStatus;
  ApplicationFilter: ApplicationFilter;
  ApplicationOutcomeFilter: ApplicationOutcomeFilter;
  ApplicationOutcome: ApplicationOutcome;
  ApplicationToManyApplicationSectionFilter: ApplicationToManyApplicationSectionFilter;
  ApplicationSectionFilter: ApplicationSectionFilter;
  TemplateSectionFilter: TemplateSectionFilter;
  TemplateSectionToManyTemplateElementFilter: TemplateSectionToManyTemplateElementFilter;
  TemplateElementFilter: TemplateElementFilter;
  TemplateElementCategoryFilter: TemplateElementCategoryFilter;
  TemplateElementCategory: TemplateElementCategory;
  TemplateElementToManyApplicationResponseFilter: TemplateElementToManyApplicationResponseFilter;
  ApplicationResponseFilter: ApplicationResponseFilter;
  ApplicationResponseToManyReviewResponseFilter: ApplicationResponseToManyReviewResponseFilter;
  ReviewResponseFilter: ReviewResponseFilter;
  ReviewResponseDecisionFilter: ReviewResponseDecisionFilter;
  ReviewResponseDecision: ReviewResponseDecision;
  ReviewResponseRecommendedApplicantVisibilityFilter: ReviewResponseRecommendedApplicantVisibilityFilter;
  ReviewResponseRecommendedApplicantVisibility: ReviewResponseRecommendedApplicantVisibility;
  ReviewResponseStatusFilter: ReviewResponseStatusFilter;
  ReviewResponseStatus: ReviewResponseStatus;
  ReviewResponseToManyReviewResponseFilter: ReviewResponseToManyReviewResponseFilter;
  ReviewQuestionAssignmentFilter: ReviewQuestionAssignmentFilter;
  ReviewQuestionAssignmentToManyReviewResponseFilter: ReviewQuestionAssignmentToManyReviewResponseFilter;
  ReviewAssignmentFilter: ReviewAssignmentFilter;
  ReviewAssignmentStatusFilter: ReviewAssignmentStatusFilter;
  ReviewAssignmentStatus: ReviewAssignmentStatus;
  ReviewAssignmentToManyReviewFilter: ReviewAssignmentToManyReviewFilter;
  ReviewFilter: ReviewFilter;
  ReviewStatusFilter: ReviewStatusFilter;
  ReviewStatus: ReviewStatus;
  ReviewToManyReviewResponseFilter: ReviewToManyReviewResponseFilter;
  ReviewToManyReviewDecisionFilter: ReviewToManyReviewDecisionFilter;
  ReviewDecisionFilter: ReviewDecisionFilter;
  DecisionFilter: DecisionFilter;
  Decision: Decision;
  ReviewToManyReviewStatusHistoryFilter: ReviewToManyReviewStatusHistoryFilter;
  ReviewStatusHistoryFilter: ReviewStatusHistoryFilter;
  ReviewToManyNotificationFilter: ReviewToManyNotificationFilter;
  NotificationFilter: NotificationFilter;
  UserFilter: UserFilter;
  DateFilter: DateFilter;
  Date: ResolverTypeWrapper<Scalars['Date']>;
  UserToManyUserOrganisationFilter: UserToManyUserOrganisationFilter;
  UserOrganisationFilter: UserOrganisationFilter;
  OrganisationFilter: OrganisationFilter;
  OrganisationToManyUserOrganisationFilter: OrganisationToManyUserOrganisationFilter;
  OrganisationToManyPermissionJoinFilter: OrganisationToManyPermissionJoinFilter;
  PermissionJoinFilter: PermissionJoinFilter;
  PermissionNameFilter: PermissionNameFilter;
  PermissionNameToManyPermissionJoinFilter: PermissionNameToManyPermissionJoinFilter;
  PermissionNameToManyTemplatePermissionFilter: PermissionNameToManyTemplatePermissionFilter;
  TemplatePermissionFilter: TemplatePermissionFilter;
  PermissionPolicyFilter: PermissionPolicyFilter;
  PermissionPolicyTypeFilter: PermissionPolicyTypeFilter;
  PermissionPolicyType: PermissionPolicyType;
  PermissionPolicyToManyPermissionNameFilter: PermissionPolicyToManyPermissionNameFilter;
  OrganisationToManyApplicationFilter: OrganisationToManyApplicationFilter;
  OrganisationToManyReviewAssignmentFilter: OrganisationToManyReviewAssignmentFilter;
  UserToManyPermissionJoinFilter: UserToManyPermissionJoinFilter;
  UserToManyApplicationFilter: UserToManyApplicationFilter;
  UserToManyReviewAssignmentFilter: UserToManyReviewAssignmentFilter;
  UserToManyReviewFilter: UserToManyReviewFilter;
  UserToManyFileFilter: UserToManyFileFilter;
  FileFilter: FileFilter;
  FileToManyNotificationFilter: FileToManyNotificationFilter;
  UserToManyNotificationFilter: UserToManyNotificationFilter;
  ReviewAssignmentToManyReviewQuestionAssignmentFilter: ReviewAssignmentToManyReviewQuestionAssignmentFilter;
  ApplicationResponseToManyFileFilter: ApplicationResponseToManyFileFilter;
  TemplateElementToManyReviewQuestionAssignmentFilter: TemplateElementToManyReviewQuestionAssignmentFilter;
  TemplateElementToManyReviewResponseFilter: TemplateElementToManyReviewResponseFilter;
  TemplateSectionToManyApplicationSectionFilter: TemplateSectionToManyApplicationSectionFilter;
  ApplicationToManyApplicationStageHistoryFilter: ApplicationToManyApplicationStageHistoryFilter;
  ApplicationToManyApplicationResponseFilter: ApplicationToManyApplicationResponseFilter;
  ApplicationToManyReviewAssignmentFilter: ApplicationToManyReviewAssignmentFilter;
  ApplicationToManyReviewFilter: ApplicationToManyReviewFilter;
  ApplicationToManyFileFilter: ApplicationToManyFileFilter;
  ApplicationToManyNotificationFilter: ApplicationToManyNotificationFilter;
  TemplateStageToManyReviewAssignmentFilter: TemplateStageToManyReviewAssignmentFilter;
  TemplateToManyTemplateSectionFilter: TemplateToManyTemplateSectionFilter;
  TemplateToManyTemplatePermissionFilter: TemplateToManyTemplatePermissionFilter;
  TemplateToManyApplicationFilter: TemplateToManyApplicationFilter;
  TemplateToManyActionQueueFilter: TemplateToManyActionQueueFilter;
  TemplateToManyTemplateActionFilter: TemplateToManyTemplateActionFilter;
  TemplateActionFilter: TemplateActionFilter;
  ActionQueuesConnection: ResolverTypeWrapper<ActionQueuesConnection>;
  ActionQueue: ResolverTypeWrapper<ActionQueue>;
  TriggerQueue: ResolverTypeWrapper<TriggerQueue>;
  Template: ResolverTypeWrapper<Template>;
  TemplateStagesOrderBy: TemplateStagesOrderBy;
  TemplateStageCondition: TemplateStageCondition;
  TemplateStagesConnection: ResolverTypeWrapper<TemplateStagesConnection>;
  TemplateStage: ResolverTypeWrapper<TemplateStage>;
  ApplicationStageHistoriesOrderBy: ApplicationStageHistoriesOrderBy;
  ApplicationStageHistoryCondition: ApplicationStageHistoryCondition;
  ApplicationStageHistoriesConnection: ResolverTypeWrapper<ApplicationStageHistoriesConnection>;
  ApplicationStageHistory: ResolverTypeWrapper<ApplicationStageHistory>;
  Application: ResolverTypeWrapper<Application>;
  User: ResolverTypeWrapper<User>;
  UserOrganisationsOrderBy: UserOrganisationsOrderBy;
  UserOrganisationCondition: UserOrganisationCondition;
  UserOrganisationsConnection: ResolverTypeWrapper<UserOrganisationsConnection>;
  UserOrganisation: ResolverTypeWrapper<UserOrganisation>;
  Organisation: ResolverTypeWrapper<Organisation>;
  PermissionJoinsOrderBy: PermissionJoinsOrderBy;
  PermissionJoinCondition: PermissionJoinCondition;
  PermissionJoinsConnection: ResolverTypeWrapper<PermissionJoinsConnection>;
  PermissionJoin: ResolverTypeWrapper<PermissionJoin>;
  PermissionName: ResolverTypeWrapper<PermissionName>;
  PermissionPolicy: ResolverTypeWrapper<PermissionPolicy>;
  PermissionNamesOrderBy: PermissionNamesOrderBy;
  PermissionNameCondition: PermissionNameCondition;
  PermissionNamesConnection: ResolverTypeWrapper<PermissionNamesConnection>;
  PermissionNamesEdge: ResolverTypeWrapper<PermissionNamesEdge>;
  TemplatePermissionsOrderBy: TemplatePermissionsOrderBy;
  TemplatePermissionCondition: TemplatePermissionCondition;
  TemplatePermissionsConnection: ResolverTypeWrapper<TemplatePermissionsConnection>;
  TemplatePermission: ResolverTypeWrapper<TemplatePermission>;
  TemplatePermissionsEdge: ResolverTypeWrapper<TemplatePermissionsEdge>;
  PermissionJoinsEdge: ResolverTypeWrapper<PermissionJoinsEdge>;
  ApplicationsOrderBy: ApplicationsOrderBy;
  ApplicationCondition: ApplicationCondition;
  ApplicationsConnection: ResolverTypeWrapper<ApplicationsConnection>;
  ApplicationsEdge: ResolverTypeWrapper<ApplicationsEdge>;
  ReviewAssignmentsOrderBy: ReviewAssignmentsOrderBy;
  ReviewAssignmentCondition: ReviewAssignmentCondition;
  ReviewAssignmentsConnection: ResolverTypeWrapper<ReviewAssignmentsConnection>;
  ReviewAssignment: ResolverTypeWrapper<ReviewAssignment>;
  ReviewsOrderBy: ReviewsOrderBy;
  ReviewCondition: ReviewCondition;
  ReviewsConnection: ResolverTypeWrapper<ReviewsConnection>;
  Review: ResolverTypeWrapper<Review>;
  ReviewResponsesOrderBy: ReviewResponsesOrderBy;
  ReviewResponseCondition: ReviewResponseCondition;
  ReviewResponsesConnection: ResolverTypeWrapper<ReviewResponsesConnection>;
  ReviewResponse: ResolverTypeWrapper<ReviewResponse>;
  ReviewQuestionAssignment: ResolverTypeWrapper<ReviewQuestionAssignment>;
  TemplateElement: ResolverTypeWrapper<TemplateElement>;
  TemplateSection: ResolverTypeWrapper<TemplateSection>;
  TemplateElementsOrderBy: TemplateElementsOrderBy;
  TemplateElementCondition: TemplateElementCondition;
  TemplateElementsConnection: ResolverTypeWrapper<TemplateElementsConnection>;
  TemplateElementsEdge: ResolverTypeWrapper<TemplateElementsEdge>;
  ApplicationSectionsOrderBy: ApplicationSectionsOrderBy;
  ApplicationSectionCondition: ApplicationSectionCondition;
  ApplicationSectionsConnection: ResolverTypeWrapper<ApplicationSectionsConnection>;
  ApplicationSection: ResolverTypeWrapper<ApplicationSection>;
  ApplicationSectionsEdge: ResolverTypeWrapper<ApplicationSectionsEdge>;
  ApplicationResponsesOrderBy: ApplicationResponsesOrderBy;
  ApplicationResponseCondition: ApplicationResponseCondition;
  ApplicationResponsesConnection: ResolverTypeWrapper<ApplicationResponsesConnection>;
  ApplicationResponse: ResolverTypeWrapper<ApplicationResponse>;
  FilesOrderBy: FilesOrderBy;
  FileCondition: FileCondition;
  FilesConnection: ResolverTypeWrapper<FilesConnection>;
  File: ResolverTypeWrapper<File>;
  NotificationsOrderBy: NotificationsOrderBy;
  NotificationCondition: NotificationCondition;
  NotificationsConnection: ResolverTypeWrapper<NotificationsConnection>;
  Notification: ResolverTypeWrapper<Notification>;
  NotificationsEdge: ResolverTypeWrapper<NotificationsEdge>;
  FilesEdge: ResolverTypeWrapper<FilesEdge>;
  ApplicationResponsesEdge: ResolverTypeWrapper<ApplicationResponsesEdge>;
  ReviewQuestionAssignmentsOrderBy: ReviewQuestionAssignmentsOrderBy;
  ReviewQuestionAssignmentCondition: ReviewQuestionAssignmentCondition;
  ReviewQuestionAssignmentsConnection: ResolverTypeWrapper<ReviewQuestionAssignmentsConnection>;
  ReviewQuestionAssignmentsEdge: ResolverTypeWrapper<ReviewQuestionAssignmentsEdge>;
  ReviewResponsesEdge: ResolverTypeWrapper<ReviewResponsesEdge>;
  ReviewDecisionsOrderBy: ReviewDecisionsOrderBy;
  ReviewDecisionCondition: ReviewDecisionCondition;
  ReviewDecisionsConnection: ResolverTypeWrapper<ReviewDecisionsConnection>;
  ReviewDecision: ResolverTypeWrapper<ReviewDecision>;
  ReviewDecisionsEdge: ResolverTypeWrapper<ReviewDecisionsEdge>;
  ReviewStatusHistoriesOrderBy: ReviewStatusHistoriesOrderBy;
  ReviewStatusHistoryCondition: ReviewStatusHistoryCondition;
  ReviewStatusHistoriesConnection: ResolverTypeWrapper<ReviewStatusHistoriesConnection>;
  ReviewStatusHistory: ResolverTypeWrapper<ReviewStatusHistory>;
  ReviewStatusHistoriesEdge: ResolverTypeWrapper<ReviewStatusHistoriesEdge>;
  ReviewsEdge: ResolverTypeWrapper<ReviewsEdge>;
  ReviewAssignmentsEdge: ResolverTypeWrapper<ReviewAssignmentsEdge>;
  UserOrganisationsEdge: ResolverTypeWrapper<UserOrganisationsEdge>;
  ApplicationStatusHistoriesOrderBy: ApplicationStatusHistoriesOrderBy;
  ApplicationStatusHistoryCondition: ApplicationStatusHistoryCondition;
  ApplicationStatusHistoriesConnection: ResolverTypeWrapper<ApplicationStatusHistoriesConnection>;
  ApplicationStatusHistory: ResolverTypeWrapper<ApplicationStatusHistory>;
  ApplicationStatusHistoriesEdge: ResolverTypeWrapper<ApplicationStatusHistoriesEdge>;
  ApplicationStageHistoriesEdge: ResolverTypeWrapper<ApplicationStageHistoriesEdge>;
  TemplateStagesEdge: ResolverTypeWrapper<TemplateStagesEdge>;
  TemplateSectionsOrderBy: TemplateSectionsOrderBy;
  TemplateSectionCondition: TemplateSectionCondition;
  TemplateSectionsConnection: ResolverTypeWrapper<TemplateSectionsConnection>;
  TemplateSectionsEdge: ResolverTypeWrapper<TemplateSectionsEdge>;
  TemplateActionsOrderBy: TemplateActionsOrderBy;
  TemplateActionCondition: TemplateActionCondition;
  TemplateActionsConnection: ResolverTypeWrapper<TemplateActionsConnection>;
  TemplateAction: ResolverTypeWrapper<TemplateAction>;
  TemplateActionsEdge: ResolverTypeWrapper<TemplateActionsEdge>;
  ActionQueuesEdge: ResolverTypeWrapper<ActionQueuesEdge>;
  AllPermissionsOrderBy: AllPermissionsOrderBy;
  AllPermissionCondition: AllPermissionCondition;
  AllPermissionFilter: AllPermissionFilter;
  AllPermissionsConnection: ResolverTypeWrapper<AllPermissionsConnection>;
  AllPermission: ResolverTypeWrapper<AllPermission>;
  AllPermissionsEdge: ResolverTypeWrapper<AllPermissionsEdge>;
  ApplicationListsOrderBy: ApplicationListsOrderBy;
  ApplicationListCondition: ApplicationListCondition;
  ApplicationListFilter: ApplicationListFilter;
  ApplicationListsConnection: ResolverTypeWrapper<ApplicationListsConnection>;
  ApplicationList: ResolverTypeWrapper<ApplicationList>;
  ApplicationListsEdge: ResolverTypeWrapper<ApplicationListsEdge>;
  ApplicationStageStatusAllsOrderBy: ApplicationStageStatusAllsOrderBy;
  ApplicationStageStatusAllCondition: ApplicationStageStatusAllCondition;
  ApplicationStageStatusAllFilter: ApplicationStageStatusAllFilter;
  ApplicationStageStatusAllsConnection: ResolverTypeWrapper<ApplicationStageStatusAllsConnection>;
  ApplicationStageStatusAll: ResolverTypeWrapper<ApplicationStageStatusAll>;
  ApplicationStageStatusAllsEdge: ResolverTypeWrapper<ApplicationStageStatusAllsEdge>;
  ApplicationStageStatusLatestsOrderBy: ApplicationStageStatusLatestsOrderBy;
  ApplicationStageStatusLatestCondition: ApplicationStageStatusLatestCondition;
  ApplicationStageStatusLatestFilter: ApplicationStageStatusLatestFilter;
  ApplicationStageStatusLatestsConnection: ResolverTypeWrapper<ApplicationStageStatusLatestsConnection>;
  ApplicationStageStatusLatest: ResolverTypeWrapper<ApplicationStageStatusLatest>;
  ApplicationStageStatusLatestsEdge: ResolverTypeWrapper<ApplicationStageStatusLatestsEdge>;
  ApplicationTriggerStatesOrderBy: ApplicationTriggerStatesOrderBy;
  ApplicationTriggerStateCondition: ApplicationTriggerStateCondition;
  ApplicationTriggerStateFilter: ApplicationTriggerStateFilter;
  ApplicationTriggerStatesConnection: ResolverTypeWrapper<ApplicationTriggerStatesConnection>;
  ApplicationTriggerState: ResolverTypeWrapper<ApplicationTriggerState>;
  ApplicationTriggerStatesEdge: ResolverTypeWrapper<ApplicationTriggerStatesEdge>;
  ElementTypePluginsOrderBy: ElementTypePluginsOrderBy;
  ElementTypePluginCondition: ElementTypePluginCondition;
  ElementTypePluginFilter: ElementTypePluginFilter;
  ElementTypePluginsConnection: ResolverTypeWrapper<ElementTypePluginsConnection>;
  ElementTypePlugin: ResolverTypeWrapper<ElementTypePlugin>;
  ElementTypePluginsEdge: ResolverTypeWrapper<ElementTypePluginsEdge>;
  OrganisationsOrderBy: OrganisationsOrderBy;
  OrganisationCondition: OrganisationCondition;
  OrganisationsConnection: ResolverTypeWrapper<OrganisationsConnection>;
  OrganisationsEdge: ResolverTypeWrapper<OrganisationsEdge>;
  PermissionPoliciesOrderBy: PermissionPoliciesOrderBy;
  PermissionPolicyCondition: PermissionPolicyCondition;
  PermissionPoliciesConnection: ResolverTypeWrapper<PermissionPoliciesConnection>;
  PermissionPoliciesEdge: ResolverTypeWrapper<PermissionPoliciesEdge>;
  TemplatesOrderBy: TemplatesOrderBy;
  TemplateCondition: TemplateCondition;
  TemplatesConnection: ResolverTypeWrapper<TemplatesConnection>;
  TemplatesEdge: ResolverTypeWrapper<TemplatesEdge>;
  TriggerQueuesOrderBy: TriggerQueuesOrderBy;
  TriggerQueueCondition: TriggerQueueCondition;
  TriggerQueuesConnection: ResolverTypeWrapper<TriggerQueuesConnection>;
  TriggerQueuesEdge: ResolverTypeWrapper<TriggerQueuesEdge>;
  UsersOrderBy: UsersOrderBy;
  UserCondition: UserCondition;
  UsersConnection: ResolverTypeWrapper<UsersConnection>;
  UsersEdge: ResolverTypeWrapper<UsersEdge>;
  UserOrgJoinsOrderBy: UserOrgJoinsOrderBy;
  UserOrgJoinCondition: UserOrgJoinCondition;
  UserOrgJoinFilter: UserOrgJoinFilter;
  UserOrgJoinsConnection: ResolverTypeWrapper<UserOrgJoinsConnection>;
  UserOrgJoin: ResolverTypeWrapper<UserOrgJoin>;
  UserOrgJoinsEdge: ResolverTypeWrapper<UserOrgJoinsEdge>;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']>;
  Mutation: ResolverTypeWrapper<{}>;
  CreateActionPluginInput: CreateActionPluginInput;
  ActionPluginInput: ActionPluginInput;
  CreateActionPluginPayload: ResolverTypeWrapper<CreateActionPluginPayload>;
  CreateActionQueueInput: CreateActionQueueInput;
  ActionQueueInput: ActionQueueInput;
  ActionQueueTriggerEventFkeyInput: ActionQueueTriggerEventFkeyInput;
  TriggerQueueTriggerQueuePkeyConnect: TriggerQueueTriggerQueuePkeyConnect;
  TriggerQueueNodeIdConnect: TriggerQueueNodeIdConnect;
  TriggerQueueTriggerQueuePkeyDelete: TriggerQueueTriggerQueuePkeyDelete;
  TriggerQueueNodeIdDelete: TriggerQueueNodeIdDelete;
  TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate: TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate;
  updateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch: UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  ActionQueueTriggerEventFkeyInverseInput: ActionQueueTriggerEventFkeyInverseInput;
  ActionQueueActionQueuePkeyConnect: ActionQueueActionQueuePkeyConnect;
  ActionQueueNodeIdConnect: ActionQueueNodeIdConnect;
  ActionQueueActionQueuePkeyDelete: ActionQueueActionQueuePkeyDelete;
  ActionQueueNodeIdDelete: ActionQueueNodeIdDelete;
  ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate;
  updateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  ActionQueueTemplateIdFkeyInput: ActionQueueTemplateIdFkeyInput;
  TemplateTemplatePkeyConnect: TemplateTemplatePkeyConnect;
  TemplateNodeIdConnect: TemplateNodeIdConnect;
  TemplateTemplatePkeyDelete: TemplateTemplatePkeyDelete;
  TemplateNodeIdDelete: TemplateNodeIdDelete;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
  TemplateStageTemplateIdFkeyInverseInput: TemplateStageTemplateIdFkeyInverseInput;
  TemplateStageTemplateStagePkeyConnect: TemplateStageTemplateStagePkeyConnect;
  TemplateStageNodeIdConnect: TemplateStageNodeIdConnect;
  TemplateStageTemplateStagePkeyDelete: TemplateStageTemplateStagePkeyDelete;
  TemplateStageNodeIdDelete: TemplateStageNodeIdDelete;
  TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate;
  updateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch: UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  TemplateStageTemplateIdFkeyInput: TemplateStageTemplateIdFkeyInput;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  TemplateSectionTemplateIdFkeyInverseInput: TemplateSectionTemplateIdFkeyInverseInput;
  TemplateSectionTemplateSectionPkeyConnect: TemplateSectionTemplateSectionPkeyConnect;
  TemplateSectionNodeIdConnect: TemplateSectionNodeIdConnect;
  TemplateSectionTemplateSectionPkeyDelete: TemplateSectionTemplateSectionPkeyDelete;
  TemplateSectionNodeIdDelete: TemplateSectionNodeIdDelete;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate;
  updateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  TemplateSectionTemplateIdFkeyInput: TemplateSectionTemplateIdFkeyInput;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  TemplatePermissionTemplateIdFkeyInverseInput: TemplatePermissionTemplateIdFkeyInverseInput;
  TemplatePermissionTemplatePermissionPkeyConnect: TemplatePermissionTemplatePermissionPkeyConnect;
  TemplatePermissionNodeIdConnect: TemplatePermissionNodeIdConnect;
  TemplatePermissionTemplatePermissionPkeyDelete: TemplatePermissionTemplatePermissionPkeyDelete;
  TemplatePermissionNodeIdDelete: TemplatePermissionNodeIdDelete;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate;
  updateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  TemplatePermissionPermissionNameIdFkeyInput: TemplatePermissionPermissionNameIdFkeyInput;
  PermissionNamePermissionNamePkeyConnect: PermissionNamePermissionNamePkeyConnect;
  PermissionNamePermissionNameNameKeyConnect: PermissionNamePermissionNameNameKeyConnect;
  PermissionNameNodeIdConnect: PermissionNameNodeIdConnect;
  PermissionNamePermissionNamePkeyDelete: PermissionNamePermissionNamePkeyDelete;
  PermissionNamePermissionNameNameKeyDelete: PermissionNamePermissionNameNameKeyDelete;
  PermissionNameNodeIdDelete: PermissionNameNodeIdDelete;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate;
  updatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  PermissionNamePermissionPolicyIdFkeyInput: PermissionNamePermissionPolicyIdFkeyInput;
  PermissionPolicyPermissionPolicyPkeyConnect: PermissionPolicyPermissionPolicyPkeyConnect;
  PermissionPolicyNodeIdConnect: PermissionPolicyNodeIdConnect;
  PermissionPolicyPermissionPolicyPkeyDelete: PermissionPolicyPermissionPolicyPkeyDelete;
  PermissionPolicyNodeIdDelete: PermissionPolicyNodeIdDelete;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate;
  updatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  PermissionNamePermissionPolicyIdFkeyInverseInput: PermissionNamePermissionPolicyIdFkeyInverseInput;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate;
  updatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  PermissionJoinPermissionNameIdFkeyInverseInput: PermissionJoinPermissionNameIdFkeyInverseInput;
  PermissionJoinPermissionJoinPkeyConnect: PermissionJoinPermissionJoinPkeyConnect;
  PermissionJoinNodeIdConnect: PermissionJoinNodeIdConnect;
  PermissionJoinPermissionJoinPkeyDelete: PermissionJoinPermissionJoinPkeyDelete;
  PermissionJoinNodeIdDelete: PermissionJoinNodeIdDelete;
  PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate;
  updatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  PermissionJoinUserIdFkeyInput: PermissionJoinUserIdFkeyInput;
  UserUserPkeyConnect: UserUserPkeyConnect;
  UserUserUsernameKeyConnect: UserUserUsernameKeyConnect;
  UserNodeIdConnect: UserNodeIdConnect;
  UserUserPkeyDelete: UserUserPkeyDelete;
  UserUserUsernameKeyDelete: UserUserUsernameKeyDelete;
  UserNodeIdDelete: UserNodeIdDelete;
  UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserPkeyUpdate: UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch: UpdateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
  UserOrganisationUserIdFkeyInverseInput: UserOrganisationUserIdFkeyInverseInput;
  UserOrganisationUserOrganisationPkeyConnect: UserOrganisationUserOrganisationPkeyConnect;
  UserOrganisationNodeIdConnect: UserOrganisationNodeIdConnect;
  UserOrganisationUserOrganisationPkeyDelete: UserOrganisationUserOrganisationPkeyDelete;
  UserOrganisationNodeIdDelete: UserOrganisationNodeIdDelete;
  UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationPkeyUpdate: UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationPkeyUpdate;
  updateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  UserOrganisationUserIdFkeyInput: UserOrganisationUserIdFkeyInput;
  UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserPkeyUpdate: UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch: UpdateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  PermissionJoinUserIdFkeyInverseInput: PermissionJoinUserIdFkeyInverseInput;
  PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyUsingPermissionJoinPkeyUpdate;
  updatePermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
  PermissionJoinOrganisationIdFkeyInput: PermissionJoinOrganisationIdFkeyInput;
  OrganisationOrganisationPkeyConnect: OrganisationOrganisationPkeyConnect;
  OrganisationOrganisationNameKeyConnect: OrganisationOrganisationNameKeyConnect;
  OrganisationNodeIdConnect: OrganisationNodeIdConnect;
  OrganisationOrganisationPkeyDelete: OrganisationOrganisationPkeyDelete;
  OrganisationOrganisationNameKeyDelete: OrganisationOrganisationNameKeyDelete;
  OrganisationNodeIdDelete: OrganisationNodeIdDelete;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  updateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  UserOrganisationOrganisationIdFkeyInverseInput: UserOrganisationOrganisationIdFkeyInverseInput;
  UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate: UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate;
  updateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  UserOrganisationOrganisationIdFkeyInput: UserOrganisationOrganisationIdFkeyInput;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  updateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  PermissionJoinOrganisationIdFkeyInverseInput: PermissionJoinOrganisationIdFkeyInverseInput;
  PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate;
  updatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  PermissionJoinPermissionNameIdFkeyInput: PermissionJoinPermissionNameIdFkeyInput;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate;
  updatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  TemplatePermissionPermissionNameIdFkeyInverseInput: TemplatePermissionPermissionNameIdFkeyInverseInput;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate;
  updateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  TemplatePermissionTemplateIdFkeyInput: TemplatePermissionTemplateIdFkeyInput;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  ApplicationTemplateIdFkeyInverseInput: ApplicationTemplateIdFkeyInverseInput;
  ApplicationApplicationPkeyConnect: ApplicationApplicationPkeyConnect;
  ApplicationApplicationSerialKeyConnect: ApplicationApplicationSerialKeyConnect;
  ApplicationNodeIdConnect: ApplicationNodeIdConnect;
  ApplicationApplicationPkeyDelete: ApplicationApplicationPkeyDelete;
  ApplicationApplicationSerialKeyDelete: ApplicationApplicationSerialKeyDelete;
  ApplicationNodeIdDelete: ApplicationNodeIdDelete;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationForApplicationTemplateIdFkeyPatch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
  ApplicationTemplateIdFkeyInput: ApplicationTemplateIdFkeyInput;
  TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnApplicationForApplicationTemplateIdFkeyPatch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
  ActionQueueTemplateIdFkeyInverseInput: ActionQueueTemplateIdFkeyInverseInput;
  ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate;
  updateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate;
  ActionQueuePatch: ActionQueuePatch;
  ActionQueueTemplateIdFkeyActionQueueCreateInput: ActionQueueTemplateIdFkeyActionQueueCreateInput;
  TemplateActionTemplateIdFkeyInverseInput: TemplateActionTemplateIdFkeyInverseInput;
  TemplateActionTemplateActionPkeyConnect: TemplateActionTemplateActionPkeyConnect;
  TemplateActionNodeIdConnect: TemplateActionNodeIdConnect;
  TemplateActionTemplateActionPkeyDelete: TemplateActionTemplateActionPkeyDelete;
  TemplateActionNodeIdDelete: TemplateActionNodeIdDelete;
  TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate: TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate;
  updateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch: UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  TemplateActionTemplateIdFkeyInput: TemplateActionTemplateIdFkeyInput;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate: TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate;
  TemplatePatch: TemplatePatch;
  TemplateActionTemplateIdFkeyTemplateCreateInput: TemplateActionTemplateIdFkeyTemplateCreateInput;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate;
  TemplateActionPatch: TemplateActionPatch;
  TemplateActionTemplateIdFkeyTemplateActionCreateInput: TemplateActionTemplateIdFkeyTemplateActionCreateInput;
  ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate;
  ApplicationTemplateIdFkeyTemplateCreateInput: ApplicationTemplateIdFkeyTemplateCreateInput;
  ApplicationUserIdFkeyInput: ApplicationUserIdFkeyInput;
  UserOnApplicationForApplicationUserIdFkeyUsingUserPkeyUpdate: UserOnApplicationForApplicationUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnApplicationForApplicationUserIdFkeyPatch: UpdateUserOnApplicationForApplicationUserIdFkeyPatch;
  ApplicationUserIdFkeyInverseInput: ApplicationUserIdFkeyInverseInput;
  ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationForApplicationUserIdFkeyPatch: UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch;
  ApplicationOrgIdFkeyInput: ApplicationOrgIdFkeyInput;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate;
  updateOrganisationOnApplicationForApplicationOrgIdFkeyPatch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
  ApplicationOrgIdFkeyInverseInput: ApplicationOrgIdFkeyInverseInput;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationForApplicationOrgIdFkeyPatch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
  ApplicationSectionApplicationIdFkeyInverseInput: ApplicationSectionApplicationIdFkeyInverseInput;
  ApplicationSectionApplicationSectionPkeyConnect: ApplicationSectionApplicationSectionPkeyConnect;
  ApplicationSectionNodeIdConnect: ApplicationSectionNodeIdConnect;
  ApplicationSectionApplicationSectionPkeyDelete: ApplicationSectionApplicationSectionPkeyDelete;
  ApplicationSectionNodeIdDelete: ApplicationSectionNodeIdDelete;
  ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSectionPkeyUpdate: ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSectionPkeyUpdate;
  updateApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch: UpdateApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch;
  ApplicationSectionApplicationIdFkeyInput: ApplicationSectionApplicationIdFkeyInput;
  ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch: UpdateApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch;
  ApplicationStageHistoryApplicationIdFkeyInverseInput: ApplicationStageHistoryApplicationIdFkeyInverseInput;
  ApplicationStageHistoryApplicationStageHistoryPkeyConnect: ApplicationStageHistoryApplicationStageHistoryPkeyConnect;
  ApplicationStageHistoryNodeIdConnect: ApplicationStageHistoryNodeIdConnect;
  ApplicationStageHistoryApplicationStageHistoryPkeyDelete: ApplicationStageHistoryApplicationStageHistoryPkeyDelete;
  ApplicationStageHistoryNodeIdDelete: ApplicationStageHistoryNodeIdDelete;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  updateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  ApplicationStageHistoryApplicationIdFkeyInput: ApplicationStageHistoryApplicationIdFkeyInput;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  ApplicationResponseApplicationIdFkeyInverseInput: ApplicationResponseApplicationIdFkeyInverseInput;
  ApplicationResponseApplicationResponsePkeyConnect: ApplicationResponseApplicationResponsePkeyConnect;
  ApplicationResponseNodeIdConnect: ApplicationResponseNodeIdConnect;
  ApplicationResponseApplicationResponsePkeyDelete: ApplicationResponseApplicationResponsePkeyDelete;
  ApplicationResponseNodeIdDelete: ApplicationResponseNodeIdDelete;
  ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate;
  updateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  ApplicationResponseTemplateElementIdFkeyInput: ApplicationResponseTemplateElementIdFkeyInput;
  TemplateElementTemplateElementPkeyConnect: TemplateElementTemplateElementPkeyConnect;
  TemplateElementNodeIdConnect: TemplateElementNodeIdConnect;
  TemplateElementTemplateElementPkeyDelete: TemplateElementTemplateElementPkeyDelete;
  TemplateElementNodeIdDelete: TemplateElementNodeIdDelete;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  updateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  TemplateElementSectionIdFkeyInput: TemplateElementSectionIdFkeyInput;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate;
  updateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  TemplateElementSectionIdFkeyInverseInput: TemplateElementSectionIdFkeyInverseInput;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate;
  updateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  ApplicationResponseTemplateElementIdFkeyInverseInput: ApplicationResponseTemplateElementIdFkeyInverseInput;
  ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate;
  updateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  ApplicationResponseApplicationIdFkeyInput: ApplicationResponseApplicationIdFkeyInput;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  ReviewAssignmentApplicationIdFkeyInverseInput: ReviewAssignmentApplicationIdFkeyInverseInput;
  ReviewAssignmentReviewAssignmentPkeyConnect: ReviewAssignmentReviewAssignmentPkeyConnect;
  ReviewAssignmentNodeIdConnect: ReviewAssignmentNodeIdConnect;
  ReviewAssignmentReviewAssignmentPkeyDelete: ReviewAssignmentReviewAssignmentPkeyDelete;
  ReviewAssignmentNodeIdDelete: ReviewAssignmentNodeIdDelete;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  ReviewAssignmentAssignerIdFkeyInput: ReviewAssignmentAssignerIdFkeyInput;
  UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserPkeyUpdate: UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserPkeyUpdate;
  updateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch: UpdateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
  ReviewAssignmentAssignerIdFkeyInverseInput: ReviewAssignmentAssignerIdFkeyInverseInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
  ReviewAssignmentReviewerIdFkeyInput: ReviewAssignmentReviewerIdFkeyInput;
  UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserPkeyUpdate: UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserPkeyUpdate;
  updateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch: UpdateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
  ReviewAssignmentReviewerIdFkeyInverseInput: ReviewAssignmentReviewerIdFkeyInverseInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
  ReviewAssignmentOrganisationIdFkeyInput: ReviewAssignmentOrganisationIdFkeyInput;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  updateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  ReviewAssignmentOrganisationIdFkeyInverseInput: ReviewAssignmentOrganisationIdFkeyInverseInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  ReviewAssignmentStageIdFkeyInput: ReviewAssignmentStageIdFkeyInput;
  TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate;
  updateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch: UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  ApplicationStageHistoryStageIdFkeyInverseInput: ApplicationStageHistoryStageIdFkeyInverseInput;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  updateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  ApplicationStageHistoryStageIdFkeyInput: ApplicationStageHistoryStageIdFkeyInput;
  TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate;
  updateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch: UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  ReviewAssignmentStageIdFkeyInverseInput: ReviewAssignmentStageIdFkeyInverseInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  ReviewAssignmentApplicationIdFkeyInput: ReviewAssignmentApplicationIdFkeyInput;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  ReviewApplicationIdFkeyInverseInput: ReviewApplicationIdFkeyInverseInput;
  ReviewReviewPkeyConnect: ReviewReviewPkeyConnect;
  ReviewNodeIdConnect: ReviewNodeIdConnect;
  ReviewReviewPkeyDelete: ReviewReviewPkeyDelete;
  ReviewNodeIdDelete: ReviewNodeIdDelete;
  ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewForReviewApplicationIdFkeyPatch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
  ReviewReviewAssignmentIdFkeyInput: ReviewReviewAssignmentIdFkeyInput;
  ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch;
  ReviewReviewAssignmentIdFkeyInverseInput: ReviewReviewAssignmentIdFkeyInverseInput;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
  ReviewApplicationIdFkeyInput: ReviewApplicationIdFkeyInput;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnReviewForReviewApplicationIdFkeyPatch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
  FileApplicationIdFkeyInverseInput: FileApplicationIdFkeyInverseInput;
  FileFilePkeyConnect: FileFilePkeyConnect;
  FileNodeIdConnect: FileNodeIdConnect;
  FileFilePkeyDelete: FileFilePkeyDelete;
  FileNodeIdDelete: FileNodeIdDelete;
  FileOnFileForFileApplicationIdFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationIdFkeyUsingFilePkeyUpdate;
  updateFileOnFileForFileApplicationIdFkeyPatch: UpdateFileOnFileForFileApplicationIdFkeyPatch;
  FileUserIdFkeyInput: FileUserIdFkeyInput;
  UserOnFileForFileUserIdFkeyUsingUserPkeyUpdate: UserOnFileForFileUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnFileForFileUserIdFkeyPatch: UpdateUserOnFileForFileUserIdFkeyPatch;
  ReviewReviewerIdFkeyInverseInput: ReviewReviewerIdFkeyInverseInput;
  ReviewOnReviewForReviewReviewerIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewReviewerIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewForReviewReviewerIdFkeyPatch: UpdateReviewOnReviewForReviewReviewerIdFkeyPatch;
  ReviewReviewerIdFkeyInput: ReviewReviewerIdFkeyInput;
  UserOnReviewForReviewReviewerIdFkeyUsingUserPkeyUpdate: UserOnReviewForReviewReviewerIdFkeyUsingUserPkeyUpdate;
  updateUserOnReviewForReviewReviewerIdFkeyPatch: UpdateUserOnReviewForReviewReviewerIdFkeyPatch;
  FileUserIdFkeyInverseInput: FileUserIdFkeyInverseInput;
  FileOnFileForFileUserIdFkeyUsingFilePkeyUpdate: FileOnFileForFileUserIdFkeyUsingFilePkeyUpdate;
  updateFileOnFileForFileUserIdFkeyPatch: UpdateFileOnFileForFileUserIdFkeyPatch;
  FileApplicationIdFkeyInput: FileApplicationIdFkeyInput;
  ApplicationOnFileForFileApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnFileForFileApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnFileForFileApplicationIdFkeyPatch: UpdateApplicationOnFileForFileApplicationIdFkeyPatch;
  NotificationApplicationIdFkeyInverseInput: NotificationApplicationIdFkeyInverseInput;
  NotificationNotificationPkeyConnect: NotificationNotificationPkeyConnect;
  NotificationNodeIdConnect: NotificationNodeIdConnect;
  NotificationNotificationPkeyDelete: NotificationNotificationPkeyDelete;
  NotificationNodeIdDelete: NotificationNodeIdDelete;
  NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate;
  updateNotificationOnNotificationForNotificationApplicationIdFkeyPatch: UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch;
  NotificationUserIdFkeyInput: NotificationUserIdFkeyInput;
  UserOnNotificationForNotificationUserIdFkeyUsingUserPkeyUpdate: UserOnNotificationForNotificationUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnNotificationForNotificationUserIdFkeyPatch: UpdateUserOnNotificationForNotificationUserIdFkeyPatch;
  NotificationUserIdFkeyInverseInput: NotificationUserIdFkeyInverseInput;
  NotificationOnNotificationForNotificationUserIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationUserIdFkeyUsingNotificationPkeyUpdate;
  updateNotificationOnNotificationForNotificationUserIdFkeyPatch: UpdateNotificationOnNotificationForNotificationUserIdFkeyPatch;
  NotificationApplicationIdFkeyInput: NotificationApplicationIdFkeyInput;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnNotificationForNotificationApplicationIdFkeyPatch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate;
  ApplicationPatch: ApplicationPatch;
  NotificationApplicationIdFkeyApplicationCreateInput: NotificationApplicationIdFkeyApplicationCreateInput;
  NotificationReviewIdFkeyInput: NotificationReviewIdFkeyInput;
  ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnNotificationForNotificationReviewIdFkeyPatch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
  ReviewResponseReviewIdFkeyInverseInput: ReviewResponseReviewIdFkeyInverseInput;
  ReviewResponseReviewResponsePkeyConnect: ReviewResponseReviewResponsePkeyConnect;
  ReviewResponseNodeIdConnect: ReviewResponseNodeIdConnect;
  ReviewResponseReviewResponsePkeyDelete: ReviewResponseReviewResponsePkeyDelete;
  ReviewResponseNodeIdDelete: ReviewResponseNodeIdDelete;
  ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  ReviewResponseReviewQuestionAssignmentIdFkeyInput: ReviewResponseReviewQuestionAssignmentIdFkeyInput;
  ReviewQuestionAssignmentReviewQuestionAssignmentPkeyConnect: ReviewQuestionAssignmentReviewQuestionAssignmentPkeyConnect;
  ReviewQuestionAssignmentNodeIdConnect: ReviewQuestionAssignmentNodeIdConnect;
  ReviewQuestionAssignmentReviewQuestionAssignmentPkeyDelete: ReviewQuestionAssignmentReviewQuestionAssignmentPkeyDelete;
  ReviewQuestionAssignmentNodeIdDelete: ReviewQuestionAssignmentNodeIdDelete;
  ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate: ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate;
  updateReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch: UpdateReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch;
  ReviewQuestionAssignmentTemplateElementIdFkeyInput: ReviewQuestionAssignmentTemplateElementIdFkeyInput;
  TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  updateTemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch: UpdateTemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch;
  ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput: ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput;
  ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingReviewQuestionAssignmentPkeyUpdate: ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingReviewQuestionAssignmentPkeyUpdate;
  updateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch: UpdateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch;
  ReviewQuestionAssignmentReviewAssignmentIdFkeyInput: ReviewQuestionAssignmentReviewAssignmentIdFkeyInput;
  ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch;
  ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput: ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput;
  ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate: ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate;
  updateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch: UpdateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch;
  ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput: ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch;
  ReviewResponseApplicationResponseIdFkeyInput: ReviewResponseApplicationResponseIdFkeyInput;
  ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate;
  updateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch: UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  ReviewResponseApplicationResponseIdFkeyInverseInput: ReviewResponseApplicationResponseIdFkeyInverseInput;
  ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  ReviewResponseReviewResponseLinkIdFkeyInput: ReviewResponseReviewResponseLinkIdFkeyInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch;
  ReviewResponseOriginalReviewResponseIdFkeyInput: ReviewResponseOriginalReviewResponseIdFkeyInput;
  ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch;
  ReviewResponseReviewIdFkeyInput: ReviewResponseReviewIdFkeyInput;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  ReviewDecisionReviewIdFkeyInverseInput: ReviewDecisionReviewIdFkeyInverseInput;
  ReviewDecisionReviewDecisionPkeyConnect: ReviewDecisionReviewDecisionPkeyConnect;
  ReviewDecisionNodeIdConnect: ReviewDecisionNodeIdConnect;
  ReviewDecisionReviewDecisionPkeyDelete: ReviewDecisionReviewDecisionPkeyDelete;
  ReviewDecisionNodeIdDelete: ReviewDecisionNodeIdDelete;
  ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate: ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate;
  updateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch: UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  ReviewDecisionReviewIdFkeyInput: ReviewDecisionReviewIdFkeyInput;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  ReviewStatusHistoryReviewIdFkeyInverseInput: ReviewStatusHistoryReviewIdFkeyInverseInput;
  ReviewStatusHistoryReviewStatusHistoryPkeyConnect: ReviewStatusHistoryReviewStatusHistoryPkeyConnect;
  ReviewStatusHistoryNodeIdConnect: ReviewStatusHistoryNodeIdConnect;
  ReviewStatusHistoryReviewStatusHistoryPkeyDelete: ReviewStatusHistoryReviewStatusHistoryPkeyDelete;
  ReviewStatusHistoryNodeIdDelete: ReviewStatusHistoryNodeIdDelete;
  ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate: ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate;
  updateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch: UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  ReviewStatusHistoryReviewIdFkeyInput: ReviewStatusHistoryReviewIdFkeyInput;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  NotificationReviewIdFkeyInverseInput: NotificationReviewIdFkeyInverseInput;
  NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate;
  updateNotificationOnNotificationForNotificationReviewIdFkeyPatch: UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch;
  NotificationDocumentIdFkeyInput: NotificationDocumentIdFkeyInput;
  FileOnNotificationForNotificationDocumentIdFkeyUsingFilePkeyUpdate: FileOnNotificationForNotificationDocumentIdFkeyUsingFilePkeyUpdate;
  updateFileOnNotificationForNotificationDocumentIdFkeyPatch: UpdateFileOnNotificationForNotificationDocumentIdFkeyPatch;
  FileApplicationResponseIdFkeyInput: FileApplicationResponseIdFkeyInput;
  ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate;
  updateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch: UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch;
  FileApplicationResponseIdFkeyInverseInput: FileApplicationResponseIdFkeyInverseInput;
  FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate;
  updateFileOnFileForFileApplicationResponseIdFkeyPatch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
  NotificationDocumentIdFkeyInverseInput: NotificationDocumentIdFkeyInverseInput;
  NotificationOnNotificationForNotificationDocumentIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationDocumentIdFkeyUsingNotificationPkeyUpdate;
  updateNotificationOnNotificationForNotificationDocumentIdFkeyPatch: UpdateNotificationOnNotificationForNotificationDocumentIdFkeyPatch;
  FileOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate: FileOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate;
  NotificationPatch: NotificationPatch;
  NotificationDocumentIdFkeyNotificationCreateInput: NotificationDocumentIdFkeyNotificationCreateInput;
  ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate: ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate;
  FilePatch: FilePatch;
  FileApplicationResponseIdFkeyFileCreateInput: FileApplicationResponseIdFkeyFileCreateInput;
  FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate: FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate;
  ApplicationResponsePatch: ApplicationResponsePatch;
  FileApplicationResponseIdFkeyApplicationResponseCreateInput: FileApplicationResponseIdFkeyApplicationResponseCreateInput;
  NotificationOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate;
  NotificationDocumentIdFkeyFileCreateInput: NotificationDocumentIdFkeyFileCreateInput;
  ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate: ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate;
  NotificationReviewIdFkeyNotificationCreateInput: NotificationReviewIdFkeyNotificationCreateInput;
  ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate: ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate;
  ReviewPatch: ReviewPatch;
  ReviewStatusHistoryReviewIdFkeyReviewCreateInput: ReviewStatusHistoryReviewIdFkeyReviewCreateInput;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate;
  ReviewStatusHistoryPatch: ReviewStatusHistoryPatch;
  ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput: ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput;
  ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate: ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate;
  ReviewDecisionReviewIdFkeyReviewCreateInput: ReviewDecisionReviewIdFkeyReviewCreateInput;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate;
  ReviewDecisionPatch: ReviewDecisionPatch;
  ReviewDecisionReviewIdFkeyReviewDecisionCreateInput: ReviewDecisionReviewIdFkeyReviewDecisionCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate;
  ReviewResponseReviewIdFkeyReviewCreateInput: ReviewResponseReviewIdFkeyReviewCreateInput;
  ReviewResponseTemplateElementIdFkeyInput: ReviewResponseTemplateElementIdFkeyInput;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  updateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  ReviewResponseTemplateElementIdFkeyInverseInput: ReviewResponseTemplateElementIdFkeyInverseInput;
  ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate;
  ReviewResponsePatch: ReviewResponsePatch;
  ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput: ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate;
  TemplateElementPatch: TemplateElementPatch;
  ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput: ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate;
  ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput: ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate;
  ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput: ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput;
  ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate: ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate;
  ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput: ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate;
  ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput: ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput;
  ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate: ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate;
  ReviewResponseReviewQuestionAssignmentIdFkeyReviewResponseCreateInput: ReviewResponseReviewQuestionAssignmentIdFkeyReviewResponseCreateInput;
  ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewQuestionAssignmentPatch: ReviewQuestionAssignmentPatch;
  ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewQuestionAssignmentCreateInput: ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewQuestionAssignmentCreateInput;
  ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate: ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewAssignmentPatch: ReviewAssignmentPatch;
  ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewAssignmentCreateInput: ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewAssignmentCreateInput;
  TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate;
  ReviewQuestionAssignmentTemplateElementIdFkeyReviewQuestionAssignmentCreateInput: ReviewQuestionAssignmentTemplateElementIdFkeyReviewQuestionAssignmentCreateInput;
  ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate: ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate;
  ReviewQuestionAssignmentTemplateElementIdFkeyTemplateElementCreateInput: ReviewQuestionAssignmentTemplateElementIdFkeyTemplateElementCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate;
  ReviewResponseReviewQuestionAssignmentIdFkeyReviewQuestionAssignmentCreateInput: ReviewResponseReviewQuestionAssignmentIdFkeyReviewQuestionAssignmentCreateInput;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate;
  ReviewResponseReviewIdFkeyReviewResponseCreateInput: ReviewResponseReviewIdFkeyReviewResponseCreateInput;
  NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate;
  NotificationReviewIdFkeyReviewCreateInput: NotificationReviewIdFkeyReviewCreateInput;
  UserOnNotificationForNotificationUserIdFkeyNodeIdUpdate: UserOnNotificationForNotificationUserIdFkeyNodeIdUpdate;
  NotificationUserIdFkeyNotificationCreateInput: NotificationUserIdFkeyNotificationCreateInput;
  UserOnNotificationForNotificationUserIdFkeyUsingUserUsernameKeyUpdate: UserOnNotificationForNotificationUserIdFkeyUsingUserUsernameKeyUpdate;
  NotificationOnNotificationForNotificationUserIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationUserIdFkeyNodeIdUpdate;
  UserPatch: UserPatch;
  NotificationUserIdFkeyUserCreateInput: NotificationUserIdFkeyUserCreateInput;
  ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate;
  NotificationApplicationIdFkeyNotificationCreateInput: NotificationApplicationIdFkeyNotificationCreateInput;
  ApplicationOnFileForFileApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnFileForFileApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  FileOnFileForFileApplicationIdFkeyNodeIdUpdate: FileOnFileForFileApplicationIdFkeyNodeIdUpdate;
  FileApplicationIdFkeyApplicationCreateInput: FileApplicationIdFkeyApplicationCreateInput;
  UserOnFileForFileUserIdFkeyNodeIdUpdate: UserOnFileForFileUserIdFkeyNodeIdUpdate;
  FileUserIdFkeyFileCreateInput: FileUserIdFkeyFileCreateInput;
  UserOnReviewForReviewReviewerIdFkeyUsingUserUsernameKeyUpdate: UserOnReviewForReviewReviewerIdFkeyUsingUserUsernameKeyUpdate;
  ReviewOnReviewForReviewReviewerIdFkeyNodeIdUpdate: ReviewOnReviewForReviewReviewerIdFkeyNodeIdUpdate;
  ReviewReviewerIdFkeyUserCreateInput: ReviewReviewerIdFkeyUserCreateInput;
  UserOnReviewForReviewReviewerIdFkeyNodeIdUpdate: UserOnReviewForReviewReviewerIdFkeyNodeIdUpdate;
  ReviewReviewerIdFkeyReviewCreateInput: ReviewReviewerIdFkeyReviewCreateInput;
  UserOnFileForFileUserIdFkeyUsingUserUsernameKeyUpdate: UserOnFileForFileUserIdFkeyUsingUserUsernameKeyUpdate;
  FileOnFileForFileUserIdFkeyNodeIdUpdate: FileOnFileForFileUserIdFkeyNodeIdUpdate;
  FileUserIdFkeyUserCreateInput: FileUserIdFkeyUserCreateInput;
  ApplicationOnFileForFileApplicationIdFkeyNodeIdUpdate: ApplicationOnFileForFileApplicationIdFkeyNodeIdUpdate;
  FileApplicationIdFkeyFileCreateInput: FileApplicationIdFkeyFileCreateInput;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate: ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate;
  ReviewApplicationIdFkeyApplicationCreateInput: ReviewApplicationIdFkeyApplicationCreateInput;
  ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewReviewAssignmentIdFkeyReviewCreateInput: ReviewReviewAssignmentIdFkeyReviewCreateInput;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput: ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput;
  ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate: ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate;
  ReviewApplicationIdFkeyReviewCreateInput: ReviewApplicationIdFkeyReviewCreateInput;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate;
  ReviewAssignmentApplicationIdFkeyApplicationCreateInput: ReviewAssignmentApplicationIdFkeyApplicationCreateInput;
  TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate: TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate;
  ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput: ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate;
  TemplateStagePatch: TemplateStagePatch;
  ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput: ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput;
  ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect: ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect;
  ApplicationStatusHistoryNodeIdConnect: ApplicationStatusHistoryNodeIdConnect;
  ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete: ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete;
  ApplicationStatusHistoryNodeIdDelete: ApplicationStatusHistoryNodeIdDelete;
  ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate: ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate;
  updateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch: UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput;
  ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  updateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate: ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate;
  ApplicationStageHistoryPatch: ApplicationStageHistoryPatch;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput;
  ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate;
  ApplicationStatusHistoryPatch: ApplicationStatusHistoryPatch;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput;
  TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate: TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate;
  ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput: ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate;
  ReviewAssignmentStageIdFkeyTemplateStageCreateInput: ReviewAssignmentStageIdFkeyTemplateStageCreateInput;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate;
  ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput: ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate;
  OrganisationPatch: OrganisationPatch;
  ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput: ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput;
  UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate: UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate;
  ReviewAssignmentReviewerIdFkeyReviewAssignmentCreateInput: ReviewAssignmentReviewerIdFkeyReviewAssignmentCreateInput;
  UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserUsernameKeyUpdate: UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserUsernameKeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate;
  ReviewAssignmentReviewerIdFkeyUserCreateInput: ReviewAssignmentReviewerIdFkeyUserCreateInput;
  UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate: UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate;
  ReviewAssignmentAssignerIdFkeyReviewAssignmentCreateInput: ReviewAssignmentAssignerIdFkeyReviewAssignmentCreateInput;
  UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserUsernameKeyUpdate: UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserUsernameKeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate;
  ReviewAssignmentAssignerIdFkeyUserCreateInput: ReviewAssignmentAssignerIdFkeyUserCreateInput;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate;
  ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput: ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate;
  ApplicationResponseApplicationIdFkeyApplicationCreateInput: ApplicationResponseApplicationIdFkeyApplicationCreateInput;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate;
  ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput: ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate;
  TemplateElementSectionIdFkeyTemplateElementCreateInput: TemplateElementSectionIdFkeyTemplateElementCreateInput;
  ApplicationSectionTemplateSectionIdFkeyInverseInput: ApplicationSectionTemplateSectionIdFkeyInverseInput;
  ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingApplicationSectionPkeyUpdate: ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingApplicationSectionPkeyUpdate;
  updateApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch: UpdateApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch;
  ApplicationSectionTemplateSectionIdFkeyInput: ApplicationSectionTemplateSectionIdFkeyInput;
  TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingTemplateSectionPkeyUpdate;
  updateTemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch: UpdateTemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch;
  ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate: ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate;
  TemplateSectionPatch: TemplateSectionPatch;
  ApplicationSectionTemplateSectionIdFkeyTemplateSectionCreateInput: ApplicationSectionTemplateSectionIdFkeyTemplateSectionCreateInput;
  TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate: TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate;
  ApplicationSectionPatch: ApplicationSectionPatch;
  ApplicationSectionTemplateSectionIdFkeyApplicationSectionCreateInput: ApplicationSectionTemplateSectionIdFkeyApplicationSectionCreateInput;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate;
  TemplateElementSectionIdFkeyTemplateSectionCreateInput: TemplateElementSectionIdFkeyTemplateSectionCreateInput;
  ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate;
  ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput: ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate;
  ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput: ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate;
  ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput: ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate;
  ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput: ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput;
  ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate: ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate;
  ApplicationSectionApplicationIdFkeyApplicationCreateInput: ApplicationSectionApplicationIdFkeyApplicationCreateInput;
  ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate;
  ApplicationSectionApplicationIdFkeyApplicationSectionCreateInput: ApplicationSectionApplicationIdFkeyApplicationSectionCreateInput;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate;
  OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate;
  ApplicationOrgIdFkeyApplicationCreateInput: ApplicationOrgIdFkeyApplicationCreateInput;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate;
  ApplicationOrgIdFkeyOrganisationCreateInput: ApplicationOrgIdFkeyOrganisationCreateInput;
  ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationSerialKeyUpdate;
  UserOnApplicationForApplicationUserIdFkeyNodeIdUpdate: UserOnApplicationForApplicationUserIdFkeyNodeIdUpdate;
  ApplicationUserIdFkeyApplicationCreateInput: ApplicationUserIdFkeyApplicationCreateInput;
  UserOnApplicationForApplicationUserIdFkeyUsingUserUsernameKeyUpdate: UserOnApplicationForApplicationUserIdFkeyUsingUserUsernameKeyUpdate;
  ApplicationOnApplicationForApplicationUserIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationUserIdFkeyNodeIdUpdate;
  ApplicationUserIdFkeyUserCreateInput: ApplicationUserIdFkeyUserCreateInput;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate;
  TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate;
  ApplicationTemplateIdFkeyApplicationCreateInput: ApplicationTemplateIdFkeyApplicationCreateInput;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate;
  TemplatePermissionTemplateIdFkeyTemplateCreateInput: TemplatePermissionTemplateIdFkeyTemplateCreateInput;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate;
  TemplatePermissionPatch: TemplatePermissionPatch;
  TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput: TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate;
  PermissionNamePatch: PermissionNamePatch;
  PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput: PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate;
  PermissionJoinPatch: PermissionJoinPatch;
  PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput: PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate: UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate;
  UserOrganisationOrganisationIdFkeyOrganisationCreateInput: UserOrganisationOrganisationIdFkeyOrganisationCreateInput;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate;
  UserOrganisationPatch: UserOrganisationPatch;
  UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput: UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate;
  PermissionJoinOrganisationIdFkeyOrganisationCreateInput: PermissionJoinOrganisationIdFkeyOrganisationCreateInput;
  UserOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate: UserOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate;
  PermissionJoinUserIdFkeyPermissionJoinCreateInput: PermissionJoinUserIdFkeyPermissionJoinCreateInput;
  UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserUsernameKeyUpdate: UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserUsernameKeyUpdate;
  UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate: UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate;
  UserOrganisationUserIdFkeyUserCreateInput: UserOrganisationUserIdFkeyUserCreateInput;
  UserOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate: UserOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate;
  UserOrganisationUserIdFkeyUserOrganisationCreateInput: UserOrganisationUserIdFkeyUserOrganisationCreateInput;
  UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserUsernameKeyUpdate: UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserUsernameKeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate;
  PermissionJoinUserIdFkeyUserCreateInput: PermissionJoinUserIdFkeyUserCreateInput;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate;
  PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput: PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate;
  PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput: PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate;
  PermissionPolicyPatch: PermissionPolicyPatch;
  PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput: PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate;
  TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput: TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate;
  TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput: TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate;
  TemplateSectionTemplateIdFkeyTemplateCreateInput: TemplateSectionTemplateIdFkeyTemplateCreateInput;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate;
  TemplateSectionTemplateIdFkeyTemplateSectionCreateInput: TemplateSectionTemplateIdFkeyTemplateSectionCreateInput;
  TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate: TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate;
  TemplateStageTemplateIdFkeyTemplateCreateInput: TemplateStageTemplateIdFkeyTemplateCreateInput;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate;
  TemplateStageTemplateIdFkeyTemplateStageCreateInput: TemplateStageTemplateIdFkeyTemplateStageCreateInput;
  ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate;
  ActionQueueTemplateIdFkeyTemplateCreateInput: ActionQueueTemplateIdFkeyTemplateCreateInput;
  TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate: TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate;
  ActionQueueTriggerEventFkeyActionQueueCreateInput: ActionQueueTriggerEventFkeyActionQueueCreateInput;
  ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate;
  TriggerQueuePatch: TriggerQueuePatch;
  ActionQueueTriggerEventFkeyTriggerQueueCreateInput: ActionQueueTriggerEventFkeyTriggerQueueCreateInput;
  CreateActionQueuePayload: ResolverTypeWrapper<CreateActionQueuePayload>;
  CreateApplicationInput: CreateApplicationInput;
  ApplicationInput: ApplicationInput;
  CreateApplicationPayload: ResolverTypeWrapper<CreateApplicationPayload>;
  CreateApplicationResponseInput: CreateApplicationResponseInput;
  ApplicationResponseInput: ApplicationResponseInput;
  CreateApplicationResponsePayload: ResolverTypeWrapper<CreateApplicationResponsePayload>;
  CreateApplicationSectionInput: CreateApplicationSectionInput;
  ApplicationSectionInput: ApplicationSectionInput;
  CreateApplicationSectionPayload: ResolverTypeWrapper<CreateApplicationSectionPayload>;
  CreateApplicationStageHistoryInput: CreateApplicationStageHistoryInput;
  ApplicationStageHistoryInput: ApplicationStageHistoryInput;
  CreateApplicationStageHistoryPayload: ResolverTypeWrapper<CreateApplicationStageHistoryPayload>;
  CreateApplicationStatusHistoryInput: CreateApplicationStatusHistoryInput;
  ApplicationStatusHistoryInput: ApplicationStatusHistoryInput;
  CreateApplicationStatusHistoryPayload: ResolverTypeWrapper<CreateApplicationStatusHistoryPayload>;
  CreateElementTypePluginInput: CreateElementTypePluginInput;
  ElementTypePluginInput: ElementTypePluginInput;
  CreateElementTypePluginPayload: ResolverTypeWrapper<CreateElementTypePluginPayload>;
  CreateFileInput: CreateFileInput;
  FileInput: FileInput;
  CreateFilePayload: ResolverTypeWrapper<CreateFilePayload>;
  CreateNotificationInput: CreateNotificationInput;
  NotificationInput: NotificationInput;
  CreateNotificationPayload: ResolverTypeWrapper<CreateNotificationPayload>;
  CreateOrganisationInput: CreateOrganisationInput;
  OrganisationInput: OrganisationInput;
  CreateOrganisationPayload: ResolverTypeWrapper<CreateOrganisationPayload>;
  CreatePermissionJoinInput: CreatePermissionJoinInput;
  PermissionJoinInput: PermissionJoinInput;
  CreatePermissionJoinPayload: ResolverTypeWrapper<CreatePermissionJoinPayload>;
  CreatePermissionNameInput: CreatePermissionNameInput;
  PermissionNameInput: PermissionNameInput;
  CreatePermissionNamePayload: ResolverTypeWrapper<CreatePermissionNamePayload>;
  CreatePermissionPolicyInput: CreatePermissionPolicyInput;
  PermissionPolicyInput: PermissionPolicyInput;
  CreatePermissionPolicyPayload: ResolverTypeWrapper<CreatePermissionPolicyPayload>;
  CreateReviewInput: CreateReviewInput;
  ReviewInput: ReviewInput;
  CreateReviewPayload: ResolverTypeWrapper<CreateReviewPayload>;
  CreateReviewAssignmentInput: CreateReviewAssignmentInput;
  ReviewAssignmentInput: ReviewAssignmentInput;
  CreateReviewAssignmentPayload: ResolverTypeWrapper<CreateReviewAssignmentPayload>;
  CreateReviewDecisionInput: CreateReviewDecisionInput;
  ReviewDecisionInput: ReviewDecisionInput;
  CreateReviewDecisionPayload: ResolverTypeWrapper<CreateReviewDecisionPayload>;
  CreateReviewQuestionAssignmentInput: CreateReviewQuestionAssignmentInput;
  ReviewQuestionAssignmentInput: ReviewQuestionAssignmentInput;
  CreateReviewQuestionAssignmentPayload: ResolverTypeWrapper<CreateReviewQuestionAssignmentPayload>;
  CreateReviewResponseInput: CreateReviewResponseInput;
  ReviewResponseInput: ReviewResponseInput;
  CreateReviewResponsePayload: ResolverTypeWrapper<CreateReviewResponsePayload>;
  CreateReviewStatusHistoryInput: CreateReviewStatusHistoryInput;
  ReviewStatusHistoryInput: ReviewStatusHistoryInput;
  CreateReviewStatusHistoryPayload: ResolverTypeWrapper<CreateReviewStatusHistoryPayload>;
  CreateTemplateInput: CreateTemplateInput;
  TemplateInput: TemplateInput;
  CreateTemplatePayload: ResolverTypeWrapper<CreateTemplatePayload>;
  CreateTemplateActionInput: CreateTemplateActionInput;
  TemplateActionInput: TemplateActionInput;
  CreateTemplateActionPayload: ResolverTypeWrapper<CreateTemplateActionPayload>;
  CreateTemplateElementInput: CreateTemplateElementInput;
  TemplateElementInput: TemplateElementInput;
  CreateTemplateElementPayload: ResolverTypeWrapper<CreateTemplateElementPayload>;
  CreateTemplatePermissionInput: CreateTemplatePermissionInput;
  TemplatePermissionInput: TemplatePermissionInput;
  CreateTemplatePermissionPayload: ResolverTypeWrapper<CreateTemplatePermissionPayload>;
  CreateTemplateSectionInput: CreateTemplateSectionInput;
  TemplateSectionInput: TemplateSectionInput;
  CreateTemplateSectionPayload: ResolverTypeWrapper<CreateTemplateSectionPayload>;
  CreateTemplateStageInput: CreateTemplateStageInput;
  TemplateStageInput: TemplateStageInput;
  CreateTemplateStagePayload: ResolverTypeWrapper<CreateTemplateStagePayload>;
  CreateTriggerQueueInput: CreateTriggerQueueInput;
  TriggerQueueInput: TriggerQueueInput;
  CreateTriggerQueuePayload: ResolverTypeWrapper<CreateTriggerQueuePayload>;
  CreateUserInput: CreateUserInput;
  UserInput: UserInput;
  CreateUserPayload: ResolverTypeWrapper<CreateUserPayload>;
  CreateUserOrganisationInput: CreateUserOrganisationInput;
  UserOrganisationInput: UserOrganisationInput;
  CreateUserOrganisationPayload: ResolverTypeWrapper<CreateUserOrganisationPayload>;
  UpdateActionPluginByNodeIdInput: UpdateActionPluginByNodeIdInput;
  ActionPluginPatch: ActionPluginPatch;
  UpdateActionPluginPayload: ResolverTypeWrapper<UpdateActionPluginPayload>;
  UpdateActionPluginInput: UpdateActionPluginInput;
  UpdateActionQueueByNodeIdInput: UpdateActionQueueByNodeIdInput;
  UpdateActionQueuePayload: ResolverTypeWrapper<UpdateActionQueuePayload>;
  UpdateActionQueueInput: UpdateActionQueueInput;
  UpdateApplicationByNodeIdInput: UpdateApplicationByNodeIdInput;
  UpdateApplicationPayload: ResolverTypeWrapper<UpdateApplicationPayload>;
  UpdateApplicationInput: UpdateApplicationInput;
  UpdateApplicationBySerialInput: UpdateApplicationBySerialInput;
  UpdateApplicationResponseByNodeIdInput: UpdateApplicationResponseByNodeIdInput;
  UpdateApplicationResponsePayload: ResolverTypeWrapper<UpdateApplicationResponsePayload>;
  UpdateApplicationResponseInput: UpdateApplicationResponseInput;
  UpdateApplicationSectionByNodeIdInput: UpdateApplicationSectionByNodeIdInput;
  UpdateApplicationSectionPayload: ResolverTypeWrapper<UpdateApplicationSectionPayload>;
  UpdateApplicationSectionInput: UpdateApplicationSectionInput;
  UpdateApplicationStageHistoryByNodeIdInput: UpdateApplicationStageHistoryByNodeIdInput;
  UpdateApplicationStageHistoryPayload: ResolverTypeWrapper<UpdateApplicationStageHistoryPayload>;
  UpdateApplicationStageHistoryInput: UpdateApplicationStageHistoryInput;
  UpdateApplicationStatusHistoryByNodeIdInput: UpdateApplicationStatusHistoryByNodeIdInput;
  UpdateApplicationStatusHistoryPayload: ResolverTypeWrapper<UpdateApplicationStatusHistoryPayload>;
  UpdateApplicationStatusHistoryInput: UpdateApplicationStatusHistoryInput;
  UpdateElementTypePluginByNodeIdInput: UpdateElementTypePluginByNodeIdInput;
  ElementTypePluginPatch: ElementTypePluginPatch;
  UpdateElementTypePluginPayload: ResolverTypeWrapper<UpdateElementTypePluginPayload>;
  UpdateElementTypePluginInput: UpdateElementTypePluginInput;
  UpdateFileByNodeIdInput: UpdateFileByNodeIdInput;
  UpdateFilePayload: ResolverTypeWrapper<UpdateFilePayload>;
  UpdateFileInput: UpdateFileInput;
  UpdateNotificationByNodeIdInput: UpdateNotificationByNodeIdInput;
  UpdateNotificationPayload: ResolverTypeWrapper<UpdateNotificationPayload>;
  UpdateNotificationInput: UpdateNotificationInput;
  UpdateOrganisationByNodeIdInput: UpdateOrganisationByNodeIdInput;
  UpdateOrganisationPayload: ResolverTypeWrapper<UpdateOrganisationPayload>;
  UpdateOrganisationInput: UpdateOrganisationInput;
  UpdateOrganisationByNameInput: UpdateOrganisationByNameInput;
  UpdatePermissionJoinByNodeIdInput: UpdatePermissionJoinByNodeIdInput;
  UpdatePermissionJoinPayload: ResolverTypeWrapper<UpdatePermissionJoinPayload>;
  UpdatePermissionJoinInput: UpdatePermissionJoinInput;
  UpdatePermissionNameByNodeIdInput: UpdatePermissionNameByNodeIdInput;
  UpdatePermissionNamePayload: ResolverTypeWrapper<UpdatePermissionNamePayload>;
  UpdatePermissionNameInput: UpdatePermissionNameInput;
  UpdatePermissionNameByNameInput: UpdatePermissionNameByNameInput;
  UpdatePermissionPolicyByNodeIdInput: UpdatePermissionPolicyByNodeIdInput;
  UpdatePermissionPolicyPayload: ResolverTypeWrapper<UpdatePermissionPolicyPayload>;
  UpdatePermissionPolicyInput: UpdatePermissionPolicyInput;
  UpdateReviewByNodeIdInput: UpdateReviewByNodeIdInput;
  UpdateReviewPayload: ResolverTypeWrapper<UpdateReviewPayload>;
  UpdateReviewInput: UpdateReviewInput;
  UpdateReviewAssignmentByNodeIdInput: UpdateReviewAssignmentByNodeIdInput;
  UpdateReviewAssignmentPayload: ResolverTypeWrapper<UpdateReviewAssignmentPayload>;
  UpdateReviewAssignmentInput: UpdateReviewAssignmentInput;
  UpdateReviewDecisionByNodeIdInput: UpdateReviewDecisionByNodeIdInput;
  UpdateReviewDecisionPayload: ResolverTypeWrapper<UpdateReviewDecisionPayload>;
  UpdateReviewDecisionInput: UpdateReviewDecisionInput;
  UpdateReviewQuestionAssignmentByNodeIdInput: UpdateReviewQuestionAssignmentByNodeIdInput;
  UpdateReviewQuestionAssignmentPayload: ResolverTypeWrapper<UpdateReviewQuestionAssignmentPayload>;
  UpdateReviewQuestionAssignmentInput: UpdateReviewQuestionAssignmentInput;
  UpdateReviewResponseByNodeIdInput: UpdateReviewResponseByNodeIdInput;
  UpdateReviewResponsePayload: ResolverTypeWrapper<UpdateReviewResponsePayload>;
  UpdateReviewResponseInput: UpdateReviewResponseInput;
  UpdateReviewStatusHistoryByNodeIdInput: UpdateReviewStatusHistoryByNodeIdInput;
  UpdateReviewStatusHistoryPayload: ResolverTypeWrapper<UpdateReviewStatusHistoryPayload>;
  UpdateReviewStatusHistoryInput: UpdateReviewStatusHistoryInput;
  UpdateTemplateByNodeIdInput: UpdateTemplateByNodeIdInput;
  UpdateTemplatePayload: ResolverTypeWrapper<UpdateTemplatePayload>;
  UpdateTemplateInput: UpdateTemplateInput;
  UpdateTemplateActionByNodeIdInput: UpdateTemplateActionByNodeIdInput;
  UpdateTemplateActionPayload: ResolverTypeWrapper<UpdateTemplateActionPayload>;
  UpdateTemplateActionInput: UpdateTemplateActionInput;
  UpdateTemplateElementByNodeIdInput: UpdateTemplateElementByNodeIdInput;
  UpdateTemplateElementPayload: ResolverTypeWrapper<UpdateTemplateElementPayload>;
  UpdateTemplateElementInput: UpdateTemplateElementInput;
  UpdateTemplatePermissionByNodeIdInput: UpdateTemplatePermissionByNodeIdInput;
  UpdateTemplatePermissionPayload: ResolverTypeWrapper<UpdateTemplatePermissionPayload>;
  UpdateTemplatePermissionInput: UpdateTemplatePermissionInput;
  UpdateTemplateSectionByNodeIdInput: UpdateTemplateSectionByNodeIdInput;
  UpdateTemplateSectionPayload: ResolverTypeWrapper<UpdateTemplateSectionPayload>;
  UpdateTemplateSectionInput: UpdateTemplateSectionInput;
  UpdateTemplateStageByNodeIdInput: UpdateTemplateStageByNodeIdInput;
  UpdateTemplateStagePayload: ResolverTypeWrapper<UpdateTemplateStagePayload>;
  UpdateTemplateStageInput: UpdateTemplateStageInput;
  UpdateTriggerQueueByNodeIdInput: UpdateTriggerQueueByNodeIdInput;
  UpdateTriggerQueuePayload: ResolverTypeWrapper<UpdateTriggerQueuePayload>;
  UpdateTriggerQueueInput: UpdateTriggerQueueInput;
  UpdateUserByNodeIdInput: UpdateUserByNodeIdInput;
  UpdateUserPayload: ResolverTypeWrapper<UpdateUserPayload>;
  UpdateUserInput: UpdateUserInput;
  UpdateUserByUsernameInput: UpdateUserByUsernameInput;
  UpdateUserOrganisationByNodeIdInput: UpdateUserOrganisationByNodeIdInput;
  UpdateUserOrganisationPayload: ResolverTypeWrapper<UpdateUserOrganisationPayload>;
  UpdateUserOrganisationInput: UpdateUserOrganisationInput;
  DeleteActionPluginByNodeIdInput: DeleteActionPluginByNodeIdInput;
  DeleteActionPluginPayload: ResolverTypeWrapper<DeleteActionPluginPayload>;
  DeleteActionPluginInput: DeleteActionPluginInput;
  DeleteActionQueueByNodeIdInput: DeleteActionQueueByNodeIdInput;
  DeleteActionQueuePayload: ResolverTypeWrapper<DeleteActionQueuePayload>;
  DeleteActionQueueInput: DeleteActionQueueInput;
  DeleteApplicationByNodeIdInput: DeleteApplicationByNodeIdInput;
  DeleteApplicationPayload: ResolverTypeWrapper<DeleteApplicationPayload>;
  DeleteApplicationInput: DeleteApplicationInput;
  DeleteApplicationBySerialInput: DeleteApplicationBySerialInput;
  DeleteApplicationResponseByNodeIdInput: DeleteApplicationResponseByNodeIdInput;
  DeleteApplicationResponsePayload: ResolverTypeWrapper<DeleteApplicationResponsePayload>;
  DeleteApplicationResponseInput: DeleteApplicationResponseInput;
  DeleteApplicationSectionByNodeIdInput: DeleteApplicationSectionByNodeIdInput;
  DeleteApplicationSectionPayload: ResolverTypeWrapper<DeleteApplicationSectionPayload>;
  DeleteApplicationSectionInput: DeleteApplicationSectionInput;
  DeleteApplicationStageHistoryByNodeIdInput: DeleteApplicationStageHistoryByNodeIdInput;
  DeleteApplicationStageHistoryPayload: ResolverTypeWrapper<DeleteApplicationStageHistoryPayload>;
  DeleteApplicationStageHistoryInput: DeleteApplicationStageHistoryInput;
  DeleteApplicationStatusHistoryByNodeIdInput: DeleteApplicationStatusHistoryByNodeIdInput;
  DeleteApplicationStatusHistoryPayload: ResolverTypeWrapper<DeleteApplicationStatusHistoryPayload>;
  DeleteApplicationStatusHistoryInput: DeleteApplicationStatusHistoryInput;
  DeleteElementTypePluginByNodeIdInput: DeleteElementTypePluginByNodeIdInput;
  DeleteElementTypePluginPayload: ResolverTypeWrapper<DeleteElementTypePluginPayload>;
  DeleteElementTypePluginInput: DeleteElementTypePluginInput;
  DeleteFileByNodeIdInput: DeleteFileByNodeIdInput;
  DeleteFilePayload: ResolverTypeWrapper<DeleteFilePayload>;
  DeleteFileInput: DeleteFileInput;
  DeleteNotificationByNodeIdInput: DeleteNotificationByNodeIdInput;
  DeleteNotificationPayload: ResolverTypeWrapper<DeleteNotificationPayload>;
  DeleteNotificationInput: DeleteNotificationInput;
  DeleteOrganisationByNodeIdInput: DeleteOrganisationByNodeIdInput;
  DeleteOrganisationPayload: ResolverTypeWrapper<DeleteOrganisationPayload>;
  DeleteOrganisationInput: DeleteOrganisationInput;
  DeleteOrganisationByNameInput: DeleteOrganisationByNameInput;
  DeletePermissionJoinByNodeIdInput: DeletePermissionJoinByNodeIdInput;
  DeletePermissionJoinPayload: ResolverTypeWrapper<DeletePermissionJoinPayload>;
  DeletePermissionJoinInput: DeletePermissionJoinInput;
  DeletePermissionNameByNodeIdInput: DeletePermissionNameByNodeIdInput;
  DeletePermissionNamePayload: ResolverTypeWrapper<DeletePermissionNamePayload>;
  DeletePermissionNameInput: DeletePermissionNameInput;
  DeletePermissionNameByNameInput: DeletePermissionNameByNameInput;
  DeletePermissionPolicyByNodeIdInput: DeletePermissionPolicyByNodeIdInput;
  DeletePermissionPolicyPayload: ResolverTypeWrapper<DeletePermissionPolicyPayload>;
  DeletePermissionPolicyInput: DeletePermissionPolicyInput;
  DeleteReviewByNodeIdInput: DeleteReviewByNodeIdInput;
  DeleteReviewPayload: ResolverTypeWrapper<DeleteReviewPayload>;
  DeleteReviewInput: DeleteReviewInput;
  DeleteReviewAssignmentByNodeIdInput: DeleteReviewAssignmentByNodeIdInput;
  DeleteReviewAssignmentPayload: ResolverTypeWrapper<DeleteReviewAssignmentPayload>;
  DeleteReviewAssignmentInput: DeleteReviewAssignmentInput;
  DeleteReviewDecisionByNodeIdInput: DeleteReviewDecisionByNodeIdInput;
  DeleteReviewDecisionPayload: ResolverTypeWrapper<DeleteReviewDecisionPayload>;
  DeleteReviewDecisionInput: DeleteReviewDecisionInput;
  DeleteReviewQuestionAssignmentByNodeIdInput: DeleteReviewQuestionAssignmentByNodeIdInput;
  DeleteReviewQuestionAssignmentPayload: ResolverTypeWrapper<DeleteReviewQuestionAssignmentPayload>;
  DeleteReviewQuestionAssignmentInput: DeleteReviewQuestionAssignmentInput;
  DeleteReviewResponseByNodeIdInput: DeleteReviewResponseByNodeIdInput;
  DeleteReviewResponsePayload: ResolverTypeWrapper<DeleteReviewResponsePayload>;
  DeleteReviewResponseInput: DeleteReviewResponseInput;
  DeleteReviewStatusHistoryByNodeIdInput: DeleteReviewStatusHistoryByNodeIdInput;
  DeleteReviewStatusHistoryPayload: ResolverTypeWrapper<DeleteReviewStatusHistoryPayload>;
  DeleteReviewStatusHistoryInput: DeleteReviewStatusHistoryInput;
  DeleteTemplateByNodeIdInput: DeleteTemplateByNodeIdInput;
  DeleteTemplatePayload: ResolverTypeWrapper<DeleteTemplatePayload>;
  DeleteTemplateInput: DeleteTemplateInput;
  DeleteTemplateActionByNodeIdInput: DeleteTemplateActionByNodeIdInput;
  DeleteTemplateActionPayload: ResolverTypeWrapper<DeleteTemplateActionPayload>;
  DeleteTemplateActionInput: DeleteTemplateActionInput;
  DeleteTemplateElementByNodeIdInput: DeleteTemplateElementByNodeIdInput;
  DeleteTemplateElementPayload: ResolverTypeWrapper<DeleteTemplateElementPayload>;
  DeleteTemplateElementInput: DeleteTemplateElementInput;
  DeleteTemplatePermissionByNodeIdInput: DeleteTemplatePermissionByNodeIdInput;
  DeleteTemplatePermissionPayload: ResolverTypeWrapper<DeleteTemplatePermissionPayload>;
  DeleteTemplatePermissionInput: DeleteTemplatePermissionInput;
  DeleteTemplateSectionByNodeIdInput: DeleteTemplateSectionByNodeIdInput;
  DeleteTemplateSectionPayload: ResolverTypeWrapper<DeleteTemplateSectionPayload>;
  DeleteTemplateSectionInput: DeleteTemplateSectionInput;
  DeleteTemplateStageByNodeIdInput: DeleteTemplateStageByNodeIdInput;
  DeleteTemplateStagePayload: ResolverTypeWrapper<DeleteTemplateStagePayload>;
  DeleteTemplateStageInput: DeleteTemplateStageInput;
  DeleteTriggerQueueByNodeIdInput: DeleteTriggerQueueByNodeIdInput;
  DeleteTriggerQueuePayload: ResolverTypeWrapper<DeleteTriggerQueuePayload>;
  DeleteTriggerQueueInput: DeleteTriggerQueueInput;
  DeleteUserByNodeIdInput: DeleteUserByNodeIdInput;
  DeleteUserPayload: ResolverTypeWrapper<DeleteUserPayload>;
  DeleteUserInput: DeleteUserInput;
  DeleteUserByUsernameInput: DeleteUserByUsernameInput;
  DeleteUserOrganisationByNodeIdInput: DeleteUserOrganisationByNodeIdInput;
  DeleteUserOrganisationPayload: ResolverTypeWrapper<DeleteUserOrganisationPayload>;
  DeleteUserOrganisationInput: DeleteUserOrganisationInput;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  Query: {};
  Node: ResolversParentTypes['Query'] | ResolversParentTypes['ActionPlugin'] | ResolversParentTypes['ActionQueue'] | ResolversParentTypes['TriggerQueue'] | ResolversParentTypes['Template'] | ResolversParentTypes['TemplateStage'] | ResolversParentTypes['ApplicationStageHistory'] | ResolversParentTypes['Application'] | ResolversParentTypes['User'] | ResolversParentTypes['UserOrganisation'] | ResolversParentTypes['Organisation'] | ResolversParentTypes['PermissionJoin'] | ResolversParentTypes['PermissionName'] | ResolversParentTypes['PermissionPolicy'] | ResolversParentTypes['TemplatePermission'] | ResolversParentTypes['ReviewAssignment'] | ResolversParentTypes['Review'] | ResolversParentTypes['ReviewResponse'] | ResolversParentTypes['ReviewQuestionAssignment'] | ResolversParentTypes['TemplateElement'] | ResolversParentTypes['TemplateSection'] | ResolversParentTypes['ApplicationSection'] | ResolversParentTypes['ApplicationResponse'] | ResolversParentTypes['File'] | ResolversParentTypes['Notification'] | ResolversParentTypes['ReviewDecision'] | ResolversParentTypes['ReviewStatusHistory'] | ResolversParentTypes['ApplicationStatusHistory'] | ResolversParentTypes['TemplateAction'] | ResolversParentTypes['ElementTypePlugin'];
  ID: Scalars['ID'];
  Int: Scalars['Int'];
  Cursor: Scalars['Cursor'];
  ActionPluginCondition: ActionPluginCondition;
  String: Scalars['String'];
  ActionPluginFilter: ActionPluginFilter;
  StringFilter: StringFilter;
  Boolean: Scalars['Boolean'];
  StringListFilter: StringListFilter;
  ActionPluginsConnection: ActionPluginsConnection;
  ActionPlugin: ActionPlugin;
  ActionPluginsEdge: ActionPluginsEdge;
  PageInfo: PageInfo;
  ActionQueueCondition: ActionQueueCondition;
  JSON: Scalars['JSON'];
  Datetime: Scalars['Datetime'];
  ActionQueueFilter: ActionQueueFilter;
  IntFilter: IntFilter;
  JSONFilter: JsonFilter;
  ActionQueueStatusFilter: ActionQueueStatusFilter;
  DatetimeFilter: DatetimeFilter;
  TriggerQueueFilter: TriggerQueueFilter;
  TriggerFilter: TriggerFilter;
  TriggerQueueStatusFilter: TriggerQueueStatusFilter;
  TriggerQueueToManyActionQueueFilter: TriggerQueueToManyActionQueueFilter;
  TemplateFilter: TemplateFilter;
  BooleanFilter: BooleanFilter;
  TemplateStatusFilter: TemplateStatusFilter;
  TemplateToManyTemplateStageFilter: TemplateToManyTemplateStageFilter;
  TemplateStageFilter: TemplateStageFilter;
  TemplateStageToManyApplicationStageHistoryFilter: TemplateStageToManyApplicationStageHistoryFilter;
  ApplicationStageHistoryFilter: ApplicationStageHistoryFilter;
  ApplicationStageHistoryToManyApplicationStatusHistoryFilter: ApplicationStageHistoryToManyApplicationStatusHistoryFilter;
  ApplicationStatusHistoryFilter: ApplicationStatusHistoryFilter;
  ApplicationStatusFilter: ApplicationStatusFilter;
  ApplicationFilter: ApplicationFilter;
  ApplicationOutcomeFilter: ApplicationOutcomeFilter;
  ApplicationToManyApplicationSectionFilter: ApplicationToManyApplicationSectionFilter;
  ApplicationSectionFilter: ApplicationSectionFilter;
  TemplateSectionFilter: TemplateSectionFilter;
  TemplateSectionToManyTemplateElementFilter: TemplateSectionToManyTemplateElementFilter;
  TemplateElementFilter: TemplateElementFilter;
  TemplateElementCategoryFilter: TemplateElementCategoryFilter;
  TemplateElementToManyApplicationResponseFilter: TemplateElementToManyApplicationResponseFilter;
  ApplicationResponseFilter: ApplicationResponseFilter;
  ApplicationResponseToManyReviewResponseFilter: ApplicationResponseToManyReviewResponseFilter;
  ReviewResponseFilter: ReviewResponseFilter;
  ReviewResponseDecisionFilter: ReviewResponseDecisionFilter;
  ReviewResponseRecommendedApplicantVisibilityFilter: ReviewResponseRecommendedApplicantVisibilityFilter;
  ReviewResponseStatusFilter: ReviewResponseStatusFilter;
  ReviewResponseToManyReviewResponseFilter: ReviewResponseToManyReviewResponseFilter;
  ReviewQuestionAssignmentFilter: ReviewQuestionAssignmentFilter;
  ReviewQuestionAssignmentToManyReviewResponseFilter: ReviewQuestionAssignmentToManyReviewResponseFilter;
  ReviewAssignmentFilter: ReviewAssignmentFilter;
  ReviewAssignmentStatusFilter: ReviewAssignmentStatusFilter;
  ReviewAssignmentToManyReviewFilter: ReviewAssignmentToManyReviewFilter;
  ReviewFilter: ReviewFilter;
  ReviewStatusFilter: ReviewStatusFilter;
  ReviewToManyReviewResponseFilter: ReviewToManyReviewResponseFilter;
  ReviewToManyReviewDecisionFilter: ReviewToManyReviewDecisionFilter;
  ReviewDecisionFilter: ReviewDecisionFilter;
  DecisionFilter: DecisionFilter;
  ReviewToManyReviewStatusHistoryFilter: ReviewToManyReviewStatusHistoryFilter;
  ReviewStatusHistoryFilter: ReviewStatusHistoryFilter;
  ReviewToManyNotificationFilter: ReviewToManyNotificationFilter;
  NotificationFilter: NotificationFilter;
  UserFilter: UserFilter;
  DateFilter: DateFilter;
  Date: Scalars['Date'];
  UserToManyUserOrganisationFilter: UserToManyUserOrganisationFilter;
  UserOrganisationFilter: UserOrganisationFilter;
  OrganisationFilter: OrganisationFilter;
  OrganisationToManyUserOrganisationFilter: OrganisationToManyUserOrganisationFilter;
  OrganisationToManyPermissionJoinFilter: OrganisationToManyPermissionJoinFilter;
  PermissionJoinFilter: PermissionJoinFilter;
  PermissionNameFilter: PermissionNameFilter;
  PermissionNameToManyPermissionJoinFilter: PermissionNameToManyPermissionJoinFilter;
  PermissionNameToManyTemplatePermissionFilter: PermissionNameToManyTemplatePermissionFilter;
  TemplatePermissionFilter: TemplatePermissionFilter;
  PermissionPolicyFilter: PermissionPolicyFilter;
  PermissionPolicyTypeFilter: PermissionPolicyTypeFilter;
  PermissionPolicyToManyPermissionNameFilter: PermissionPolicyToManyPermissionNameFilter;
  OrganisationToManyApplicationFilter: OrganisationToManyApplicationFilter;
  OrganisationToManyReviewAssignmentFilter: OrganisationToManyReviewAssignmentFilter;
  UserToManyPermissionJoinFilter: UserToManyPermissionJoinFilter;
  UserToManyApplicationFilter: UserToManyApplicationFilter;
  UserToManyReviewAssignmentFilter: UserToManyReviewAssignmentFilter;
  UserToManyReviewFilter: UserToManyReviewFilter;
  UserToManyFileFilter: UserToManyFileFilter;
  FileFilter: FileFilter;
  FileToManyNotificationFilter: FileToManyNotificationFilter;
  UserToManyNotificationFilter: UserToManyNotificationFilter;
  ReviewAssignmentToManyReviewQuestionAssignmentFilter: ReviewAssignmentToManyReviewQuestionAssignmentFilter;
  ApplicationResponseToManyFileFilter: ApplicationResponseToManyFileFilter;
  TemplateElementToManyReviewQuestionAssignmentFilter: TemplateElementToManyReviewQuestionAssignmentFilter;
  TemplateElementToManyReviewResponseFilter: TemplateElementToManyReviewResponseFilter;
  TemplateSectionToManyApplicationSectionFilter: TemplateSectionToManyApplicationSectionFilter;
  ApplicationToManyApplicationStageHistoryFilter: ApplicationToManyApplicationStageHistoryFilter;
  ApplicationToManyApplicationResponseFilter: ApplicationToManyApplicationResponseFilter;
  ApplicationToManyReviewAssignmentFilter: ApplicationToManyReviewAssignmentFilter;
  ApplicationToManyReviewFilter: ApplicationToManyReviewFilter;
  ApplicationToManyFileFilter: ApplicationToManyFileFilter;
  ApplicationToManyNotificationFilter: ApplicationToManyNotificationFilter;
  TemplateStageToManyReviewAssignmentFilter: TemplateStageToManyReviewAssignmentFilter;
  TemplateToManyTemplateSectionFilter: TemplateToManyTemplateSectionFilter;
  TemplateToManyTemplatePermissionFilter: TemplateToManyTemplatePermissionFilter;
  TemplateToManyApplicationFilter: TemplateToManyApplicationFilter;
  TemplateToManyActionQueueFilter: TemplateToManyActionQueueFilter;
  TemplateToManyTemplateActionFilter: TemplateToManyTemplateActionFilter;
  TemplateActionFilter: TemplateActionFilter;
  ActionQueuesConnection: ActionQueuesConnection;
  ActionQueue: ActionQueue;
  TriggerQueue: TriggerQueue;
  Template: Template;
  TemplateStageCondition: TemplateStageCondition;
  TemplateStagesConnection: TemplateStagesConnection;
  TemplateStage: TemplateStage;
  ApplicationStageHistoryCondition: ApplicationStageHistoryCondition;
  ApplicationStageHistoriesConnection: ApplicationStageHistoriesConnection;
  ApplicationStageHistory: ApplicationStageHistory;
  Application: Application;
  User: User;
  UserOrganisationCondition: UserOrganisationCondition;
  UserOrganisationsConnection: UserOrganisationsConnection;
  UserOrganisation: UserOrganisation;
  Organisation: Organisation;
  PermissionJoinCondition: PermissionJoinCondition;
  PermissionJoinsConnection: PermissionJoinsConnection;
  PermissionJoin: PermissionJoin;
  PermissionName: PermissionName;
  PermissionPolicy: PermissionPolicy;
  PermissionNameCondition: PermissionNameCondition;
  PermissionNamesConnection: PermissionNamesConnection;
  PermissionNamesEdge: PermissionNamesEdge;
  TemplatePermissionCondition: TemplatePermissionCondition;
  TemplatePermissionsConnection: TemplatePermissionsConnection;
  TemplatePermission: TemplatePermission;
  TemplatePermissionsEdge: TemplatePermissionsEdge;
  PermissionJoinsEdge: PermissionJoinsEdge;
  ApplicationCondition: ApplicationCondition;
  ApplicationsConnection: ApplicationsConnection;
  ApplicationsEdge: ApplicationsEdge;
  ReviewAssignmentCondition: ReviewAssignmentCondition;
  ReviewAssignmentsConnection: ReviewAssignmentsConnection;
  ReviewAssignment: ReviewAssignment;
  ReviewCondition: ReviewCondition;
  ReviewsConnection: ReviewsConnection;
  Review: Review;
  ReviewResponseCondition: ReviewResponseCondition;
  ReviewResponsesConnection: ReviewResponsesConnection;
  ReviewResponse: ReviewResponse;
  ReviewQuestionAssignment: ReviewQuestionAssignment;
  TemplateElement: TemplateElement;
  TemplateSection: TemplateSection;
  TemplateElementCondition: TemplateElementCondition;
  TemplateElementsConnection: TemplateElementsConnection;
  TemplateElementsEdge: TemplateElementsEdge;
  ApplicationSectionCondition: ApplicationSectionCondition;
  ApplicationSectionsConnection: ApplicationSectionsConnection;
  ApplicationSection: ApplicationSection;
  ApplicationSectionsEdge: ApplicationSectionsEdge;
  ApplicationResponseCondition: ApplicationResponseCondition;
  ApplicationResponsesConnection: ApplicationResponsesConnection;
  ApplicationResponse: ApplicationResponse;
  FileCondition: FileCondition;
  FilesConnection: FilesConnection;
  File: File;
  NotificationCondition: NotificationCondition;
  NotificationsConnection: NotificationsConnection;
  Notification: Notification;
  NotificationsEdge: NotificationsEdge;
  FilesEdge: FilesEdge;
  ApplicationResponsesEdge: ApplicationResponsesEdge;
  ReviewQuestionAssignmentCondition: ReviewQuestionAssignmentCondition;
  ReviewQuestionAssignmentsConnection: ReviewQuestionAssignmentsConnection;
  ReviewQuestionAssignmentsEdge: ReviewQuestionAssignmentsEdge;
  ReviewResponsesEdge: ReviewResponsesEdge;
  ReviewDecisionCondition: ReviewDecisionCondition;
  ReviewDecisionsConnection: ReviewDecisionsConnection;
  ReviewDecision: ReviewDecision;
  ReviewDecisionsEdge: ReviewDecisionsEdge;
  ReviewStatusHistoryCondition: ReviewStatusHistoryCondition;
  ReviewStatusHistoriesConnection: ReviewStatusHistoriesConnection;
  ReviewStatusHistory: ReviewStatusHistory;
  ReviewStatusHistoriesEdge: ReviewStatusHistoriesEdge;
  ReviewsEdge: ReviewsEdge;
  ReviewAssignmentsEdge: ReviewAssignmentsEdge;
  UserOrganisationsEdge: UserOrganisationsEdge;
  ApplicationStatusHistoryCondition: ApplicationStatusHistoryCondition;
  ApplicationStatusHistoriesConnection: ApplicationStatusHistoriesConnection;
  ApplicationStatusHistory: ApplicationStatusHistory;
  ApplicationStatusHistoriesEdge: ApplicationStatusHistoriesEdge;
  ApplicationStageHistoriesEdge: ApplicationStageHistoriesEdge;
  TemplateStagesEdge: TemplateStagesEdge;
  TemplateSectionCondition: TemplateSectionCondition;
  TemplateSectionsConnection: TemplateSectionsConnection;
  TemplateSectionsEdge: TemplateSectionsEdge;
  TemplateActionCondition: TemplateActionCondition;
  TemplateActionsConnection: TemplateActionsConnection;
  TemplateAction: TemplateAction;
  TemplateActionsEdge: TemplateActionsEdge;
  ActionQueuesEdge: ActionQueuesEdge;
  AllPermissionCondition: AllPermissionCondition;
  AllPermissionFilter: AllPermissionFilter;
  AllPermissionsConnection: AllPermissionsConnection;
  AllPermission: AllPermission;
  AllPermissionsEdge: AllPermissionsEdge;
  ApplicationListCondition: ApplicationListCondition;
  ApplicationListFilter: ApplicationListFilter;
  ApplicationListsConnection: ApplicationListsConnection;
  ApplicationList: ApplicationList;
  ApplicationListsEdge: ApplicationListsEdge;
  ApplicationStageStatusAllCondition: ApplicationStageStatusAllCondition;
  ApplicationStageStatusAllFilter: ApplicationStageStatusAllFilter;
  ApplicationStageStatusAllsConnection: ApplicationStageStatusAllsConnection;
  ApplicationStageStatusAll: ApplicationStageStatusAll;
  ApplicationStageStatusAllsEdge: ApplicationStageStatusAllsEdge;
  ApplicationStageStatusLatestCondition: ApplicationStageStatusLatestCondition;
  ApplicationStageStatusLatestFilter: ApplicationStageStatusLatestFilter;
  ApplicationStageStatusLatestsConnection: ApplicationStageStatusLatestsConnection;
  ApplicationStageStatusLatest: ApplicationStageStatusLatest;
  ApplicationStageStatusLatestsEdge: ApplicationStageStatusLatestsEdge;
  ApplicationTriggerStateCondition: ApplicationTriggerStateCondition;
  ApplicationTriggerStateFilter: ApplicationTriggerStateFilter;
  ApplicationTriggerStatesConnection: ApplicationTriggerStatesConnection;
  ApplicationTriggerState: ApplicationTriggerState;
  ApplicationTriggerStatesEdge: ApplicationTriggerStatesEdge;
  ElementTypePluginCondition: ElementTypePluginCondition;
  ElementTypePluginFilter: ElementTypePluginFilter;
  ElementTypePluginsConnection: ElementTypePluginsConnection;
  ElementTypePlugin: ElementTypePlugin;
  ElementTypePluginsEdge: ElementTypePluginsEdge;
  OrganisationCondition: OrganisationCondition;
  OrganisationsConnection: OrganisationsConnection;
  OrganisationsEdge: OrganisationsEdge;
  PermissionPolicyCondition: PermissionPolicyCondition;
  PermissionPoliciesConnection: PermissionPoliciesConnection;
  PermissionPoliciesEdge: PermissionPoliciesEdge;
  TemplateCondition: TemplateCondition;
  TemplatesConnection: TemplatesConnection;
  TemplatesEdge: TemplatesEdge;
  TriggerQueueCondition: TriggerQueueCondition;
  TriggerQueuesConnection: TriggerQueuesConnection;
  TriggerQueuesEdge: TriggerQueuesEdge;
  UserCondition: UserCondition;
  UsersConnection: UsersConnection;
  UsersEdge: UsersEdge;
  UserOrgJoinCondition: UserOrgJoinCondition;
  UserOrgJoinFilter: UserOrgJoinFilter;
  UserOrgJoinsConnection: UserOrgJoinsConnection;
  UserOrgJoin: UserOrgJoin;
  UserOrgJoinsEdge: UserOrgJoinsEdge;
  BigInt: Scalars['BigInt'];
  Mutation: {};
  CreateActionPluginInput: CreateActionPluginInput;
  ActionPluginInput: ActionPluginInput;
  CreateActionPluginPayload: CreateActionPluginPayload;
  CreateActionQueueInput: CreateActionQueueInput;
  ActionQueueInput: ActionQueueInput;
  ActionQueueTriggerEventFkeyInput: ActionQueueTriggerEventFkeyInput;
  TriggerQueueTriggerQueuePkeyConnect: TriggerQueueTriggerQueuePkeyConnect;
  TriggerQueueNodeIdConnect: TriggerQueueNodeIdConnect;
  TriggerQueueTriggerQueuePkeyDelete: TriggerQueueTriggerQueuePkeyDelete;
  TriggerQueueNodeIdDelete: TriggerQueueNodeIdDelete;
  TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate: TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate;
  updateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch: UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  ActionQueueTriggerEventFkeyInverseInput: ActionQueueTriggerEventFkeyInverseInput;
  ActionQueueActionQueuePkeyConnect: ActionQueueActionQueuePkeyConnect;
  ActionQueueNodeIdConnect: ActionQueueNodeIdConnect;
  ActionQueueActionQueuePkeyDelete: ActionQueueActionQueuePkeyDelete;
  ActionQueueNodeIdDelete: ActionQueueNodeIdDelete;
  ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate;
  updateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  ActionQueueTemplateIdFkeyInput: ActionQueueTemplateIdFkeyInput;
  TemplateTemplatePkeyConnect: TemplateTemplatePkeyConnect;
  TemplateNodeIdConnect: TemplateNodeIdConnect;
  TemplateTemplatePkeyDelete: TemplateTemplatePkeyDelete;
  TemplateNodeIdDelete: TemplateNodeIdDelete;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
  TemplateStageTemplateIdFkeyInverseInput: TemplateStageTemplateIdFkeyInverseInput;
  TemplateStageTemplateStagePkeyConnect: TemplateStageTemplateStagePkeyConnect;
  TemplateStageNodeIdConnect: TemplateStageNodeIdConnect;
  TemplateStageTemplateStagePkeyDelete: TemplateStageTemplateStagePkeyDelete;
  TemplateStageNodeIdDelete: TemplateStageNodeIdDelete;
  TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate;
  updateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch: UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  TemplateStageTemplateIdFkeyInput: TemplateStageTemplateIdFkeyInput;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  TemplateSectionTemplateIdFkeyInverseInput: TemplateSectionTemplateIdFkeyInverseInput;
  TemplateSectionTemplateSectionPkeyConnect: TemplateSectionTemplateSectionPkeyConnect;
  TemplateSectionNodeIdConnect: TemplateSectionNodeIdConnect;
  TemplateSectionTemplateSectionPkeyDelete: TemplateSectionTemplateSectionPkeyDelete;
  TemplateSectionNodeIdDelete: TemplateSectionNodeIdDelete;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate;
  updateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  TemplateSectionTemplateIdFkeyInput: TemplateSectionTemplateIdFkeyInput;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  TemplatePermissionTemplateIdFkeyInverseInput: TemplatePermissionTemplateIdFkeyInverseInput;
  TemplatePermissionTemplatePermissionPkeyConnect: TemplatePermissionTemplatePermissionPkeyConnect;
  TemplatePermissionNodeIdConnect: TemplatePermissionNodeIdConnect;
  TemplatePermissionTemplatePermissionPkeyDelete: TemplatePermissionTemplatePermissionPkeyDelete;
  TemplatePermissionNodeIdDelete: TemplatePermissionNodeIdDelete;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate;
  updateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  TemplatePermissionPermissionNameIdFkeyInput: TemplatePermissionPermissionNameIdFkeyInput;
  PermissionNamePermissionNamePkeyConnect: PermissionNamePermissionNamePkeyConnect;
  PermissionNamePermissionNameNameKeyConnect: PermissionNamePermissionNameNameKeyConnect;
  PermissionNameNodeIdConnect: PermissionNameNodeIdConnect;
  PermissionNamePermissionNamePkeyDelete: PermissionNamePermissionNamePkeyDelete;
  PermissionNamePermissionNameNameKeyDelete: PermissionNamePermissionNameNameKeyDelete;
  PermissionNameNodeIdDelete: PermissionNameNodeIdDelete;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate;
  updatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  PermissionNamePermissionPolicyIdFkeyInput: PermissionNamePermissionPolicyIdFkeyInput;
  PermissionPolicyPermissionPolicyPkeyConnect: PermissionPolicyPermissionPolicyPkeyConnect;
  PermissionPolicyNodeIdConnect: PermissionPolicyNodeIdConnect;
  PermissionPolicyPermissionPolicyPkeyDelete: PermissionPolicyPermissionPolicyPkeyDelete;
  PermissionPolicyNodeIdDelete: PermissionPolicyNodeIdDelete;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate;
  updatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  PermissionNamePermissionPolicyIdFkeyInverseInput: PermissionNamePermissionPolicyIdFkeyInverseInput;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate;
  updatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  PermissionJoinPermissionNameIdFkeyInverseInput: PermissionJoinPermissionNameIdFkeyInverseInput;
  PermissionJoinPermissionJoinPkeyConnect: PermissionJoinPermissionJoinPkeyConnect;
  PermissionJoinNodeIdConnect: PermissionJoinNodeIdConnect;
  PermissionJoinPermissionJoinPkeyDelete: PermissionJoinPermissionJoinPkeyDelete;
  PermissionJoinNodeIdDelete: PermissionJoinNodeIdDelete;
  PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate;
  updatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  PermissionJoinUserIdFkeyInput: PermissionJoinUserIdFkeyInput;
  UserUserPkeyConnect: UserUserPkeyConnect;
  UserUserUsernameKeyConnect: UserUserUsernameKeyConnect;
  UserNodeIdConnect: UserNodeIdConnect;
  UserUserPkeyDelete: UserUserPkeyDelete;
  UserUserUsernameKeyDelete: UserUserUsernameKeyDelete;
  UserNodeIdDelete: UserNodeIdDelete;
  UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserPkeyUpdate: UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch: UpdateUserOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
  UserOrganisationUserIdFkeyInverseInput: UserOrganisationUserIdFkeyInverseInput;
  UserOrganisationUserOrganisationPkeyConnect: UserOrganisationUserOrganisationPkeyConnect;
  UserOrganisationNodeIdConnect: UserOrganisationNodeIdConnect;
  UserOrganisationUserOrganisationPkeyDelete: UserOrganisationUserOrganisationPkeyDelete;
  UserOrganisationNodeIdDelete: UserOrganisationNodeIdDelete;
  UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationPkeyUpdate: UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserOrganisationPkeyUpdate;
  updateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  UserOrganisationUserIdFkeyInput: UserOrganisationUserIdFkeyInput;
  UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserPkeyUpdate: UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch: UpdateUserOnUserOrganisationForUserOrganisationUserIdFkeyPatch;
  PermissionJoinUserIdFkeyInverseInput: PermissionJoinUserIdFkeyInverseInput;
  PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyUsingPermissionJoinPkeyUpdate;
  updatePermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyPatch;
  PermissionJoinOrganisationIdFkeyInput: PermissionJoinOrganisationIdFkeyInput;
  OrganisationOrganisationPkeyConnect: OrganisationOrganisationPkeyConnect;
  OrganisationOrganisationNameKeyConnect: OrganisationOrganisationNameKeyConnect;
  OrganisationNodeIdConnect: OrganisationNodeIdConnect;
  OrganisationOrganisationPkeyDelete: OrganisationOrganisationPkeyDelete;
  OrganisationOrganisationNameKeyDelete: OrganisationOrganisationNameKeyDelete;
  OrganisationNodeIdDelete: OrganisationNodeIdDelete;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  updateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  UserOrganisationOrganisationIdFkeyInverseInput: UserOrganisationOrganisationIdFkeyInverseInput;
  UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate: UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate;
  updateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  UserOrganisationOrganisationIdFkeyInput: UserOrganisationOrganisationIdFkeyInput;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  updateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  PermissionJoinOrganisationIdFkeyInverseInput: PermissionJoinOrganisationIdFkeyInverseInput;
  PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate;
  updatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  PermissionJoinPermissionNameIdFkeyInput: PermissionJoinPermissionNameIdFkeyInput;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate;
  updatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  TemplatePermissionPermissionNameIdFkeyInverseInput: TemplatePermissionPermissionNameIdFkeyInverseInput;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate;
  updateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  TemplatePermissionTemplateIdFkeyInput: TemplatePermissionTemplateIdFkeyInput;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  ApplicationTemplateIdFkeyInverseInput: ApplicationTemplateIdFkeyInverseInput;
  ApplicationApplicationPkeyConnect: ApplicationApplicationPkeyConnect;
  ApplicationApplicationSerialKeyConnect: ApplicationApplicationSerialKeyConnect;
  ApplicationNodeIdConnect: ApplicationNodeIdConnect;
  ApplicationApplicationPkeyDelete: ApplicationApplicationPkeyDelete;
  ApplicationApplicationSerialKeyDelete: ApplicationApplicationSerialKeyDelete;
  ApplicationNodeIdDelete: ApplicationNodeIdDelete;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationForApplicationTemplateIdFkeyPatch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
  ApplicationTemplateIdFkeyInput: ApplicationTemplateIdFkeyInput;
  TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnApplicationForApplicationTemplateIdFkeyPatch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
  ActionQueueTemplateIdFkeyInverseInput: ActionQueueTemplateIdFkeyInverseInput;
  ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate;
  updateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate;
  ActionQueuePatch: ActionQueuePatch;
  ActionQueueTemplateIdFkeyActionQueueCreateInput: ActionQueueTemplateIdFkeyActionQueueCreateInput;
  TemplateActionTemplateIdFkeyInverseInput: TemplateActionTemplateIdFkeyInverseInput;
  TemplateActionTemplateActionPkeyConnect: TemplateActionTemplateActionPkeyConnect;
  TemplateActionNodeIdConnect: TemplateActionNodeIdConnect;
  TemplateActionTemplateActionPkeyDelete: TemplateActionTemplateActionPkeyDelete;
  TemplateActionNodeIdDelete: TemplateActionNodeIdDelete;
  TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate: TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate;
  updateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch: UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  TemplateActionTemplateIdFkeyInput: TemplateActionTemplateIdFkeyInput;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate;
  updateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate: TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate;
  TemplatePatch: TemplatePatch;
  TemplateActionTemplateIdFkeyTemplateCreateInput: TemplateActionTemplateIdFkeyTemplateCreateInput;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate;
  TemplateActionPatch: TemplateActionPatch;
  TemplateActionTemplateIdFkeyTemplateActionCreateInput: TemplateActionTemplateIdFkeyTemplateActionCreateInput;
  ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate;
  ApplicationTemplateIdFkeyTemplateCreateInput: ApplicationTemplateIdFkeyTemplateCreateInput;
  ApplicationUserIdFkeyInput: ApplicationUserIdFkeyInput;
  UserOnApplicationForApplicationUserIdFkeyUsingUserPkeyUpdate: UserOnApplicationForApplicationUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnApplicationForApplicationUserIdFkeyPatch: UpdateUserOnApplicationForApplicationUserIdFkeyPatch;
  ApplicationUserIdFkeyInverseInput: ApplicationUserIdFkeyInverseInput;
  ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationForApplicationUserIdFkeyPatch: UpdateApplicationOnApplicationForApplicationUserIdFkeyPatch;
  ApplicationOrgIdFkeyInput: ApplicationOrgIdFkeyInput;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate;
  updateOrganisationOnApplicationForApplicationOrgIdFkeyPatch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
  ApplicationOrgIdFkeyInverseInput: ApplicationOrgIdFkeyInverseInput;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationForApplicationOrgIdFkeyPatch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
  ApplicationSectionApplicationIdFkeyInverseInput: ApplicationSectionApplicationIdFkeyInverseInput;
  ApplicationSectionApplicationSectionPkeyConnect: ApplicationSectionApplicationSectionPkeyConnect;
  ApplicationSectionNodeIdConnect: ApplicationSectionNodeIdConnect;
  ApplicationSectionApplicationSectionPkeyDelete: ApplicationSectionApplicationSectionPkeyDelete;
  ApplicationSectionNodeIdDelete: ApplicationSectionNodeIdDelete;
  ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSectionPkeyUpdate: ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSectionPkeyUpdate;
  updateApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch: UpdateApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch;
  ApplicationSectionApplicationIdFkeyInput: ApplicationSectionApplicationIdFkeyInput;
  ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch: UpdateApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyPatch;
  ApplicationStageHistoryApplicationIdFkeyInverseInput: ApplicationStageHistoryApplicationIdFkeyInverseInput;
  ApplicationStageHistoryApplicationStageHistoryPkeyConnect: ApplicationStageHistoryApplicationStageHistoryPkeyConnect;
  ApplicationStageHistoryNodeIdConnect: ApplicationStageHistoryNodeIdConnect;
  ApplicationStageHistoryApplicationStageHistoryPkeyDelete: ApplicationStageHistoryApplicationStageHistoryPkeyDelete;
  ApplicationStageHistoryNodeIdDelete: ApplicationStageHistoryNodeIdDelete;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  updateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  ApplicationStageHistoryApplicationIdFkeyInput: ApplicationStageHistoryApplicationIdFkeyInput;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  ApplicationResponseApplicationIdFkeyInverseInput: ApplicationResponseApplicationIdFkeyInverseInput;
  ApplicationResponseApplicationResponsePkeyConnect: ApplicationResponseApplicationResponsePkeyConnect;
  ApplicationResponseNodeIdConnect: ApplicationResponseNodeIdConnect;
  ApplicationResponseApplicationResponsePkeyDelete: ApplicationResponseApplicationResponsePkeyDelete;
  ApplicationResponseNodeIdDelete: ApplicationResponseNodeIdDelete;
  ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate;
  updateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  ApplicationResponseTemplateElementIdFkeyInput: ApplicationResponseTemplateElementIdFkeyInput;
  TemplateElementTemplateElementPkeyConnect: TemplateElementTemplateElementPkeyConnect;
  TemplateElementNodeIdConnect: TemplateElementNodeIdConnect;
  TemplateElementTemplateElementPkeyDelete: TemplateElementTemplateElementPkeyDelete;
  TemplateElementNodeIdDelete: TemplateElementNodeIdDelete;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  updateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  TemplateElementSectionIdFkeyInput: TemplateElementSectionIdFkeyInput;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate;
  updateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  TemplateElementSectionIdFkeyInverseInput: TemplateElementSectionIdFkeyInverseInput;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate;
  updateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  ApplicationResponseTemplateElementIdFkeyInverseInput: ApplicationResponseTemplateElementIdFkeyInverseInput;
  ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate;
  updateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  ApplicationResponseApplicationIdFkeyInput: ApplicationResponseApplicationIdFkeyInput;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  ReviewAssignmentApplicationIdFkeyInverseInput: ReviewAssignmentApplicationIdFkeyInverseInput;
  ReviewAssignmentReviewAssignmentPkeyConnect: ReviewAssignmentReviewAssignmentPkeyConnect;
  ReviewAssignmentNodeIdConnect: ReviewAssignmentNodeIdConnect;
  ReviewAssignmentReviewAssignmentPkeyDelete: ReviewAssignmentReviewAssignmentPkeyDelete;
  ReviewAssignmentNodeIdDelete: ReviewAssignmentNodeIdDelete;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  ReviewAssignmentAssignerIdFkeyInput: ReviewAssignmentAssignerIdFkeyInput;
  UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserPkeyUpdate: UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserPkeyUpdate;
  updateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch: UpdateUserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
  ReviewAssignmentAssignerIdFkeyInverseInput: ReviewAssignmentAssignerIdFkeyInverseInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyPatch;
  ReviewAssignmentReviewerIdFkeyInput: ReviewAssignmentReviewerIdFkeyInput;
  UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserPkeyUpdate: UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserPkeyUpdate;
  updateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch: UpdateUserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
  ReviewAssignmentReviewerIdFkeyInverseInput: ReviewAssignmentReviewerIdFkeyInverseInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyPatch;
  ReviewAssignmentOrganisationIdFkeyInput: ReviewAssignmentOrganisationIdFkeyInput;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  updateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  ReviewAssignmentOrganisationIdFkeyInverseInput: ReviewAssignmentOrganisationIdFkeyInverseInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  ReviewAssignmentStageIdFkeyInput: ReviewAssignmentStageIdFkeyInput;
  TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate;
  updateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch: UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  ApplicationStageHistoryStageIdFkeyInverseInput: ApplicationStageHistoryStageIdFkeyInverseInput;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  updateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  ApplicationStageHistoryStageIdFkeyInput: ApplicationStageHistoryStageIdFkeyInput;
  TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate;
  updateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch: UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  ReviewAssignmentStageIdFkeyInverseInput: ReviewAssignmentStageIdFkeyInverseInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  ReviewAssignmentApplicationIdFkeyInput: ReviewAssignmentApplicationIdFkeyInput;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  ReviewApplicationIdFkeyInverseInput: ReviewApplicationIdFkeyInverseInput;
  ReviewReviewPkeyConnect: ReviewReviewPkeyConnect;
  ReviewNodeIdConnect: ReviewNodeIdConnect;
  ReviewReviewPkeyDelete: ReviewReviewPkeyDelete;
  ReviewNodeIdDelete: ReviewNodeIdDelete;
  ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewForReviewApplicationIdFkeyPatch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
  ReviewReviewAssignmentIdFkeyInput: ReviewReviewAssignmentIdFkeyInput;
  ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch;
  ReviewReviewAssignmentIdFkeyInverseInput: ReviewReviewAssignmentIdFkeyInverseInput;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
  ReviewApplicationIdFkeyInput: ReviewApplicationIdFkeyInput;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnReviewForReviewApplicationIdFkeyPatch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
  FileApplicationIdFkeyInverseInput: FileApplicationIdFkeyInverseInput;
  FileFilePkeyConnect: FileFilePkeyConnect;
  FileNodeIdConnect: FileNodeIdConnect;
  FileFilePkeyDelete: FileFilePkeyDelete;
  FileNodeIdDelete: FileNodeIdDelete;
  FileOnFileForFileApplicationIdFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationIdFkeyUsingFilePkeyUpdate;
  updateFileOnFileForFileApplicationIdFkeyPatch: UpdateFileOnFileForFileApplicationIdFkeyPatch;
  FileUserIdFkeyInput: FileUserIdFkeyInput;
  UserOnFileForFileUserIdFkeyUsingUserPkeyUpdate: UserOnFileForFileUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnFileForFileUserIdFkeyPatch: UpdateUserOnFileForFileUserIdFkeyPatch;
  ReviewReviewerIdFkeyInverseInput: ReviewReviewerIdFkeyInverseInput;
  ReviewOnReviewForReviewReviewerIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewReviewerIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewForReviewReviewerIdFkeyPatch: UpdateReviewOnReviewForReviewReviewerIdFkeyPatch;
  ReviewReviewerIdFkeyInput: ReviewReviewerIdFkeyInput;
  UserOnReviewForReviewReviewerIdFkeyUsingUserPkeyUpdate: UserOnReviewForReviewReviewerIdFkeyUsingUserPkeyUpdate;
  updateUserOnReviewForReviewReviewerIdFkeyPatch: UpdateUserOnReviewForReviewReviewerIdFkeyPatch;
  FileUserIdFkeyInverseInput: FileUserIdFkeyInverseInput;
  FileOnFileForFileUserIdFkeyUsingFilePkeyUpdate: FileOnFileForFileUserIdFkeyUsingFilePkeyUpdate;
  updateFileOnFileForFileUserIdFkeyPatch: UpdateFileOnFileForFileUserIdFkeyPatch;
  FileApplicationIdFkeyInput: FileApplicationIdFkeyInput;
  ApplicationOnFileForFileApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnFileForFileApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnFileForFileApplicationIdFkeyPatch: UpdateApplicationOnFileForFileApplicationIdFkeyPatch;
  NotificationApplicationIdFkeyInverseInput: NotificationApplicationIdFkeyInverseInput;
  NotificationNotificationPkeyConnect: NotificationNotificationPkeyConnect;
  NotificationNodeIdConnect: NotificationNodeIdConnect;
  NotificationNotificationPkeyDelete: NotificationNotificationPkeyDelete;
  NotificationNodeIdDelete: NotificationNodeIdDelete;
  NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate;
  updateNotificationOnNotificationForNotificationApplicationIdFkeyPatch: UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch;
  NotificationUserIdFkeyInput: NotificationUserIdFkeyInput;
  UserOnNotificationForNotificationUserIdFkeyUsingUserPkeyUpdate: UserOnNotificationForNotificationUserIdFkeyUsingUserPkeyUpdate;
  updateUserOnNotificationForNotificationUserIdFkeyPatch: UpdateUserOnNotificationForNotificationUserIdFkeyPatch;
  NotificationUserIdFkeyInverseInput: NotificationUserIdFkeyInverseInput;
  NotificationOnNotificationForNotificationUserIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationUserIdFkeyUsingNotificationPkeyUpdate;
  updateNotificationOnNotificationForNotificationUserIdFkeyPatch: UpdateNotificationOnNotificationForNotificationUserIdFkeyPatch;
  NotificationApplicationIdFkeyInput: NotificationApplicationIdFkeyInput;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate;
  updateApplicationOnNotificationForNotificationApplicationIdFkeyPatch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate;
  ApplicationPatch: ApplicationPatch;
  NotificationApplicationIdFkeyApplicationCreateInput: NotificationApplicationIdFkeyApplicationCreateInput;
  NotificationReviewIdFkeyInput: NotificationReviewIdFkeyInput;
  ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnNotificationForNotificationReviewIdFkeyPatch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
  ReviewResponseReviewIdFkeyInverseInput: ReviewResponseReviewIdFkeyInverseInput;
  ReviewResponseReviewResponsePkeyConnect: ReviewResponseReviewResponsePkeyConnect;
  ReviewResponseNodeIdConnect: ReviewResponseNodeIdConnect;
  ReviewResponseReviewResponsePkeyDelete: ReviewResponseReviewResponsePkeyDelete;
  ReviewResponseNodeIdDelete: ReviewResponseNodeIdDelete;
  ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  ReviewResponseReviewQuestionAssignmentIdFkeyInput: ReviewResponseReviewQuestionAssignmentIdFkeyInput;
  ReviewQuestionAssignmentReviewQuestionAssignmentPkeyConnect: ReviewQuestionAssignmentReviewQuestionAssignmentPkeyConnect;
  ReviewQuestionAssignmentNodeIdConnect: ReviewQuestionAssignmentNodeIdConnect;
  ReviewQuestionAssignmentReviewQuestionAssignmentPkeyDelete: ReviewQuestionAssignmentReviewQuestionAssignmentPkeyDelete;
  ReviewQuestionAssignmentNodeIdDelete: ReviewQuestionAssignmentNodeIdDelete;
  ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate: ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate;
  updateReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch: UpdateReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch;
  ReviewQuestionAssignmentTemplateElementIdFkeyInput: ReviewQuestionAssignmentTemplateElementIdFkeyInput;
  TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  updateTemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch: UpdateTemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch;
  ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput: ReviewQuestionAssignmentTemplateElementIdFkeyInverseInput;
  ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingReviewQuestionAssignmentPkeyUpdate: ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyUsingReviewQuestionAssignmentPkeyUpdate;
  updateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch: UpdateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyPatch;
  ReviewQuestionAssignmentReviewAssignmentIdFkeyInput: ReviewQuestionAssignmentReviewAssignmentIdFkeyInput;
  ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate;
  updateReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch;
  ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput: ReviewQuestionAssignmentReviewAssignmentIdFkeyInverseInput;
  ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate: ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyUsingReviewQuestionAssignmentPkeyUpdate;
  updateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch: UpdateReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyPatch;
  ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput: ReviewResponseReviewQuestionAssignmentIdFkeyInverseInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyPatch;
  ReviewResponseApplicationResponseIdFkeyInput: ReviewResponseApplicationResponseIdFkeyInput;
  ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate;
  updateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch: UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  ReviewResponseApplicationResponseIdFkeyInverseInput: ReviewResponseApplicationResponseIdFkeyInverseInput;
  ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  ReviewResponseReviewResponseLinkIdFkeyInput: ReviewResponseReviewResponseLinkIdFkeyInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch;
  ReviewResponseOriginalReviewResponseIdFkeyInput: ReviewResponseOriginalReviewResponseIdFkeyInput;
  ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch;
  ReviewResponseReviewIdFkeyInput: ReviewResponseReviewIdFkeyInput;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  ReviewDecisionReviewIdFkeyInverseInput: ReviewDecisionReviewIdFkeyInverseInput;
  ReviewDecisionReviewDecisionPkeyConnect: ReviewDecisionReviewDecisionPkeyConnect;
  ReviewDecisionNodeIdConnect: ReviewDecisionNodeIdConnect;
  ReviewDecisionReviewDecisionPkeyDelete: ReviewDecisionReviewDecisionPkeyDelete;
  ReviewDecisionNodeIdDelete: ReviewDecisionNodeIdDelete;
  ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate: ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate;
  updateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch: UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  ReviewDecisionReviewIdFkeyInput: ReviewDecisionReviewIdFkeyInput;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  ReviewStatusHistoryReviewIdFkeyInverseInput: ReviewStatusHistoryReviewIdFkeyInverseInput;
  ReviewStatusHistoryReviewStatusHistoryPkeyConnect: ReviewStatusHistoryReviewStatusHistoryPkeyConnect;
  ReviewStatusHistoryNodeIdConnect: ReviewStatusHistoryNodeIdConnect;
  ReviewStatusHistoryReviewStatusHistoryPkeyDelete: ReviewStatusHistoryReviewStatusHistoryPkeyDelete;
  ReviewStatusHistoryNodeIdDelete: ReviewStatusHistoryNodeIdDelete;
  ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate: ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate;
  updateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch: UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  ReviewStatusHistoryReviewIdFkeyInput: ReviewStatusHistoryReviewIdFkeyInput;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate;
  updateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  NotificationReviewIdFkeyInverseInput: NotificationReviewIdFkeyInverseInput;
  NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate;
  updateNotificationOnNotificationForNotificationReviewIdFkeyPatch: UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch;
  NotificationDocumentIdFkeyInput: NotificationDocumentIdFkeyInput;
  FileOnNotificationForNotificationDocumentIdFkeyUsingFilePkeyUpdate: FileOnNotificationForNotificationDocumentIdFkeyUsingFilePkeyUpdate;
  updateFileOnNotificationForNotificationDocumentIdFkeyPatch: UpdateFileOnNotificationForNotificationDocumentIdFkeyPatch;
  FileApplicationResponseIdFkeyInput: FileApplicationResponseIdFkeyInput;
  ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate;
  updateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch: UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch;
  FileApplicationResponseIdFkeyInverseInput: FileApplicationResponseIdFkeyInverseInput;
  FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate;
  updateFileOnFileForFileApplicationResponseIdFkeyPatch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
  NotificationDocumentIdFkeyInverseInput: NotificationDocumentIdFkeyInverseInput;
  NotificationOnNotificationForNotificationDocumentIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationDocumentIdFkeyUsingNotificationPkeyUpdate;
  updateNotificationOnNotificationForNotificationDocumentIdFkeyPatch: UpdateNotificationOnNotificationForNotificationDocumentIdFkeyPatch;
  FileOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate: FileOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate;
  NotificationPatch: NotificationPatch;
  NotificationDocumentIdFkeyNotificationCreateInput: NotificationDocumentIdFkeyNotificationCreateInput;
  ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate: ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate;
  FilePatch: FilePatch;
  FileApplicationResponseIdFkeyFileCreateInput: FileApplicationResponseIdFkeyFileCreateInput;
  FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate: FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate;
  ApplicationResponsePatch: ApplicationResponsePatch;
  FileApplicationResponseIdFkeyApplicationResponseCreateInput: FileApplicationResponseIdFkeyApplicationResponseCreateInput;
  NotificationOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationDocumentIdFkeyNodeIdUpdate;
  NotificationDocumentIdFkeyFileCreateInput: NotificationDocumentIdFkeyFileCreateInput;
  ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate: ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate;
  NotificationReviewIdFkeyNotificationCreateInput: NotificationReviewIdFkeyNotificationCreateInput;
  ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate: ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate;
  ReviewPatch: ReviewPatch;
  ReviewStatusHistoryReviewIdFkeyReviewCreateInput: ReviewStatusHistoryReviewIdFkeyReviewCreateInput;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate;
  ReviewStatusHistoryPatch: ReviewStatusHistoryPatch;
  ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput: ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput;
  ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate: ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate;
  ReviewDecisionReviewIdFkeyReviewCreateInput: ReviewDecisionReviewIdFkeyReviewCreateInput;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate;
  ReviewDecisionPatch: ReviewDecisionPatch;
  ReviewDecisionReviewIdFkeyReviewDecisionCreateInput: ReviewDecisionReviewIdFkeyReviewDecisionCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate;
  ReviewResponseReviewIdFkeyReviewCreateInput: ReviewResponseReviewIdFkeyReviewCreateInput;
  ReviewResponseTemplateElementIdFkeyInput: ReviewResponseTemplateElementIdFkeyInput;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  updateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  ReviewResponseTemplateElementIdFkeyInverseInput: ReviewResponseTemplateElementIdFkeyInverseInput;
  ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate;
  updateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate;
  ReviewResponsePatch: ReviewResponsePatch;
  ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput: ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate;
  TemplateElementPatch: TemplateElementPatch;
  ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput: ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate;
  ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput: ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate;
  ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput: ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput;
  ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate: ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate;
  ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput: ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate;
  ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput: ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput;
  ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate: ReviewQuestionAssignmentOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate;
  ReviewResponseReviewQuestionAssignmentIdFkeyReviewResponseCreateInput: ReviewResponseReviewQuestionAssignmentIdFkeyReviewResponseCreateInput;
  ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewQuestionAssignmentPatch: ReviewQuestionAssignmentPatch;
  ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewQuestionAssignmentCreateInput: ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewQuestionAssignmentCreateInput;
  ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate: ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewAssignmentPatch: ReviewAssignmentPatch;
  ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewAssignmentCreateInput: ReviewQuestionAssignmentReviewAssignmentIdFkeyReviewAssignmentCreateInput;
  TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate;
  ReviewQuestionAssignmentTemplateElementIdFkeyReviewQuestionAssignmentCreateInput: ReviewQuestionAssignmentTemplateElementIdFkeyReviewQuestionAssignmentCreateInput;
  ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate: ReviewQuestionAssignmentOnReviewQuestionAssignmentForReviewQuestionAssignmentTemplateElementIdFkeyNodeIdUpdate;
  ReviewQuestionAssignmentTemplateElementIdFkeyTemplateElementCreateInput: ReviewQuestionAssignmentTemplateElementIdFkeyTemplateElementCreateInput;
  ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewQuestionAssignmentIdFkeyNodeIdUpdate;
  ReviewResponseReviewQuestionAssignmentIdFkeyReviewQuestionAssignmentCreateInput: ReviewResponseReviewQuestionAssignmentIdFkeyReviewQuestionAssignmentCreateInput;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate;
  ReviewResponseReviewIdFkeyReviewResponseCreateInput: ReviewResponseReviewIdFkeyReviewResponseCreateInput;
  NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate;
  NotificationReviewIdFkeyReviewCreateInput: NotificationReviewIdFkeyReviewCreateInput;
  UserOnNotificationForNotificationUserIdFkeyNodeIdUpdate: UserOnNotificationForNotificationUserIdFkeyNodeIdUpdate;
  NotificationUserIdFkeyNotificationCreateInput: NotificationUserIdFkeyNotificationCreateInput;
  UserOnNotificationForNotificationUserIdFkeyUsingUserUsernameKeyUpdate: UserOnNotificationForNotificationUserIdFkeyUsingUserUsernameKeyUpdate;
  NotificationOnNotificationForNotificationUserIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationUserIdFkeyNodeIdUpdate;
  UserPatch: UserPatch;
  NotificationUserIdFkeyUserCreateInput: NotificationUserIdFkeyUserCreateInput;
  ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate;
  NotificationApplicationIdFkeyNotificationCreateInput: NotificationApplicationIdFkeyNotificationCreateInput;
  ApplicationOnFileForFileApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnFileForFileApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  FileOnFileForFileApplicationIdFkeyNodeIdUpdate: FileOnFileForFileApplicationIdFkeyNodeIdUpdate;
  FileApplicationIdFkeyApplicationCreateInput: FileApplicationIdFkeyApplicationCreateInput;
  UserOnFileForFileUserIdFkeyNodeIdUpdate: UserOnFileForFileUserIdFkeyNodeIdUpdate;
  FileUserIdFkeyFileCreateInput: FileUserIdFkeyFileCreateInput;
  UserOnReviewForReviewReviewerIdFkeyUsingUserUsernameKeyUpdate: UserOnReviewForReviewReviewerIdFkeyUsingUserUsernameKeyUpdate;
  ReviewOnReviewForReviewReviewerIdFkeyNodeIdUpdate: ReviewOnReviewForReviewReviewerIdFkeyNodeIdUpdate;
  ReviewReviewerIdFkeyUserCreateInput: ReviewReviewerIdFkeyUserCreateInput;
  UserOnReviewForReviewReviewerIdFkeyNodeIdUpdate: UserOnReviewForReviewReviewerIdFkeyNodeIdUpdate;
  ReviewReviewerIdFkeyReviewCreateInput: ReviewReviewerIdFkeyReviewCreateInput;
  UserOnFileForFileUserIdFkeyUsingUserUsernameKeyUpdate: UserOnFileForFileUserIdFkeyUsingUserUsernameKeyUpdate;
  FileOnFileForFileUserIdFkeyNodeIdUpdate: FileOnFileForFileUserIdFkeyNodeIdUpdate;
  FileUserIdFkeyUserCreateInput: FileUserIdFkeyUserCreateInput;
  ApplicationOnFileForFileApplicationIdFkeyNodeIdUpdate: ApplicationOnFileForFileApplicationIdFkeyNodeIdUpdate;
  FileApplicationIdFkeyFileCreateInput: FileApplicationIdFkeyFileCreateInput;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate: ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate;
  ReviewApplicationIdFkeyApplicationCreateInput: ReviewApplicationIdFkeyApplicationCreateInput;
  ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewReviewAssignmentIdFkeyReviewCreateInput: ReviewReviewAssignmentIdFkeyReviewCreateInput;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput: ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput;
  ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate: ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate;
  ReviewApplicationIdFkeyReviewCreateInput: ReviewApplicationIdFkeyReviewCreateInput;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate;
  ReviewAssignmentApplicationIdFkeyApplicationCreateInput: ReviewAssignmentApplicationIdFkeyApplicationCreateInput;
  TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate: TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate;
  ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput: ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate;
  TemplateStagePatch: TemplateStagePatch;
  ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput: ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput;
  ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect: ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect;
  ApplicationStatusHistoryNodeIdConnect: ApplicationStatusHistoryNodeIdConnect;
  ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete: ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete;
  ApplicationStatusHistoryNodeIdDelete: ApplicationStatusHistoryNodeIdDelete;
  ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate: ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate;
  updateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch: UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput;
  ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  updateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate: ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate;
  ApplicationStageHistoryPatch: ApplicationStageHistoryPatch;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput;
  ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate;
  ApplicationStatusHistoryPatch: ApplicationStatusHistoryPatch;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput;
  TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate: TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate;
  ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput: ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate;
  ReviewAssignmentStageIdFkeyTemplateStageCreateInput: ReviewAssignmentStageIdFkeyTemplateStageCreateInput;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate;
  ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput: ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate;
  OrganisationPatch: OrganisationPatch;
  ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput: ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput;
  UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate: UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate;
  ReviewAssignmentReviewerIdFkeyReviewAssignmentCreateInput: ReviewAssignmentReviewerIdFkeyReviewAssignmentCreateInput;
  UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserUsernameKeyUpdate: UserOnReviewAssignmentForReviewAssignmentReviewerIdFkeyUsingUserUsernameKeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentReviewerIdFkeyNodeIdUpdate;
  ReviewAssignmentReviewerIdFkeyUserCreateInput: ReviewAssignmentReviewerIdFkeyUserCreateInput;
  UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate: UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate;
  ReviewAssignmentAssignerIdFkeyReviewAssignmentCreateInput: ReviewAssignmentAssignerIdFkeyReviewAssignmentCreateInput;
  UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserUsernameKeyUpdate: UserOnReviewAssignmentForReviewAssignmentAssignerIdFkeyUsingUserUsernameKeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentAssignerIdFkeyNodeIdUpdate;
  ReviewAssignmentAssignerIdFkeyUserCreateInput: ReviewAssignmentAssignerIdFkeyUserCreateInput;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate;
  ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput: ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate;
  ApplicationResponseApplicationIdFkeyApplicationCreateInput: ApplicationResponseApplicationIdFkeyApplicationCreateInput;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate;
  ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput: ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate;
  TemplateElementSectionIdFkeyTemplateElementCreateInput: TemplateElementSectionIdFkeyTemplateElementCreateInput;
  ApplicationSectionTemplateSectionIdFkeyInverseInput: ApplicationSectionTemplateSectionIdFkeyInverseInput;
  ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingApplicationSectionPkeyUpdate: ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingApplicationSectionPkeyUpdate;
  updateApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch: UpdateApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch;
  ApplicationSectionTemplateSectionIdFkeyInput: ApplicationSectionTemplateSectionIdFkeyInput;
  TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyUsingTemplateSectionPkeyUpdate;
  updateTemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch: UpdateTemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyPatch;
  ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate: ApplicationSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate;
  TemplateSectionPatch: TemplateSectionPatch;
  ApplicationSectionTemplateSectionIdFkeyTemplateSectionCreateInput: ApplicationSectionTemplateSectionIdFkeyTemplateSectionCreateInput;
  TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate: TemplateSectionOnApplicationSectionForApplicationSectionTemplateSectionIdFkeyNodeIdUpdate;
  ApplicationSectionPatch: ApplicationSectionPatch;
  ApplicationSectionTemplateSectionIdFkeyApplicationSectionCreateInput: ApplicationSectionTemplateSectionIdFkeyApplicationSectionCreateInput;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate;
  TemplateElementSectionIdFkeyTemplateSectionCreateInput: TemplateElementSectionIdFkeyTemplateSectionCreateInput;
  ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate;
  ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput: ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate;
  ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput: ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate;
  ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput: ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate;
  ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput: ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput;
  ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate: ApplicationSectionOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate;
  ApplicationSectionApplicationIdFkeyApplicationCreateInput: ApplicationSectionApplicationIdFkeyApplicationCreateInput;
  ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationSectionForApplicationSectionApplicationIdFkeyNodeIdUpdate;
  ApplicationSectionApplicationIdFkeyApplicationSectionCreateInput: ApplicationSectionApplicationIdFkeyApplicationSectionCreateInput;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate;
  OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate;
  ApplicationOrgIdFkeyApplicationCreateInput: ApplicationOrgIdFkeyApplicationCreateInput;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate;
  ApplicationOrgIdFkeyOrganisationCreateInput: ApplicationOrgIdFkeyOrganisationCreateInput;
  ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationUserIdFkeyUsingApplicationSerialKeyUpdate;
  UserOnApplicationForApplicationUserIdFkeyNodeIdUpdate: UserOnApplicationForApplicationUserIdFkeyNodeIdUpdate;
  ApplicationUserIdFkeyApplicationCreateInput: ApplicationUserIdFkeyApplicationCreateInput;
  UserOnApplicationForApplicationUserIdFkeyUsingUserUsernameKeyUpdate: UserOnApplicationForApplicationUserIdFkeyUsingUserUsernameKeyUpdate;
  ApplicationOnApplicationForApplicationUserIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationUserIdFkeyNodeIdUpdate;
  ApplicationUserIdFkeyUserCreateInput: ApplicationUserIdFkeyUserCreateInput;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate;
  TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate;
  ApplicationTemplateIdFkeyApplicationCreateInput: ApplicationTemplateIdFkeyApplicationCreateInput;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate;
  TemplatePermissionTemplateIdFkeyTemplateCreateInput: TemplatePermissionTemplateIdFkeyTemplateCreateInput;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate;
  TemplatePermissionPatch: TemplatePermissionPatch;
  TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput: TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate;
  PermissionNamePatch: PermissionNamePatch;
  PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput: PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate;
  PermissionJoinPatch: PermissionJoinPatch;
  PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput: PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate: UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate;
  UserOrganisationOrganisationIdFkeyOrganisationCreateInput: UserOrganisationOrganisationIdFkeyOrganisationCreateInput;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate;
  UserOrganisationPatch: UserOrganisationPatch;
  UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput: UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate;
  PermissionJoinOrganisationIdFkeyOrganisationCreateInput: PermissionJoinOrganisationIdFkeyOrganisationCreateInput;
  UserOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate: UserOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate;
  PermissionJoinUserIdFkeyPermissionJoinCreateInput: PermissionJoinUserIdFkeyPermissionJoinCreateInput;
  UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserUsernameKeyUpdate: UserOnUserOrganisationForUserOrganisationUserIdFkeyUsingUserUsernameKeyUpdate;
  UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate: UserOrganisationOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate;
  UserOrganisationUserIdFkeyUserCreateInput: UserOrganisationUserIdFkeyUserCreateInput;
  UserOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate: UserOnUserOrganisationForUserOrganisationUserIdFkeyNodeIdUpdate;
  UserOrganisationUserIdFkeyUserOrganisationCreateInput: UserOrganisationUserIdFkeyUserOrganisationCreateInput;
  UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserUsernameKeyUpdate: UserOnPermissionJoinForPermissionJoinUserIdFkeyUsingUserUsernameKeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinUserIdFkeyNodeIdUpdate;
  PermissionJoinUserIdFkeyUserCreateInput: PermissionJoinUserIdFkeyUserCreateInput;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate;
  PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput: PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate;
  PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput: PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate;
  PermissionPolicyPatch: PermissionPolicyPatch;
  PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput: PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate;
  TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput: TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate;
  TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput: TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate;
  TemplateSectionTemplateIdFkeyTemplateCreateInput: TemplateSectionTemplateIdFkeyTemplateCreateInput;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate;
  TemplateSectionTemplateIdFkeyTemplateSectionCreateInput: TemplateSectionTemplateIdFkeyTemplateSectionCreateInput;
  TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate: TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate;
  TemplateStageTemplateIdFkeyTemplateCreateInput: TemplateStageTemplateIdFkeyTemplateCreateInput;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate;
  TemplateStageTemplateIdFkeyTemplateStageCreateInput: TemplateStageTemplateIdFkeyTemplateStageCreateInput;
  ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate;
  ActionQueueTemplateIdFkeyTemplateCreateInput: ActionQueueTemplateIdFkeyTemplateCreateInput;
  TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate: TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate;
  ActionQueueTriggerEventFkeyActionQueueCreateInput: ActionQueueTriggerEventFkeyActionQueueCreateInput;
  ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate;
  TriggerQueuePatch: TriggerQueuePatch;
  ActionQueueTriggerEventFkeyTriggerQueueCreateInput: ActionQueueTriggerEventFkeyTriggerQueueCreateInput;
  CreateActionQueuePayload: CreateActionQueuePayload;
  CreateApplicationInput: CreateApplicationInput;
  ApplicationInput: ApplicationInput;
  CreateApplicationPayload: CreateApplicationPayload;
  CreateApplicationResponseInput: CreateApplicationResponseInput;
  ApplicationResponseInput: ApplicationResponseInput;
  CreateApplicationResponsePayload: CreateApplicationResponsePayload;
  CreateApplicationSectionInput: CreateApplicationSectionInput;
  ApplicationSectionInput: ApplicationSectionInput;
  CreateApplicationSectionPayload: CreateApplicationSectionPayload;
  CreateApplicationStageHistoryInput: CreateApplicationStageHistoryInput;
  ApplicationStageHistoryInput: ApplicationStageHistoryInput;
  CreateApplicationStageHistoryPayload: CreateApplicationStageHistoryPayload;
  CreateApplicationStatusHistoryInput: CreateApplicationStatusHistoryInput;
  ApplicationStatusHistoryInput: ApplicationStatusHistoryInput;
  CreateApplicationStatusHistoryPayload: CreateApplicationStatusHistoryPayload;
  CreateElementTypePluginInput: CreateElementTypePluginInput;
  ElementTypePluginInput: ElementTypePluginInput;
  CreateElementTypePluginPayload: CreateElementTypePluginPayload;
  CreateFileInput: CreateFileInput;
  FileInput: FileInput;
  CreateFilePayload: CreateFilePayload;
  CreateNotificationInput: CreateNotificationInput;
  NotificationInput: NotificationInput;
  CreateNotificationPayload: CreateNotificationPayload;
  CreateOrganisationInput: CreateOrganisationInput;
  OrganisationInput: OrganisationInput;
  CreateOrganisationPayload: CreateOrganisationPayload;
  CreatePermissionJoinInput: CreatePermissionJoinInput;
  PermissionJoinInput: PermissionJoinInput;
  CreatePermissionJoinPayload: CreatePermissionJoinPayload;
  CreatePermissionNameInput: CreatePermissionNameInput;
  PermissionNameInput: PermissionNameInput;
  CreatePermissionNamePayload: CreatePermissionNamePayload;
  CreatePermissionPolicyInput: CreatePermissionPolicyInput;
  PermissionPolicyInput: PermissionPolicyInput;
  CreatePermissionPolicyPayload: CreatePermissionPolicyPayload;
  CreateReviewInput: CreateReviewInput;
  ReviewInput: ReviewInput;
  CreateReviewPayload: CreateReviewPayload;
  CreateReviewAssignmentInput: CreateReviewAssignmentInput;
  ReviewAssignmentInput: ReviewAssignmentInput;
  CreateReviewAssignmentPayload: CreateReviewAssignmentPayload;
  CreateReviewDecisionInput: CreateReviewDecisionInput;
  ReviewDecisionInput: ReviewDecisionInput;
  CreateReviewDecisionPayload: CreateReviewDecisionPayload;
  CreateReviewQuestionAssignmentInput: CreateReviewQuestionAssignmentInput;
  ReviewQuestionAssignmentInput: ReviewQuestionAssignmentInput;
  CreateReviewQuestionAssignmentPayload: CreateReviewQuestionAssignmentPayload;
  CreateReviewResponseInput: CreateReviewResponseInput;
  ReviewResponseInput: ReviewResponseInput;
  CreateReviewResponsePayload: CreateReviewResponsePayload;
  CreateReviewStatusHistoryInput: CreateReviewStatusHistoryInput;
  ReviewStatusHistoryInput: ReviewStatusHistoryInput;
  CreateReviewStatusHistoryPayload: CreateReviewStatusHistoryPayload;
  CreateTemplateInput: CreateTemplateInput;
  TemplateInput: TemplateInput;
  CreateTemplatePayload: CreateTemplatePayload;
  CreateTemplateActionInput: CreateTemplateActionInput;
  TemplateActionInput: TemplateActionInput;
  CreateTemplateActionPayload: CreateTemplateActionPayload;
  CreateTemplateElementInput: CreateTemplateElementInput;
  TemplateElementInput: TemplateElementInput;
  CreateTemplateElementPayload: CreateTemplateElementPayload;
  CreateTemplatePermissionInput: CreateTemplatePermissionInput;
  TemplatePermissionInput: TemplatePermissionInput;
  CreateTemplatePermissionPayload: CreateTemplatePermissionPayload;
  CreateTemplateSectionInput: CreateTemplateSectionInput;
  TemplateSectionInput: TemplateSectionInput;
  CreateTemplateSectionPayload: CreateTemplateSectionPayload;
  CreateTemplateStageInput: CreateTemplateStageInput;
  TemplateStageInput: TemplateStageInput;
  CreateTemplateStagePayload: CreateTemplateStagePayload;
  CreateTriggerQueueInput: CreateTriggerQueueInput;
  TriggerQueueInput: TriggerQueueInput;
  CreateTriggerQueuePayload: CreateTriggerQueuePayload;
  CreateUserInput: CreateUserInput;
  UserInput: UserInput;
  CreateUserPayload: CreateUserPayload;
  CreateUserOrganisationInput: CreateUserOrganisationInput;
  UserOrganisationInput: UserOrganisationInput;
  CreateUserOrganisationPayload: CreateUserOrganisationPayload;
  UpdateActionPluginByNodeIdInput: UpdateActionPluginByNodeIdInput;
  ActionPluginPatch: ActionPluginPatch;
  UpdateActionPluginPayload: UpdateActionPluginPayload;
  UpdateActionPluginInput: UpdateActionPluginInput;
  UpdateActionQueueByNodeIdInput: UpdateActionQueueByNodeIdInput;
  UpdateActionQueuePayload: UpdateActionQueuePayload;
  UpdateActionQueueInput: UpdateActionQueueInput;
  UpdateApplicationByNodeIdInput: UpdateApplicationByNodeIdInput;
  UpdateApplicationPayload: UpdateApplicationPayload;
  UpdateApplicationInput: UpdateApplicationInput;
  UpdateApplicationBySerialInput: UpdateApplicationBySerialInput;
  UpdateApplicationResponseByNodeIdInput: UpdateApplicationResponseByNodeIdInput;
  UpdateApplicationResponsePayload: UpdateApplicationResponsePayload;
  UpdateApplicationResponseInput: UpdateApplicationResponseInput;
  UpdateApplicationSectionByNodeIdInput: UpdateApplicationSectionByNodeIdInput;
  UpdateApplicationSectionPayload: UpdateApplicationSectionPayload;
  UpdateApplicationSectionInput: UpdateApplicationSectionInput;
  UpdateApplicationStageHistoryByNodeIdInput: UpdateApplicationStageHistoryByNodeIdInput;
  UpdateApplicationStageHistoryPayload: UpdateApplicationStageHistoryPayload;
  UpdateApplicationStageHistoryInput: UpdateApplicationStageHistoryInput;
  UpdateApplicationStatusHistoryByNodeIdInput: UpdateApplicationStatusHistoryByNodeIdInput;
  UpdateApplicationStatusHistoryPayload: UpdateApplicationStatusHistoryPayload;
  UpdateApplicationStatusHistoryInput: UpdateApplicationStatusHistoryInput;
  UpdateElementTypePluginByNodeIdInput: UpdateElementTypePluginByNodeIdInput;
  ElementTypePluginPatch: ElementTypePluginPatch;
  UpdateElementTypePluginPayload: UpdateElementTypePluginPayload;
  UpdateElementTypePluginInput: UpdateElementTypePluginInput;
  UpdateFileByNodeIdInput: UpdateFileByNodeIdInput;
  UpdateFilePayload: UpdateFilePayload;
  UpdateFileInput: UpdateFileInput;
  UpdateNotificationByNodeIdInput: UpdateNotificationByNodeIdInput;
  UpdateNotificationPayload: UpdateNotificationPayload;
  UpdateNotificationInput: UpdateNotificationInput;
  UpdateOrganisationByNodeIdInput: UpdateOrganisationByNodeIdInput;
  UpdateOrganisationPayload: UpdateOrganisationPayload;
  UpdateOrganisationInput: UpdateOrganisationInput;
  UpdateOrganisationByNameInput: UpdateOrganisationByNameInput;
  UpdatePermissionJoinByNodeIdInput: UpdatePermissionJoinByNodeIdInput;
  UpdatePermissionJoinPayload: UpdatePermissionJoinPayload;
  UpdatePermissionJoinInput: UpdatePermissionJoinInput;
  UpdatePermissionNameByNodeIdInput: UpdatePermissionNameByNodeIdInput;
  UpdatePermissionNamePayload: UpdatePermissionNamePayload;
  UpdatePermissionNameInput: UpdatePermissionNameInput;
  UpdatePermissionNameByNameInput: UpdatePermissionNameByNameInput;
  UpdatePermissionPolicyByNodeIdInput: UpdatePermissionPolicyByNodeIdInput;
  UpdatePermissionPolicyPayload: UpdatePermissionPolicyPayload;
  UpdatePermissionPolicyInput: UpdatePermissionPolicyInput;
  UpdateReviewByNodeIdInput: UpdateReviewByNodeIdInput;
  UpdateReviewPayload: UpdateReviewPayload;
  UpdateReviewInput: UpdateReviewInput;
  UpdateReviewAssignmentByNodeIdInput: UpdateReviewAssignmentByNodeIdInput;
  UpdateReviewAssignmentPayload: UpdateReviewAssignmentPayload;
  UpdateReviewAssignmentInput: UpdateReviewAssignmentInput;
  UpdateReviewDecisionByNodeIdInput: UpdateReviewDecisionByNodeIdInput;
  UpdateReviewDecisionPayload: UpdateReviewDecisionPayload;
  UpdateReviewDecisionInput: UpdateReviewDecisionInput;
  UpdateReviewQuestionAssignmentByNodeIdInput: UpdateReviewQuestionAssignmentByNodeIdInput;
  UpdateReviewQuestionAssignmentPayload: UpdateReviewQuestionAssignmentPayload;
  UpdateReviewQuestionAssignmentInput: UpdateReviewQuestionAssignmentInput;
  UpdateReviewResponseByNodeIdInput: UpdateReviewResponseByNodeIdInput;
  UpdateReviewResponsePayload: UpdateReviewResponsePayload;
  UpdateReviewResponseInput: UpdateReviewResponseInput;
  UpdateReviewStatusHistoryByNodeIdInput: UpdateReviewStatusHistoryByNodeIdInput;
  UpdateReviewStatusHistoryPayload: UpdateReviewStatusHistoryPayload;
  UpdateReviewStatusHistoryInput: UpdateReviewStatusHistoryInput;
  UpdateTemplateByNodeIdInput: UpdateTemplateByNodeIdInput;
  UpdateTemplatePayload: UpdateTemplatePayload;
  UpdateTemplateInput: UpdateTemplateInput;
  UpdateTemplateActionByNodeIdInput: UpdateTemplateActionByNodeIdInput;
  UpdateTemplateActionPayload: UpdateTemplateActionPayload;
  UpdateTemplateActionInput: UpdateTemplateActionInput;
  UpdateTemplateElementByNodeIdInput: UpdateTemplateElementByNodeIdInput;
  UpdateTemplateElementPayload: UpdateTemplateElementPayload;
  UpdateTemplateElementInput: UpdateTemplateElementInput;
  UpdateTemplatePermissionByNodeIdInput: UpdateTemplatePermissionByNodeIdInput;
  UpdateTemplatePermissionPayload: UpdateTemplatePermissionPayload;
  UpdateTemplatePermissionInput: UpdateTemplatePermissionInput;
  UpdateTemplateSectionByNodeIdInput: UpdateTemplateSectionByNodeIdInput;
  UpdateTemplateSectionPayload: UpdateTemplateSectionPayload;
  UpdateTemplateSectionInput: UpdateTemplateSectionInput;
  UpdateTemplateStageByNodeIdInput: UpdateTemplateStageByNodeIdInput;
  UpdateTemplateStagePayload: UpdateTemplateStagePayload;
  UpdateTemplateStageInput: UpdateTemplateStageInput;
  UpdateTriggerQueueByNodeIdInput: UpdateTriggerQueueByNodeIdInput;
  UpdateTriggerQueuePayload: UpdateTriggerQueuePayload;
  UpdateTriggerQueueInput: UpdateTriggerQueueInput;
  UpdateUserByNodeIdInput: UpdateUserByNodeIdInput;
  UpdateUserPayload: UpdateUserPayload;
  UpdateUserInput: UpdateUserInput;
  UpdateUserByUsernameInput: UpdateUserByUsernameInput;
  UpdateUserOrganisationByNodeIdInput: UpdateUserOrganisationByNodeIdInput;
  UpdateUserOrganisationPayload: UpdateUserOrganisationPayload;
  UpdateUserOrganisationInput: UpdateUserOrganisationInput;
  DeleteActionPluginByNodeIdInput: DeleteActionPluginByNodeIdInput;
  DeleteActionPluginPayload: DeleteActionPluginPayload;
  DeleteActionPluginInput: DeleteActionPluginInput;
  DeleteActionQueueByNodeIdInput: DeleteActionQueueByNodeIdInput;
  DeleteActionQueuePayload: DeleteActionQueuePayload;
  DeleteActionQueueInput: DeleteActionQueueInput;
  DeleteApplicationByNodeIdInput: DeleteApplicationByNodeIdInput;
  DeleteApplicationPayload: DeleteApplicationPayload;
  DeleteApplicationInput: DeleteApplicationInput;
  DeleteApplicationBySerialInput: DeleteApplicationBySerialInput;
  DeleteApplicationResponseByNodeIdInput: DeleteApplicationResponseByNodeIdInput;
  DeleteApplicationResponsePayload: DeleteApplicationResponsePayload;
  DeleteApplicationResponseInput: DeleteApplicationResponseInput;
  DeleteApplicationSectionByNodeIdInput: DeleteApplicationSectionByNodeIdInput;
  DeleteApplicationSectionPayload: DeleteApplicationSectionPayload;
  DeleteApplicationSectionInput: DeleteApplicationSectionInput;
  DeleteApplicationStageHistoryByNodeIdInput: DeleteApplicationStageHistoryByNodeIdInput;
  DeleteApplicationStageHistoryPayload: DeleteApplicationStageHistoryPayload;
  DeleteApplicationStageHistoryInput: DeleteApplicationStageHistoryInput;
  DeleteApplicationStatusHistoryByNodeIdInput: DeleteApplicationStatusHistoryByNodeIdInput;
  DeleteApplicationStatusHistoryPayload: DeleteApplicationStatusHistoryPayload;
  DeleteApplicationStatusHistoryInput: DeleteApplicationStatusHistoryInput;
  DeleteElementTypePluginByNodeIdInput: DeleteElementTypePluginByNodeIdInput;
  DeleteElementTypePluginPayload: DeleteElementTypePluginPayload;
  DeleteElementTypePluginInput: DeleteElementTypePluginInput;
  DeleteFileByNodeIdInput: DeleteFileByNodeIdInput;
  DeleteFilePayload: DeleteFilePayload;
  DeleteFileInput: DeleteFileInput;
  DeleteNotificationByNodeIdInput: DeleteNotificationByNodeIdInput;
  DeleteNotificationPayload: DeleteNotificationPayload;
  DeleteNotificationInput: DeleteNotificationInput;
  DeleteOrganisationByNodeIdInput: DeleteOrganisationByNodeIdInput;
  DeleteOrganisationPayload: DeleteOrganisationPayload;
  DeleteOrganisationInput: DeleteOrganisationInput;
  DeleteOrganisationByNameInput: DeleteOrganisationByNameInput;
  DeletePermissionJoinByNodeIdInput: DeletePermissionJoinByNodeIdInput;
  DeletePermissionJoinPayload: DeletePermissionJoinPayload;
  DeletePermissionJoinInput: DeletePermissionJoinInput;
  DeletePermissionNameByNodeIdInput: DeletePermissionNameByNodeIdInput;
  DeletePermissionNamePayload: DeletePermissionNamePayload;
  DeletePermissionNameInput: DeletePermissionNameInput;
  DeletePermissionNameByNameInput: DeletePermissionNameByNameInput;
  DeletePermissionPolicyByNodeIdInput: DeletePermissionPolicyByNodeIdInput;
  DeletePermissionPolicyPayload: DeletePermissionPolicyPayload;
  DeletePermissionPolicyInput: DeletePermissionPolicyInput;
  DeleteReviewByNodeIdInput: DeleteReviewByNodeIdInput;
  DeleteReviewPayload: DeleteReviewPayload;
  DeleteReviewInput: DeleteReviewInput;
  DeleteReviewAssignmentByNodeIdInput: DeleteReviewAssignmentByNodeIdInput;
  DeleteReviewAssignmentPayload: DeleteReviewAssignmentPayload;
  DeleteReviewAssignmentInput: DeleteReviewAssignmentInput;
  DeleteReviewDecisionByNodeIdInput: DeleteReviewDecisionByNodeIdInput;
  DeleteReviewDecisionPayload: DeleteReviewDecisionPayload;
  DeleteReviewDecisionInput: DeleteReviewDecisionInput;
  DeleteReviewQuestionAssignmentByNodeIdInput: DeleteReviewQuestionAssignmentByNodeIdInput;
  DeleteReviewQuestionAssignmentPayload: DeleteReviewQuestionAssignmentPayload;
  DeleteReviewQuestionAssignmentInput: DeleteReviewQuestionAssignmentInput;
  DeleteReviewResponseByNodeIdInput: DeleteReviewResponseByNodeIdInput;
  DeleteReviewResponsePayload: DeleteReviewResponsePayload;
  DeleteReviewResponseInput: DeleteReviewResponseInput;
  DeleteReviewStatusHistoryByNodeIdInput: DeleteReviewStatusHistoryByNodeIdInput;
  DeleteReviewStatusHistoryPayload: DeleteReviewStatusHistoryPayload;
  DeleteReviewStatusHistoryInput: DeleteReviewStatusHistoryInput;
  DeleteTemplateByNodeIdInput: DeleteTemplateByNodeIdInput;
  DeleteTemplatePayload: DeleteTemplatePayload;
  DeleteTemplateInput: DeleteTemplateInput;
  DeleteTemplateActionByNodeIdInput: DeleteTemplateActionByNodeIdInput;
  DeleteTemplateActionPayload: DeleteTemplateActionPayload;
  DeleteTemplateActionInput: DeleteTemplateActionInput;
  DeleteTemplateElementByNodeIdInput: DeleteTemplateElementByNodeIdInput;
  DeleteTemplateElementPayload: DeleteTemplateElementPayload;
  DeleteTemplateElementInput: DeleteTemplateElementInput;
  DeleteTemplatePermissionByNodeIdInput: DeleteTemplatePermissionByNodeIdInput;
  DeleteTemplatePermissionPayload: DeleteTemplatePermissionPayload;
  DeleteTemplatePermissionInput: DeleteTemplatePermissionInput;
  DeleteTemplateSectionByNodeIdInput: DeleteTemplateSectionByNodeIdInput;
  DeleteTemplateSectionPayload: DeleteTemplateSectionPayload;
  DeleteTemplateSectionInput: DeleteTemplateSectionInput;
  DeleteTemplateStageByNodeIdInput: DeleteTemplateStageByNodeIdInput;
  DeleteTemplateStagePayload: DeleteTemplateStagePayload;
  DeleteTemplateStageInput: DeleteTemplateStageInput;
  DeleteTriggerQueueByNodeIdInput: DeleteTriggerQueueByNodeIdInput;
  DeleteTriggerQueuePayload: DeleteTriggerQueuePayload;
  DeleteTriggerQueueInput: DeleteTriggerQueueInput;
  DeleteUserByNodeIdInput: DeleteUserByNodeIdInput;
  DeleteUserPayload: DeleteUserPayload;
  DeleteUserInput: DeleteUserInput;
  DeleteUserByUsernameInput: DeleteUserByUsernameInput;
  DeleteUserOrganisationByNodeIdInput: DeleteUserOrganisationByNodeIdInput;
  DeleteUserOrganisationPayload: DeleteUserOrganisationPayload;
  DeleteUserOrganisationInput: DeleteUserOrganisationInput;
};

export type ActionPluginResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionPlugin'] = ResolversParentTypes['ActionPlugin']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  functionName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  requiredParameters?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  outputProperties?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionPluginsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionPluginsConnection'] = ResolversParentTypes['ActionPluginsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ActionPlugin']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ActionPluginsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionPluginsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionPluginsEdge'] = ResolversParentTypes['ActionPluginsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionQueueResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionQueue'] = ResolversParentTypes['ActionQueue']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  triggerEvent?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  sequence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  actionCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationData?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  parameterQueries?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  parametersEvaluated?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ActionQueueStatus']>, ParentType, ContextType>;
  output?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  timeQueued?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeCompleted?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeScheduled?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  errorLog?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  triggerQueueByTriggerEvent?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionQueuesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionQueuesConnection'] = ResolversParentTypes['ActionQueuesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ActionQueue']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ActionQueuesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionQueuesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionQueuesEdge'] = ResolversParentTypes['ActionQueuesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AllPermissionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AllPermission'] = ResolversParentTypes['AllPermission']> = {
  permissionType?: Resolver<Maybe<ResolversTypes['PermissionPolicyType']>, ParentType, ContextType>;
  permissionPolicyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  permissionPolicyRules?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  permissionNameId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templatePermissionId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templatePermissionRestrictions?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AllPermissionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AllPermissionsConnection'] = ResolversParentTypes['AllPermissionsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['AllPermission']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['AllPermissionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AllPermissionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AllPermissionsEdge'] = ResolversParentTypes['AllPermissionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['AllPermission']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Application'] = ResolversParentTypes['Application']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  outcome?: Resolver<Maybe<ResolversTypes['ApplicationOutcome']>, ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  applicationSections?: Resolver<ResolversTypes['ApplicationSectionsConnection'], ParentType, ContextType, RequireFields<ApplicationApplicationSectionsArgs, 'orderBy'>>;
  applicationStageHistories?: Resolver<ResolversTypes['ApplicationStageHistoriesConnection'], ParentType, ContextType, RequireFields<ApplicationApplicationStageHistoriesArgs, 'orderBy'>>;
  applicationResponses?: Resolver<ResolversTypes['ApplicationResponsesConnection'], ParentType, ContextType, RequireFields<ApplicationApplicationResponsesArgs, 'orderBy'>>;
  reviewAssignments?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<ApplicationReviewAssignmentsArgs, 'orderBy'>>;
  reviews?: Resolver<ResolversTypes['ReviewsConnection'], ParentType, ContextType, RequireFields<ApplicationReviewsArgs, 'orderBy'>>;
  files?: Resolver<ResolversTypes['FilesConnection'], ParentType, ContextType, RequireFields<ApplicationFilesArgs, 'orderBy'>>;
  notifications?: Resolver<ResolversTypes['NotificationsConnection'], ParentType, ContextType, RequireFields<ApplicationNotificationsArgs, 'orderBy'>>;
  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationList'] = ResolversParentTypes['ApplicationList']> = {
  id?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicantUsername?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicantFirstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicantLastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicant?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  outcome?: Resolver<Maybe<ResolversTypes['ApplicationOutcome']>, ParentType, ContextType>;
  lastActiveDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  isFullyAssignedLevel1?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListsConnection'] = ResolversParentTypes['ApplicationListsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationList']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationListsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListsEdge'] = ResolversParentTypes['ApplicationListsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationResponse'] = ResolversParentTypes['ApplicationResponse']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  templateElementId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  isValid?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  timeUpdated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviewResponses?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ApplicationResponseReviewResponsesArgs, 'orderBy'>>;
  files?: Resolver<ResolversTypes['FilesConnection'], ParentType, ContextType, RequireFields<ApplicationResponseFilesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationResponsesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationResponsesConnection'] = ResolversParentTypes['ApplicationResponsesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationResponse']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationResponsesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationResponsesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationResponsesEdge'] = ResolversParentTypes['ApplicationResponsesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationsConnection'] = ResolversParentTypes['ApplicationsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['Application']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationSectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationSection'] = ResolversParentTypes['ApplicationSection']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateSectionId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationSectionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationSectionsConnection'] = ResolversParentTypes['ApplicationSectionsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationSection']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationSectionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationSectionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationSectionsEdge'] = ResolversParentTypes['ApplicationSectionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationSection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationsEdge'] = ResolversParentTypes['ApplicationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageHistoriesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageHistoriesConnection'] = ResolversParentTypes['ApplicationStageHistoriesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationStageHistory']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationStageHistoriesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageHistoriesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageHistoriesEdge'] = ResolversParentTypes['ApplicationStageHistoriesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageHistoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageHistory'] = ResolversParentTypes['ApplicationStageHistory']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  isCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  applicationStatusHistories?: Resolver<ResolversTypes['ApplicationStatusHistoriesConnection'], ParentType, ContextType, RequireFields<ApplicationStageHistoryApplicationStatusHistoriesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusAllResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusAll'] = ResolversParentTypes['ApplicationStageStatusAll']> = {
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageHistoryTimeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  stageIsCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  statusHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  statusHistoryTimeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  statusIsCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusAllsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusAllsConnection'] = ResolversParentTypes['ApplicationStageStatusAllsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationStageStatusAll']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationStageStatusAllsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusAllsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusAllsEdge'] = ResolversParentTypes['ApplicationStageStatusAllsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationStageStatusAll']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusLatestResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusLatest'] = ResolversParentTypes['ApplicationStageStatusLatest']> = {
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageHistoryTimeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  stageIsCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  statusHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  statusHistoryTimeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  statusIsCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusLatestsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusLatestsConnection'] = ResolversParentTypes['ApplicationStageStatusLatestsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationStageStatusLatest']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationStageStatusLatestsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusLatestsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusLatestsEdge'] = ResolversParentTypes['ApplicationStageStatusLatestsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationStageStatusLatest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStatusHistoriesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStatusHistoriesConnection'] = ResolversParentTypes['ApplicationStatusHistoriesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationStatusHistory']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationStatusHistoriesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStatusHistoriesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStatusHistoriesEdge'] = ResolversParentTypes['ApplicationStatusHistoriesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStatusHistoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStatusHistory'] = ResolversParentTypes['ApplicationStatusHistory']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  applicationStageHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  isCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationTriggerStateResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationTriggerState'] = ResolversParentTypes['ApplicationTriggerState']> = {
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  applicationTrigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  reviewAssignmentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewAssignmentTrigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  reviewId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewTrigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationTriggerStatesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationTriggerStatesConnection'] = ResolversParentTypes['ApplicationTriggerStatesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationTriggerState']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ApplicationTriggerStatesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationTriggerStatesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationTriggerStatesEdge'] = ResolversParentTypes['ApplicationTriggerStatesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationTriggerState']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export type CreateActionPluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateActionPluginPayload'] = ResolversParentTypes['CreateActionPluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionPlugin?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  actionPluginEdge?: Resolver<Maybe<ResolversTypes['ActionPluginsEdge']>, ParentType, ContextType, RequireFields<CreateActionPluginPayloadActionPluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateActionQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateActionQueuePayload'] = ResolversParentTypes['CreateActionQueuePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionQueue?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueueByTriggerEvent?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  actionQueueEdge?: Resolver<Maybe<ResolversTypes['ActionQueuesEdge']>, ParentType, ContextType, RequireFields<CreateActionQueuePayloadActionQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationPayload'] = ResolversParentTypes['CreateApplicationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  applicationEdge?: Resolver<Maybe<ResolversTypes['ApplicationsEdge']>, ParentType, ContextType, RequireFields<CreateApplicationPayloadApplicationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationResponsePayload'] = ResolversParentTypes['CreateApplicationResponsePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponseEdge?: Resolver<Maybe<ResolversTypes['ApplicationResponsesEdge']>, ParentType, ContextType, RequireFields<CreateApplicationResponsePayloadApplicationResponseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationSectionPayload'] = ResolversParentTypes['CreateApplicationSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationSection?: Resolver<Maybe<ResolversTypes['ApplicationSection']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  applicationSectionEdge?: Resolver<Maybe<ResolversTypes['ApplicationSectionsEdge']>, ParentType, ContextType, RequireFields<CreateApplicationSectionPayloadApplicationSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationStageHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationStageHistoryPayload'] = ResolversParentTypes['CreateApplicationStageHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  applicationStageHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStageHistoriesEdge']>, ParentType, ContextType, RequireFields<CreateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationStatusHistoryPayload'] = ResolversParentTypes['CreateApplicationStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationStatusHistory?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<CreateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateElementTypePluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateElementTypePluginPayload'] = ResolversParentTypes['CreateElementTypePluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elementTypePlugin?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  elementTypePluginEdge?: Resolver<Maybe<ResolversTypes['ElementTypePluginsEdge']>, ParentType, ContextType, RequireFields<CreateElementTypePluginPayloadElementTypePluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFilePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFilePayload'] = ResolversParentTypes['CreateFilePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  fileEdge?: Resolver<Maybe<ResolversTypes['FilesEdge']>, ParentType, ContextType, RequireFields<CreateFilePayloadFileEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateNotificationPayload'] = ResolversParentTypes['CreateNotificationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  document?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<CreateNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOrganisationPayload'] = ResolversParentTypes['CreateOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  organisationEdge?: Resolver<Maybe<ResolversTypes['OrganisationsEdge']>, ParentType, ContextType, RequireFields<CreateOrganisationPayloadOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePermissionJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePermissionJoinPayload'] = ResolversParentTypes['CreatePermissionJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionJoin?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  permissionJoinEdge?: Resolver<Maybe<ResolversTypes['PermissionJoinsEdge']>, ParentType, ContextType, RequireFields<CreatePermissionJoinPayloadPermissionJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePermissionNamePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePermissionNamePayload'] = ResolversParentTypes['CreatePermissionNamePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  permissionNameEdge?: Resolver<Maybe<ResolversTypes['PermissionNamesEdge']>, ParentType, ContextType, RequireFields<CreatePermissionNamePayloadPermissionNameEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePermissionPolicyPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePermissionPolicyPayload'] = ResolversParentTypes['CreatePermissionPolicyPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionPolicyEdge?: Resolver<Maybe<ResolversTypes['PermissionPoliciesEdge']>, ParentType, ContextType, RequireFields<CreatePermissionPolicyPayloadPermissionPolicyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewAssignmentPayload'] = ResolversParentTypes['CreateReviewAssignmentPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  assigner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  reviewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviewAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentsEdge']>, ParentType, ContextType, RequireFields<CreateReviewAssignmentPayloadReviewAssignmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewDecisionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewDecisionPayload'] = ResolversParentTypes['CreateReviewDecisionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewDecisionEdge?: Resolver<Maybe<ResolversTypes['ReviewDecisionsEdge']>, ParentType, ContextType, RequireFields<CreateReviewDecisionPayloadReviewDecisionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewPayload'] = ResolversParentTypes['CreateReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<CreateReviewPayloadReviewEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewQuestionAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewQuestionAssignmentPayload'] = ResolversParentTypes['CreateReviewQuestionAssignmentPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewQuestionAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignmentsEdge']>, ParentType, ContextType, RequireFields<CreateReviewQuestionAssignmentPayloadReviewQuestionAssignmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewResponsePayload'] = ResolversParentTypes['CreateReviewResponsePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  reviewResponseLink?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  originalReviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  reviewResponseEdge?: Resolver<Maybe<ResolversTypes['ReviewResponsesEdge']>, ParentType, ContextType, RequireFields<CreateReviewResponsePayloadReviewResponseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewStatusHistoryPayload'] = ResolversParentTypes['CreateReviewStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewStatusHistory?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ReviewStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<CreateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateActionPayload'] = ResolversParentTypes['CreateTemplateActionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateAction?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateActionEdge?: Resolver<Maybe<ResolversTypes['TemplateActionsEdge']>, ParentType, ContextType, RequireFields<CreateTemplateActionPayloadTemplateActionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateElementPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateElementPayload'] = ResolversParentTypes['CreateTemplateElementPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateElementEdge?: Resolver<Maybe<ResolversTypes['TemplateElementsEdge']>, ParentType, ContextType, RequireFields<CreateTemplateElementPayloadTemplateElementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplatePayload'] = ResolversParentTypes['CreateTemplatePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<CreateTemplatePayloadTemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplatePermissionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplatePermissionPayload'] = ResolversParentTypes['CreateTemplatePermissionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templatePermission?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templatePermissionEdge?: Resolver<Maybe<ResolversTypes['TemplatePermissionsEdge']>, ParentType, ContextType, RequireFields<CreateTemplatePermissionPayloadTemplatePermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateSectionPayload'] = ResolversParentTypes['CreateTemplateSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateSectionEdge?: Resolver<Maybe<ResolversTypes['TemplateSectionsEdge']>, ParentType, ContextType, RequireFields<CreateTemplateSectionPayloadTemplateSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateStagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateStagePayload'] = ResolversParentTypes['CreateTemplateStagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateStage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateStageEdge?: Resolver<Maybe<ResolversTypes['TemplateStagesEdge']>, ParentType, ContextType, RequireFields<CreateTemplateStagePayloadTemplateStageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTriggerQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTriggerQueuePayload'] = ResolversParentTypes['CreateTriggerQueuePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  triggerQueue?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueueEdge?: Resolver<Maybe<ResolversTypes['TriggerQueuesEdge']>, ParentType, ContextType, RequireFields<CreateTriggerQueuePayloadTriggerQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserOrganisationPayload'] = ResolversParentTypes['CreateUserOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userOrganisation?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  userOrganisationEdge?: Resolver<Maybe<ResolversTypes['UserOrganisationsEdge']>, ParentType, ContextType, RequireFields<CreateUserOrganisationPayloadUserOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserPayload'] = ResolversParentTypes['CreateUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<CreateUserPayloadUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface CursorScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Cursor'], any> {
  name: 'Cursor';
}

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export interface DatetimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Datetime'], any> {
  name: 'Datetime';
}

export type DeleteActionPluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteActionPluginPayload'] = ResolversParentTypes['DeleteActionPluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionPlugin?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType>;
  deletedActionPluginNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  actionPluginEdge?: Resolver<Maybe<ResolversTypes['ActionPluginsEdge']>, ParentType, ContextType, RequireFields<DeleteActionPluginPayloadActionPluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteActionQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteActionQueuePayload'] = ResolversParentTypes['DeleteActionQueuePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionQueue?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType>;
  deletedActionQueueNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueueByTriggerEvent?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  actionQueueEdge?: Resolver<Maybe<ResolversTypes['ActionQueuesEdge']>, ParentType, ContextType, RequireFields<DeleteActionQueuePayloadActionQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationPayload'] = ResolversParentTypes['DeleteApplicationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  deletedApplicationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  applicationEdge?: Resolver<Maybe<ResolversTypes['ApplicationsEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationPayloadApplicationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationResponsePayload'] = ResolversParentTypes['DeleteApplicationResponsePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  deletedApplicationResponseNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponseEdge?: Resolver<Maybe<ResolversTypes['ApplicationResponsesEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationResponsePayloadApplicationResponseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationSectionPayload'] = ResolversParentTypes['DeleteApplicationSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationSection?: Resolver<Maybe<ResolversTypes['ApplicationSection']>, ParentType, ContextType>;
  deletedApplicationSectionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  applicationSectionEdge?: Resolver<Maybe<ResolversTypes['ApplicationSectionsEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationSectionPayloadApplicationSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationStageHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationStageHistoryPayload'] = ResolversParentTypes['DeleteApplicationStageHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  deletedApplicationStageHistoryNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  applicationStageHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStageHistoriesEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationStatusHistoryPayload'] = ResolversParentTypes['DeleteApplicationStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationStatusHistory?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType>;
  deletedApplicationStatusHistoryNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteElementTypePluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteElementTypePluginPayload'] = ResolversParentTypes['DeleteElementTypePluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elementTypePlugin?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType>;
  deletedElementTypePluginNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  elementTypePluginEdge?: Resolver<Maybe<ResolversTypes['ElementTypePluginsEdge']>, ParentType, ContextType, RequireFields<DeleteElementTypePluginPayloadElementTypePluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteFilePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteFilePayload'] = ResolversParentTypes['DeleteFilePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  deletedFileNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  fileEdge?: Resolver<Maybe<ResolversTypes['FilesEdge']>, ParentType, ContextType, RequireFields<DeleteFilePayloadFileEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteNotificationPayload'] = ResolversParentTypes['DeleteNotificationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  deletedNotificationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  document?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<DeleteNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteOrganisationPayload'] = ResolversParentTypes['DeleteOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  deletedOrganisationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  organisationEdge?: Resolver<Maybe<ResolversTypes['OrganisationsEdge']>, ParentType, ContextType, RequireFields<DeleteOrganisationPayloadOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePermissionJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePermissionJoinPayload'] = ResolversParentTypes['DeletePermissionJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionJoin?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType>;
  deletedPermissionJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  permissionJoinEdge?: Resolver<Maybe<ResolversTypes['PermissionJoinsEdge']>, ParentType, ContextType, RequireFields<DeletePermissionJoinPayloadPermissionJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePermissionNamePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePermissionNamePayload'] = ResolversParentTypes['DeletePermissionNamePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  deletedPermissionNameNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  permissionNameEdge?: Resolver<Maybe<ResolversTypes['PermissionNamesEdge']>, ParentType, ContextType, RequireFields<DeletePermissionNamePayloadPermissionNameEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePermissionPolicyPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePermissionPolicyPayload'] = ResolversParentTypes['DeletePermissionPolicyPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  deletedPermissionPolicyNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionPolicyEdge?: Resolver<Maybe<ResolversTypes['PermissionPoliciesEdge']>, ParentType, ContextType, RequireFields<DeletePermissionPolicyPayloadPermissionPolicyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewAssignmentPayload'] = ResolversParentTypes['DeleteReviewAssignmentPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  deletedReviewAssignmentNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  assigner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  reviewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviewAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewAssignmentPayloadReviewAssignmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewDecisionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewDecisionPayload'] = ResolversParentTypes['DeleteReviewDecisionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  deletedReviewDecisionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewDecisionEdge?: Resolver<Maybe<ResolversTypes['ReviewDecisionsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewDecisionPayloadReviewDecisionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewPayload'] = ResolversParentTypes['DeleteReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  deletedReviewNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewPayloadReviewEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewQuestionAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewQuestionAssignmentPayload'] = ResolversParentTypes['DeleteReviewQuestionAssignmentPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType>;
  deletedReviewQuestionAssignmentNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewQuestionAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignmentsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewQuestionAssignmentPayloadReviewQuestionAssignmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewResponsePayload'] = ResolversParentTypes['DeleteReviewResponsePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  deletedReviewResponseNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  reviewResponseLink?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  originalReviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  reviewResponseEdge?: Resolver<Maybe<ResolversTypes['ReviewResponsesEdge']>, ParentType, ContextType, RequireFields<DeleteReviewResponsePayloadReviewResponseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewStatusHistoryPayload'] = ResolversParentTypes['DeleteReviewStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewStatusHistory?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType>;
  deletedReviewStatusHistoryNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ReviewStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<DeleteReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateActionPayload'] = ResolversParentTypes['DeleteTemplateActionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateAction?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType>;
  deletedTemplateActionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateActionEdge?: Resolver<Maybe<ResolversTypes['TemplateActionsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateActionPayloadTemplateActionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateElementPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateElementPayload'] = ResolversParentTypes['DeleteTemplateElementPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  deletedTemplateElementNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateElementEdge?: Resolver<Maybe<ResolversTypes['TemplateElementsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateElementPayloadTemplateElementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplatePayload'] = ResolversParentTypes['DeleteTemplatePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  deletedTemplateNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<DeleteTemplatePayloadTemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplatePermissionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplatePermissionPayload'] = ResolversParentTypes['DeleteTemplatePermissionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templatePermission?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType>;
  deletedTemplatePermissionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templatePermissionEdge?: Resolver<Maybe<ResolversTypes['TemplatePermissionsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplatePermissionPayloadTemplatePermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateSectionPayload'] = ResolversParentTypes['DeleteTemplateSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  deletedTemplateSectionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateSectionEdge?: Resolver<Maybe<ResolversTypes['TemplateSectionsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateSectionPayloadTemplateSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateStagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateStagePayload'] = ResolversParentTypes['DeleteTemplateStagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateStage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  deletedTemplateStageNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateStageEdge?: Resolver<Maybe<ResolversTypes['TemplateStagesEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateStagePayloadTemplateStageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTriggerQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTriggerQueuePayload'] = ResolversParentTypes['DeleteTriggerQueuePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  triggerQueue?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  deletedTriggerQueueNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueueEdge?: Resolver<Maybe<ResolversTypes['TriggerQueuesEdge']>, ParentType, ContextType, RequireFields<DeleteTriggerQueuePayloadTriggerQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteUserOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteUserOrganisationPayload'] = ResolversParentTypes['DeleteUserOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userOrganisation?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType>;
  deletedUserOrganisationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  userOrganisationEdge?: Resolver<Maybe<ResolversTypes['UserOrganisationsEdge']>, ParentType, ContextType, RequireFields<DeleteUserOrganisationPayloadUserOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteUserPayload'] = ResolversParentTypes['DeleteUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  deletedUserNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<DeleteUserPayloadUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElementTypePluginResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElementTypePlugin'] = ResolversParentTypes['ElementTypePlugin']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['TemplateElementCategory']>, ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayComponentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  configComponentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  requiredParameters?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElementTypePluginsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElementTypePluginsConnection'] = ResolversParentTypes['ElementTypePluginsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ElementTypePlugin']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ElementTypePluginsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElementTypePluginsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElementTypePluginsEdge'] = ResolversParentTypes['ElementTypePluginsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileResolvers<ContextType = any, ParentType extends ResolversParentTypes['File'] = ResolversParentTypes['File']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalFilename?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  mimetype?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  applicationResponseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  notificationsByDocumentId?: Resolver<ResolversTypes['NotificationsConnection'], ParentType, ContextType, RequireFields<FileNotificationsByDocumentIdArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilesConnection'] = ResolversParentTypes['FilesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['File']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['FilesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilesEdge'] = ResolversParentTypes['FilesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  createActionPlugin?: Resolver<Maybe<ResolversTypes['CreateActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationCreateActionPluginArgs, 'input'>>;
  createActionQueue?: Resolver<Maybe<ResolversTypes['CreateActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationCreateActionQueueArgs, 'input'>>;
  createApplication?: Resolver<Maybe<ResolversTypes['CreateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationArgs, 'input'>>;
  createApplicationResponse?: Resolver<Maybe<ResolversTypes['CreateApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationResponseArgs, 'input'>>;
  createApplicationSection?: Resolver<Maybe<ResolversTypes['CreateApplicationSectionPayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationSectionArgs, 'input'>>;
  createApplicationStageHistory?: Resolver<Maybe<ResolversTypes['CreateApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationStageHistoryArgs, 'input'>>;
  createApplicationStatusHistory?: Resolver<Maybe<ResolversTypes['CreateApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationStatusHistoryArgs, 'input'>>;
  createElementTypePlugin?: Resolver<Maybe<ResolversTypes['CreateElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationCreateElementTypePluginArgs, 'input'>>;
  createFile?: Resolver<Maybe<ResolversTypes['CreateFilePayload']>, ParentType, ContextType, RequireFields<MutationCreateFileArgs, 'input'>>;
  createNotification?: Resolver<Maybe<ResolversTypes['CreateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationCreateNotificationArgs, 'input'>>;
  createOrganisation?: Resolver<Maybe<ResolversTypes['CreateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationCreateOrganisationArgs, 'input'>>;
  createPermissionJoin?: Resolver<Maybe<ResolversTypes['CreatePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreatePermissionJoinArgs, 'input'>>;
  createPermissionName?: Resolver<Maybe<ResolversTypes['CreatePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationCreatePermissionNameArgs, 'input'>>;
  createPermissionPolicy?: Resolver<Maybe<ResolversTypes['CreatePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationCreatePermissionPolicyArgs, 'input'>>;
  createReview?: Resolver<Maybe<ResolversTypes['CreateReviewPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewArgs, 'input'>>;
  createReviewAssignment?: Resolver<Maybe<ResolversTypes['CreateReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewAssignmentArgs, 'input'>>;
  createReviewDecision?: Resolver<Maybe<ResolversTypes['CreateReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewDecisionArgs, 'input'>>;
  createReviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['CreateReviewQuestionAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewQuestionAssignmentArgs, 'input'>>;
  createReviewResponse?: Resolver<Maybe<ResolversTypes['CreateReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewResponseArgs, 'input'>>;
  createReviewStatusHistory?: Resolver<Maybe<ResolversTypes['CreateReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewStatusHistoryArgs, 'input'>>;
  createTemplate?: Resolver<Maybe<ResolversTypes['CreateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateArgs, 'input'>>;
  createTemplateAction?: Resolver<Maybe<ResolversTypes['CreateTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateActionArgs, 'input'>>;
  createTemplateElement?: Resolver<Maybe<ResolversTypes['CreateTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateElementArgs, 'input'>>;
  createTemplatePermission?: Resolver<Maybe<ResolversTypes['CreateTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplatePermissionArgs, 'input'>>;
  createTemplateSection?: Resolver<Maybe<ResolversTypes['CreateTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateSectionArgs, 'input'>>;
  createTemplateStage?: Resolver<Maybe<ResolversTypes['CreateTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateStageArgs, 'input'>>;
  createTriggerQueue?: Resolver<Maybe<ResolversTypes['CreateTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationCreateTriggerQueueArgs, 'input'>>;
  createUser?: Resolver<Maybe<ResolversTypes['CreateUserPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserArgs, 'input'>>;
  createUserOrganisation?: Resolver<Maybe<ResolversTypes['CreateUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserOrganisationArgs, 'input'>>;
  updateActionPluginByNodeId?: Resolver<Maybe<ResolversTypes['UpdateActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionPluginByNodeIdArgs, 'input'>>;
  updateActionPlugin?: Resolver<Maybe<ResolversTypes['UpdateActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionPluginArgs, 'input'>>;
  updateActionQueueByNodeId?: Resolver<Maybe<ResolversTypes['UpdateActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionQueueByNodeIdArgs, 'input'>>;
  updateActionQueue?: Resolver<Maybe<ResolversTypes['UpdateActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionQueueArgs, 'input'>>;
  updateApplicationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationByNodeIdArgs, 'input'>>;
  updateApplication?: Resolver<Maybe<ResolversTypes['UpdateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationArgs, 'input'>>;
  updateApplicationBySerial?: Resolver<Maybe<ResolversTypes['UpdateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationBySerialArgs, 'input'>>;
  updateApplicationResponseByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationResponseByNodeIdArgs, 'input'>>;
  updateApplicationResponse?: Resolver<Maybe<ResolversTypes['UpdateApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationResponseArgs, 'input'>>;
  updateApplicationSectionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationSectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationSectionByNodeIdArgs, 'input'>>;
  updateApplicationSection?: Resolver<Maybe<ResolversTypes['UpdateApplicationSectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationSectionArgs, 'input'>>;
  updateApplicationStageHistoryByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationStageHistoryByNodeIdArgs, 'input'>>;
  updateApplicationStageHistory?: Resolver<Maybe<ResolversTypes['UpdateApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationStageHistoryArgs, 'input'>>;
  updateApplicationStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationStatusHistoryByNodeIdArgs, 'input'>>;
  updateApplicationStatusHistory?: Resolver<Maybe<ResolversTypes['UpdateApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationStatusHistoryArgs, 'input'>>;
  updateElementTypePluginByNodeId?: Resolver<Maybe<ResolversTypes['UpdateElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateElementTypePluginByNodeIdArgs, 'input'>>;
  updateElementTypePlugin?: Resolver<Maybe<ResolversTypes['UpdateElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateElementTypePluginArgs, 'input'>>;
  updateFileByNodeId?: Resolver<Maybe<ResolversTypes['UpdateFilePayload']>, ParentType, ContextType, RequireFields<MutationUpdateFileByNodeIdArgs, 'input'>>;
  updateFile?: Resolver<Maybe<ResolversTypes['UpdateFilePayload']>, ParentType, ContextType, RequireFields<MutationUpdateFileArgs, 'input'>>;
  updateNotificationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateNotificationByNodeIdArgs, 'input'>>;
  updateNotification?: Resolver<Maybe<ResolversTypes['UpdateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateNotificationArgs, 'input'>>;
  updateOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationByNodeIdArgs, 'input'>>;
  updateOrganisation?: Resolver<Maybe<ResolversTypes['UpdateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationArgs, 'input'>>;
  updateOrganisationByName?: Resolver<Maybe<ResolversTypes['UpdateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationByNameArgs, 'input'>>;
  updatePermissionJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdatePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionJoinByNodeIdArgs, 'input'>>;
  updatePermissionJoin?: Resolver<Maybe<ResolversTypes['UpdatePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionJoinArgs, 'input'>>;
  updatePermissionNameByNodeId?: Resolver<Maybe<ResolversTypes['UpdatePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionNameByNodeIdArgs, 'input'>>;
  updatePermissionName?: Resolver<Maybe<ResolversTypes['UpdatePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionNameArgs, 'input'>>;
  updatePermissionNameByName?: Resolver<Maybe<ResolversTypes['UpdatePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionNameByNameArgs, 'input'>>;
  updatePermissionPolicyByNodeId?: Resolver<Maybe<ResolversTypes['UpdatePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionPolicyByNodeIdArgs, 'input'>>;
  updatePermissionPolicy?: Resolver<Maybe<ResolversTypes['UpdatePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionPolicyArgs, 'input'>>;
  updateReviewByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewByNodeIdArgs, 'input'>>;
  updateReview?: Resolver<Maybe<ResolversTypes['UpdateReviewPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewArgs, 'input'>>;
  updateReviewAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewAssignmentByNodeIdArgs, 'input'>>;
  updateReviewAssignment?: Resolver<Maybe<ResolversTypes['UpdateReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewAssignmentArgs, 'input'>>;
  updateReviewDecisionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewDecisionByNodeIdArgs, 'input'>>;
  updateReviewDecision?: Resolver<Maybe<ResolversTypes['UpdateReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewDecisionArgs, 'input'>>;
  updateReviewQuestionAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewQuestionAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewQuestionAssignmentByNodeIdArgs, 'input'>>;
  updateReviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['UpdateReviewQuestionAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewQuestionAssignmentArgs, 'input'>>;
  updateReviewResponseByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewResponseByNodeIdArgs, 'input'>>;
  updateReviewResponse?: Resolver<Maybe<ResolversTypes['UpdateReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewResponseArgs, 'input'>>;
  updateReviewStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewStatusHistoryByNodeIdArgs, 'input'>>;
  updateReviewStatusHistory?: Resolver<Maybe<ResolversTypes['UpdateReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewStatusHistoryArgs, 'input'>>;
  updateTemplateByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateByNodeIdArgs, 'input'>>;
  updateTemplate?: Resolver<Maybe<ResolversTypes['UpdateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateArgs, 'input'>>;
  updateTemplateActionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateActionByNodeIdArgs, 'input'>>;
  updateTemplateAction?: Resolver<Maybe<ResolversTypes['UpdateTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateActionArgs, 'input'>>;
  updateTemplateElementByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateElementByNodeIdArgs, 'input'>>;
  updateTemplateElement?: Resolver<Maybe<ResolversTypes['UpdateTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateElementArgs, 'input'>>;
  updateTemplatePermissionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplatePermissionByNodeIdArgs, 'input'>>;
  updateTemplatePermission?: Resolver<Maybe<ResolversTypes['UpdateTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplatePermissionArgs, 'input'>>;
  updateTemplateSectionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateSectionByNodeIdArgs, 'input'>>;
  updateTemplateSection?: Resolver<Maybe<ResolversTypes['UpdateTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateSectionArgs, 'input'>>;
  updateTemplateStageByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateStageByNodeIdArgs, 'input'>>;
  updateTemplateStage?: Resolver<Maybe<ResolversTypes['UpdateTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateStageArgs, 'input'>>;
  updateTriggerQueueByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTriggerQueueByNodeIdArgs, 'input'>>;
  updateTriggerQueue?: Resolver<Maybe<ResolversTypes['UpdateTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTriggerQueueArgs, 'input'>>;
  updateUserByNodeId?: Resolver<Maybe<ResolversTypes['UpdateUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserByNodeIdArgs, 'input'>>;
  updateUser?: Resolver<Maybe<ResolversTypes['UpdateUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserArgs, 'input'>>;
  updateUserByUsername?: Resolver<Maybe<ResolversTypes['UpdateUserPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserByUsernameArgs, 'input'>>;
  updateUserOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserOrganisationByNodeIdArgs, 'input'>>;
  updateUserOrganisation?: Resolver<Maybe<ResolversTypes['UpdateUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserOrganisationArgs, 'input'>>;
  deleteActionPluginByNodeId?: Resolver<Maybe<ResolversTypes['DeleteActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionPluginByNodeIdArgs, 'input'>>;
  deleteActionPlugin?: Resolver<Maybe<ResolversTypes['DeleteActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionPluginArgs, 'input'>>;
  deleteActionQueueByNodeId?: Resolver<Maybe<ResolversTypes['DeleteActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionQueueByNodeIdArgs, 'input'>>;
  deleteActionQueue?: Resolver<Maybe<ResolversTypes['DeleteActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionQueueArgs, 'input'>>;
  deleteApplicationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationByNodeIdArgs, 'input'>>;
  deleteApplication?: Resolver<Maybe<ResolversTypes['DeleteApplicationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationArgs, 'input'>>;
  deleteApplicationBySerial?: Resolver<Maybe<ResolversTypes['DeleteApplicationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationBySerialArgs, 'input'>>;
  deleteApplicationResponseByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationResponseByNodeIdArgs, 'input'>>;
  deleteApplicationResponse?: Resolver<Maybe<ResolversTypes['DeleteApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationResponseArgs, 'input'>>;
  deleteApplicationSectionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationSectionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationSectionByNodeIdArgs, 'input'>>;
  deleteApplicationSection?: Resolver<Maybe<ResolversTypes['DeleteApplicationSectionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationSectionArgs, 'input'>>;
  deleteApplicationStageHistoryByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationStageHistoryByNodeIdArgs, 'input'>>;
  deleteApplicationStageHistory?: Resolver<Maybe<ResolversTypes['DeleteApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationStageHistoryArgs, 'input'>>;
  deleteApplicationStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationStatusHistoryByNodeIdArgs, 'input'>>;
  deleteApplicationStatusHistory?: Resolver<Maybe<ResolversTypes['DeleteApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationStatusHistoryArgs, 'input'>>;
  deleteElementTypePluginByNodeId?: Resolver<Maybe<ResolversTypes['DeleteElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteElementTypePluginByNodeIdArgs, 'input'>>;
  deleteElementTypePlugin?: Resolver<Maybe<ResolversTypes['DeleteElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteElementTypePluginArgs, 'input'>>;
  deleteFileByNodeId?: Resolver<Maybe<ResolversTypes['DeleteFilePayload']>, ParentType, ContextType, RequireFields<MutationDeleteFileByNodeIdArgs, 'input'>>;
  deleteFile?: Resolver<Maybe<ResolversTypes['DeleteFilePayload']>, ParentType, ContextType, RequireFields<MutationDeleteFileArgs, 'input'>>;
  deleteNotificationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteNotificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteNotificationByNodeIdArgs, 'input'>>;
  deleteNotification?: Resolver<Maybe<ResolversTypes['DeleteNotificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteNotificationArgs, 'input'>>;
  deleteOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationByNodeIdArgs, 'input'>>;
  deleteOrganisation?: Resolver<Maybe<ResolversTypes['DeleteOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationArgs, 'input'>>;
  deleteOrganisationByName?: Resolver<Maybe<ResolversTypes['DeleteOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationByNameArgs, 'input'>>;
  deletePermissionJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeletePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionJoinByNodeIdArgs, 'input'>>;
  deletePermissionJoin?: Resolver<Maybe<ResolversTypes['DeletePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionJoinArgs, 'input'>>;
  deletePermissionNameByNodeId?: Resolver<Maybe<ResolversTypes['DeletePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionNameByNodeIdArgs, 'input'>>;
  deletePermissionName?: Resolver<Maybe<ResolversTypes['DeletePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionNameArgs, 'input'>>;
  deletePermissionNameByName?: Resolver<Maybe<ResolversTypes['DeletePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionNameByNameArgs, 'input'>>;
  deletePermissionPolicyByNodeId?: Resolver<Maybe<ResolversTypes['DeletePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionPolicyByNodeIdArgs, 'input'>>;
  deletePermissionPolicy?: Resolver<Maybe<ResolversTypes['DeletePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionPolicyArgs, 'input'>>;
  deleteReviewByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewByNodeIdArgs, 'input'>>;
  deleteReview?: Resolver<Maybe<ResolversTypes['DeleteReviewPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewArgs, 'input'>>;
  deleteReviewAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewAssignmentByNodeIdArgs, 'input'>>;
  deleteReviewAssignment?: Resolver<Maybe<ResolversTypes['DeleteReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewAssignmentArgs, 'input'>>;
  deleteReviewDecisionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewDecisionByNodeIdArgs, 'input'>>;
  deleteReviewDecision?: Resolver<Maybe<ResolversTypes['DeleteReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewDecisionArgs, 'input'>>;
  deleteReviewQuestionAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewQuestionAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewQuestionAssignmentByNodeIdArgs, 'input'>>;
  deleteReviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['DeleteReviewQuestionAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewQuestionAssignmentArgs, 'input'>>;
  deleteReviewResponseByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewResponseByNodeIdArgs, 'input'>>;
  deleteReviewResponse?: Resolver<Maybe<ResolversTypes['DeleteReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewResponseArgs, 'input'>>;
  deleteReviewStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewStatusHistoryByNodeIdArgs, 'input'>>;
  deleteReviewStatusHistory?: Resolver<Maybe<ResolversTypes['DeleteReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewStatusHistoryArgs, 'input'>>;
  deleteTemplateByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplatePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateByNodeIdArgs, 'input'>>;
  deleteTemplate?: Resolver<Maybe<ResolversTypes['DeleteTemplatePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateArgs, 'input'>>;
  deleteTemplateActionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateActionByNodeIdArgs, 'input'>>;
  deleteTemplateAction?: Resolver<Maybe<ResolversTypes['DeleteTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateActionArgs, 'input'>>;
  deleteTemplateElementByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateElementByNodeIdArgs, 'input'>>;
  deleteTemplateElement?: Resolver<Maybe<ResolversTypes['DeleteTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateElementArgs, 'input'>>;
  deleteTemplatePermissionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplatePermissionByNodeIdArgs, 'input'>>;
  deleteTemplatePermission?: Resolver<Maybe<ResolversTypes['DeleteTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplatePermissionArgs, 'input'>>;
  deleteTemplateSectionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateSectionByNodeIdArgs, 'input'>>;
  deleteTemplateSection?: Resolver<Maybe<ResolversTypes['DeleteTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateSectionArgs, 'input'>>;
  deleteTemplateStageByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateStageByNodeIdArgs, 'input'>>;
  deleteTemplateStage?: Resolver<Maybe<ResolversTypes['DeleteTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateStageArgs, 'input'>>;
  deleteTriggerQueueByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTriggerQueueByNodeIdArgs, 'input'>>;
  deleteTriggerQueue?: Resolver<Maybe<ResolversTypes['DeleteTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTriggerQueueArgs, 'input'>>;
  deleteUserByNodeId?: Resolver<Maybe<ResolversTypes['DeleteUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserByNodeIdArgs, 'input'>>;
  deleteUser?: Resolver<Maybe<ResolversTypes['DeleteUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserArgs, 'input'>>;
  deleteUserByUsername?: Resolver<Maybe<ResolversTypes['DeleteUserPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserByUsernameArgs, 'input'>>;
  deleteUserOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserOrganisationByNodeIdArgs, 'input'>>;
  deleteUserOrganisation?: Resolver<Maybe<ResolversTypes['DeleteUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserOrganisationArgs, 'input'>>;
};

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'Query' | 'ActionPlugin' | 'ActionQueue' | 'TriggerQueue' | 'Template' | 'TemplateStage' | 'ApplicationStageHistory' | 'Application' | 'User' | 'UserOrganisation' | 'Organisation' | 'PermissionJoin' | 'PermissionName' | 'PermissionPolicy' | 'TemplatePermission' | 'ReviewAssignment' | 'Review' | 'ReviewResponse' | 'ReviewQuestionAssignment' | 'TemplateElement' | 'TemplateSection' | 'ApplicationSection' | 'ApplicationResponse' | 'File' | 'Notification' | 'ReviewDecision' | 'ReviewStatusHistory' | 'ApplicationStatusHistory' | 'TemplateAction' | 'ElementTypePlugin', ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type NotificationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Notification'] = ResolversParentTypes['Notification']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  documentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  isRead?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  document?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationsConnection'] = ResolversParentTypes['NotificationsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['Notification']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['NotificationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationsEdge'] = ResolversParentTypes['NotificationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Organisation'] = ResolversParentTypes['Organisation']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  licenceNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userOrganisations?: Resolver<ResolversTypes['UserOrganisationsConnection'], ParentType, ContextType, RequireFields<OrganisationUserOrganisationsArgs, 'orderBy'>>;
  permissionJoins?: Resolver<ResolversTypes['PermissionJoinsConnection'], ParentType, ContextType, RequireFields<OrganisationPermissionJoinsArgs, 'orderBy'>>;
  applicationsByOrgId?: Resolver<ResolversTypes['ApplicationsConnection'], ParentType, ContextType, RequireFields<OrganisationApplicationsByOrgIdArgs, 'orderBy'>>;
  reviewAssignments?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<OrganisationReviewAssignmentsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganisationsConnection'] = ResolversParentTypes['OrganisationsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['Organisation']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['OrganisationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganisationsEdge'] = ResolversParentTypes['OrganisationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  endCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionJoin'] = ResolversParentTypes['PermissionJoin']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  organisationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  permissionNameId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionJoinsConnection'] = ResolversParentTypes['PermissionJoinsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['PermissionJoin']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PermissionJoinsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionJoinsEdge'] = ResolversParentTypes['PermissionJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionNameResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionName'] = ResolversParentTypes['PermissionName']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionPolicyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  permissionJoins?: Resolver<ResolversTypes['PermissionJoinsConnection'], ParentType, ContextType, RequireFields<PermissionNamePermissionJoinsArgs, 'orderBy'>>;
  templatePermissions?: Resolver<ResolversTypes['TemplatePermissionsConnection'], ParentType, ContextType, RequireFields<PermissionNameTemplatePermissionsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionNamesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionNamesConnection'] = ResolversParentTypes['PermissionNamesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['PermissionName']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PermissionNamesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionNamesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionNamesEdge'] = ResolversParentTypes['PermissionNamesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionPoliciesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionPoliciesConnection'] = ResolversParentTypes['PermissionPoliciesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['PermissionPolicy']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['PermissionPoliciesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionPoliciesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionPoliciesEdge'] = ResolversParentTypes['PermissionPoliciesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionPolicyResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionPolicy'] = ResolversParentTypes['PermissionPolicy']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  rules?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['PermissionPolicyType']>, ParentType, ContextType>;
  defaultRestrictions?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  permissionNames?: Resolver<ResolversTypes['PermissionNamesConnection'], ParentType, ContextType, RequireFields<PermissionPolicyPermissionNamesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QueryNodeArgs, 'nodeId'>>;
  actionPlugins?: Resolver<Maybe<ResolversTypes['ActionPluginsConnection']>, ParentType, ContextType, RequireFields<QueryActionPluginsArgs, 'orderBy'>>;
  actionQueues?: Resolver<Maybe<ResolversTypes['ActionQueuesConnection']>, ParentType, ContextType, RequireFields<QueryActionQueuesArgs, 'orderBy'>>;
  allPermissions?: Resolver<Maybe<ResolversTypes['AllPermissionsConnection']>, ParentType, ContextType, RequireFields<QueryAllPermissionsArgs, 'orderBy'>>;
  applications?: Resolver<Maybe<ResolversTypes['ApplicationsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationsArgs, 'orderBy'>>;
  applicationLists?: Resolver<Maybe<ResolversTypes['ApplicationListsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationListsArgs, 'orderBy'>>;
  applicationResponses?: Resolver<Maybe<ResolversTypes['ApplicationResponsesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationResponsesArgs, 'orderBy'>>;
  applicationSections?: Resolver<Maybe<ResolversTypes['ApplicationSectionsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationSectionsArgs, 'orderBy'>>;
  applicationStageHistories?: Resolver<Maybe<ResolversTypes['ApplicationStageHistoriesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationStageHistoriesArgs, 'orderBy'>>;
  applicationStageStatusAlls?: Resolver<Maybe<ResolversTypes['ApplicationStageStatusAllsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationStageStatusAllsArgs, 'orderBy'>>;
  applicationStageStatusLatests?: Resolver<Maybe<ResolversTypes['ApplicationStageStatusLatestsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationStageStatusLatestsArgs, 'orderBy'>>;
  applicationStatusHistories?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistoriesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationStatusHistoriesArgs, 'orderBy'>>;
  applicationTriggerStates?: Resolver<Maybe<ResolversTypes['ApplicationTriggerStatesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationTriggerStatesArgs, 'orderBy'>>;
  elementTypePlugins?: Resolver<Maybe<ResolversTypes['ElementTypePluginsConnection']>, ParentType, ContextType, RequireFields<QueryElementTypePluginsArgs, 'orderBy'>>;
  files?: Resolver<Maybe<ResolversTypes['FilesConnection']>, ParentType, ContextType, RequireFields<QueryFilesArgs, 'orderBy'>>;
  notifications?: Resolver<Maybe<ResolversTypes['NotificationsConnection']>, ParentType, ContextType, RequireFields<QueryNotificationsArgs, 'orderBy'>>;
  organisations?: Resolver<Maybe<ResolversTypes['OrganisationsConnection']>, ParentType, ContextType, RequireFields<QueryOrganisationsArgs, 'orderBy'>>;
  permissionJoins?: Resolver<Maybe<ResolversTypes['PermissionJoinsConnection']>, ParentType, ContextType, RequireFields<QueryPermissionJoinsArgs, 'orderBy'>>;
  permissionNames?: Resolver<Maybe<ResolversTypes['PermissionNamesConnection']>, ParentType, ContextType, RequireFields<QueryPermissionNamesArgs, 'orderBy'>>;
  permissionPolicies?: Resolver<Maybe<ResolversTypes['PermissionPoliciesConnection']>, ParentType, ContextType, RequireFields<QueryPermissionPoliciesArgs, 'orderBy'>>;
  reviews?: Resolver<Maybe<ResolversTypes['ReviewsConnection']>, ParentType, ContextType, RequireFields<QueryReviewsArgs, 'orderBy'>>;
  reviewAssignments?: Resolver<Maybe<ResolversTypes['ReviewAssignmentsConnection']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentsArgs, 'orderBy'>>;
  reviewDecisions?: Resolver<Maybe<ResolversTypes['ReviewDecisionsConnection']>, ParentType, ContextType, RequireFields<QueryReviewDecisionsArgs, 'orderBy'>>;
  reviewQuestionAssignments?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignmentsConnection']>, ParentType, ContextType, RequireFields<QueryReviewQuestionAssignmentsArgs, 'orderBy'>>;
  reviewResponses?: Resolver<Maybe<ResolversTypes['ReviewResponsesConnection']>, ParentType, ContextType, RequireFields<QueryReviewResponsesArgs, 'orderBy'>>;
  reviewStatusHistories?: Resolver<Maybe<ResolversTypes['ReviewStatusHistoriesConnection']>, ParentType, ContextType, RequireFields<QueryReviewStatusHistoriesArgs, 'orderBy'>>;
  templates?: Resolver<Maybe<ResolversTypes['TemplatesConnection']>, ParentType, ContextType, RequireFields<QueryTemplatesArgs, 'orderBy'>>;
  templateActions?: Resolver<Maybe<ResolversTypes['TemplateActionsConnection']>, ParentType, ContextType, RequireFields<QueryTemplateActionsArgs, 'orderBy'>>;
  templateElements?: Resolver<Maybe<ResolversTypes['TemplateElementsConnection']>, ParentType, ContextType, RequireFields<QueryTemplateElementsArgs, 'orderBy'>>;
  templatePermissions?: Resolver<Maybe<ResolversTypes['TemplatePermissionsConnection']>, ParentType, ContextType, RequireFields<QueryTemplatePermissionsArgs, 'orderBy'>>;
  templateSections?: Resolver<Maybe<ResolversTypes['TemplateSectionsConnection']>, ParentType, ContextType, RequireFields<QueryTemplateSectionsArgs, 'orderBy'>>;
  templateStages?: Resolver<Maybe<ResolversTypes['TemplateStagesConnection']>, ParentType, ContextType, RequireFields<QueryTemplateStagesArgs, 'orderBy'>>;
  triggerQueues?: Resolver<Maybe<ResolversTypes['TriggerQueuesConnection']>, ParentType, ContextType, RequireFields<QueryTriggerQueuesArgs, 'orderBy'>>;
  users?: Resolver<Maybe<ResolversTypes['UsersConnection']>, ParentType, ContextType, RequireFields<QueryUsersArgs, 'orderBy'>>;
  userOrgJoins?: Resolver<Maybe<ResolversTypes['UserOrgJoinsConnection']>, ParentType, ContextType, RequireFields<QueryUserOrgJoinsArgs, 'orderBy'>>;
  userOrganisations?: Resolver<Maybe<ResolversTypes['UserOrganisationsConnection']>, ParentType, ContextType, RequireFields<QueryUserOrganisationsArgs, 'orderBy'>>;
  actionPlugin?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType, RequireFields<QueryActionPluginArgs, 'code'>>;
  actionQueue?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType, RequireFields<QueryActionQueueArgs, 'id'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType, RequireFields<QueryApplicationArgs, 'id'>>;
  applicationBySerial?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType, RequireFields<QueryApplicationBySerialArgs, 'serial'>>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType, RequireFields<QueryApplicationResponseArgs, 'id'>>;
  applicationSection?: Resolver<Maybe<ResolversTypes['ApplicationSection']>, ParentType, ContextType, RequireFields<QueryApplicationSectionArgs, 'id'>>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType, RequireFields<QueryApplicationStageHistoryArgs, 'id'>>;
  applicationStatusHistory?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType, RequireFields<QueryApplicationStatusHistoryArgs, 'id'>>;
  elementTypePlugin?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType, RequireFields<QueryElementTypePluginArgs, 'code'>>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<QueryFileArgs, 'id'>>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType, RequireFields<QueryNotificationArgs, 'id'>>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType, RequireFields<QueryOrganisationArgs, 'id'>>;
  organisationByName?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType, RequireFields<QueryOrganisationByNameArgs, 'name'>>;
  permissionJoin?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType, RequireFields<QueryPermissionJoinArgs, 'id'>>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType, RequireFields<QueryPermissionNameArgs, 'id'>>;
  permissionNameByName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType, RequireFields<QueryPermissionNameByNameArgs, 'name'>>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType, RequireFields<QueryPermissionPolicyArgs, 'id'>>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<QueryReviewArgs, 'id'>>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentArgs, 'id'>>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType, RequireFields<QueryReviewDecisionArgs, 'id'>>;
  reviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType, RequireFields<QueryReviewQuestionAssignmentArgs, 'id'>>;
  reviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType, RequireFields<QueryReviewResponseArgs, 'id'>>;
  reviewStatusHistory?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType, RequireFields<QueryReviewStatusHistoryArgs, 'id'>>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType, RequireFields<QueryTemplateArgs, 'id'>>;
  templateAction?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType, RequireFields<QueryTemplateActionArgs, 'id'>>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType, RequireFields<QueryTemplateElementArgs, 'id'>>;
  templatePermission?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType, RequireFields<QueryTemplatePermissionArgs, 'id'>>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType, RequireFields<QueryTemplateSectionArgs, 'id'>>;
  templateStage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType, RequireFields<QueryTemplateStageArgs, 'id'>>;
  triggerQueue?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType, RequireFields<QueryTriggerQueueArgs, 'id'>>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserArgs, 'id'>>;
  userByUsername?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserByUsernameArgs, 'username'>>;
  userOrganisation?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType, RequireFields<QueryUserOrganisationArgs, 'id'>>;
  applicationStatusHistoryApplicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<QueryApplicationStatusHistoryApplicationIdArgs, never>>;
  jwtGetBigint?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, RequireFields<QueryJwtGetBigintArgs, never>>;
  jwtGetBoolean?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryJwtGetBooleanArgs, never>>;
  jwtGetText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, RequireFields<QueryJwtGetTextArgs, never>>;
  reviewApplicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<QueryReviewApplicationIdArgs, never>>;
  reviewIsLastLevel?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, RequireFields<QueryReviewIsLastLevelArgs, never>>;
  reviewLevel?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<QueryReviewLevelArgs, never>>;
  reviewReviewerId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType, RequireFields<QueryReviewReviewerIdArgs, never>>;
  actionPluginByNodeId?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType, RequireFields<QueryActionPluginByNodeIdArgs, 'nodeId'>>;
  actionQueueByNodeId?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType, RequireFields<QueryActionQueueByNodeIdArgs, 'nodeId'>>;
  applicationByNodeId?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType, RequireFields<QueryApplicationByNodeIdArgs, 'nodeId'>>;
  applicationResponseByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType, RequireFields<QueryApplicationResponseByNodeIdArgs, 'nodeId'>>;
  applicationSectionByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationSection']>, ParentType, ContextType, RequireFields<QueryApplicationSectionByNodeIdArgs, 'nodeId'>>;
  applicationStageHistoryByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType, RequireFields<QueryApplicationStageHistoryByNodeIdArgs, 'nodeId'>>;
  applicationStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType, RequireFields<QueryApplicationStatusHistoryByNodeIdArgs, 'nodeId'>>;
  elementTypePluginByNodeId?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType, RequireFields<QueryElementTypePluginByNodeIdArgs, 'nodeId'>>;
  fileByNodeId?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<QueryFileByNodeIdArgs, 'nodeId'>>;
  notificationByNodeId?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType, RequireFields<QueryNotificationByNodeIdArgs, 'nodeId'>>;
  organisationByNodeId?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType, RequireFields<QueryOrganisationByNodeIdArgs, 'nodeId'>>;
  permissionJoinByNodeId?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType, RequireFields<QueryPermissionJoinByNodeIdArgs, 'nodeId'>>;
  permissionNameByNodeId?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType, RequireFields<QueryPermissionNameByNodeIdArgs, 'nodeId'>>;
  permissionPolicyByNodeId?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType, RequireFields<QueryPermissionPolicyByNodeIdArgs, 'nodeId'>>;
  reviewByNodeId?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<QueryReviewByNodeIdArgs, 'nodeId'>>;
  reviewAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentByNodeIdArgs, 'nodeId'>>;
  reviewDecisionByNodeId?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType, RequireFields<QueryReviewDecisionByNodeIdArgs, 'nodeId'>>;
  reviewQuestionAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType, RequireFields<QueryReviewQuestionAssignmentByNodeIdArgs, 'nodeId'>>;
  reviewResponseByNodeId?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType, RequireFields<QueryReviewResponseByNodeIdArgs, 'nodeId'>>;
  reviewStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType, RequireFields<QueryReviewStatusHistoryByNodeIdArgs, 'nodeId'>>;
  templateByNodeId?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType, RequireFields<QueryTemplateByNodeIdArgs, 'nodeId'>>;
  templateActionByNodeId?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType, RequireFields<QueryTemplateActionByNodeIdArgs, 'nodeId'>>;
  templateElementByNodeId?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType, RequireFields<QueryTemplateElementByNodeIdArgs, 'nodeId'>>;
  templatePermissionByNodeId?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType, RequireFields<QueryTemplatePermissionByNodeIdArgs, 'nodeId'>>;
  templateSectionByNodeId?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType, RequireFields<QueryTemplateSectionByNodeIdArgs, 'nodeId'>>;
  templateStageByNodeId?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType, RequireFields<QueryTemplateStageByNodeIdArgs, 'nodeId'>>;
  triggerQueueByNodeId?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType, RequireFields<QueryTriggerQueueByNodeIdArgs, 'nodeId'>>;
  userByNodeId?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType, RequireFields<QueryUserByNodeIdArgs, 'nodeId'>>;
  userOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType, RequireFields<QueryUserOrganisationByNodeIdArgs, 'nodeId'>>;
};

export type ReviewResolvers<ContextType = any, ParentType extends ResolversParentTypes['Review'] = ResolversParentTypes['Review']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  reviewAssignmentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewerId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  isLastLevel?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  reviewResponses?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ReviewReviewResponsesArgs, 'orderBy'>>;
  reviewDecisions?: Resolver<ResolversTypes['ReviewDecisionsConnection'], ParentType, ContextType, RequireFields<ReviewReviewDecisionsArgs, 'orderBy'>>;
  reviewStatusHistories?: Resolver<ResolversTypes['ReviewStatusHistoriesConnection'], ParentType, ContextType, RequireFields<ReviewReviewStatusHistoriesArgs, 'orderBy'>>;
  notifications?: Resolver<ResolversTypes['NotificationsConnection'], ParentType, ContextType, RequireFields<ReviewNotificationsArgs, 'orderBy'>>;
  latestDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ReviewStatus']>, ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignment'] = ResolversParentTypes['ReviewAssignment']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assignerId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewerId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  organisationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['ReviewAssignmentStatus'], ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateSectionRestrictions?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  isLastLevel?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  assigner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  reviewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviews?: Resolver<ResolversTypes['ReviewsConnection'], ParentType, ContextType, RequireFields<ReviewAssignmentReviewsArgs, 'orderBy'>>;
  reviewQuestionAssignments?: Resolver<ResolversTypes['ReviewQuestionAssignmentsConnection'], ParentType, ContextType, RequireFields<ReviewAssignmentReviewQuestionAssignmentsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentsConnection'] = ResolversParentTypes['ReviewAssignmentsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewAssignment']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReviewAssignmentsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentsEdge'] = ResolversParentTypes['ReviewAssignmentsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDecisionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewDecision'] = ResolversParentTypes['ReviewDecision']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  reviewId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  decision?: Resolver<Maybe<ResolversTypes['Decision']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timeUpdated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDecisionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewDecisionsConnection'] = ResolversParentTypes['ReviewDecisionsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewDecision']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReviewDecisionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDecisionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewDecisionsEdge'] = ResolversParentTypes['ReviewDecisionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewQuestionAssignmentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewQuestionAssignment'] = ResolversParentTypes['ReviewQuestionAssignment']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  templateElementId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewAssignmentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewResponses?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ReviewQuestionAssignmentReviewResponsesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewQuestionAssignmentsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewQuestionAssignmentsConnection'] = ResolversParentTypes['ReviewQuestionAssignmentsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewQuestionAssignment']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReviewQuestionAssignmentsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewQuestionAssignmentsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewQuestionAssignmentsEdge'] = ResolversParentTypes['ReviewQuestionAssignmentsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewResponse'] = ResolversParentTypes['ReviewResponse']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  decision?: Resolver<Maybe<ResolversTypes['ReviewResponseDecision']>, ParentType, ContextType>;
  reviewQuestionAssignmentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  applicationResponseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewResponseLinkId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  originalReviewResponseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  timeUpdated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  isVisibleToApplicant?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  templateElementId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  recommendedApplicantVisibility?: Resolver<Maybe<ResolversTypes['ReviewResponseRecommendedApplicantVisibility']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ReviewResponseStatus']>, ParentType, ContextType>;
  reviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  reviewResponseLink?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  originalReviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  reviewResponsesByReviewResponseLinkId?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ReviewResponseReviewResponsesByReviewResponseLinkIdArgs, 'orderBy'>>;
  reviewResponsesByOriginalReviewResponseId?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ReviewResponseReviewResponsesByOriginalReviewResponseIdArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewResponsesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewResponsesConnection'] = ResolversParentTypes['ReviewResponsesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewResponse']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReviewResponsesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewResponsesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewResponsesEdge'] = ResolversParentTypes['ReviewResponsesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewsConnection'] = ResolversParentTypes['ReviewsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['Review']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReviewsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewsEdge'] = ResolversParentTypes['ReviewsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewStatusHistoriesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewStatusHistoriesConnection'] = ResolversParentTypes['ReviewStatusHistoriesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewStatusHistory']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['ReviewStatusHistoriesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewStatusHistoriesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewStatusHistoriesEdge'] = ResolversParentTypes['ReviewStatusHistoriesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewStatusHistoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewStatusHistory'] = ResolversParentTypes['ReviewStatusHistory']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  reviewId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ReviewStatus']>, ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  isCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateResolvers<ContextType = any, ParentType extends ResolversParentTypes['Template'] = ResolversParentTypes['Template']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  isLinear?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  startMessage?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['TemplateStatus']>, ParentType, ContextType>;
  submissionMessage?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  versionTimestamp?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  templateStages?: Resolver<ResolversTypes['TemplateStagesConnection'], ParentType, ContextType, RequireFields<TemplateTemplateStagesArgs, 'orderBy'>>;
  templateSections?: Resolver<ResolversTypes['TemplateSectionsConnection'], ParentType, ContextType, RequireFields<TemplateTemplateSectionsArgs, 'orderBy'>>;
  templatePermissions?: Resolver<ResolversTypes['TemplatePermissionsConnection'], ParentType, ContextType, RequireFields<TemplateTemplatePermissionsArgs, 'orderBy'>>;
  applications?: Resolver<ResolversTypes['ApplicationsConnection'], ParentType, ContextType, RequireFields<TemplateApplicationsArgs, 'orderBy'>>;
  actionQueues?: Resolver<ResolversTypes['ActionQueuesConnection'], ParentType, ContextType, RequireFields<TemplateActionQueuesArgs, 'orderBy'>>;
  templateActions?: Resolver<ResolversTypes['TemplateActionsConnection'], ParentType, ContextType, RequireFields<TemplateTemplateActionsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateAction'] = ResolversParentTypes['TemplateAction']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  actionCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  sequence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  condition?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  parameterQueries?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateActionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateActionsConnection'] = ResolversParentTypes['TemplateActionsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateAction']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TemplateActionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateActionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateActionsEdge'] = ResolversParentTypes['TemplateActionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateElementResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateElement'] = ResolversParentTypes['TemplateElement']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  sectionId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['TemplateElementCategory']>, ParentType, ContextType>;
  elementTypePluginCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visibilityCondition?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  isRequired?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  isEditable?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  validation?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  validationMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  parameters?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  applicationResponses?: Resolver<ResolversTypes['ApplicationResponsesConnection'], ParentType, ContextType, RequireFields<TemplateElementApplicationResponsesArgs, 'orderBy'>>;
  reviewQuestionAssignments?: Resolver<ResolversTypes['ReviewQuestionAssignmentsConnection'], ParentType, ContextType, RequireFields<TemplateElementReviewQuestionAssignmentsArgs, 'orderBy'>>;
  reviewResponses?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<TemplateElementReviewResponsesArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateElementsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateElementsConnection'] = ResolversParentTypes['TemplateElementsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateElement']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TemplateElementsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateElementsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateElementsEdge'] = ResolversParentTypes['TemplateElementsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatePermissionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatePermission'] = ResolversParentTypes['TemplatePermission']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  permissionNameId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restrictions?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatePermissionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatePermissionsConnection'] = ResolversParentTypes['TemplatePermissionsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplatePermission']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TemplatePermissionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatePermissionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatePermissionsEdge'] = ResolversParentTypes['TemplatePermissionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatesConnection'] = ResolversParentTypes['TemplatesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['Template']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TemplatesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateSectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateSection'] = ResolversParentTypes['TemplateSection']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateElementsBySectionId?: Resolver<ResolversTypes['TemplateElementsConnection'], ParentType, ContextType, RequireFields<TemplateSectionTemplateElementsBySectionIdArgs, 'orderBy'>>;
  applicationSections?: Resolver<ResolversTypes['ApplicationSectionsConnection'], ParentType, ContextType, RequireFields<TemplateSectionApplicationSectionsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateSectionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateSectionsConnection'] = ResolversParentTypes['TemplateSectionsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateSection']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TemplateSectionsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateSectionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateSectionsEdge'] = ResolversParentTypes['TemplateSectionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatesEdge'] = ResolversParentTypes['TemplatesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStageResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStage'] = ResolversParentTypes['TemplateStage']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  applicationStageHistoriesByStageId?: Resolver<ResolversTypes['ApplicationStageHistoriesConnection'], ParentType, ContextType, RequireFields<TemplateStageApplicationStageHistoriesByStageIdArgs, 'orderBy'>>;
  reviewAssignmentsByStageId?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<TemplateStageReviewAssignmentsByStageIdArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStagesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStagesConnection'] = ResolversParentTypes['TemplateStagesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateStage']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TemplateStagesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStagesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStagesEdge'] = ResolversParentTypes['TemplateStagesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerQueueResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerQueue'] = ResolversParentTypes['TriggerQueue']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  triggerType?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  table?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  recordId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['TriggerQueueStatus']>, ParentType, ContextType>;
  log?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  actionQueuesByTriggerEvent?: Resolver<ResolversTypes['ActionQueuesConnection'], ParentType, ContextType, RequireFields<TriggerQueueActionQueuesByTriggerEventArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerQueuesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerQueuesConnection'] = ResolversParentTypes['TriggerQueuesConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['TriggerQueue']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['TriggerQueuesEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerQueuesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerQueuesEdge'] = ResolversParentTypes['TriggerQueuesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateActionPluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateActionPluginPayload'] = ResolversParentTypes['UpdateActionPluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionPlugin?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  actionPluginEdge?: Resolver<Maybe<ResolversTypes['ActionPluginsEdge']>, ParentType, ContextType, RequireFields<UpdateActionPluginPayloadActionPluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateActionQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateActionQueuePayload'] = ResolversParentTypes['UpdateActionQueuePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  actionQueue?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueueByTriggerEvent?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  actionQueueEdge?: Resolver<Maybe<ResolversTypes['ActionQueuesEdge']>, ParentType, ContextType, RequireFields<UpdateActionQueuePayloadActionQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationPayload'] = ResolversParentTypes['UpdateApplicationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  applicationEdge?: Resolver<Maybe<ResolversTypes['ApplicationsEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationPayloadApplicationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationResponsePayload'] = ResolversParentTypes['UpdateApplicationResponsePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponseEdge?: Resolver<Maybe<ResolversTypes['ApplicationResponsesEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationResponsePayloadApplicationResponseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationSectionPayload'] = ResolversParentTypes['UpdateApplicationSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationSection?: Resolver<Maybe<ResolversTypes['ApplicationSection']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  applicationSectionEdge?: Resolver<Maybe<ResolversTypes['ApplicationSectionsEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationSectionPayloadApplicationSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationStageHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationStageHistoryPayload'] = ResolversParentTypes['UpdateApplicationStageHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  applicationStageHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStageHistoriesEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationStatusHistoryPayload'] = ResolversParentTypes['UpdateApplicationStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationStatusHistory?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateElementTypePluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateElementTypePluginPayload'] = ResolversParentTypes['UpdateElementTypePluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elementTypePlugin?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  elementTypePluginEdge?: Resolver<Maybe<ResolversTypes['ElementTypePluginsEdge']>, ParentType, ContextType, RequireFields<UpdateElementTypePluginPayloadElementTypePluginEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateFilePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateFilePayload'] = ResolversParentTypes['UpdateFilePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  fileEdge?: Resolver<Maybe<ResolversTypes['FilesEdge']>, ParentType, ContextType, RequireFields<UpdateFilePayloadFileEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateNotificationPayload'] = ResolversParentTypes['UpdateNotificationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  document?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<UpdateNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateOrganisationPayload'] = ResolversParentTypes['UpdateOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  organisationEdge?: Resolver<Maybe<ResolversTypes['OrganisationsEdge']>, ParentType, ContextType, RequireFields<UpdateOrganisationPayloadOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePermissionJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePermissionJoinPayload'] = ResolversParentTypes['UpdatePermissionJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionJoin?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  permissionJoinEdge?: Resolver<Maybe<ResolversTypes['PermissionJoinsEdge']>, ParentType, ContextType, RequireFields<UpdatePermissionJoinPayloadPermissionJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePermissionNamePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePermissionNamePayload'] = ResolversParentTypes['UpdatePermissionNamePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  permissionNameEdge?: Resolver<Maybe<ResolversTypes['PermissionNamesEdge']>, ParentType, ContextType, RequireFields<UpdatePermissionNamePayloadPermissionNameEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePermissionPolicyPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePermissionPolicyPayload'] = ResolversParentTypes['UpdatePermissionPolicyPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionPolicyEdge?: Resolver<Maybe<ResolversTypes['PermissionPoliciesEdge']>, ParentType, ContextType, RequireFields<UpdatePermissionPolicyPayloadPermissionPolicyEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewAssignmentPayload'] = ResolversParentTypes['UpdateReviewAssignmentPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  assigner?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  reviewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviewAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewAssignmentPayloadReviewAssignmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewDecisionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewDecisionPayload'] = ResolversParentTypes['UpdateReviewDecisionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewDecisionEdge?: Resolver<Maybe<ResolversTypes['ReviewDecisionsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewDecisionPayloadReviewDecisionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewPayload'] = ResolversParentTypes['UpdateReviewPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  reviewer?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewPayloadReviewEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewQuestionAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewQuestionAssignmentPayload'] = ResolversParentTypes['UpdateReviewQuestionAssignmentPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewQuestionAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignmentsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewQuestionAssignmentPayloadReviewQuestionAssignmentEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewResponsePayload'] = ResolversParentTypes['UpdateReviewResponsePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewQuestionAssignment?: Resolver<Maybe<ResolversTypes['ReviewQuestionAssignment']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  reviewResponseLink?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  originalReviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  reviewResponseEdge?: Resolver<Maybe<ResolversTypes['ReviewResponsesEdge']>, ParentType, ContextType, RequireFields<UpdateReviewResponsePayloadReviewResponseEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewStatusHistoryPayload'] = ResolversParentTypes['UpdateReviewStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewStatusHistory?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ReviewStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<UpdateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateActionPayload'] = ResolversParentTypes['UpdateTemplateActionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateAction?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateActionEdge?: Resolver<Maybe<ResolversTypes['TemplateActionsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateActionPayloadTemplateActionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateElementPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateElementPayload'] = ResolversParentTypes['UpdateTemplateElementPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateElementEdge?: Resolver<Maybe<ResolversTypes['TemplateElementsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateElementPayloadTemplateElementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplatePayload'] = ResolversParentTypes['UpdateTemplatePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<UpdateTemplatePayloadTemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplatePermissionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplatePermissionPayload'] = ResolversParentTypes['UpdateTemplatePermissionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templatePermission?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templatePermissionEdge?: Resolver<Maybe<ResolversTypes['TemplatePermissionsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplatePermissionPayloadTemplatePermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateSectionPayload'] = ResolversParentTypes['UpdateTemplateSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateSectionEdge?: Resolver<Maybe<ResolversTypes['TemplateSectionsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateSectionPayloadTemplateSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateStagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateStagePayload'] = ResolversParentTypes['UpdateTemplateStagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateStage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateStageEdge?: Resolver<Maybe<ResolversTypes['TemplateStagesEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateStagePayloadTemplateStageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTriggerQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTriggerQueuePayload'] = ResolversParentTypes['UpdateTriggerQueuePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  triggerQueue?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueueEdge?: Resolver<Maybe<ResolversTypes['TriggerQueuesEdge']>, ParentType, ContextType, RequireFields<UpdateTriggerQueuePayloadTriggerQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateUserOrganisationPayload'] = ResolversParentTypes['UpdateUserOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userOrganisation?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  userOrganisationEdge?: Resolver<Maybe<ResolversTypes['UserOrganisationsEdge']>, ParentType, ContextType, RequireFields<UpdateUserOrganisationPayloadUserOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateUserPayload'] = ResolversParentTypes['UpdateUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<UpdateUserPayloadUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateOfBirth?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  passwordHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userOrganisations?: Resolver<ResolversTypes['UserOrganisationsConnection'], ParentType, ContextType, RequireFields<UserUserOrganisationsArgs, 'orderBy'>>;
  permissionJoins?: Resolver<ResolversTypes['PermissionJoinsConnection'], ParentType, ContextType, RequireFields<UserPermissionJoinsArgs, 'orderBy'>>;
  applications?: Resolver<ResolversTypes['ApplicationsConnection'], ParentType, ContextType, RequireFields<UserApplicationsArgs, 'orderBy'>>;
  reviewAssignmentsByAssignerId?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<UserReviewAssignmentsByAssignerIdArgs, 'orderBy'>>;
  reviewedReviewAssignments?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<UserReviewedReviewAssignmentsArgs, 'orderBy'>>;
  reviewedReviews?: Resolver<ResolversTypes['ReviewsConnection'], ParentType, ContextType, RequireFields<UserReviewedReviewsArgs, 'orderBy'>>;
  files?: Resolver<ResolversTypes['FilesConnection'], ParentType, ContextType, RequireFields<UserFilesArgs, 'orderBy'>>;
  notifications?: Resolver<ResolversTypes['NotificationsConnection'], ParentType, ContextType, RequireFields<UserNotificationsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrganisationResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrganisation'] = ResolversParentTypes['UserOrganisation']> = {
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  organisationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  userRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrganisationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrganisationsConnection'] = ResolversParentTypes['UserOrganisationsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['UserOrganisation']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['UserOrganisationsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrganisationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrganisationsEdge'] = ResolversParentTypes['UserOrganisationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrgJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrgJoin'] = ResolversParentTypes['UserOrgJoin']> = {
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateOfBirth?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  passwordHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  orgName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  licenceNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrgJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrgJoinsConnection'] = ResolversParentTypes['UserOrgJoinsConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['UserOrgJoin']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['UserOrgJoinsEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrgJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrgJoinsEdge'] = ResolversParentTypes['UserOrgJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserOrgJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UsersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsersConnection'] = ResolversParentTypes['UsersConnection']> = {
  nodes?: Resolver<Array<Maybe<ResolversTypes['User']>>, ParentType, ContextType>;
  edges?: Resolver<Array<ResolversTypes['UsersEdge']>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UsersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsersEdge'] = ResolversParentTypes['UsersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type Resolvers<ContextType = any> = {
  ActionPlugin?: ActionPluginResolvers<ContextType>;
  ActionPluginsConnection?: ActionPluginsConnectionResolvers<ContextType>;
  ActionPluginsEdge?: ActionPluginsEdgeResolvers<ContextType>;
  ActionQueue?: ActionQueueResolvers<ContextType>;
  ActionQueuesConnection?: ActionQueuesConnectionResolvers<ContextType>;
  ActionQueuesEdge?: ActionQueuesEdgeResolvers<ContextType>;
  AllPermission?: AllPermissionResolvers<ContextType>;
  AllPermissionsConnection?: AllPermissionsConnectionResolvers<ContextType>;
  AllPermissionsEdge?: AllPermissionsEdgeResolvers<ContextType>;
  Application?: ApplicationResolvers<ContextType>;
  ApplicationList?: ApplicationListResolvers<ContextType>;
  ApplicationListsConnection?: ApplicationListsConnectionResolvers<ContextType>;
  ApplicationListsEdge?: ApplicationListsEdgeResolvers<ContextType>;
  ApplicationResponse?: ApplicationResponseResolvers<ContextType>;
  ApplicationResponsesConnection?: ApplicationResponsesConnectionResolvers<ContextType>;
  ApplicationResponsesEdge?: ApplicationResponsesEdgeResolvers<ContextType>;
  ApplicationsConnection?: ApplicationsConnectionResolvers<ContextType>;
  ApplicationSection?: ApplicationSectionResolvers<ContextType>;
  ApplicationSectionsConnection?: ApplicationSectionsConnectionResolvers<ContextType>;
  ApplicationSectionsEdge?: ApplicationSectionsEdgeResolvers<ContextType>;
  ApplicationsEdge?: ApplicationsEdgeResolvers<ContextType>;
  ApplicationStageHistoriesConnection?: ApplicationStageHistoriesConnectionResolvers<ContextType>;
  ApplicationStageHistoriesEdge?: ApplicationStageHistoriesEdgeResolvers<ContextType>;
  ApplicationStageHistory?: ApplicationStageHistoryResolvers<ContextType>;
  ApplicationStageStatusAll?: ApplicationStageStatusAllResolvers<ContextType>;
  ApplicationStageStatusAllsConnection?: ApplicationStageStatusAllsConnectionResolvers<ContextType>;
  ApplicationStageStatusAllsEdge?: ApplicationStageStatusAllsEdgeResolvers<ContextType>;
  ApplicationStageStatusLatest?: ApplicationStageStatusLatestResolvers<ContextType>;
  ApplicationStageStatusLatestsConnection?: ApplicationStageStatusLatestsConnectionResolvers<ContextType>;
  ApplicationStageStatusLatestsEdge?: ApplicationStageStatusLatestsEdgeResolvers<ContextType>;
  ApplicationStatusHistoriesConnection?: ApplicationStatusHistoriesConnectionResolvers<ContextType>;
  ApplicationStatusHistoriesEdge?: ApplicationStatusHistoriesEdgeResolvers<ContextType>;
  ApplicationStatusHistory?: ApplicationStatusHistoryResolvers<ContextType>;
  ApplicationTriggerState?: ApplicationTriggerStateResolvers<ContextType>;
  ApplicationTriggerStatesConnection?: ApplicationTriggerStatesConnectionResolvers<ContextType>;
  ApplicationTriggerStatesEdge?: ApplicationTriggerStatesEdgeResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  CreateActionPluginPayload?: CreateActionPluginPayloadResolvers<ContextType>;
  CreateActionQueuePayload?: CreateActionQueuePayloadResolvers<ContextType>;
  CreateApplicationPayload?: CreateApplicationPayloadResolvers<ContextType>;
  CreateApplicationResponsePayload?: CreateApplicationResponsePayloadResolvers<ContextType>;
  CreateApplicationSectionPayload?: CreateApplicationSectionPayloadResolvers<ContextType>;
  CreateApplicationStageHistoryPayload?: CreateApplicationStageHistoryPayloadResolvers<ContextType>;
  CreateApplicationStatusHistoryPayload?: CreateApplicationStatusHistoryPayloadResolvers<ContextType>;
  CreateElementTypePluginPayload?: CreateElementTypePluginPayloadResolvers<ContextType>;
  CreateFilePayload?: CreateFilePayloadResolvers<ContextType>;
  CreateNotificationPayload?: CreateNotificationPayloadResolvers<ContextType>;
  CreateOrganisationPayload?: CreateOrganisationPayloadResolvers<ContextType>;
  CreatePermissionJoinPayload?: CreatePermissionJoinPayloadResolvers<ContextType>;
  CreatePermissionNamePayload?: CreatePermissionNamePayloadResolvers<ContextType>;
  CreatePermissionPolicyPayload?: CreatePermissionPolicyPayloadResolvers<ContextType>;
  CreateReviewAssignmentPayload?: CreateReviewAssignmentPayloadResolvers<ContextType>;
  CreateReviewDecisionPayload?: CreateReviewDecisionPayloadResolvers<ContextType>;
  CreateReviewPayload?: CreateReviewPayloadResolvers<ContextType>;
  CreateReviewQuestionAssignmentPayload?: CreateReviewQuestionAssignmentPayloadResolvers<ContextType>;
  CreateReviewResponsePayload?: CreateReviewResponsePayloadResolvers<ContextType>;
  CreateReviewStatusHistoryPayload?: CreateReviewStatusHistoryPayloadResolvers<ContextType>;
  CreateTemplateActionPayload?: CreateTemplateActionPayloadResolvers<ContextType>;
  CreateTemplateElementPayload?: CreateTemplateElementPayloadResolvers<ContextType>;
  CreateTemplatePayload?: CreateTemplatePayloadResolvers<ContextType>;
  CreateTemplatePermissionPayload?: CreateTemplatePermissionPayloadResolvers<ContextType>;
  CreateTemplateSectionPayload?: CreateTemplateSectionPayloadResolvers<ContextType>;
  CreateTemplateStagePayload?: CreateTemplateStagePayloadResolvers<ContextType>;
  CreateTriggerQueuePayload?: CreateTriggerQueuePayloadResolvers<ContextType>;
  CreateUserOrganisationPayload?: CreateUserOrganisationPayloadResolvers<ContextType>;
  CreateUserPayload?: CreateUserPayloadResolvers<ContextType>;
  Cursor?: GraphQLScalarType;
  Date?: GraphQLScalarType;
  Datetime?: GraphQLScalarType;
  DeleteActionPluginPayload?: DeleteActionPluginPayloadResolvers<ContextType>;
  DeleteActionQueuePayload?: DeleteActionQueuePayloadResolvers<ContextType>;
  DeleteApplicationPayload?: DeleteApplicationPayloadResolvers<ContextType>;
  DeleteApplicationResponsePayload?: DeleteApplicationResponsePayloadResolvers<ContextType>;
  DeleteApplicationSectionPayload?: DeleteApplicationSectionPayloadResolvers<ContextType>;
  DeleteApplicationStageHistoryPayload?: DeleteApplicationStageHistoryPayloadResolvers<ContextType>;
  DeleteApplicationStatusHistoryPayload?: DeleteApplicationStatusHistoryPayloadResolvers<ContextType>;
  DeleteElementTypePluginPayload?: DeleteElementTypePluginPayloadResolvers<ContextType>;
  DeleteFilePayload?: DeleteFilePayloadResolvers<ContextType>;
  DeleteNotificationPayload?: DeleteNotificationPayloadResolvers<ContextType>;
  DeleteOrganisationPayload?: DeleteOrganisationPayloadResolvers<ContextType>;
  DeletePermissionJoinPayload?: DeletePermissionJoinPayloadResolvers<ContextType>;
  DeletePermissionNamePayload?: DeletePermissionNamePayloadResolvers<ContextType>;
  DeletePermissionPolicyPayload?: DeletePermissionPolicyPayloadResolvers<ContextType>;
  DeleteReviewAssignmentPayload?: DeleteReviewAssignmentPayloadResolvers<ContextType>;
  DeleteReviewDecisionPayload?: DeleteReviewDecisionPayloadResolvers<ContextType>;
  DeleteReviewPayload?: DeleteReviewPayloadResolvers<ContextType>;
  DeleteReviewQuestionAssignmentPayload?: DeleteReviewQuestionAssignmentPayloadResolvers<ContextType>;
  DeleteReviewResponsePayload?: DeleteReviewResponsePayloadResolvers<ContextType>;
  DeleteReviewStatusHistoryPayload?: DeleteReviewStatusHistoryPayloadResolvers<ContextType>;
  DeleteTemplateActionPayload?: DeleteTemplateActionPayloadResolvers<ContextType>;
  DeleteTemplateElementPayload?: DeleteTemplateElementPayloadResolvers<ContextType>;
  DeleteTemplatePayload?: DeleteTemplatePayloadResolvers<ContextType>;
  DeleteTemplatePermissionPayload?: DeleteTemplatePermissionPayloadResolvers<ContextType>;
  DeleteTemplateSectionPayload?: DeleteTemplateSectionPayloadResolvers<ContextType>;
  DeleteTemplateStagePayload?: DeleteTemplateStagePayloadResolvers<ContextType>;
  DeleteTriggerQueuePayload?: DeleteTriggerQueuePayloadResolvers<ContextType>;
  DeleteUserOrganisationPayload?: DeleteUserOrganisationPayloadResolvers<ContextType>;
  DeleteUserPayload?: DeleteUserPayloadResolvers<ContextType>;
  ElementTypePlugin?: ElementTypePluginResolvers<ContextType>;
  ElementTypePluginsConnection?: ElementTypePluginsConnectionResolvers<ContextType>;
  ElementTypePluginsEdge?: ElementTypePluginsEdgeResolvers<ContextType>;
  File?: FileResolvers<ContextType>;
  FilesConnection?: FilesConnectionResolvers<ContextType>;
  FilesEdge?: FilesEdgeResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  Notification?: NotificationResolvers<ContextType>;
  NotificationsConnection?: NotificationsConnectionResolvers<ContextType>;
  NotificationsEdge?: NotificationsEdgeResolvers<ContextType>;
  Organisation?: OrganisationResolvers<ContextType>;
  OrganisationsConnection?: OrganisationsConnectionResolvers<ContextType>;
  OrganisationsEdge?: OrganisationsEdgeResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PermissionJoin?: PermissionJoinResolvers<ContextType>;
  PermissionJoinsConnection?: PermissionJoinsConnectionResolvers<ContextType>;
  PermissionJoinsEdge?: PermissionJoinsEdgeResolvers<ContextType>;
  PermissionName?: PermissionNameResolvers<ContextType>;
  PermissionNamesConnection?: PermissionNamesConnectionResolvers<ContextType>;
  PermissionNamesEdge?: PermissionNamesEdgeResolvers<ContextType>;
  PermissionPoliciesConnection?: PermissionPoliciesConnectionResolvers<ContextType>;
  PermissionPoliciesEdge?: PermissionPoliciesEdgeResolvers<ContextType>;
  PermissionPolicy?: PermissionPolicyResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Review?: ReviewResolvers<ContextType>;
  ReviewAssignment?: ReviewAssignmentResolvers<ContextType>;
  ReviewAssignmentsConnection?: ReviewAssignmentsConnectionResolvers<ContextType>;
  ReviewAssignmentsEdge?: ReviewAssignmentsEdgeResolvers<ContextType>;
  ReviewDecision?: ReviewDecisionResolvers<ContextType>;
  ReviewDecisionsConnection?: ReviewDecisionsConnectionResolvers<ContextType>;
  ReviewDecisionsEdge?: ReviewDecisionsEdgeResolvers<ContextType>;
  ReviewQuestionAssignment?: ReviewQuestionAssignmentResolvers<ContextType>;
  ReviewQuestionAssignmentsConnection?: ReviewQuestionAssignmentsConnectionResolvers<ContextType>;
  ReviewQuestionAssignmentsEdge?: ReviewQuestionAssignmentsEdgeResolvers<ContextType>;
  ReviewResponse?: ReviewResponseResolvers<ContextType>;
  ReviewResponsesConnection?: ReviewResponsesConnectionResolvers<ContextType>;
  ReviewResponsesEdge?: ReviewResponsesEdgeResolvers<ContextType>;
  ReviewsConnection?: ReviewsConnectionResolvers<ContextType>;
  ReviewsEdge?: ReviewsEdgeResolvers<ContextType>;
  ReviewStatusHistoriesConnection?: ReviewStatusHistoriesConnectionResolvers<ContextType>;
  ReviewStatusHistoriesEdge?: ReviewStatusHistoriesEdgeResolvers<ContextType>;
  ReviewStatusHistory?: ReviewStatusHistoryResolvers<ContextType>;
  Template?: TemplateResolvers<ContextType>;
  TemplateAction?: TemplateActionResolvers<ContextType>;
  TemplateActionsConnection?: TemplateActionsConnectionResolvers<ContextType>;
  TemplateActionsEdge?: TemplateActionsEdgeResolvers<ContextType>;
  TemplateElement?: TemplateElementResolvers<ContextType>;
  TemplateElementsConnection?: TemplateElementsConnectionResolvers<ContextType>;
  TemplateElementsEdge?: TemplateElementsEdgeResolvers<ContextType>;
  TemplatePermission?: TemplatePermissionResolvers<ContextType>;
  TemplatePermissionsConnection?: TemplatePermissionsConnectionResolvers<ContextType>;
  TemplatePermissionsEdge?: TemplatePermissionsEdgeResolvers<ContextType>;
  TemplatesConnection?: TemplatesConnectionResolvers<ContextType>;
  TemplateSection?: TemplateSectionResolvers<ContextType>;
  TemplateSectionsConnection?: TemplateSectionsConnectionResolvers<ContextType>;
  TemplateSectionsEdge?: TemplateSectionsEdgeResolvers<ContextType>;
  TemplatesEdge?: TemplatesEdgeResolvers<ContextType>;
  TemplateStage?: TemplateStageResolvers<ContextType>;
  TemplateStagesConnection?: TemplateStagesConnectionResolvers<ContextType>;
  TemplateStagesEdge?: TemplateStagesEdgeResolvers<ContextType>;
  TriggerQueue?: TriggerQueueResolvers<ContextType>;
  TriggerQueuesConnection?: TriggerQueuesConnectionResolvers<ContextType>;
  TriggerQueuesEdge?: TriggerQueuesEdgeResolvers<ContextType>;
  UpdateActionPluginPayload?: UpdateActionPluginPayloadResolvers<ContextType>;
  UpdateActionQueuePayload?: UpdateActionQueuePayloadResolvers<ContextType>;
  UpdateApplicationPayload?: UpdateApplicationPayloadResolvers<ContextType>;
  UpdateApplicationResponsePayload?: UpdateApplicationResponsePayloadResolvers<ContextType>;
  UpdateApplicationSectionPayload?: UpdateApplicationSectionPayloadResolvers<ContextType>;
  UpdateApplicationStageHistoryPayload?: UpdateApplicationStageHistoryPayloadResolvers<ContextType>;
  UpdateApplicationStatusHistoryPayload?: UpdateApplicationStatusHistoryPayloadResolvers<ContextType>;
  UpdateElementTypePluginPayload?: UpdateElementTypePluginPayloadResolvers<ContextType>;
  UpdateFilePayload?: UpdateFilePayloadResolvers<ContextType>;
  UpdateNotificationPayload?: UpdateNotificationPayloadResolvers<ContextType>;
  UpdateOrganisationPayload?: UpdateOrganisationPayloadResolvers<ContextType>;
  UpdatePermissionJoinPayload?: UpdatePermissionJoinPayloadResolvers<ContextType>;
  UpdatePermissionNamePayload?: UpdatePermissionNamePayloadResolvers<ContextType>;
  UpdatePermissionPolicyPayload?: UpdatePermissionPolicyPayloadResolvers<ContextType>;
  UpdateReviewAssignmentPayload?: UpdateReviewAssignmentPayloadResolvers<ContextType>;
  UpdateReviewDecisionPayload?: UpdateReviewDecisionPayloadResolvers<ContextType>;
  UpdateReviewPayload?: UpdateReviewPayloadResolvers<ContextType>;
  UpdateReviewQuestionAssignmentPayload?: UpdateReviewQuestionAssignmentPayloadResolvers<ContextType>;
  UpdateReviewResponsePayload?: UpdateReviewResponsePayloadResolvers<ContextType>;
  UpdateReviewStatusHistoryPayload?: UpdateReviewStatusHistoryPayloadResolvers<ContextType>;
  UpdateTemplateActionPayload?: UpdateTemplateActionPayloadResolvers<ContextType>;
  UpdateTemplateElementPayload?: UpdateTemplateElementPayloadResolvers<ContextType>;
  UpdateTemplatePayload?: UpdateTemplatePayloadResolvers<ContextType>;
  UpdateTemplatePermissionPayload?: UpdateTemplatePermissionPayloadResolvers<ContextType>;
  UpdateTemplateSectionPayload?: UpdateTemplateSectionPayloadResolvers<ContextType>;
  UpdateTemplateStagePayload?: UpdateTemplateStagePayloadResolvers<ContextType>;
  UpdateTriggerQueuePayload?: UpdateTriggerQueuePayloadResolvers<ContextType>;
  UpdateUserOrganisationPayload?: UpdateUserOrganisationPayloadResolvers<ContextType>;
  UpdateUserPayload?: UpdateUserPayloadResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserOrganisation?: UserOrganisationResolvers<ContextType>;
  UserOrganisationsConnection?: UserOrganisationsConnectionResolvers<ContextType>;
  UserOrganisationsEdge?: UserOrganisationsEdgeResolvers<ContextType>;
  UserOrgJoin?: UserOrgJoinResolvers<ContextType>;
  UserOrgJoinsConnection?: UserOrgJoinsConnectionResolvers<ContextType>;
  UserOrgJoinsEdge?: UserOrgJoinsEdgeResolvers<ContextType>;
  UsersConnection?: UsersConnectionResolvers<ContextType>;
  UsersEdge?: UsersEdgeResolvers<ContextType>;
};


/**
 * @deprecated
 * Use "Resolvers" root object instead. If you wish to get "IResolvers", add "typesPrefix: I" to your config.
 */
export type IResolvers<ContextType = any> = Resolvers<ContextType>;
