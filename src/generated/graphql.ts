import { GraphQLResolveInfo, GraphQLScalarType, GraphQLScalarTypeConfig } from 'graphql';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
export type RequireFields<T, K extends keyof T> = Omit<T, K> & { [P in K]-?: NonNullable<T[P]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  BigInt: { input: any; output: any; }
  CharacterData: { input: any; output: any; }
  Cursor: { input: any; output: any; }
  Date: { input: any; output: any; }
  Datetime: { input: any; output: any; }
  JSON: { input: any; output: any; }
  SqlIdentifier: { input: any; output: any; }
  YesOrNo: { input: any; output: any; }
};

export type ActionPlugin = Node & {
  __typename?: 'ActionPlugin';
  code?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  optionalParameters?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  outputProperties?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  path?: Maybe<Scalars['String']['output']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/**
 * A condition to be used against `ActionPlugin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ActionPluginCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `optionalParameters` field. */
  optionalParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `outputProperties` field. */
  outputProperties?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `path` field. */
  path?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `requiredParameters` field. */
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A filter to be used against `ActionPlugin` object types. All fields are combined with a logical ‘and.’ */
export type ActionPluginFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ActionPluginFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ActionPluginFilter>;
  /** Filter by the object’s `optionalParameters` field. */
  optionalParameters?: InputMaybe<StringListFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ActionPluginFilter>>;
  /** Filter by the object’s `outputProperties` field. */
  outputProperties?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `path` field. */
  path?: InputMaybe<StringFilter>;
  /** Filter by the object’s `requiredParameters` field. */
  requiredParameters?: InputMaybe<StringListFilter>;
};

/** An input for mutations affecting `ActionPlugin` */
export type ActionPluginInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  optionalParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  outputProperties?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  path?: InputMaybe<Scalars['String']['input']>;
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Represents an update to a `ActionPlugin`. Fields that are set will be updated. */
export type ActionPluginPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  optionalParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  outputProperties?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  path?: InputMaybe<Scalars['String']['input']>;
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A connection to a list of `ActionPlugin` values. */
export type ActionPluginsConnection = {
  __typename?: 'ActionPluginsConnection';
  /** A list of edges which contains the `ActionPlugin` and cursor to aid in pagination. */
  edges: Array<ActionPluginsEdge>;
  /** A list of `ActionPlugin` objects. */
  nodes: Array<Maybe<ActionPlugin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActionPlugin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ActionPlugin` edge in the connection. */
export type ActionPluginsEdge = {
  __typename?: 'ActionPluginsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ActionPlugin` at the end of the edge. */
  node?: Maybe<ActionPlugin>;
};

/** Methods to use when ordering `ActionPlugin`. */
export enum ActionPluginsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OptionalParametersAsc = 'OPTIONAL_PARAMETERS_ASC',
  OptionalParametersDesc = 'OPTIONAL_PARAMETERS_DESC',
  OutputPropertiesAsc = 'OUTPUT_PROPERTIES_ASC',
  OutputPropertiesDesc = 'OUTPUT_PROPERTIES_DESC',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequiredParametersAsc = 'REQUIRED_PARAMETERS_ASC',
  RequiredParametersDesc = 'REQUIRED_PARAMETERS_DESC'
}

export type ActionQueue = Node & {
  __typename?: 'ActionQueue';
  actionCode?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Application` that is related to this `ActionQueue`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  conditionExpression?: Maybe<Scalars['JSON']['output']>;
  errorLog?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  output?: Maybe<Scalars['JSON']['output']>;
  parameterQueries?: Maybe<Scalars['JSON']['output']>;
  parametersEvaluated?: Maybe<Scalars['JSON']['output']>;
  sequence?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ActionQueueStatus>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  templateId?: Maybe<Scalars['Int']['output']>;
  timeCompleted?: Maybe<Scalars['Datetime']['output']>;
  timeQueued?: Maybe<Scalars['Datetime']['output']>;
  triggerEvent?: Maybe<Scalars['Int']['output']>;
  triggerPayload?: Maybe<Scalars['JSON']['output']>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
};

/** The fields on `actionQueue` to look up the row to connect. */
export type ActionQueueActionQueuePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `actionQueue` to look up the row to delete. */
export type ActionQueueActionQueuePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The `actionQueue` to be created by this mutation. */
export type ActionQueueApplicationIdFkeyActionQueueCreateInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** The `application` to be created by this mutation. */
export type ActionQueueApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ActionQueueInput` mutation. */
export type ActionQueueApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ActionQueueApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ActionQueueOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `actionQueue` in the `ApplicationInput` mutation. */
export type ActionQueueApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ActionQueueActionQueuePkeyConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ActionQueueNodeIdConnect>>;
  /** A `ActionQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ActionQueueApplicationIdFkeyActionQueueCreateInput>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ActionQueueActionQueuePkeyDelete>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ActionQueueNodeIdDelete>>;
  /** Flag indicating whether all other `actionQueue` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ActionQueueOnActionQueueForActionQueueApplicationIdFkeyUsingActionQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate>>;
};

/**
 * A condition to be used against `ActionQueue` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ActionQueueCondition = {
  /** Checks for equality with the object’s `actionCode` field. */
  actionCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `conditionExpression` field. */
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `errorLog` field. */
  errorLog?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `output` field. */
  output?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `parameterQueries` field. */
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `parametersEvaluated` field. */
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `sequence` field. */
  sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ActionQueueStatus>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeCompleted` field. */
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeQueued` field. */
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `triggerEvent` field. */
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `triggerPayload` field. */
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type ActionQueueFilter = {
  /** Filter by the object’s `actionCode` field. */
  actionCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ActionQueueFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `conditionExpression` field. */
  conditionExpression?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `errorLog` field. */
  errorLog?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ActionQueueFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ActionQueueFilter>>;
  /** Filter by the object’s `output` field. */
  output?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parameterQueries` field. */
  parameterQueries?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parametersEvaluated` field. */
  parametersEvaluated?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `sequence` field. */
  sequence?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ActionQueueStatusFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeCompleted` field. */
  timeCompleted?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeQueued` field. */
  timeQueued?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `triggerEvent` field. */
  triggerEvent?: InputMaybe<IntFilter>;
  /** Filter by the object’s `triggerPayload` field. */
  triggerPayload?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `triggerQueueByTriggerEvent` relation. */
  triggerQueueByTriggerEvent?: InputMaybe<TriggerQueueFilter>;
  /** A related `triggerQueueByTriggerEvent` exists. */
  triggerQueueByTriggerEventExists?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `ActionQueue` */
export type ActionQueueInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ActionQueueNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ActionQueueNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ActionQueueOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `actionQueue` to look up the row to update. */
export type ActionQueueOnActionQueueForActionQueueApplicationIdFkeyUsingActionQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: UpdateActionQueueOnActionQueueForActionQueueApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `actionQueue` to look up the row to update. */
export type ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** The fields on `actionQueue` to look up the row to update. */
export type ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
};

/** Represents an update to a `ActionQueue`. Fields that are set will be updated. */
export type ActionQueuePatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

export enum ActionQueueStatus {
  ConditionNotMet = 'CONDITION_NOT_MET',
  Fail = 'FAIL',
  Processing = 'PROCESSING',
  Queued = 'QUEUED',
  Success = 'SUCCESS'
}

/** A filter to be used against ActionQueueStatus fields. All fields are combined with a logical ‘and.’ */
export type ActionQueueStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ActionQueueStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ActionQueueStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ActionQueueStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ActionQueueStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ActionQueueStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ActionQueueStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ActionQueueStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ActionQueueStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ActionQueueStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ActionQueueStatus>>;
};

/** The `actionQueue` to be created by this mutation. */
export type ActionQueueTemplateIdFkeyActionQueueCreateInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** Input for the nested mutation of `template` in the `ActionQueueInput` mutation. */
export type ActionQueueTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<ActionQueueTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `actionQueue` in the `TemplateInput` mutation. */
export type ActionQueueTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ActionQueueActionQueuePkeyConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ActionQueueNodeIdConnect>>;
  /** A `ActionQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ActionQueueTemplateIdFkeyActionQueueCreateInput>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ActionQueueActionQueuePkeyDelete>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ActionQueueNodeIdDelete>>;
  /** Flag indicating whether all other `actionQueue` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type ActionQueueTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `actionQueue` to be created by this mutation. */
export type ActionQueueTriggerEventFkeyActionQueueCreateInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** Input for the nested mutation of `triggerQueue` in the `ActionQueueInput` mutation. */
export type ActionQueueTriggerEventFkeyInput = {
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectById?: InputMaybe<TriggerQueueTriggerQueuePkeyConnect>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TriggerQueueNodeIdConnect>;
  /** A `TriggerQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<ActionQueueTriggerEventFkeyTriggerQueueCreateInput>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<TriggerQueueTriggerQueuePkeyDelete>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TriggerQueueNodeIdDelete>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateById?: InputMaybe<TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `actionQueue` in the `TriggerQueueInput` mutation. */
export type ActionQueueTriggerEventFkeyInverseInput = {
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ActionQueueActionQueuePkeyConnect>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ActionQueueNodeIdConnect>>;
  /** A `ActionQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ActionQueueTriggerEventFkeyActionQueueCreateInput>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ActionQueueActionQueuePkeyDelete>>;
  /** The primary key(s) for `actionQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ActionQueueNodeIdDelete>>;
  /** Flag indicating whether all other `actionQueue` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `actionQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate>>;
};

/** The `triggerQueue` to be created by this mutation. */
export type ActionQueueTriggerEventFkeyTriggerQueueCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** A connection to a list of `ActionQueue` values. */
export type ActionQueuesConnection = {
  __typename?: 'ActionQueuesConnection';
  /** A list of edges which contains the `ActionQueue` and cursor to aid in pagination. */
  edges: Array<ActionQueuesEdge>;
  /** A list of `ActionQueue` objects. */
  nodes: Array<Maybe<ActionQueue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActionQueue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ActionQueue` edge in the connection. */
export type ActionQueuesEdge = {
  __typename?: 'ActionQueuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ActionQueue` at the end of the edge. */
  node?: Maybe<ActionQueue>;
};

/** Methods to use when ordering `ActionQueue`. */
export enum ActionQueuesOrderBy {
  ActionCodeAsc = 'ACTION_CODE_ASC',
  ActionCodeDesc = 'ACTION_CODE_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ConditionExpressionAsc = 'CONDITION_EXPRESSION_ASC',
  ConditionExpressionDesc = 'CONDITION_EXPRESSION_DESC',
  ErrorLogAsc = 'ERROR_LOG_ASC',
  ErrorLogDesc = 'ERROR_LOG_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OutputAsc = 'OUTPUT_ASC',
  OutputDesc = 'OUTPUT_DESC',
  ParametersEvaluatedAsc = 'PARAMETERS_EVALUATED_ASC',
  ParametersEvaluatedDesc = 'PARAMETERS_EVALUATED_DESC',
  ParameterQueriesAsc = 'PARAMETER_QUERIES_ASC',
  ParameterQueriesDesc = 'PARAMETER_QUERIES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SequenceAsc = 'SEQUENCE_ASC',
  SequenceDesc = 'SEQUENCE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TimeCompletedAsc = 'TIME_COMPLETED_ASC',
  TimeCompletedDesc = 'TIME_COMPLETED_DESC',
  TimeQueuedAsc = 'TIME_QUEUED_ASC',
  TimeQueuedDesc = 'TIME_QUEUED_DESC',
  TriggerEventAsc = 'TRIGGER_EVENT_ASC',
  TriggerEventDesc = 'TRIGGER_EVENT_DESC',
  TriggerPayloadAsc = 'TRIGGER_PAYLOAD_ASC',
  TriggerPayloadDesc = 'TRIGGER_PAYLOAD_DESC'
}

export type ActivityLog = Node & {
  __typename?: 'ActivityLog';
  /** Reads a single `Application` that is related to this `ActivityLog`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  details: Scalars['JSON']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  recordId?: Maybe<Scalars['Int']['output']>;
  table: Scalars['String']['output'];
  timestamp: Scalars['Datetime']['output'];
  type: EventType;
  value: Scalars['String']['output'];
};

/** The fields on `activityLog` to look up the row to connect. */
export type ActivityLogActivityLogPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `activityLog` to look up the row to delete. */
export type ActivityLogActivityLogPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The `activityLog` to be created by this mutation. */
export type ActivityLogApplicationIdFkeyActivityLogCreateInput = {
  applicationToApplicationId?: InputMaybe<ActivityLogApplicationIdFkeyInput>;
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  table: Scalars['String']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  type: EventType;
  value: Scalars['String']['input'];
};

/** The `application` to be created by this mutation. */
export type ActivityLogApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ActivityLogInput` mutation. */
export type ActivityLogApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ActivityLogApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ActivityLogOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `activityLog` in the `ApplicationInput` mutation. */
export type ActivityLogApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `activityLog` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ActivityLogActivityLogPkeyConnect>>;
  /** The primary key(s) for `activityLog` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ActivityLogNodeIdConnect>>;
  /** A `ActivityLogInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ActivityLogApplicationIdFkeyActivityLogCreateInput>>;
  /** The primary key(s) for `activityLog` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ActivityLogActivityLogPkeyDelete>>;
  /** The primary key(s) for `activityLog` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ActivityLogNodeIdDelete>>;
  /** Flag indicating whether all other `activityLog` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `activityLog` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ActivityLogOnActivityLogForActivityLogApplicationIdFkeyUsingActivityLogPkeyUpdate>>;
  /** The primary key(s) and patch data for `activityLog` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate>>;
};

/**
 * A condition to be used against `ActivityLog` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ActivityLogCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `details` field. */
  details?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `recordId` field. */
  recordId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `table` field. */
  table?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<EventType>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ActivityLog` object types. All fields are combined with a logical ‘and.’ */
export type ActivityLogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ActivityLogFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `details` field. */
  details?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ActivityLogFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ActivityLogFilter>>;
  /** Filter by the object’s `recordId` field. */
  recordId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `table` field. */
  table?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<EventTypeFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `ActivityLog` */
export type ActivityLogInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActivityLogApplicationIdFkeyInput>;
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  table: Scalars['String']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  type: EventType;
  value: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ActivityLogNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `activityLog` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ActivityLogNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `activityLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ActivityLogOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `activityLog` to look up the row to update. */
export type ActivityLogOnActivityLogForActivityLogApplicationIdFkeyUsingActivityLogPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `activityLog` being updated. */
  patch: UpdateActivityLogOnActivityLogForActivityLogApplicationIdFkeyPatch;
};

/** Represents an update to a `ActivityLog`. Fields that are set will be updated. */
export type ActivityLogPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActivityLogApplicationIdFkeyInput>;
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  type?: InputMaybe<EventType>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `ActivityLog` values. */
export type ActivityLogsConnection = {
  __typename?: 'ActivityLogsConnection';
  /** A list of edges which contains the `ActivityLog` and cursor to aid in pagination. */
  edges: Array<ActivityLogsEdge>;
  /** A list of `ActivityLog` objects. */
  nodes: Array<Maybe<ActivityLog>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ActivityLog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ActivityLog` edge in the connection. */
export type ActivityLogsEdge = {
  __typename?: 'ActivityLogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ActivityLog` at the end of the edge. */
  node?: Maybe<ActivityLog>;
};

/** Methods to use when ordering `ActivityLog`. */
export enum ActivityLogsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DetailsAsc = 'DETAILS_ASC',
  DetailsDesc = 'DETAILS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecordIdAsc = 'RECORD_ID_ASC',
  RecordIdDesc = 'RECORD_ID_DESC',
  TableAsc = 'TABLE_ASC',
  TableDesc = 'TABLE_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export type AllowedSelfAssignableSectionsShape = {
  __typename?: 'AllowedSelfAssignableSectionsShape';
  allowedSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  reviewAssignmentId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `AllowedSelfAssignableSectionsShape` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type AllowedSelfAssignableSectionsShapeCondition = {
  /** Checks for equality with the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `AllowedSelfAssignableSectionsShape` object types. All fields are combined with a logical ‘and.’ */
export type AllowedSelfAssignableSectionsShapeFilter = {
  /** Filter by the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AllowedSelfAssignableSectionsShapeFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<AllowedSelfAssignableSectionsShapeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AllowedSelfAssignableSectionsShapeFilter>>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `AllowedSelfAssignableSectionsShape` */
export type AllowedSelfAssignableSectionsShapeInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `AllowedSelfAssignableSectionsShape` values. */
export type AllowedSelfAssignableSectionsShapesConnection = {
  __typename?: 'AllowedSelfAssignableSectionsShapesConnection';
  /** A list of edges which contains the `AllowedSelfAssignableSectionsShape` and cursor to aid in pagination. */
  edges: Array<AllowedSelfAssignableSectionsShapesEdge>;
  /** A list of `AllowedSelfAssignableSectionsShape` objects. */
  nodes: Array<Maybe<AllowedSelfAssignableSectionsShape>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AllowedSelfAssignableSectionsShape` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AllowedSelfAssignableSectionsShape` edge in the connection. */
export type AllowedSelfAssignableSectionsShapesEdge = {
  __typename?: 'AllowedSelfAssignableSectionsShapesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AllowedSelfAssignableSectionsShape` at the end of the edge. */
  node?: Maybe<AllowedSelfAssignableSectionsShape>;
};

/** Methods to use when ordering `AllowedSelfAssignableSectionsShape`. */
export enum AllowedSelfAssignableSectionsShapesOrderBy {
  AllowedSectionsAsc = 'ALLOWED_SECTIONS_ASC',
  AllowedSectionsDesc = 'ALLOWED_SECTIONS_DESC',
  Natural = 'NATURAL',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC'
}

export type Application = Node & {
  __typename?: 'Application';
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueues: ActionQueuesConnection;
  /** Reads and enables pagination through a set of `ActivityLog`. */
  activityLogs: ActivityLogsConnection;
  /** Reads and enables pagination through a set of `ApplicationNote`. */
  applicationNotes: ApplicationNotesConnection;
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses: ApplicationResponsesConnection;
  /** Reads and enables pagination through a set of `ApplicationReviewerAction`. */
  applicationReviewerActions: ApplicationReviewerActionsConnection;
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistories: ApplicationStageHistoriesConnection;
  assignerList?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads and enables pagination through a set of `DataChangelog`. */
  dataChangelogs: DataChangelogsConnection;
  /** Reads and enables pagination through a set of `DataTableManufacturerApplicationJoin`. */
  dataTableManufacturerApplicationJoins: DataTableManufacturerApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `DataTableManufacturerRepresentativeApplicationJoin`. */
  dataTableManufacturerRepresentativeApplicationJoins: DataTableManufacturerRepresentativeApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `DataTablePermitChemicalApplicationJoin`. */
  dataTablePermitChemicalApplicationJoins: DataTablePermitChemicalApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `DataTablePrequalManufacturerApplicationJoin`. */
  dataTablePrequalManufacturerApplicationJoins: DataTablePrequalManufacturerApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `DataTableProductApplicationJoin`. */
  dataTableProductApplicationJoins: DataTableProductApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `DataTableProvisionalProductApplicationJoin`. */
  dataTableProvisionalProductApplicationJoins: DataTableProvisionalProductApplicationJoinsConnection;
  /** Reads and enables pagination through a set of `File`. */
  filesByApplicationSerial: FilesConnection;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isConfig?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Notification`. */
  notifications: NotificationsConnection;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  orgId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `OrganisationApplicationJoin`. */
  organisationApplicationJoins: OrganisationApplicationJoinsConnection;
  outcome?: Maybe<ApplicationOutcome>;
  outcomeRegistration?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments: ReviewAssignmentsConnection;
  reviewerList?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads and enables pagination through a set of `Review`. */
  reviews: ReviewsConnection;
  serial?: Maybe<Scalars['String']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  stage?: Maybe<Scalars['String']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ApplicationStatus>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
  trigger?: Maybe<Trigger>;
  /** Reads and enables pagination through a set of `TriggerQueue`. */
  triggerQueues: TriggerQueuesConnection;
  /** Reads and enables pagination through a set of `TriggerSchedule`. */
  triggerSchedules: TriggerSchedulesConnection;
  /** Reads a single `UserList` that is related to this `Application`. */
  user?: Maybe<UserList>;
  /** Reads and enables pagination through a set of `UserApplicationJoin`. */
  userApplicationJoins: UserApplicationJoinsConnection;
  userId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Verification`. */
  verifications: VerificationsConnection;
};


export type ApplicationActionQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionQueueCondition>;
  filter?: InputMaybe<ActionQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};


export type ApplicationActivityLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActivityLogCondition>;
  filter?: InputMaybe<ActivityLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};


export type ApplicationApplicationNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationNoteCondition>;
  filter?: InputMaybe<ApplicationNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};


export type ApplicationApplicationResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationResponseCondition>;
  filter?: InputMaybe<ApplicationResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};


export type ApplicationApplicationReviewerActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationReviewerActionCondition>;
  filter?: InputMaybe<ApplicationReviewerActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationReviewerActionsOrderBy>>;
};


export type ApplicationApplicationStageHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageHistoryCondition>;
  filter?: InputMaybe<ApplicationStageHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};


export type ApplicationDataChangelogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataChangelogCondition>;
  filter?: InputMaybe<DataChangelogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataChangelogsOrderBy>>;
};


export type ApplicationDataTableManufacturerApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturerApplicationJoinCondition>;
  filter?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturerApplicationJoinsOrderBy>>;
};


export type ApplicationDataTableManufacturerRepresentativeApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinCondition>;
  filter?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinsOrderBy>>;
};


export type ApplicationDataTablePermitChemicalApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePermitChemicalApplicationJoinCondition>;
  filter?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinsOrderBy>>;
};


export type ApplicationDataTablePrequalManufacturerApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePrequalManufacturerApplicationJoinCondition>;
  filter?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinsOrderBy>>;
};


export type ApplicationDataTableProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProductApplicationJoinCondition>;
  filter?: InputMaybe<DataTableProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};


export type ApplicationDataTableProvisionalProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProvisionalProductApplicationJoinCondition>;
  filter?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinsOrderBy>>;
};


export type ApplicationFilesByApplicationSerialArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


export type ApplicationNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotificationCondition>;
  filter?: InputMaybe<NotificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};


export type ApplicationOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganisationApplicationJoinCondition>;
  filter?: InputMaybe<OrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};


export type ApplicationReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type ApplicationReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewCondition>;
  filter?: InputMaybe<ReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};


export type ApplicationTriggerQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerQueueCondition>;
  filter?: InputMaybe<TriggerQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};


export type ApplicationTriggerSchedulesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerScheduleCondition>;
  filter?: InputMaybe<TriggerScheduleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};


export type ApplicationUserApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserApplicationJoinCondition>;
  filter?: InputMaybe<UserApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};


export type ApplicationVerificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationCondition>;
  filter?: InputMaybe<VerificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

/** The fields on `application` to look up the row to connect. */
export type ApplicationApplicationOutcomeRegistrationKeyConnect = {
  outcomeRegistration: Scalars['String']['input'];
};

/** The fields on `application` to look up the row to delete. */
export type ApplicationApplicationOutcomeRegistrationKeyDelete = {
  outcomeRegistration: Scalars['String']['input'];
};

/** The fields on `application` to look up the row to connect. */
export type ApplicationApplicationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `application` to look up the row to delete. */
export type ApplicationApplicationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `application` to look up the row to connect. */
export type ApplicationApplicationSerialKeyConnect = {
  serial: Scalars['String']['input'];
};

/** The fields on `application` to look up the row to delete. */
export type ApplicationApplicationSerialKeyDelete = {
  serial: Scalars['String']['input'];
};

/**
 * A condition to be used against `Application` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type ApplicationCondition = {
  /** Checks for equality with the object’s `assignerList` field. */
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isConfig` field. */
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `outcomeRegistration` field. */
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `reviewerList` field. */
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sessionId` field. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Application` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationFilter = {
  /** Filter by the object’s `actionQueues` relation. */
  actionQueues?: InputMaybe<ApplicationToManyActionQueueFilter>;
  /** Some related `actionQueues` exist. */
  actionQueuesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `activityLogs` relation. */
  activityLogs?: InputMaybe<ApplicationToManyActivityLogFilter>;
  /** Some related `activityLogs` exist. */
  activityLogsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationFilter>>;
  /** Filter by the object’s `applicationNotes` relation. */
  applicationNotes?: InputMaybe<ApplicationToManyApplicationNoteFilter>;
  /** Some related `applicationNotes` exist. */
  applicationNotesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationResponses` relation. */
  applicationResponses?: InputMaybe<ApplicationToManyApplicationResponseFilter>;
  /** Some related `applicationResponses` exist. */
  applicationResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationReviewerActions` relation. */
  applicationReviewerActions?: InputMaybe<ApplicationToManyApplicationReviewerActionFilter>;
  /** Some related `applicationReviewerActions` exist. */
  applicationReviewerActionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationStageHistories` relation. */
  applicationStageHistories?: InputMaybe<ApplicationToManyApplicationStageHistoryFilter>;
  /** Some related `applicationStageHistories` exist. */
  applicationStageHistoriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assignerList` field. */
  assignerList?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `dataChangelogs` relation. */
  dataChangelogs?: InputMaybe<ApplicationToManyDataChangelogFilter>;
  /** Some related `dataChangelogs` exist. */
  dataChangelogsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dataTableManufacturerApplicationJoins` relation. */
  dataTableManufacturerApplicationJoins?: InputMaybe<ApplicationToManyDataTableManufacturerApplicationJoinFilter>;
  /** Some related `dataTableManufacturerApplicationJoins` exist. */
  dataTableManufacturerApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dataTableManufacturerRepresentativeApplicationJoins` relation. */
  dataTableManufacturerRepresentativeApplicationJoins?: InputMaybe<ApplicationToManyDataTableManufacturerRepresentativeApplicationJoinFilter>;
  /** Some related `dataTableManufacturerRepresentativeApplicationJoins` exist. */
  dataTableManufacturerRepresentativeApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dataTablePermitChemicalApplicationJoins` relation. */
  dataTablePermitChemicalApplicationJoins?: InputMaybe<ApplicationToManyDataTablePermitChemicalApplicationJoinFilter>;
  /** Some related `dataTablePermitChemicalApplicationJoins` exist. */
  dataTablePermitChemicalApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dataTablePrequalManufacturerApplicationJoins` relation. */
  dataTablePrequalManufacturerApplicationJoins?: InputMaybe<ApplicationToManyDataTablePrequalManufacturerApplicationJoinFilter>;
  /** Some related `dataTablePrequalManufacturerApplicationJoins` exist. */
  dataTablePrequalManufacturerApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dataTableProductApplicationJoins` relation. */
  dataTableProductApplicationJoins?: InputMaybe<ApplicationToManyDataTableProductApplicationJoinFilter>;
  /** Some related `dataTableProductApplicationJoins` exist. */
  dataTableProductApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dataTableProvisionalProductApplicationJoins` relation. */
  dataTableProvisionalProductApplicationJoins?: InputMaybe<ApplicationToManyDataTableProvisionalProductApplicationJoinFilter>;
  /** Some related `dataTableProvisionalProductApplicationJoins` exist. */
  dataTableProvisionalProductApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `filesByApplicationSerial` relation. */
  filesByApplicationSerial?: InputMaybe<ApplicationToManyFileFilter>;
  /** Some related `filesByApplicationSerial` exist. */
  filesByApplicationSerialExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isConfig` field. */
  isConfig?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `notifications` relation. */
  notifications?: InputMaybe<ApplicationToManyNotificationFilter>;
  /** Some related `notifications` exist. */
  notificationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationFilter>>;
  /** Filter by the object’s `org` relation. */
  org?: InputMaybe<OrganisationFilter>;
  /** A related `org` exists. */
  orgExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `organisationApplicationJoins` relation. */
  organisationApplicationJoins?: InputMaybe<ApplicationToManyOrganisationApplicationJoinFilter>;
  /** Some related `organisationApplicationJoins` exist. */
  organisationApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `outcomeRegistration` field. */
  outcomeRegistration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reviewAssignments` relation. */
  reviewAssignments?: InputMaybe<ApplicationToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignments` exist. */
  reviewAssignmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewerList` field. */
  reviewerList?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `reviews` relation. */
  reviews?: InputMaybe<ApplicationToManyReviewFilter>;
  /** Some related `reviews` exist. */
  reviewsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `serial` field. */
  serial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sessionId` field. */
  sessionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
  /** Filter by the object’s `triggerQueues` relation. */
  triggerQueues?: InputMaybe<ApplicationToManyTriggerQueueFilter>;
  /** Some related `triggerQueues` exist. */
  triggerQueuesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `triggerSchedules` relation. */
  triggerSchedules?: InputMaybe<ApplicationToManyTriggerScheduleFilter>;
  /** Some related `triggerSchedules` exist. */
  triggerSchedulesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserListFilter>;
  /** Filter by the object’s `userApplicationJoins` relation. */
  userApplicationJoins?: InputMaybe<ApplicationToManyUserApplicationJoinFilter>;
  /** Some related `userApplicationJoins` exist. */
  userApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `verifications` relation. */
  verifications?: InputMaybe<ApplicationToManyVerificationFilter>;
  /** Some related `verifications` exist. */
  verificationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Application` */
export type ApplicationInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterApplicantConnection = {
  __typename?: 'ApplicationListFilterApplicantConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterApplicantEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterApplicantEdge = {
  __typename?: 'ApplicationListFilterApplicantEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterAssignerConnection = {
  __typename?: 'ApplicationListFilterAssignerConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterAssignerEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterAssignerEdge = {
  __typename?: 'ApplicationListFilterAssignerEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterOrganisationConnection = {
  __typename?: 'ApplicationListFilterOrganisationConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterOrganisationEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterOrganisationEdge = {
  __typename?: 'ApplicationListFilterOrganisationEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterReviewerConnection = {
  __typename?: 'ApplicationListFilterReviewerConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterReviewerEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterReviewerEdge = {
  __typename?: 'ApplicationListFilterReviewerEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

/** A connection to a list of `String` values. */
export type ApplicationListFilterStageConnection = {
  __typename?: 'ApplicationListFilterStageConnection';
  /** A list of edges which contains the `String` and cursor to aid in pagination. */
  edges: Array<ApplicationListFilterStageEdge>;
  /** A list of `String` objects. */
  nodes: Array<Maybe<Scalars['String']['output']>>;
  /** The count of *all* `String` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `String` edge in the connection. */
export type ApplicationListFilterStageEdge = {
  __typename?: 'ApplicationListFilterStageEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `String` at the end of the edge. */
  node?: Maybe<Scalars['String']['output']>;
};

export type ApplicationListShape = {
  __typename?: 'ApplicationListShape';
  applicant?: Maybe<Scalars['String']['output']>;
  applicantDeadline?: Maybe<Scalars['Datetime']['output']>;
  assignerAction?: Maybe<AssignerAction>;
  assigners?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  id?: Maybe<Scalars['Int']['output']>;
  lastActiveDate?: Maybe<Scalars['Datetime']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  orgName?: Maybe<Scalars['String']['output']>;
  outcome?: Maybe<ApplicationOutcome>;
  reviewerAction?: Maybe<ReviewerAction>;
  reviewers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  serial?: Maybe<Scalars['String']['output']>;
  stage?: Maybe<Scalars['String']['output']>;
  stageColour?: Maybe<Scalars['String']['output']>;
  status?: Maybe<ApplicationStatus>;
  templateCode?: Maybe<Scalars['String']['output']>;
  templateName?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `ApplicationListShape` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationListShapeCondition = {
  /** Checks for equality with the object’s `applicant` field. */
  applicant?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `applicantDeadline` field. */
  applicantDeadline?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerAction>;
  /** Checks for equality with the object’s `assigners` field. */
  assigners?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lastActiveDate` field. */
  lastActiveDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerAction>;
  /** Checks for equality with the object’s `reviewers` field. */
  reviewers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageColour` field. */
  stageColour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationStatus>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateName` field. */
  templateName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `ApplicationListShape` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationListShapeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationListShapeFilter>>;
  /** Filter by the object’s `applicant` field. */
  applicant?: InputMaybe<StringFilter>;
  /** Filter by the object’s `applicantDeadline` field. */
  applicantDeadline?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerActionFilter>;
  /** Filter by the object’s `assigners` field. */
  assigners?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lastActiveDate` field. */
  lastActiveDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationListShapeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationListShapeFilter>>;
  /** Filter by the object’s `orgName` field. */
  orgName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerActionFilter>;
  /** Filter by the object’s `reviewers` field. */
  reviewers?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageColour` field. */
  stageColour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateName` field. */
  templateName?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `ApplicationListShape` */
export type ApplicationListShapeInput = {
  applicant?: InputMaybe<Scalars['String']['input']>;
  applicantDeadline?: InputMaybe<Scalars['Datetime']['input']>;
  assignerAction?: InputMaybe<AssignerAction>;
  assigners?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastActiveDate?: InputMaybe<Scalars['Datetime']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  orgName?: InputMaybe<Scalars['String']['input']>;
  outcome?: InputMaybe<ApplicationOutcome>;
  reviewerAction?: InputMaybe<ReviewerAction>;
  reviewers?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  serial?: InputMaybe<Scalars['String']['input']>;
  stage?: InputMaybe<Scalars['String']['input']>;
  stageColour?: InputMaybe<Scalars['String']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `ApplicationListShape` values. */
export type ApplicationListShapesConnection = {
  __typename?: 'ApplicationListShapesConnection';
  /** A list of edges which contains the `ApplicationListShape` and cursor to aid in pagination. */
  edges: Array<ApplicationListShapesEdge>;
  /** A list of `ApplicationListShape` objects. */
  nodes: Array<Maybe<ApplicationListShape>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationListShape` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationListShape` edge in the connection. */
export type ApplicationListShapesEdge = {
  __typename?: 'ApplicationListShapesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationListShape` at the end of the edge. */
  node?: Maybe<ApplicationListShape>;
};

/** Methods to use when ordering `ApplicationListShape`. */
export enum ApplicationListShapesOrderBy {
  ApplicantAsc = 'APPLICANT_ASC',
  ApplicantDeadlineAsc = 'APPLICANT_DEADLINE_ASC',
  ApplicantDeadlineDesc = 'APPLICANT_DEADLINE_DESC',
  ApplicantDesc = 'APPLICANT_DESC',
  AssignersAsc = 'ASSIGNERS_ASC',
  AssignersDesc = 'ASSIGNERS_DESC',
  AssignerActionAsc = 'ASSIGNER_ACTION_ASC',
  AssignerActionDesc = 'ASSIGNER_ACTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastActiveDateAsc = 'LAST_ACTIVE_DATE_ASC',
  LastActiveDateDesc = 'LAST_ACTIVE_DATE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgNameAsc = 'ORG_NAME_ASC',
  OrgNameDesc = 'ORG_NAME_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  ReviewersAsc = 'REVIEWERS_ASC',
  ReviewersDesc = 'REVIEWERS_DESC',
  ReviewerActionAsc = 'REVIEWER_ACTION_ASC',
  ReviewerActionDesc = 'REVIEWER_ACTION_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  StageAsc = 'STAGE_ASC',
  StageColourAsc = 'STAGE_COLOUR_ASC',
  StageColourDesc = 'STAGE_COLOUR_DESC',
  StageDesc = 'STAGE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateNameAsc = 'TEMPLATE_NAME_ASC',
  TemplateNameDesc = 'TEMPLATE_NAME_DESC'
}

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `application` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

export type ApplicationNote = Node & {
  __typename?: 'ApplicationNote';
  /** Reads a single `Application` that is related to this `ApplicationNote`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  comment: Scalars['String']['output'];
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `ApplicationNote`. */
  org?: Maybe<Organisation>;
  orgId: Scalars['Int']['output'];
  timestamp?: Maybe<Scalars['Datetime']['output']>;
  /** Reads a single `UserList` that is related to this `ApplicationNote`. */
  user?: Maybe<UserList>;
  userId: Scalars['Int']['output'];
};


export type ApplicationNoteFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ApplicationNoteApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `applicationNote` to be created by this mutation. */
export type ApplicationNoteApplicationIdFkeyApplicationNoteCreateInput = {
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** Input for the nested mutation of `application` in the `ApplicationNoteInput` mutation. */
export type ApplicationNoteApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationNoteApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `applicationNote` in the `ApplicationInput` mutation. */
export type ApplicationNoteApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyConnect>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdConnect>>;
  /** A `ApplicationNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationNoteApplicationIdFkeyApplicationNoteCreateInput>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyDelete>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdDelete>>;
  /** Flag indicating whether all other `applicationNote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationNotePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate>>;
};

/** The fields on `applicationNote` to look up the row to connect. */
export type ApplicationNoteApplicationNotePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationNote` to look up the row to delete. */
export type ApplicationNoteApplicationNotePkeyDelete = {
  id: Scalars['Int']['input'];
};

/**
 * A condition to be used against `ApplicationNote` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ApplicationNoteCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ApplicationNote` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationNoteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationNoteFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<ApplicationNoteToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationNoteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationNoteFilter>>;
  /** Filter by the object’s `org` relation. */
  org?: InputMaybe<OrganisationFilter>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserListFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ApplicationNote` */
export type ApplicationNoteInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationNoteNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationNoteNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationNote` to look up the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationNotePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `applicationNote` to look up the row to update. */
export type ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyUsingApplicationNotePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
};

/** The fields on `applicationNote` to look up the row to update. */
export type ApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0UsingApplicationNotePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: UpdateApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0Patch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationNoteOnFileForFileApplicationNoteIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `applicationNote` to look up the row to update. */
export type ApplicationNoteOnFileForFileApplicationNoteIdFkeyUsingApplicationNotePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: UpdateApplicationNoteOnFileForFileApplicationNoteIdFkeyPatch;
};

/** The `applicationNote` to be created by this mutation. */
export type ApplicationNoteOrgIdFkeyApplicationNoteCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** Input for the nested mutation of `organisation` in the `ApplicationNoteInput` mutation. */
export type ApplicationNoteOrgIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationNoteOrgIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `applicationNote` in the `OrganisationInput` mutation. */
export type ApplicationNoteOrgIdFkeyInverseInput = {
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyConnect>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdConnect>>;
  /** A `ApplicationNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationNoteOrgIdFkeyApplicationNoteCreateInput>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyDelete>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdDelete>>;
  /** Flag indicating whether all other `applicationNote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyUsingApplicationNotePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type ApplicationNoteOrgIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** Represents an update to a `ApplicationNote`. Fields that are set will be updated. */
export type ApplicationNotePatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationNoteToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A connection to a list of `ApplicationNote` values. */
export type ApplicationNotesConnection = {
  __typename?: 'ApplicationNotesConnection';
  /** A list of edges which contains the `ApplicationNote` and cursor to aid in pagination. */
  edges: Array<ApplicationNotesEdge>;
  /** A list of `ApplicationNote` objects. */
  nodes: Array<Maybe<ApplicationNote>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationNote` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationNote` edge in the connection. */
export type ApplicationNotesEdge = {
  __typename?: 'ApplicationNotesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationNote` at the end of the edge. */
  node?: Maybe<ApplicationNote>;
};

/** Methods to use when ordering `ApplicationNote`. */
export enum ApplicationNotesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `activityLog` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `activityLog` being updated. */
  patch: ActivityLogPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForFakePublicApplicationForeignKey0Patch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForFakePublicApplicationForeignKey0Patch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationForFakePublicApplicationForeignKey0Patch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationReviewerAction` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationReviewerAction` being updated. */
  patch: ApplicationReviewerActionPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataChangelog` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataChangelog` being updated. */
  patch: DataChangelogPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataChangelogForDataChangelogApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataChangelogForDataChangelogApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataChangelogForDataChangelogApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerApplicationJoin` being updated. */
  patch: DataTableManufacturerApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerRepresentativeApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerRepresentativeApplicationJoin` being updated. */
  patch: DataTableManufacturerRepresentativeApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTablePermitChemicalApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTablePermitChemicalApplicationJoin` being updated. */
  patch: DataTablePermitChemicalApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTablePrequalManufacturerApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTablePrequalManufacturerApplicationJoin` being updated. */
  patch: DataTablePrequalManufacturerApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableProductApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
  patch: DataTableProductApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableProvisionalProductApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableProvisionalProductApplicationJoin` being updated. */
  patch: DataTableProvisionalProductApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnFileForFileApplicationSerialFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnFileForFileApplicationSerialFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnFileForFileApplicationSerialFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnFileForFileApplicationSerialFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
  patch: OrganisationApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
  patch: UserApplicationJoinPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `verification` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `verification` being updated. */
  patch: VerificationPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate = {
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch;
};

/** The fields on `application` to look up the row to update. */
export type ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationSerialKeyUpdate = {
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch;
  serial: Scalars['String']['input'];
};

/** The `application` to be created by this mutation. */
export type ApplicationOrgIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `organisation` in the `ApplicationInput` mutation. */
export type ApplicationOrgIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationOrgIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `application` in the `OrganisationInput` mutation. */
export type ApplicationOrgIdFkeyInverseInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationOrgIdFkeyApplicationCreateInput>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<Array<ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<Array<ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type ApplicationOrgIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

export enum ApplicationOutcome {
  Approved = 'APPROVED',
  Expired = 'EXPIRED',
  Pending = 'PENDING',
  Rejected = 'REJECTED',
  Withdrawn = 'WITHDRAWN'
}

/** A filter to be used against ApplicationOutcome fields. All fields are combined with a logical ‘and.’ */
export type ApplicationOutcomeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ApplicationOutcome>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ApplicationOutcome>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ApplicationOutcome>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ApplicationOutcome>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ApplicationOutcome>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ApplicationOutcome>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ApplicationOutcome>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ApplicationOutcome>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ApplicationOutcome>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ApplicationOutcome>>;
};

/** Represents an update to a `Application`. Fields that are set will be updated. */
export type ApplicationPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

export type ApplicationResponse = Node & {
  __typename?: 'ApplicationResponse';
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  evaluatedParameters?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  id: Scalars['Int']['output'];
  isValid?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ApplicationResponseStatus>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
  templateElementId: Scalars['Int']['output'];
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
  timeSubmitted?: Maybe<Scalars['Datetime']['output']>;
  timeUpdated?: Maybe<Scalars['Datetime']['output']>;
  value?: Maybe<Scalars['JSON']['output']>;
};


export type ApplicationResponseFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


export type ApplicationResponseReviewResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ApplicationResponseApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `applicationResponse` to be created by this mutation. */
export type ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput = {
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** Input for the nested mutation of `application` in the `ApplicationResponseInput` mutation. */
export type ApplicationResponseApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationResponseApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `applicationResponse` in the `ApplicationInput` mutation. */
export type ApplicationResponseApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationResponseApplicationResponsePkeyConnect>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationResponseNodeIdConnect>>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationResponseApplicationResponsePkeyDelete>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationResponseNodeIdDelete>>;
  /** Flag indicating whether all other `applicationResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate>>;
};

/** The fields on `applicationResponse` to look up the row to connect. */
export type ApplicationResponseApplicationResponsePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationResponse` to look up the row to delete. */
export type ApplicationResponseApplicationResponsePkeyDelete = {
  id: Scalars['Int']['input'];
};

/**
 * A condition to be used against `ApplicationResponse` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationResponseCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `evaluatedParameters` field. */
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isValid` field. */
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationResponseStatus>;
  /** Checks for equality with the object’s `templateElementId` field. */
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeSubmitted` field. */
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationResponseFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `evaluatedParameters` field. */
  evaluatedParameters?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<ApplicationResponseToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isValid` field. */
  isValid?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationResponseFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationResponseFilter>>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: InputMaybe<ApplicationResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationResponseStatusFilter>;
  /** Filter by the object’s `templateElement` relation. */
  templateElement?: InputMaybe<TemplateElementFilter>;
  /** Filter by the object’s `templateElementId` field. */
  templateElementId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeSubmitted` field. */
  timeSubmitted?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<JsonFilter>;
};

/** An input for mutations affecting `ApplicationResponse` */
export type ApplicationResponseInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationResponseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationResponseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `applicationResponse` to look up the row to update. */
export type ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
};

/** Represents an update to a `ApplicationResponse`. Fields that are set will be updated. */
export type ApplicationResponsePatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

export enum ApplicationResponseStatus {
  Draft = 'DRAFT',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ApplicationResponseStatus fields. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ApplicationResponseStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ApplicationResponseStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ApplicationResponseStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ApplicationResponseStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ApplicationResponseStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ApplicationResponseStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ApplicationResponseStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ApplicationResponseStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ApplicationResponseStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ApplicationResponseStatus>>;
};

/** The `applicationResponse` to be created by this mutation. */
export type ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** Input for the nested mutation of `templateElement` in the `ApplicationResponseInput` mutation. */
export type ApplicationResponseTemplateElementIdFkeyInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateElementTemplateElementPkeyConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateElementNodeIdConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateElementTemplateElementPkeyDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateElementNodeIdDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate>;
};

/** Input for the nested mutation of `applicationResponse` in the `TemplateElementInput` mutation. */
export type ApplicationResponseTemplateElementIdFkeyInverseInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationResponseApplicationResponsePkeyConnect>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationResponseNodeIdConnect>>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationResponseApplicationResponsePkeyDelete>>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationResponseNodeIdDelete>>;
  /** Flag indicating whether all other `applicationResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate>>;
};

/** The `templateElement` to be created by this mutation. */
export type ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  reviewability?: InputMaybe<Reviewability>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode: Scalars['String']['input'];
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion: Scalars['String']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationResponseToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewResponseFilter>;
};

/** A connection to a list of `ApplicationResponse` values. */
export type ApplicationResponsesConnection = {
  __typename?: 'ApplicationResponsesConnection';
  /** A list of edges which contains the `ApplicationResponse` and cursor to aid in pagination. */
  edges: Array<ApplicationResponsesEdge>;
  /** A list of `ApplicationResponse` objects. */
  nodes: Array<Maybe<ApplicationResponse>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationResponse` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationResponse` edge in the connection. */
export type ApplicationResponsesEdge = {
  __typename?: 'ApplicationResponsesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationResponse` at the end of the edge. */
  node?: Maybe<ApplicationResponse>;
};

/** Methods to use when ordering `ApplicationResponse`. */
export enum ApplicationResponsesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  EvaluatedParametersAsc = 'EVALUATED_PARAMETERS_ASC',
  EvaluatedParametersDesc = 'EVALUATED_PARAMETERS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsValidAsc = 'IS_VALID_ASC',
  IsValidDesc = 'IS_VALID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateElementIdAsc = 'TEMPLATE_ELEMENT_ID_ASC',
  TemplateElementIdDesc = 'TEMPLATE_ELEMENT_ID_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  TimeSubmittedAsc = 'TIME_SUBMITTED_ASC',
  TimeSubmittedDesc = 'TIME_SUBMITTED_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export type ApplicationReviewerAction = Node & {
  __typename?: 'ApplicationReviewerAction';
  /** Reads a single `Application` that is related to this `ApplicationReviewerAction`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  assignerAction?: Maybe<AssignerAction>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  reviewerAction?: Maybe<ReviewerAction>;
  userId: Scalars['Int']['output'];
};

/** The `application` to be created by this mutation. */
export type ApplicationReviewerActionApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `applicationReviewerAction` to be created by this mutation. */
export type ApplicationReviewerActionApplicationIdFkeyApplicationReviewerActionCreateInput = {
  applicationToApplicationId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInput>;
  assignerAction?: InputMaybe<AssignerAction>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewerAction?: InputMaybe<ReviewerAction>;
  userId: Scalars['Int']['input'];
};

/** Input for the nested mutation of `application` in the `ApplicationReviewerActionInput` mutation. */
export type ApplicationReviewerActionApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `applicationReviewerAction` in the `ApplicationInput` mutation. */
export type ApplicationReviewerActionApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `applicationReviewerAction` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationReviewerActionApplicationReviewerActionPkeyConnect>>;
  /** The primary key(s) for `applicationReviewerAction` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationReviewerActionNodeIdConnect>>;
  /** The primary key(s) for `applicationReviewerAction` for the far side of the relationship. */
  connectByUserIdAndApplicationId?: InputMaybe<Array<ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyConnect>>;
  /** A `ApplicationReviewerActionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationReviewerActionApplicationIdFkeyApplicationReviewerActionCreateInput>>;
  /** The primary key(s) for `applicationReviewerAction` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationReviewerActionApplicationReviewerActionPkeyDelete>>;
  /** The primary key(s) for `applicationReviewerAction` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationReviewerActionNodeIdDelete>>;
  /** The primary key(s) for `applicationReviewerAction` for the far side of the relationship. */
  deleteByUserIdAndApplicationId?: InputMaybe<Array<ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyDelete>>;
  /** Flag indicating whether all other `applicationReviewerAction` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationReviewerAction` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationReviewerAction` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `applicationReviewerAction` for the far side of the relationship. */
  updateByUserIdAndApplicationId?: InputMaybe<Array<ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionUserIdApplicationIdKeyUpdate>>;
};

/** The fields on `applicationReviewerAction` to look up the row to connect. */
export type ApplicationReviewerActionApplicationReviewerActionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationReviewerAction` to look up the row to delete. */
export type ApplicationReviewerActionApplicationReviewerActionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationReviewerAction` to look up the row to connect. */
export type ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyConnect = {
  applicationId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/** The fields on `applicationReviewerAction` to look up the row to delete. */
export type ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyDelete = {
  applicationId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};

/**
 * A condition to be used against `ApplicationReviewerAction` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationReviewerActionCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerAction>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerAction>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ApplicationReviewerAction` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationReviewerActionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationReviewerActionFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerActionFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationReviewerActionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationReviewerActionFilter>>;
  /** Filter by the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerActionFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ApplicationReviewerAction` */
export type ApplicationReviewerActionInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInput>;
  assignerAction?: InputMaybe<AssignerAction>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewerAction?: InputMaybe<ReviewerAction>;
  userId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationReviewerActionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationReviewerAction` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationReviewerActionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationReviewerAction` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationReviewerAction` to look up the row to update. */
export type ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationReviewerAction` being updated. */
  patch: UpdateApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
};

/** The fields on `applicationReviewerAction` to look up the row to update. */
export type ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionUserIdApplicationIdKeyUpdate = {
  applicationId: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationReviewerAction` being updated. */
  patch: UpdateApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
  userId: Scalars['Int']['input'];
};

/** Represents an update to a `ApplicationReviewerAction`. Fields that are set will be updated. */
export type ApplicationReviewerActionPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInput>;
  assignerAction?: InputMaybe<AssignerAction>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewerAction?: InputMaybe<ReviewerAction>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ApplicationReviewerAction` values. */
export type ApplicationReviewerActionsConnection = {
  __typename?: 'ApplicationReviewerActionsConnection';
  /** A list of edges which contains the `ApplicationReviewerAction` and cursor to aid in pagination. */
  edges: Array<ApplicationReviewerActionsEdge>;
  /** A list of `ApplicationReviewerAction` objects. */
  nodes: Array<Maybe<ApplicationReviewerAction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationReviewerAction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationReviewerAction` edge in the connection. */
export type ApplicationReviewerActionsEdge = {
  __typename?: 'ApplicationReviewerActionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationReviewerAction` at the end of the edge. */
  node?: Maybe<ApplicationReviewerAction>;
};

/** Methods to use when ordering `ApplicationReviewerAction`. */
export enum ApplicationReviewerActionsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  AssignerActionAsc = 'ASSIGNER_ACTION_ASC',
  AssignerActionDesc = 'ASSIGNER_ACTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewerActionAsc = 'REVIEWER_ACTION_ASC',
  ReviewerActionDesc = 'REVIEWER_ACTION_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A connection to a list of `ApplicationStageHistory` values. */
export type ApplicationStageHistoriesConnection = {
  __typename?: 'ApplicationStageHistoriesConnection';
  /** A list of edges which contains the `ApplicationStageHistory` and cursor to aid in pagination. */
  edges: Array<ApplicationStageHistoriesEdge>;
  /** A list of `ApplicationStageHistory` objects. */
  nodes: Array<Maybe<ApplicationStageHistory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationStageHistory` edge in the connection. */
export type ApplicationStageHistoriesEdge = {
  __typename?: 'ApplicationStageHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationStageHistory` at the end of the edge. */
  node?: Maybe<ApplicationStageHistory>;
};

/** Methods to use when ordering `ApplicationStageHistory`. */
export enum ApplicationStageHistoriesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC'
}

export type ApplicationStageHistory = Node & {
  __typename?: 'ApplicationStageHistory';
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `ApplicationStatusHistory`. */
  applicationStatusHistories: ApplicationStatusHistoriesConnection;
  id: Scalars['Int']['output'];
  isCurrent?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
  stageId: Scalars['Int']['output'];
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
};


export type ApplicationStageHistoryApplicationStatusHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStatusHistoryCondition>;
  filter?: InputMaybe<ApplicationStatusHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput = {
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `application` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStageHistoryApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `ApplicationInput` mutation. */
export type ApplicationStageHistoryApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationStageHistoryNodeIdConnect>>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationStageHistoryNodeIdDelete>>;
  /** Flag indicating whether all other `applicationStageHistory` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate>>;
};

/** The fields on `applicationStageHistory` to look up the row to connect. */
export type ApplicationStageHistoryApplicationStageHistoryPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationStageHistory` to look up the row to delete. */
export type ApplicationStageHistoryApplicationStageHistoryPkeyDelete = {
  id: Scalars['Int']['input'];
};

/**
 * A condition to be used against `ApplicationStageHistory` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationStageHistoryCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageHistoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationStageHistoryFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationStatusHistories` relation. */
  applicationStatusHistories?: InputMaybe<ApplicationStageHistoryToManyApplicationStatusHistoryFilter>;
  /** Some related `applicationStatusHistories` exist. */
  applicationStatusHistoriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationStageHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationStageHistoryFilter>>;
  /** Filter by the object’s `stage` relation. */
  stage?: InputMaybe<TemplateStageFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ApplicationStageHistory` */
export type ApplicationStageHistoryInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationStageHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationStageHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
};

/** The fields on `applicationStageHistory` to look up the row to update. */
export type ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
};

/** Represents an update to a `ApplicationStageHistory`. Fields that are set will be updated. */
export type ApplicationStageHistoryPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `templateStage` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStageHistoryStageIdFkeyInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateStageTemplateStagePkeyConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateStageNodeIdConnect>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateStageTemplateStagePkeyDelete>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateStageNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `TemplateStageInput` mutation. */
export type ApplicationStageHistoryStageIdFkeyInverseInput = {
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationStageHistoryNodeIdConnect>>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationStageHistoryNodeIdDelete>>;
  /** Flag indicating whether all other `applicationStageHistory` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate>>;
};

/** The `templateStage` to be created by this mutation. */
export type ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `ApplicationStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageHistoryToManyApplicationStatusHistoryFilter = {
  /** Every related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationStatusHistoryFilter>;
  /** No related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationStatusHistoryFilter>;
  /** Some related `ApplicationStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationStatusHistoryFilter>;
};

export type ApplicationStageStatusAll = {
  __typename?: 'ApplicationStageStatusAll';
  applicationId?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  orgId?: Maybe<Scalars['Int']['output']>;
  outcome?: Maybe<ApplicationOutcome>;
  serial?: Maybe<Scalars['String']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  stage?: Maybe<Scalars['String']['output']>;
  stageColour?: Maybe<Scalars['String']['output']>;
  stageHistoryId?: Maybe<Scalars['Int']['output']>;
  stageHistoryTimeCreated?: Maybe<Scalars['Datetime']['output']>;
  stageId?: Maybe<Scalars['Int']['output']>;
  stageIsCurrent?: Maybe<Scalars['Boolean']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ApplicationStatus>;
  statusHistoryId?: Maybe<Scalars['Int']['output']>;
  statusHistoryTimeCreated?: Maybe<Scalars['Datetime']['output']>;
  statusIsCurrent?: Maybe<Scalars['Boolean']['output']>;
  templateCode?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['Int']['output']>;
  templateName?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `ApplicationStageStatusAll` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationStageStatusAllCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sessionId` field. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageColour` field. */
  stageColour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageHistoryId` field. */
  stageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageIsCurrent` field. */
  stageIsCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationStatus>;
  /** Checks for equality with the object’s `statusHistoryId` field. */
  statusHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `statusIsCurrent` field. */
  statusIsCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateName` field. */
  templateName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ApplicationStageStatusAll` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageStatusAllFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationStageStatusAllFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationStageStatusAllFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationStageStatusAllFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sessionId` field. */
  sessionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageColour` field. */
  stageColour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageHistoryId` field. */
  stageHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageIsCurrent` field. */
  stageIsCurrent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `statusHistoryId` field. */
  statusHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `statusIsCurrent` field. */
  statusIsCurrent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateName` field. */
  templateName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `ApplicationStageStatusAll` values. */
export type ApplicationStageStatusAllsConnection = {
  __typename?: 'ApplicationStageStatusAllsConnection';
  /** A list of edges which contains the `ApplicationStageStatusAll` and cursor to aid in pagination. */
  edges: Array<ApplicationStageStatusAllsEdge>;
  /** A list of `ApplicationStageStatusAll` objects. */
  nodes: Array<Maybe<ApplicationStageStatusAll>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageStatusAll` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationStageStatusAll` edge in the connection. */
export type ApplicationStageStatusAllsEdge = {
  __typename?: 'ApplicationStageStatusAllsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationStageStatusAll` at the end of the edge. */
  node?: Maybe<ApplicationStageStatusAll>;
};

/** Methods to use when ordering `ApplicationStageStatusAll`. */
export enum ApplicationStageStatusAllsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  SessionIdAsc = 'SESSION_ID_ASC',
  SessionIdDesc = 'SESSION_ID_DESC',
  StageAsc = 'STAGE_ASC',
  StageColourAsc = 'STAGE_COLOUR_ASC',
  StageColourDesc = 'STAGE_COLOUR_DESC',
  StageDesc = 'STAGE_DESC',
  StageHistoryIdAsc = 'STAGE_HISTORY_ID_ASC',
  StageHistoryIdDesc = 'STAGE_HISTORY_ID_DESC',
  StageHistoryTimeCreatedAsc = 'STAGE_HISTORY_TIME_CREATED_ASC',
  StageHistoryTimeCreatedDesc = 'STAGE_HISTORY_TIME_CREATED_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageIsCurrentAsc = 'STAGE_IS_CURRENT_ASC',
  StageIsCurrentDesc = 'STAGE_IS_CURRENT_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StatusHistoryIdAsc = 'STATUS_HISTORY_ID_ASC',
  StatusHistoryIdDesc = 'STATUS_HISTORY_ID_DESC',
  StatusHistoryTimeCreatedAsc = 'STATUS_HISTORY_TIME_CREATED_ASC',
  StatusHistoryTimeCreatedDesc = 'STATUS_HISTORY_TIME_CREATED_DESC',
  StatusIsCurrentAsc = 'STATUS_IS_CURRENT_ASC',
  StatusIsCurrentDesc = 'STATUS_IS_CURRENT_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TemplateNameAsc = 'TEMPLATE_NAME_ASC',
  TemplateNameDesc = 'TEMPLATE_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type ApplicationStageStatusLatest = {
  __typename?: 'ApplicationStageStatusLatest';
  applicationId?: Maybe<Scalars['Int']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  orgId?: Maybe<Scalars['Int']['output']>;
  outcome?: Maybe<ApplicationOutcome>;
  serial?: Maybe<Scalars['String']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  stage?: Maybe<Scalars['String']['output']>;
  stageColour?: Maybe<Scalars['String']['output']>;
  stageHistoryId?: Maybe<Scalars['Int']['output']>;
  stageHistoryTimeCreated?: Maybe<Scalars['Datetime']['output']>;
  stageId?: Maybe<Scalars['Int']['output']>;
  stageIsCurrent?: Maybe<Scalars['Boolean']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ApplicationStatus>;
  statusHistoryId?: Maybe<Scalars['Int']['output']>;
  statusHistoryTimeCreated?: Maybe<Scalars['Datetime']['output']>;
  statusIsCurrent?: Maybe<Scalars['Boolean']['output']>;
  templateCode?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['Int']['output']>;
  templateName?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `ApplicationStageStatusLatest` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationStageStatusLatestCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcome>;
  /** Checks for equality with the object’s `serial` field. */
  serial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sessionId` field. */
  sessionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stage` field. */
  stage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageColour` field. */
  stageColour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `stageHistoryId` field. */
  stageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageIsCurrent` field. */
  stageIsCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationStatus>;
  /** Checks for equality with the object’s `statusHistoryId` field. */
  statusHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `statusIsCurrent` field. */
  statusIsCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateName` field. */
  templateName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ApplicationStageStatusLatest` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStageStatusLatestFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationStageStatusLatestFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationStageStatusLatestFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationStageStatusLatestFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `outcome` field. */
  outcome?: InputMaybe<ApplicationOutcomeFilter>;
  /** Filter by the object’s `serial` field. */
  serial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sessionId` field. */
  sessionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stage` field. */
  stage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageColour` field. */
  stageColour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `stageHistoryId` field. */
  stageHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageHistoryTimeCreated` field. */
  stageHistoryTimeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageIsCurrent` field. */
  stageIsCurrent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `statusHistoryId` field. */
  statusHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `statusHistoryTimeCreated` field. */
  statusHistoryTimeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `statusIsCurrent` field. */
  statusIsCurrent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateName` field. */
  templateName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `ApplicationStageStatusLatest` values. */
export type ApplicationStageStatusLatestsConnection = {
  __typename?: 'ApplicationStageStatusLatestsConnection';
  /** A list of edges which contains the `ApplicationStageStatusLatest` and cursor to aid in pagination. */
  edges: Array<ApplicationStageStatusLatestsEdge>;
  /** A list of `ApplicationStageStatusLatest` objects. */
  nodes: Array<Maybe<ApplicationStageStatusLatest>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStageStatusLatest` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationStageStatusLatest` edge in the connection. */
export type ApplicationStageStatusLatestsEdge = {
  __typename?: 'ApplicationStageStatusLatestsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationStageStatusLatest` at the end of the edge. */
  node?: Maybe<ApplicationStageStatusLatest>;
};

/** Methods to use when ordering `ApplicationStageStatusLatest`. */
export enum ApplicationStageStatusLatestsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  SessionIdAsc = 'SESSION_ID_ASC',
  SessionIdDesc = 'SESSION_ID_DESC',
  StageAsc = 'STAGE_ASC',
  StageColourAsc = 'STAGE_COLOUR_ASC',
  StageColourDesc = 'STAGE_COLOUR_DESC',
  StageDesc = 'STAGE_DESC',
  StageHistoryIdAsc = 'STAGE_HISTORY_ID_ASC',
  StageHistoryIdDesc = 'STAGE_HISTORY_ID_DESC',
  StageHistoryTimeCreatedAsc = 'STAGE_HISTORY_TIME_CREATED_ASC',
  StageHistoryTimeCreatedDesc = 'STAGE_HISTORY_TIME_CREATED_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageIsCurrentAsc = 'STAGE_IS_CURRENT_ASC',
  StageIsCurrentDesc = 'STAGE_IS_CURRENT_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  StatusHistoryIdAsc = 'STATUS_HISTORY_ID_ASC',
  StatusHistoryIdDesc = 'STATUS_HISTORY_ID_DESC',
  StatusHistoryTimeCreatedAsc = 'STATUS_HISTORY_TIME_CREATED_ASC',
  StatusHistoryTimeCreatedDesc = 'STATUS_HISTORY_TIME_CREATED_DESC',
  StatusIsCurrentAsc = 'STATUS_IS_CURRENT_ASC',
  StatusIsCurrentDesc = 'STATUS_IS_CURRENT_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TemplateNameAsc = 'TEMPLATE_NAME_ASC',
  TemplateNameDesc = 'TEMPLATE_NAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export enum ApplicationStatus {
  ChangesRequired = 'CHANGES_REQUIRED',
  Completed = 'COMPLETED',
  Draft = 'DRAFT',
  ReSubmitted = 'RE_SUBMITTED',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ApplicationStatus fields. All fields are combined with a logical ‘and.’ */
export type ApplicationStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ApplicationStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ApplicationStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ApplicationStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ApplicationStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ApplicationStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ApplicationStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ApplicationStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ApplicationStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ApplicationStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ApplicationStatus>>;
};

/** A connection to a list of `ApplicationStatusHistory` values. */
export type ApplicationStatusHistoriesConnection = {
  __typename?: 'ApplicationStatusHistoriesConnection';
  /** A list of edges which contains the `ApplicationStatusHistory` and cursor to aid in pagination. */
  edges: Array<ApplicationStatusHistoriesEdge>;
  /** A list of `ApplicationStatusHistory` objects. */
  nodes: Array<Maybe<ApplicationStatusHistory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ApplicationStatusHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ApplicationStatusHistory` edge in the connection. */
export type ApplicationStatusHistoriesEdge = {
  __typename?: 'ApplicationStatusHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ApplicationStatusHistory` at the end of the edge. */
  node?: Maybe<ApplicationStatusHistory>;
};

/** Methods to use when ordering `ApplicationStatusHistory`. */
export enum ApplicationStatusHistoriesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  ApplicationStageHistoryIdAsc = 'APPLICATION_STAGE_HISTORY_ID_ASC',
  ApplicationStageHistoryIdDesc = 'APPLICATION_STAGE_HISTORY_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC'
}

export type ApplicationStatusHistory = Node & {
  __typename?: 'ApplicationStatusHistory';
  applicationId: Scalars['Int']['output'];
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  applicationStageHistoryId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  isCurrent?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  status?: Maybe<ApplicationStatus>;
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
};

/** The `applicationStageHistory` to be created by this mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `applicationStatusHistory` to be created by this mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput = {
  applicationId: Scalars['Int']['input'];
  applicationStageHistoryToApplicationStageHistoryId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `applicationStageHistory` in the `ApplicationStatusHistoryInput` mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput = {
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationStageHistoryApplicationStageHistoryPkeyConnect>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationStageHistoryNodeIdConnect>;
  /** A `ApplicationStageHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationStageHistoryApplicationStageHistoryPkeyDelete>;
  /** The primary key(s) for `applicationStageHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationStageHistoryNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate>;
  /** The primary key(s) and patch data for `applicationStageHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `applicationStatusHistory` in the `ApplicationStageHistoryInput` mutation. */
export type ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput = {
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationStatusHistoryNodeIdConnect>>;
  /** A `ApplicationStatusHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete>>;
  /** The primary key(s) for `applicationStatusHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationStatusHistoryNodeIdDelete>>;
  /** Flag indicating whether all other `applicationStatusHistory` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationStatusHistory` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationStatusHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate>>;
};

/** The fields on `applicationStatusHistory` to look up the row to connect. */
export type ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `applicationStatusHistory` to look up the row to delete. */
export type ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete = {
  id: Scalars['Int']['input'];
};

/**
 * A condition to be used against `ApplicationStatusHistory` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ApplicationStatusHistoryCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `applicationStageHistoryId` field. */
  applicationStageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ApplicationStatus>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ApplicationStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationStatusHistoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ApplicationStatusHistoryFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationStageHistory` relation. */
  applicationStageHistory?: InputMaybe<ApplicationStageHistoryFilter>;
  /** Filter by the object’s `applicationStageHistoryId` field. */
  applicationStageHistoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ApplicationStatusHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ApplicationStatusHistoryFilter>>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ApplicationStatusFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ApplicationStatusHistory` */
export type ApplicationStatusHistoryInput = {
  applicationId: Scalars['Int']['input'];
  applicationStageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryToApplicationStageHistoryId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ApplicationStatusHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ApplicationStatusHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `applicationStatusHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `applicationStatusHistory` to look up the row to update. */
export type ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
  patch: UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
};

/** Represents an update to a `ApplicationStatusHistory`. Fields that are set will be updated. */
export type ApplicationStatusHistoryPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryToApplicationStageHistoryId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `application` to be created by this mutation. */
export type ApplicationTemplateIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `template` in the `ApplicationInput` mutation. */
export type ApplicationTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<ApplicationTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `application` in the `TemplateInput` mutation. */
export type ApplicationTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ApplicationTemplateIdFkeyApplicationCreateInput>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<Array<ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<Array<ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate>>;
};

/** The `template` to be created by this mutation. */
export type ApplicationTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyActionQueueFilter = {
  /** Every related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionQueueFilter>;
  /** No related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionQueueFilter>;
  /** Some related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionQueueFilter>;
};

/** A filter to be used against many `ActivityLog` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyActivityLogFilter = {
  /** Every related `ActivityLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActivityLogFilter>;
  /** No related `ActivityLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActivityLogFilter>;
  /** Some related `ActivityLog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActivityLogFilter>;
};

/** A filter to be used against many `ApplicationNote` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationNoteFilter = {
  /** Every related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationNoteFilter>;
  /** No related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationNoteFilter>;
  /** Some related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationNoteFilter>;
};

/** A filter to be used against many `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationResponseFilter = {
  /** Every related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationResponseFilter>;
  /** No related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationResponseFilter>;
  /** Some related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationResponseFilter>;
};

/** A filter to be used against many `ApplicationReviewerAction` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationReviewerActionFilter = {
  /** Every related `ApplicationReviewerAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationReviewerActionFilter>;
  /** No related `ApplicationReviewerAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationReviewerActionFilter>;
  /** Some related `ApplicationReviewerAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationReviewerActionFilter>;
};

/** A filter to be used against many `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyApplicationStageHistoryFilter = {
  /** Every related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationStageHistoryFilter>;
  /** No related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationStageHistoryFilter>;
  /** Some related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationStageHistoryFilter>;
};

/** A filter to be used against many `DataChangelog` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDataChangelogFilter = {
  /** Every related `DataChangelog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataChangelogFilter>;
  /** No related `DataChangelog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataChangelogFilter>;
  /** Some related `DataChangelog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataChangelogFilter>;
};

/** A filter to be used against many `DataTableManufacturerApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDataTableManufacturerApplicationJoinFilter = {
  /** Every related `DataTableManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
  /** No related `DataTableManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
  /** Some related `DataTableManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
};

/** A filter to be used against many `DataTableManufacturerRepresentativeApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDataTableManufacturerRepresentativeApplicationJoinFilter = {
  /** Every related `DataTableManufacturerRepresentativeApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
  /** No related `DataTableManufacturerRepresentativeApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
  /** Some related `DataTableManufacturerRepresentativeApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
};

/** A filter to be used against many `DataTablePermitChemicalApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDataTablePermitChemicalApplicationJoinFilter = {
  /** Every related `DataTablePermitChemicalApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
  /** No related `DataTablePermitChemicalApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
  /** Some related `DataTablePermitChemicalApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
};

/** A filter to be used against many `DataTablePrequalManufacturerApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDataTablePrequalManufacturerApplicationJoinFilter = {
  /** Every related `DataTablePrequalManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
  /** No related `DataTablePrequalManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
  /** Some related `DataTablePrequalManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
};

/** A filter to be used against many `DataTableProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDataTableProductApplicationJoinFilter = {
  /** Every related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableProductApplicationJoinFilter>;
  /** No related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableProductApplicationJoinFilter>;
  /** Some related `DataTableProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableProductApplicationJoinFilter>;
};

/** A filter to be used against many `DataTableProvisionalProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyDataTableProvisionalProductApplicationJoinFilter = {
  /** Every related `DataTableProvisionalProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
  /** No related `DataTableProvisionalProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
  /** Some related `DataTableProvisionalProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<NotificationFilter>;
};

/** A filter to be used against many `OrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyOrganisationApplicationJoinFilter = {
  /** Every related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** No related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** Some related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganisationApplicationJoinFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `Review` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyReviewFilter = {
  /** Every related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewFilter>;
  /** No related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewFilter>;
  /** Some related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewFilter>;
};

/** A filter to be used against many `TriggerQueue` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyTriggerQueueFilter = {
  /** Every related `TriggerQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TriggerQueueFilter>;
  /** No related `TriggerQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TriggerQueueFilter>;
  /** Some related `TriggerQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TriggerQueueFilter>;
};

/** A filter to be used against many `TriggerSchedule` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyTriggerScheduleFilter = {
  /** Every related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TriggerScheduleFilter>;
  /** No related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TriggerScheduleFilter>;
  /** Some related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TriggerScheduleFilter>;
};

/** A filter to be used against many `UserApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyUserApplicationJoinFilter = {
  /** Every related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserApplicationJoinFilter>;
  /** No related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserApplicationJoinFilter>;
  /** Some related `UserApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserApplicationJoinFilter>;
};

/** A filter to be used against many `Verification` object types. All fields are combined with a logical ‘and.’ */
export type ApplicationToManyVerificationFilter = {
  /** Every related `Verification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<VerificationFilter>;
  /** No related `Verification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<VerificationFilter>;
  /** Some related `Verification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<VerificationFilter>;
};

/** A connection to a list of `Application` values. */
export type ApplicationsConnection = {
  __typename?: 'ApplicationsConnection';
  /** A list of edges which contains the `Application` and cursor to aid in pagination. */
  edges: Array<ApplicationsEdge>;
  /** A list of `Application` objects. */
  nodes: Array<Maybe<Application>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Application` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Application` edge in the connection. */
export type ApplicationsEdge = {
  __typename?: 'ApplicationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Application` at the end of the edge. */
  node?: Maybe<Application>;
};

/** Methods to use when ordering `Application`. */
export enum ApplicationsOrderBy {
  AssignerListAsc = 'ASSIGNER_LIST_ASC',
  AssignerListDesc = 'ASSIGNER_LIST_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  IsConfigAsc = 'IS_CONFIG_ASC',
  IsConfigDesc = 'IS_CONFIG_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OutcomeAsc = 'OUTCOME_ASC',
  OutcomeDesc = 'OUTCOME_DESC',
  OutcomeRegistrationAsc = 'OUTCOME_REGISTRATION_ASC',
  OutcomeRegistrationDesc = 'OUTCOME_REGISTRATION_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewerListAsc = 'REVIEWER_LIST_ASC',
  ReviewerListDesc = 'REVIEWER_LIST_DESC',
  SerialAsc = 'SERIAL_ASC',
  SerialDesc = 'SERIAL_DESC',
  SessionIdAsc = 'SESSION_ID_ASC',
  SessionIdDesc = 'SESSION_ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A `AssignedQuestionsRecord` edge in the connection. */
export type AssignedQuestionEdge = {
  __typename?: 'AssignedQuestionEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssignedQuestionsRecord` at the end of the edge. */
  node?: Maybe<AssignedQuestionsRecord>;
};

/** A connection to a list of `AssignedQuestionsRecord` values. */
export type AssignedQuestionsConnection = {
  __typename?: 'AssignedQuestionsConnection';
  /** A list of edges which contains the `AssignedQuestionsRecord` and cursor to aid in pagination. */
  edges: Array<AssignedQuestionEdge>;
  /** A list of `AssignedQuestionsRecord` objects. */
  nodes: Array<Maybe<AssignedQuestionsRecord>>;
  /** The count of *all* `AssignedQuestionsRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The return type of our `assignedQuestions` query. */
export type AssignedQuestionsRecord = {
  __typename?: 'AssignedQuestionsRecord';
  decision?: Maybe<ReviewResponseDecision>;
  isLastestReview?: Maybe<Scalars['Boolean']['output']>;
  isOptional?: Maybe<Scalars['Boolean']['output']>;
  responseId?: Maybe<Scalars['Int']['output']>;
  reviewAssignmentId?: Maybe<Scalars['Int']['output']>;
  reviewId?: Maybe<Scalars['Int']['output']>;
  reviewResponseCode?: Maybe<Scalars['String']['output']>;
  reviewResponseStatus?: Maybe<ReviewResponseStatus>;
};

/** A filter to be used against `AssignedQuestionsRecord` object types. All fields are combined with a logical ‘and.’ */
export type AssignedQuestionsRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssignedQuestionsRecordFilter>>;
  /** Filter by the object’s `decision` field. */
  decision?: InputMaybe<ReviewResponseDecisionFilter>;
  /** Filter by the object’s `isLastestReview` field. */
  isLastestReview?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isOptional` field. */
  isOptional?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssignedQuestionsRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssignedQuestionsRecordFilter>>;
  /** Filter by the object’s `responseId` field. */
  responseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewResponseCode` field. */
  reviewResponseCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reviewResponseStatus` field. */
  reviewResponseStatus?: InputMaybe<ReviewResponseStatusFilter>;
};

export type AssignedSectionsByStageAndLevel = {
  __typename?: 'AssignedSectionsByStageAndLevel';
  applicationId?: Maybe<Scalars['Int']['output']>;
  assignedInProgressSections?: Maybe<Scalars['BigInt']['output']>;
  assignedSectionForLevel?: Maybe<Scalars['BigInt']['output']>;
  assignerId?: Maybe<Scalars['Int']['output']>;
  levelNumber?: Maybe<Scalars['Int']['output']>;
  stageId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `AssignedSectionsByStageAndLevel` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type AssignedSectionsByStageAndLevelCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `assignedInProgressSections` field. */
  assignedInProgressSections?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `assignedSectionForLevel` field. */
  assignedSectionForLevel?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `assignerId` field. */
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `AssignedSectionsByStageAndLevel` object types. All fields are combined with a logical ‘and.’ */
export type AssignedSectionsByStageAndLevelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssignedSectionsByStageAndLevelFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assignedInProgressSections` field. */
  assignedInProgressSections?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `assignedSectionForLevel` field. */
  assignedSectionForLevel?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `assignerId` field. */
  assignerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssignedSectionsByStageAndLevelFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssignedSectionsByStageAndLevelFilter>>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `AssignedSectionsByStageAndLevel` values. */
export type AssignedSectionsByStageAndLevelsConnection = {
  __typename?: 'AssignedSectionsByStageAndLevelsConnection';
  /** A list of edges which contains the `AssignedSectionsByStageAndLevel` and cursor to aid in pagination. */
  edges: Array<AssignedSectionsByStageAndLevelsEdge>;
  /** A list of `AssignedSectionsByStageAndLevel` objects. */
  nodes: Array<Maybe<AssignedSectionsByStageAndLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `AssignedSectionsByStageAndLevel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssignedSectionsByStageAndLevel` edge in the connection. */
export type AssignedSectionsByStageAndLevelsEdge = {
  __typename?: 'AssignedSectionsByStageAndLevelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssignedSectionsByStageAndLevel` at the end of the edge. */
  node?: Maybe<AssignedSectionsByStageAndLevel>;
};

/** Methods to use when ordering `AssignedSectionsByStageAndLevel`. */
export enum AssignedSectionsByStageAndLevelsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  AssignedInProgressSectionsAsc = 'ASSIGNED_IN_PROGRESS_SECTIONS_ASC',
  AssignedInProgressSectionsDesc = 'ASSIGNED_IN_PROGRESS_SECTIONS_DESC',
  AssignedSectionForLevelAsc = 'ASSIGNED_SECTION_FOR_LEVEL_ASC',
  AssignedSectionForLevelDesc = 'ASSIGNED_SECTION_FOR_LEVEL_DESC',
  AssignerIdAsc = 'ASSIGNER_ID_ASC',
  AssignerIdDesc = 'ASSIGNER_ID_DESC',
  LevelNumberAsc = 'LEVEL_NUMBER_ASC',
  LevelNumberDesc = 'LEVEL_NUMBER_DESC',
  Natural = 'NATURAL',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC'
}

export enum AssignerAction {
  Assign = 'ASSIGN',
  ReAssign = 'RE_ASSIGN'
}

/** A filter to be used against AssignerAction fields. All fields are combined with a logical ‘and.’ */
export type AssignerActionFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<AssignerAction>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<AssignerAction>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<AssignerAction>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<AssignerAction>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<AssignerAction>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<AssignerAction>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<AssignerAction>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<AssignerAction>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<AssignerAction>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<AssignerAction>>;
};

/** A connection to a list of `AssignerListRecord` values. */
export type AssignerListConnection = {
  __typename?: 'AssignerListConnection';
  /** A list of edges which contains the `AssignerListRecord` and cursor to aid in pagination. */
  edges: Array<AssignerListEdge>;
  /** A list of `AssignerListRecord` objects. */
  nodes: Array<Maybe<AssignerListRecord>>;
  /** The count of *all* `AssignerListRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssignerListRecord` edge in the connection. */
export type AssignerListEdge = {
  __typename?: 'AssignerListEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssignerListRecord` at the end of the edge. */
  node?: Maybe<AssignerListRecord>;
};

/** The return type of our `assignerList` query. */
export type AssignerListRecord = {
  __typename?: 'AssignerListRecord';
  applicationId?: Maybe<Scalars['Int']['output']>;
  assignerAction?: Maybe<AssignerAction>;
};

/** A filter to be used against `AssignerListRecord` object types. All fields are combined with a logical ‘and.’ */
export type AssignerListRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssignerListRecordFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerActionFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssignerListRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssignerListRecordFilter>>;
};

/** A connection to a list of `AssignmentListRecord` values. */
export type AssignmentListConnection = {
  __typename?: 'AssignmentListConnection';
  /** A list of edges which contains the `AssignmentListRecord` and cursor to aid in pagination. */
  edges: Array<AssignmentListEdge>;
  /** A list of `AssignmentListRecord` objects. */
  nodes: Array<Maybe<AssignmentListRecord>>;
  /** The count of *all* `AssignmentListRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `AssignmentListRecord` edge in the connection. */
export type AssignmentListEdge = {
  __typename?: 'AssignmentListEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `AssignmentListRecord` at the end of the edge. */
  node?: Maybe<AssignmentListRecord>;
};

/** The return type of our `assignmentList` query. */
export type AssignmentListRecord = {
  __typename?: 'AssignmentListRecord';
  applicationId?: Maybe<Scalars['Int']['output']>;
  assigners?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  reviewers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** A filter to be used against `AssignmentListRecord` object types. All fields are combined with a logical ‘and.’ */
export type AssignmentListRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<AssignmentListRecordFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assigners` field. */
  assigners?: InputMaybe<StringListFilter>;
  /** Negates the expression. */
  not?: InputMaybe<AssignmentListRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<AssignmentListRecordFilter>>;
  /** Filter by the object’s `reviewers` field. */
  reviewers?: InputMaybe<StringListFilter>;
};

/** A filter to be used against BigInt fields. All fields are combined with a logical ‘and.’ */
export type BigIntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['BigInt']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['BigInt']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['BigInt']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['BigInt']['input']>>;
};

/** A filter to be used against Boolean fields. All fields are combined with a logical ‘and.’ */
export type BooleanFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Boolean']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

export enum ChangelogType {
  Create = 'CREATE',
  Delete = 'DELETE',
  Update = 'UPDATE'
}

/** A filter to be used against ChangelogType fields. All fields are combined with a logical ‘and.’ */
export type ChangelogTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ChangelogType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ChangelogType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ChangelogType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ChangelogType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ChangelogType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ChangelogType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ChangelogType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ChangelogType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ChangelogType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ChangelogType>>;
};

/** A filter to be used against CharacterData fields. All fields are combined with a logical ‘and.’ */
export type CharacterDataFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['CharacterData']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['CharacterData']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['CharacterData']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['CharacterData']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['CharacterData']['input']>;
};

export type ConstraintsInfo = {
  __typename?: 'ConstraintsInfo';
  constraintType?: Maybe<Scalars['CharacterData']['output']>;
  fromColumnName?: Maybe<Scalars['SqlIdentifier']['output']>;
  fromTableName?: Maybe<Scalars['SqlIdentifier']['output']>;
  toColumnName?: Maybe<Scalars['SqlIdentifier']['output']>;
  toTableName?: Maybe<Scalars['SqlIdentifier']['output']>;
};

/**
 * A condition to be used against `ConstraintsInfo` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ConstraintsInfoCondition = {
  /** Checks for equality with the object’s `constraintType` field. */
  constraintType?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `fromColumnName` field. */
  fromColumnName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `fromTableName` field. */
  fromTableName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `toColumnName` field. */
  toColumnName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `toTableName` field. */
  toTableName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
};

/** A filter to be used against `ConstraintsInfo` object types. All fields are combined with a logical ‘and.’ */
export type ConstraintsInfoFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ConstraintsInfoFilter>>;
  /** Filter by the object’s `constraintType` field. */
  constraintType?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `fromColumnName` field. */
  fromColumnName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `fromTableName` field. */
  fromTableName?: InputMaybe<SqlIdentifierFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ConstraintsInfoFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ConstraintsInfoFilter>>;
  /** Filter by the object’s `toColumnName` field. */
  toColumnName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `toTableName` field. */
  toTableName?: InputMaybe<SqlIdentifierFilter>;
};

/** A connection to a list of `ConstraintsInfo` values. */
export type ConstraintsInfosConnection = {
  __typename?: 'ConstraintsInfosConnection';
  /** A list of edges which contains the `ConstraintsInfo` and cursor to aid in pagination. */
  edges: Array<ConstraintsInfosEdge>;
  /** A list of `ConstraintsInfo` objects. */
  nodes: Array<Maybe<ConstraintsInfo>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ConstraintsInfo` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ConstraintsInfo` edge in the connection. */
export type ConstraintsInfosEdge = {
  __typename?: 'ConstraintsInfosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ConstraintsInfo` at the end of the edge. */
  node?: Maybe<ConstraintsInfo>;
};

/** Methods to use when ordering `ConstraintsInfo`. */
export enum ConstraintsInfosOrderBy {
  ConstraintTypeAsc = 'CONSTRAINT_TYPE_ASC',
  ConstraintTypeDesc = 'CONSTRAINT_TYPE_DESC',
  FromColumnNameAsc = 'FROM_COLUMN_NAME_ASC',
  FromColumnNameDesc = 'FROM_COLUMN_NAME_DESC',
  FromTableNameAsc = 'FROM_TABLE_NAME_ASC',
  FromTableNameDesc = 'FROM_TABLE_NAME_DESC',
  Natural = 'NATURAL',
  ToColumnNameAsc = 'TO_COLUMN_NAME_ASC',
  ToColumnNameDesc = 'TO_COLUMN_NAME_DESC',
  ToTableNameAsc = 'TO_TABLE_NAME_ASC',
  ToTableNameDesc = 'TO_TABLE_NAME_DESC'
}

export type Counter = Node & {
  __typename?: 'Counter';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  value?: Maybe<Scalars['Int']['output']>;
};

/** A condition to be used against `Counter` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type CounterCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Counter` object types. All fields are combined with a logical ‘and.’ */
export type CounterFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<CounterFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<CounterFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<CounterFilter>>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Counter` */
export type CounterInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `Counter`. Fields that are set will be updated. */
export type CounterPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  value?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `Counter` values. */
export type CountersConnection = {
  __typename?: 'CountersConnection';
  /** A list of edges which contains the `Counter` and cursor to aid in pagination. */
  edges: Array<CountersEdge>;
  /** A list of `Counter` objects. */
  nodes: Array<Maybe<Counter>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Counter` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Counter` edge in the connection. */
export type CountersEdge = {
  __typename?: 'CountersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Counter` at the end of the edge. */
  node?: Maybe<Counter>;
};

/** Methods to use when ordering `Counter`. */
export enum CountersOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

/** All input for the create `ActionPlugin` mutation. */
export type CreateActionPluginInput = {
  /** The `ActionPlugin` to be created by this mutation. */
  actionPlugin: ActionPluginInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ActionPlugin` mutation. */
export type CreateActionPluginPayload = {
  __typename?: 'CreateActionPluginPayload';
  /** The `ActionPlugin` that was created by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ActionPlugin` mutation. */
export type CreateActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the create `ActionQueue` mutation. */
export type CreateActionQueueInput = {
  /** The `ActionQueue` to be created by this mutation. */
  actionQueue: ActionQueueInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ActionQueue` mutation. */
export type CreateActionQueuePayload = {
  __typename?: 'CreateActionQueuePayload';
  /** The `ActionQueue` that was created by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
  /** Reads a single `Application` that is related to this `ActionQueue`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
};


/** The output of our create `ActionQueue` mutation. */
export type CreateActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the create `ActivityLog` mutation. */
export type CreateActivityLogInput = {
  /** The `ActivityLog` to be created by this mutation. */
  activityLog: ActivityLogInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ActivityLog` mutation. */
export type CreateActivityLogPayload = {
  __typename?: 'CreateActivityLogPayload';
  /** The `ActivityLog` that was created by this mutation. */
  activityLog?: Maybe<ActivityLog>;
  /** An edge for our `ActivityLog`. May be used by Relay 1. */
  activityLogEdge?: Maybe<ActivityLogsEdge>;
  /** Reads a single `Application` that is related to this `ActivityLog`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ActivityLog` mutation. */
export type CreateActivityLogPayloadActivityLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};

/** All input for the create `AllowedSelfAssignableSectionsShape` mutation. */
export type CreateAllowedSelfAssignableSectionsShapeInput = {
  /** The `AllowedSelfAssignableSectionsShape` to be created by this mutation. */
  allowedSelfAssignableSectionsShape: AllowedSelfAssignableSectionsShapeInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `AllowedSelfAssignableSectionsShape` mutation. */
export type CreateAllowedSelfAssignableSectionsShapePayload = {
  __typename?: 'CreateAllowedSelfAssignableSectionsShapePayload';
  /** The `AllowedSelfAssignableSectionsShape` that was created by this mutation. */
  allowedSelfAssignableSectionsShape?: Maybe<AllowedSelfAssignableSectionsShape>;
  /** An edge for our `AllowedSelfAssignableSectionsShape`. May be used by Relay 1. */
  allowedSelfAssignableSectionsShapeEdge?: Maybe<AllowedSelfAssignableSectionsShapesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `AllowedSelfAssignableSectionsShape` mutation. */
export type CreateAllowedSelfAssignableSectionsShapePayloadAllowedSelfAssignableSectionsShapeEdgeArgs = {
  orderBy?: InputMaybe<Array<AllowedSelfAssignableSectionsShapesOrderBy>>;
};

/** All input for the create `Application` mutation. */
export type CreateApplicationInput = {
  /** The `Application` to be created by this mutation. */
  application: ApplicationInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** All input for the create `ApplicationListShape` mutation. */
export type CreateApplicationListShapeInput = {
  /** The `ApplicationListShape` to be created by this mutation. */
  applicationListShape: ApplicationListShapeInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationListShape` mutation. */
export type CreateApplicationListShapePayload = {
  __typename?: 'CreateApplicationListShapePayload';
  /** The `ApplicationListShape` that was created by this mutation. */
  applicationListShape?: Maybe<ApplicationListShape>;
  /** An edge for our `ApplicationListShape`. May be used by Relay 1. */
  applicationListShapeEdge?: Maybe<ApplicationListShapesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ApplicationListShape` mutation. */
export type CreateApplicationListShapePayloadApplicationListShapeEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationListShapesOrderBy>>;
};

/** All input for the create `ApplicationNote` mutation. */
export type CreateApplicationNoteInput = {
  /** The `ApplicationNote` to be created by this mutation. */
  applicationNote: ApplicationNoteInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationNote` mutation. */
export type CreateApplicationNotePayload = {
  __typename?: 'CreateApplicationNotePayload';
  /** Reads a single `Application` that is related to this `ApplicationNote`. */
  application?: Maybe<Application>;
  /** The `ApplicationNote` that was created by this mutation. */
  applicationNote?: Maybe<ApplicationNote>;
  /** An edge for our `ApplicationNote`. May be used by Relay 1. */
  applicationNoteEdge?: Maybe<ApplicationNotesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `ApplicationNote`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserList` that is related to this `ApplicationNote`. */
  user?: Maybe<UserList>;
};


/** The output of our create `ApplicationNote` mutation. */
export type CreateApplicationNotePayloadApplicationNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};

/** The output of our create `Application` mutation. */
export type CreateApplicationPayload = {
  __typename?: 'CreateApplicationPayload';
  /** The `Application` that was created by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `UserList` that is related to this `Application`. */
  user?: Maybe<UserList>;
};


/** The output of our create `Application` mutation. */
export type CreateApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the create `ApplicationResponse` mutation. */
export type CreateApplicationResponseInput = {
  /** The `ApplicationResponse` to be created by this mutation. */
  applicationResponse: ApplicationResponseInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationResponse` mutation. */
export type CreateApplicationResponsePayload = {
  __typename?: 'CreateApplicationResponsePayload';
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** The `ApplicationResponse` that was created by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our create `ApplicationResponse` mutation. */
export type CreateApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the create `ApplicationReviewerAction` mutation. */
export type CreateApplicationReviewerActionInput = {
  /** The `ApplicationReviewerAction` to be created by this mutation. */
  applicationReviewerAction: ApplicationReviewerActionInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationReviewerAction` mutation. */
export type CreateApplicationReviewerActionPayload = {
  __typename?: 'CreateApplicationReviewerActionPayload';
  /** Reads a single `Application` that is related to this `ApplicationReviewerAction`. */
  application?: Maybe<Application>;
  /** The `ApplicationReviewerAction` that was created by this mutation. */
  applicationReviewerAction?: Maybe<ApplicationReviewerAction>;
  /** An edge for our `ApplicationReviewerAction`. May be used by Relay 1. */
  applicationReviewerActionEdge?: Maybe<ApplicationReviewerActionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ApplicationReviewerAction` mutation. */
export type CreateApplicationReviewerActionPayloadApplicationReviewerActionEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationReviewerActionsOrderBy>>;
};

/** All input for the create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryInput = {
  /** The `ApplicationStageHistory` to be created by this mutation. */
  applicationStageHistory: ApplicationStageHistoryInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryPayload = {
  __typename?: 'CreateApplicationStageHistoryPayload';
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** The `ApplicationStageHistory` that was created by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
};


/** The output of our create `ApplicationStageHistory` mutation. */
export type CreateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryInput = {
  /** The `ApplicationStatusHistory` to be created by this mutation. */
  applicationStatusHistory: ApplicationStatusHistoryInput;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryPayload = {
  __typename?: 'CreateApplicationStatusHistoryPayload';
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** The `ApplicationStatusHistory` that was created by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ApplicationStatusHistory` mutation. */
export type CreateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the create `Counter` mutation. */
export type CreateCounterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Counter` to be created by this mutation. */
  counter: CounterInput;
};

/** The output of our create `Counter` mutation. */
export type CreateCounterPayload = {
  __typename?: 'CreateCounterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Counter` that was created by this mutation. */
  counter?: Maybe<Counter>;
  /** An edge for our `Counter`. May be used by Relay 1. */
  counterEdge?: Maybe<CountersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Counter` mutation. */
export type CreateCounterPayloadCounterEdgeArgs = {
  orderBy?: InputMaybe<Array<CountersOrderBy>>;
};

/** All input for the create `DataChangelog` mutation. */
export type CreateDataChangelogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataChangelog` to be created by this mutation. */
  dataChangelog: DataChangelogInput;
};

/** The output of our create `DataChangelog` mutation. */
export type CreateDataChangelogPayload = {
  __typename?: 'CreateDataChangelogPayload';
  /** Reads a single `Application` that is related to this `DataChangelog`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataChangelog` that was created by this mutation. */
  dataChangelog?: Maybe<DataChangelog>;
  /** An edge for our `DataChangelog`. May be used by Relay 1. */
  dataChangelogEdge?: Maybe<DataChangelogsEdge>;
  /** Reads a single `Organisation` that is related to this `DataChangelog`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataChangelog` mutation. */
export type CreateDataChangelogPayloadDataChangelogEdgeArgs = {
  orderBy?: InputMaybe<Array<DataChangelogsOrderBy>>;
};

/** All input for the create `DataTableActiveIngredient` mutation. */
export type CreateDataTableActiveIngredientInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableActiveIngredient` to be created by this mutation. */
  dataTableActiveIngredient: DataTableActiveIngredientInput;
};

/** The output of our create `DataTableActiveIngredient` mutation. */
export type CreateDataTableActiveIngredientPayload = {
  __typename?: 'CreateDataTableActiveIngredientPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableActiveIngredient` that was created by this mutation. */
  dataTableActiveIngredient?: Maybe<DataTableActiveIngredient>;
  /** An edge for our `DataTableActiveIngredient`. May be used by Relay 1. */
  dataTableActiveIngredientEdge?: Maybe<DataTableActiveIngredientsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableActiveIngredient` mutation. */
export type CreateDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableActiveIngredientsOrderBy>>;
};

/** All input for the create `DataTableAdministrationRoute` mutation. */
export type CreateDataTableAdministrationRouteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableAdministrationRoute` to be created by this mutation. */
  dataTableAdministrationRoute: DataTableAdministrationRouteInput;
};

/** The output of our create `DataTableAdministrationRoute` mutation. */
export type CreateDataTableAdministrationRoutePayload = {
  __typename?: 'CreateDataTableAdministrationRoutePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAdministrationRoute` that was created by this mutation. */
  dataTableAdministrationRoute?: Maybe<DataTableAdministrationRoute>;
  /** An edge for our `DataTableAdministrationRoute`. May be used by Relay 1. */
  dataTableAdministrationRouteEdge?: Maybe<DataTableAdministrationRoutesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableAdministrationRoute` mutation. */
export type CreateDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAdministrationRoutesOrderBy>>;
};

/** All input for the create `DataTableAtcCode` mutation. */
export type CreateDataTableAtcCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableAtcCode` to be created by this mutation. */
  dataTableAtcCode: DataTableAtcCodeInput;
};

/** The output of our create `DataTableAtcCode` mutation. */
export type CreateDataTableAtcCodePayload = {
  __typename?: 'CreateDataTableAtcCodePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcCode` that was created by this mutation. */
  dataTableAtcCode?: Maybe<DataTableAtcCode>;
  /** An edge for our `DataTableAtcCode`. May be used by Relay 1. */
  dataTableAtcCodeEdge?: Maybe<DataTableAtcCodesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableAtcCode` mutation. */
export type CreateDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcCodesOrderBy>>;
};

/** All input for the create `DataTableContainer` mutation. */
export type CreateDataTableContainerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableContainer` to be created by this mutation. */
  dataTableContainer: DataTableContainerInput;
};

/** The output of our create `DataTableContainer` mutation. */
export type CreateDataTableContainerPayload = {
  __typename?: 'CreateDataTableContainerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableContainer` that was created by this mutation. */
  dataTableContainer?: Maybe<DataTableContainer>;
  /** An edge for our `DataTableContainer`. May be used by Relay 1. */
  dataTableContainerEdge?: Maybe<DataTableContainersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableContainer` mutation. */
export type CreateDataTableContainerPayloadDataTableContainerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableContainersOrderBy>>;
};

/** All input for the create `DataTableCountry` mutation. */
export type CreateDataTableCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableCountry` to be created by this mutation. */
  dataTableCountry: DataTableCountryInput;
};

/** The output of our create `DataTableCountry` mutation. */
export type CreateDataTableCountryPayload = {
  __typename?: 'CreateDataTableCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableCountry` that was created by this mutation. */
  dataTableCountry?: Maybe<DataTableCountry>;
  /** An edge for our `DataTableCountry`. May be used by Relay 1. */
  dataTableCountryEdge?: Maybe<DataTableCountriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableCountry` mutation. */
export type CreateDataTableCountryPayloadDataTableCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableCountriesOrderBy>>;
};

/** All input for the create `DataTableDosageFormGroup` mutation. */
export type CreateDataTableDosageFormGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableDosageFormGroup` to be created by this mutation. */
  dataTableDosageFormGroup: DataTableDosageFormGroupInput;
};

/** The output of our create `DataTableDosageFormGroup` mutation. */
export type CreateDataTableDosageFormGroupPayload = {
  __typename?: 'CreateDataTableDosageFormGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageFormGroup` that was created by this mutation. */
  dataTableDosageFormGroup?: Maybe<DataTableDosageFormGroup>;
  /** An edge for our `DataTableDosageFormGroup`. May be used by Relay 1. */
  dataTableDosageFormGroupEdge?: Maybe<DataTableDosageFormGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableDosageFormGroup` mutation. */
export type CreateDataTableDosageFormGroupPayloadDataTableDosageFormGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormGroupsOrderBy>>;
};

/** All input for the create `DataTableDosageForm` mutation. */
export type CreateDataTableDosageFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableDosageForm` to be created by this mutation. */
  dataTableDosageForm: DataTableDosageFormInput;
};

/** The output of our create `DataTableDosageForm` mutation. */
export type CreateDataTableDosageFormPayload = {
  __typename?: 'CreateDataTableDosageFormPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageForm` that was created by this mutation. */
  dataTableDosageForm?: Maybe<DataTableDosageForm>;
  /** An edge for our `DataTableDosageForm`. May be used by Relay 1. */
  dataTableDosageFormEdge?: Maybe<DataTableDosageFormsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableDosageForm` mutation. */
export type CreateDataTableDosageFormPayloadDataTableDosageFormEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormsOrderBy>>;
};

/** All input for the create `DataTableGenericIngredient` mutation. */
export type CreateDataTableGenericIngredientInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableGenericIngredient` to be created by this mutation. */
  dataTableGenericIngredient: DataTableGenericIngredientInput;
};

/** The output of our create `DataTableGenericIngredient` mutation. */
export type CreateDataTableGenericIngredientPayload = {
  __typename?: 'CreateDataTableGenericIngredientPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableGenericIngredient` that was created by this mutation. */
  dataTableGenericIngredient?: Maybe<DataTableGenericIngredient>;
  /** An edge for our `DataTableGenericIngredient`. May be used by Relay 1. */
  dataTableGenericIngredientEdge?: Maybe<DataTableGenericIngredientsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableGenericIngredient` mutation. */
export type CreateDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableGenericIngredientsOrderBy>>;
};

/** All input for the create `DataTable` mutation. */
export type CreateDataTableInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTable` to be created by this mutation. */
  dataTable: DataTableInput;
};

/** All input for the create `DataTableManufacturerApplicationJoin` mutation. */
export type CreateDataTableManufacturerApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableManufacturerApplicationJoin` to be created by this mutation. */
  dataTableManufacturerApplicationJoin: DataTableManufacturerApplicationJoinInput;
};

/** The output of our create `DataTableManufacturerApplicationJoin` mutation. */
export type CreateDataTableManufacturerApplicationJoinPayload = {
  __typename?: 'CreateDataTableManufacturerApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableManufacturerApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableManufacturer` that is related to this `DataTableManufacturerApplicationJoin`. */
  dataTableManufacturer?: Maybe<DataTableManufacturer>;
  /** The `DataTableManufacturerApplicationJoin` that was created by this mutation. */
  dataTableManufacturerApplicationJoin?: Maybe<DataTableManufacturerApplicationJoin>;
  /** An edge for our `DataTableManufacturerApplicationJoin`. May be used by Relay 1. */
  dataTableManufacturerApplicationJoinEdge?: Maybe<DataTableManufacturerApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableManufacturerApplicationJoin` mutation. */
export type CreateDataTableManufacturerApplicationJoinPayloadDataTableManufacturerApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerApplicationJoinsOrderBy>>;
};

/** All input for the create `DataTableManufacturer` mutation. */
export type CreateDataTableManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableManufacturer` to be created by this mutation. */
  dataTableManufacturer: DataTableManufacturerInput;
};

/** The output of our create `DataTableManufacturer` mutation. */
export type CreateDataTableManufacturerPayload = {
  __typename?: 'CreateDataTableManufacturerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturer` that was created by this mutation. */
  dataTableManufacturer?: Maybe<DataTableManufacturer>;
  /** An edge for our `DataTableManufacturer`. May be used by Relay 1. */
  dataTableManufacturerEdge?: Maybe<DataTableManufacturersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableManufacturer` mutation. */
export type CreateDataTableManufacturerPayloadDataTableManufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturersOrderBy>>;
};

/** All input for the create `DataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type CreateDataTableManufacturerRepresentativeApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableManufacturerRepresentativeApplicationJoin` to be created by this mutation. */
  dataTableManufacturerRepresentativeApplicationJoin: DataTableManufacturerRepresentativeApplicationJoinInput;
};

/** The output of our create `DataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type CreateDataTableManufacturerRepresentativeApplicationJoinPayload = {
  __typename?: 'CreateDataTableManufacturerRepresentativeApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableManufacturerRepresentativeApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * Reads a single `DataTableManufacturerRepresentative` that is related to this
   * `DataTableManufacturerRepresentativeApplicationJoin`.
   */
  dataTableManufacturerRepresentative?: Maybe<DataTableManufacturerRepresentative>;
  /** The `DataTableManufacturerRepresentativeApplicationJoin` that was created by this mutation. */
  dataTableManufacturerRepresentativeApplicationJoin?: Maybe<DataTableManufacturerRepresentativeApplicationJoin>;
  /** An edge for our `DataTableManufacturerRepresentativeApplicationJoin`. May be used by Relay 1. */
  dataTableManufacturerRepresentativeApplicationJoinEdge?: Maybe<DataTableManufacturerRepresentativeApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type CreateDataTableManufacturerRepresentativeApplicationJoinPayloadDataTableManufacturerRepresentativeApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinsOrderBy>>;
};

/** All input for the create `DataTableManufacturerRepresentative` mutation. */
export type CreateDataTableManufacturerRepresentativeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableManufacturerRepresentative` to be created by this mutation. */
  dataTableManufacturerRepresentative: DataTableManufacturerRepresentativeInput;
};

/** The output of our create `DataTableManufacturerRepresentative` mutation. */
export type CreateDataTableManufacturerRepresentativePayload = {
  __typename?: 'CreateDataTableManufacturerRepresentativePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturerRepresentative` that was created by this mutation. */
  dataTableManufacturerRepresentative?: Maybe<DataTableManufacturerRepresentative>;
  /** An edge for our `DataTableManufacturerRepresentative`. May be used by Relay 1. */
  dataTableManufacturerRepresentativeEdge?: Maybe<DataTableManufacturerRepresentativesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableManufacturerRepresentative` mutation. */
export type CreateDataTableManufacturerRepresentativePayloadDataTableManufacturerRepresentativeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativesOrderBy>>;
};

/** The output of our create `DataTable` mutation. */
export type CreateDataTablePayload = {
  __typename?: 'CreateDataTablePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTable` that was created by this mutation. */
  dataTable?: Maybe<DataTable>;
  /** An edge for our `DataTable`. May be used by Relay 1. */
  dataTableEdge?: Maybe<DataTablesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTable` mutation. */
export type CreateDataTablePayloadDataTableEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablesOrderBy>>;
};

/** All input for the create `DataTablePermitChemicalApplicationJoin` mutation. */
export type CreateDataTablePermitChemicalApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTablePermitChemicalApplicationJoin` to be created by this mutation. */
  dataTablePermitChemicalApplicationJoin: DataTablePermitChemicalApplicationJoinInput;
};

/** The output of our create `DataTablePermitChemicalApplicationJoin` mutation. */
export type CreateDataTablePermitChemicalApplicationJoinPayload = {
  __typename?: 'CreateDataTablePermitChemicalApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTablePermitChemicalApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTablePermitChemical` that is related to this `DataTablePermitChemicalApplicationJoin`. */
  dataTablePermitChemical?: Maybe<DataTablePermitChemical>;
  /** The `DataTablePermitChemicalApplicationJoin` that was created by this mutation. */
  dataTablePermitChemicalApplicationJoin?: Maybe<DataTablePermitChemicalApplicationJoin>;
  /** An edge for our `DataTablePermitChemicalApplicationJoin`. May be used by Relay 1. */
  dataTablePermitChemicalApplicationJoinEdge?: Maybe<DataTablePermitChemicalApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTablePermitChemicalApplicationJoin` mutation. */
export type CreateDataTablePermitChemicalApplicationJoinPayloadDataTablePermitChemicalApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinsOrderBy>>;
};

/** All input for the create `DataTablePermitChemical` mutation. */
export type CreateDataTablePermitChemicalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTablePermitChemical` to be created by this mutation. */
  dataTablePermitChemical: DataTablePermitChemicalInput;
};

/** The output of our create `DataTablePermitChemical` mutation. */
export type CreateDataTablePermitChemicalPayload = {
  __typename?: 'CreateDataTablePermitChemicalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePermitChemical` that was created by this mutation. */
  dataTablePermitChemical?: Maybe<DataTablePermitChemical>;
  /** An edge for our `DataTablePermitChemical`. May be used by Relay 1. */
  dataTablePermitChemicalEdge?: Maybe<DataTablePermitChemicalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTablePermitChemical` mutation. */
export type CreateDataTablePermitChemicalPayloadDataTablePermitChemicalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePermitChemicalsOrderBy>>;
};

/** All input for the create `DataTablePreRegisteredProductsProvisional` mutation. */
export type CreateDataTablePreRegisteredProductsProvisionalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTablePreRegisteredProductsProvisional` to be created by this mutation. */
  dataTablePreRegisteredProductsProvisional: DataTablePreRegisteredProductsProvisionalInput;
};

/** The output of our create `DataTablePreRegisteredProductsProvisional` mutation. */
export type CreateDataTablePreRegisteredProductsProvisionalPayload = {
  __typename?: 'CreateDataTablePreRegisteredProductsProvisionalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePreRegisteredProductsProvisional` that was created by this mutation. */
  dataTablePreRegisteredProductsProvisional?: Maybe<DataTablePreRegisteredProductsProvisional>;
  /** An edge for our `DataTablePreRegisteredProductsProvisional`. May be used by Relay 1. */
  dataTablePreRegisteredProductsProvisionalEdge?: Maybe<DataTablePreRegisteredProductsProvisionalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTablePreRegisteredProductsProvisional` mutation. */
export type CreateDataTablePreRegisteredProductsProvisionalPayloadDataTablePreRegisteredProductsProvisionalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePreRegisteredProductsProvisionalsOrderBy>>;
};

/** All input for the create `DataTablePrequalManufacturerApplicationJoin` mutation. */
export type CreateDataTablePrequalManufacturerApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTablePrequalManufacturerApplicationJoin` to be created by this mutation. */
  dataTablePrequalManufacturerApplicationJoin: DataTablePrequalManufacturerApplicationJoinInput;
};

/** The output of our create `DataTablePrequalManufacturerApplicationJoin` mutation. */
export type CreateDataTablePrequalManufacturerApplicationJoinPayload = {
  __typename?: 'CreateDataTablePrequalManufacturerApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTablePrequalManufacturerApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTablePrequalManufacturer` that is related to this `DataTablePrequalManufacturerApplicationJoin`. */
  dataTablePrequalManufacturer?: Maybe<DataTablePrequalManufacturer>;
  /** The `DataTablePrequalManufacturerApplicationJoin` that was created by this mutation. */
  dataTablePrequalManufacturerApplicationJoin?: Maybe<DataTablePrequalManufacturerApplicationJoin>;
  /** An edge for our `DataTablePrequalManufacturerApplicationJoin`. May be used by Relay 1. */
  dataTablePrequalManufacturerApplicationJoinEdge?: Maybe<DataTablePrequalManufacturerApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTablePrequalManufacturerApplicationJoin` mutation. */
export type CreateDataTablePrequalManufacturerApplicationJoinPayloadDataTablePrequalManufacturerApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinsOrderBy>>;
};

/** All input for the create `DataTablePrequalManufacturer` mutation. */
export type CreateDataTablePrequalManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTablePrequalManufacturer` to be created by this mutation. */
  dataTablePrequalManufacturer: DataTablePrequalManufacturerInput;
};

/** The output of our create `DataTablePrequalManufacturer` mutation. */
export type CreateDataTablePrequalManufacturerPayload = {
  __typename?: 'CreateDataTablePrequalManufacturerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePrequalManufacturer` that was created by this mutation. */
  dataTablePrequalManufacturer?: Maybe<DataTablePrequalManufacturer>;
  /** An edge for our `DataTablePrequalManufacturer`. May be used by Relay 1. */
  dataTablePrequalManufacturerEdge?: Maybe<DataTablePrequalManufacturersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTablePrequalManufacturer` mutation. */
export type CreateDataTablePrequalManufacturerPayloadDataTablePrequalManufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturersOrderBy>>;
};

/** All input for the create `DataTableProcessingStep` mutation. */
export type CreateDataTableProcessingStepInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProcessingStep` to be created by this mutation. */
  dataTableProcessingStep: DataTableProcessingStepInput;
};

/** The output of our create `DataTableProcessingStep` mutation. */
export type CreateDataTableProcessingStepPayload = {
  __typename?: 'CreateDataTableProcessingStepPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProcessingStep` that was created by this mutation. */
  dataTableProcessingStep?: Maybe<DataTableProcessingStep>;
  /** An edge for our `DataTableProcessingStep`. May be used by Relay 1. */
  dataTableProcessingStepEdge?: Maybe<DataTableProcessingStepsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProcessingStep` mutation. */
export type CreateDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProcessingStepsOrderBy>>;
};

/** All input for the create `DataTableProductApplicationJoin` mutation. */
export type CreateDataTableProductApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProductApplicationJoin` to be created by this mutation. */
  dataTableProductApplicationJoin: DataTableProductApplicationJoinInput;
};

/** The output of our create `DataTableProductApplicationJoin` mutation. */
export type CreateDataTableProductApplicationJoinPayload = {
  __typename?: 'CreateDataTableProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProductApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProductApplicationJoin` that was created by this mutation. */
  dataTableProductApplicationJoin?: Maybe<DataTableProductApplicationJoin>;
  /** An edge for our `DataTableProductApplicationJoin`. May be used by Relay 1. */
  dataTableProductApplicationJoinEdge?: Maybe<DataTableProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProductApplicationJoin` mutation. */
export type CreateDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};

/** All input for the create `DataTableProduct` mutation. */
export type CreateDataTableProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProduct` to be created by this mutation. */
  dataTableProduct: DataTableProductInput;
};

/** The output of our create `DataTableProduct` mutation. */
export type CreateDataTableProductPayload = {
  __typename?: 'CreateDataTableProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProduct` that was created by this mutation. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** An edge for our `DataTableProduct`. May be used by Relay 1. */
  dataTableProductEdge?: Maybe<DataTableProductsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProduct` mutation. */
export type CreateDataTableProductPayloadDataTableProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductsOrderBy>>;
};

/** All input for the create `DataTableProvisionalProductApplicationJoin` mutation. */
export type CreateDataTableProvisionalProductApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProvisionalProductApplicationJoin` to be created by this mutation. */
  dataTableProvisionalProductApplicationJoin: DataTableProvisionalProductApplicationJoinInput;
};

/** The output of our create `DataTableProvisionalProductApplicationJoin` mutation. */
export type CreateDataTableProvisionalProductApplicationJoinPayload = {
  __typename?: 'CreateDataTableProvisionalProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProvisionalProductApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableProvisionalProduct` that is related to this `DataTableProvisionalProductApplicationJoin`. */
  dataTableProvisionalProduct?: Maybe<DataTableProvisionalProduct>;
  /** The `DataTableProvisionalProductApplicationJoin` that was created by this mutation. */
  dataTableProvisionalProductApplicationJoin?: Maybe<DataTableProvisionalProductApplicationJoin>;
  /** An edge for our `DataTableProvisionalProductApplicationJoin`. May be used by Relay 1. */
  dataTableProvisionalProductApplicationJoinEdge?: Maybe<DataTableProvisionalProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProvisionalProductApplicationJoin` mutation. */
export type CreateDataTableProvisionalProductApplicationJoinPayloadDataTableProvisionalProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinsOrderBy>>;
};

/** All input for the create `DataTableProvisionalProduct` mutation. */
export type CreateDataTableProvisionalProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableProvisionalProduct` to be created by this mutation. */
  dataTableProvisionalProduct: DataTableProvisionalProductInput;
};

/** The output of our create `DataTableProvisionalProduct` mutation. */
export type CreateDataTableProvisionalProductPayload = {
  __typename?: 'CreateDataTableProvisionalProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProvisionalProduct` that was created by this mutation. */
  dataTableProvisionalProduct?: Maybe<DataTableProvisionalProduct>;
  /** An edge for our `DataTableProvisionalProduct`. May be used by Relay 1. */
  dataTableProvisionalProductEdge?: Maybe<DataTableProvisionalProductsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableProvisionalProduct` mutation. */
export type CreateDataTableProvisionalProductPayloadDataTableProvisionalProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvisionalProductsOrderBy>>;
};

/** All input for the create `DataTableScheduledChemical` mutation. */
export type CreateDataTableScheduledChemicalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableScheduledChemical` to be created by this mutation. */
  dataTableScheduledChemical: DataTableScheduledChemicalInput;
};

/** The output of our create `DataTableScheduledChemical` mutation. */
export type CreateDataTableScheduledChemicalPayload = {
  __typename?: 'CreateDataTableScheduledChemicalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableScheduledChemical` that was created by this mutation. */
  dataTableScheduledChemical?: Maybe<DataTableScheduledChemical>;
  /** An edge for our `DataTableScheduledChemical`. May be used by Relay 1. */
  dataTableScheduledChemicalEdge?: Maybe<DataTableScheduledChemicalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableScheduledChemical` mutation. */
export type CreateDataTableScheduledChemicalPayloadDataTableScheduledChemicalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableScheduledChemicalsOrderBy>>;
};

/** All input for the create `DataTableStorageCondition` mutation. */
export type CreateDataTableStorageConditionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableStorageCondition` to be created by this mutation. */
  dataTableStorageCondition: DataTableStorageConditionInput;
};

/** The output of our create `DataTableStorageCondition` mutation. */
export type CreateDataTableStorageConditionPayload = {
  __typename?: 'CreateDataTableStorageConditionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageCondition` that was created by this mutation. */
  dataTableStorageCondition?: Maybe<DataTableStorageCondition>;
  /** An edge for our `DataTableStorageCondition`. May be used by Relay 1. */
  dataTableStorageConditionEdge?: Maybe<DataTableStorageConditionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableStorageCondition` mutation. */
export type CreateDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsOrderBy>>;
};

/** All input for the create `DataTableStorageConditionsSimplified` mutation. */
export type CreateDataTableStorageConditionsSimplifiedInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableStorageConditionsSimplified` to be created by this mutation. */
  dataTableStorageConditionsSimplified: DataTableStorageConditionsSimplifiedInput;
};

/** The output of our create `DataTableStorageConditionsSimplified` mutation. */
export type CreateDataTableStorageConditionsSimplifiedPayload = {
  __typename?: 'CreateDataTableStorageConditionsSimplifiedPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageConditionsSimplified` that was created by this mutation. */
  dataTableStorageConditionsSimplified?: Maybe<DataTableStorageConditionsSimplified>;
  /** An edge for our `DataTableStorageConditionsSimplified`. May be used by Relay 1. */
  dataTableStorageConditionsSimplifiedEdge?: Maybe<DataTableStorageConditionsSimplifiedsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableStorageConditionsSimplified` mutation. */
export type CreateDataTableStorageConditionsSimplifiedPayloadDataTableStorageConditionsSimplifiedEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsSimplifiedsOrderBy>>;
};

/** All input for the create `DataTableUnitsOfProportion` mutation. */
export type CreateDataTableUnitsOfProportionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableUnitsOfProportion` to be created by this mutation. */
  dataTableUnitsOfProportion: DataTableUnitsOfProportionInput;
};

/** The output of our create `DataTableUnitsOfProportion` mutation. */
export type CreateDataTableUnitsOfProportionPayload = {
  __typename?: 'CreateDataTableUnitsOfProportionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableUnitsOfProportion` that was created by this mutation. */
  dataTableUnitsOfProportion?: Maybe<DataTableUnitsOfProportion>;
  /** An edge for our `DataTableUnitsOfProportion`. May be used by Relay 1. */
  dataTableUnitsOfProportionEdge?: Maybe<DataTableUnitsOfProportionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableUnitsOfProportion` mutation. */
export type CreateDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableUnitsOfProportionsOrderBy>>;
};

/** All input for the create `DataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type CreateDataTableWorldHealthOrganisationPqListOfFppInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataTableWorldHealthOrganisationPqListOfFpp` to be created by this mutation. */
  dataTableWorldHealthOrganisationPqListOfFpp: DataTableWorldHealthOrganisationPqListOfFppInput;
};

/** The output of our create `DataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type CreateDataTableWorldHealthOrganisationPqListOfFppPayload = {
  __typename?: 'CreateDataTableWorldHealthOrganisationPqListOfFppPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableWorldHealthOrganisationPqListOfFpp` that was created by this mutation. */
  dataTableWorldHealthOrganisationPqListOfFpp?: Maybe<DataTableWorldHealthOrganisationPqListOfFpp>;
  /** An edge for our `DataTableWorldHealthOrganisationPqListOfFpp`. May be used by Relay 1. */
  dataTableWorldHealthOrganisationPqListOfFppEdge?: Maybe<DataTableWorldHealthOrganisationPqListOfFppsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type CreateDataTableWorldHealthOrganisationPqListOfFppPayloadDataTableWorldHealthOrganisationPqListOfFppEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableWorldHealthOrganisationPqListOfFppsOrderBy>>;
};

/** All input for the create `DataViewColumnDefinition` mutation. */
export type CreateDataViewColumnDefinitionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataViewColumnDefinition` to be created by this mutation. */
  dataViewColumnDefinition: DataViewColumnDefinitionInput;
};

/** The output of our create `DataViewColumnDefinition` mutation. */
export type CreateDataViewColumnDefinitionPayload = {
  __typename?: 'CreateDataViewColumnDefinitionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataViewColumnDefinition` that was created by this mutation. */
  dataViewColumnDefinition?: Maybe<DataViewColumnDefinition>;
  /** An edge for our `DataViewColumnDefinition`. May be used by Relay 1. */
  dataViewColumnDefinitionEdge?: Maybe<DataViewColumnDefinitionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataViewColumnDefinition` mutation. */
export type CreateDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewColumnDefinitionsOrderBy>>;
};

/** All input for the create `DataView` mutation. */
export type CreateDataViewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `DataView` to be created by this mutation. */
  dataView: DataViewInput;
};

/** The output of our create `DataView` mutation. */
export type CreateDataViewPayload = {
  __typename?: 'CreateDataViewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataView` that was created by this mutation. */
  dataView?: Maybe<DataView>;
  /** An edge for our `DataView`. May be used by Relay 1. */
  dataViewEdge?: Maybe<DataViewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `DataView` mutation. */
export type CreateDataViewPayloadDataViewEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewsOrderBy>>;
};

/** All input for the create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ElementTypePlugin` to be created by this mutation. */
  elementTypePlugin: ElementTypePluginInput;
};

/** The output of our create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginPayload = {
  __typename?: 'CreateElementTypePluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ElementTypePlugin` that was created by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `ElementTypePlugin` mutation. */
export type CreateElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the create `File` mutation. */
export type CreateFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `File` to be created by this mutation. */
  file: FileInput;
};

/** The output of our create `File` mutation. */
export type CreateFilePayload = {
  __typename?: 'CreateFilePayload';
  /** Reads a single `Application` that is related to this `File`. */
  applicationByApplicationSerial?: Maybe<Application>;
  /** Reads a single `ApplicationNote` that is related to this `File`. */
  applicationNote?: Maybe<ApplicationNote>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `File` that was created by this mutation. */
  file?: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `File`. */
  template?: Maybe<Template>;
};


/** The output of our create `File` mutation. */
export type CreateFilePayloadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};

/** All input for the create `Filter` mutation. */
export type CreateFilterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Filter` to be created by this mutation. */
  filter: FilterInput;
};

/** The output of our create `Filter` mutation. */
export type CreateFilterPayload = {
  __typename?: 'CreateFilterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Filter` that was created by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Filter` mutation. */
export type CreateFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the create `GrafanaDashboardImage` mutation. */
export type CreateGrafanaDashboardImageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `GrafanaDashboardImage` to be created by this mutation. */
  grafanaDashboardImage: GrafanaDashboardImageInput;
};

/** The output of our create `GrafanaDashboardImage` mutation. */
export type CreateGrafanaDashboardImagePayload = {
  __typename?: 'CreateGrafanaDashboardImagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `GrafanaDashboardImage` that was created by this mutation. */
  grafanaDashboardImage?: Maybe<GrafanaDashboardImage>;
  /** An edge for our `GrafanaDashboardImage`. May be used by Relay 1. */
  grafanaDashboardImageEdge?: Maybe<GrafanaDashboardImagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `GrafanaDashboardImage` mutation. */
export type CreateGrafanaDashboardImagePayloadGrafanaDashboardImageEdgeArgs = {
  orderBy?: InputMaybe<Array<GrafanaDashboardImagesOrderBy>>;
};

/** All input for the create `Notification` mutation. */
export type CreateNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Notification` to be created by this mutation. */
  notification: NotificationInput;
};

/** The output of our create `Notification` mutation. */
export type CreateNotificationPayload = {
  __typename?: 'CreateNotificationPayload';
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Notification` that was created by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
};


/** The output of our create `Notification` mutation. */
export type CreateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the create `OrganisationApplicationJoin` mutation. */
export type CreateOrganisationApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `OrganisationApplicationJoin` to be created by this mutation. */
  organisationApplicationJoin: OrganisationApplicationJoinInput;
};

/** The output of our create `OrganisationApplicationJoin` mutation. */
export type CreateOrganisationApplicationJoinPayload = {
  __typename?: 'CreateOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `OrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `OrganisationApplicationJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `OrganisationApplicationJoin` that was created by this mutation. */
  organisationApplicationJoin?: Maybe<OrganisationApplicationJoin>;
  /** An edge for our `OrganisationApplicationJoin`. May be used by Relay 1. */
  organisationApplicationJoinEdge?: Maybe<OrganisationApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `OrganisationApplicationJoin` mutation. */
export type CreateOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};

/** All input for the create `Organisation` mutation. */
export type CreateOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Organisation` to be created by this mutation. */
  organisation: OrganisationInput;
};

/** The output of our create `Organisation` mutation. */
export type CreateOrganisationPayload = {
  __typename?: 'CreateOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Organisation` that was created by this mutation. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `Organisation` mutation. */
export type CreateOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationsOrderBy>>;
};

/** All input for the create `PermissionJoin` mutation. */
export type CreatePermissionJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PermissionJoin` to be created by this mutation. */
  permissionJoin: PermissionJoinInput;
};

/** The output of our create `PermissionJoin` mutation. */
export type CreatePermissionJoinPayload = {
  __typename?: 'CreatePermissionJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `PermissionJoin` that was created by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserList` that is related to this `PermissionJoin`. */
  user?: Maybe<UserList>;
};


/** The output of our create `PermissionJoin` mutation. */
export type CreatePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the create `PermissionName` mutation. */
export type CreatePermissionNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PermissionName` to be created by this mutation. */
  permissionName: PermissionNameInput;
};

/** The output of our create `PermissionName` mutation. */
export type CreatePermissionNamePayload = {
  __typename?: 'CreatePermissionNamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PermissionName` that was created by this mutation. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PermissionName` mutation. */
export type CreatePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `PermissionPolicy` to be created by this mutation. */
  permissionPolicy: PermissionPolicyInput;
};

/** The output of our create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyPayload = {
  __typename?: 'CreatePermissionPolicyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PermissionPolicy` that was created by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our create `PermissionPolicy` mutation. */
export type CreatePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the create `ReviewAssignmentAssignedSectionsShape` mutation. */
export type CreateReviewAssignmentAssignedSectionsShapeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewAssignmentAssignedSectionsShape` to be created by this mutation. */
  reviewAssignmentAssignedSectionsShape: ReviewAssignmentAssignedSectionsShapeInput;
};

/** The output of our create `ReviewAssignmentAssignedSectionsShape` mutation. */
export type CreateReviewAssignmentAssignedSectionsShapePayload = {
  __typename?: 'CreateReviewAssignmentAssignedSectionsShapePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `ReviewAssignmentAssignedSectionsShape` that was created by this mutation. */
  reviewAssignmentAssignedSectionsShape?: Maybe<ReviewAssignmentAssignedSectionsShape>;
  /** An edge for our `ReviewAssignmentAssignedSectionsShape`. May be used by Relay 1. */
  reviewAssignmentAssignedSectionsShapeEdge?: Maybe<ReviewAssignmentAssignedSectionsShapesEdge>;
};


/** The output of our create `ReviewAssignmentAssignedSectionsShape` mutation. */
export type CreateReviewAssignmentAssignedSectionsShapePayloadReviewAssignmentAssignedSectionsShapeEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignedSectionsShapesOrderBy>>;
};

/** All input for the create `ReviewAssignmentAssignerJoin` mutation. */
export type CreateReviewAssignmentAssignerJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewAssignmentAssignerJoin` to be created by this mutation. */
  reviewAssignmentAssignerJoin: ReviewAssignmentAssignerJoinInput;
};

/** The output of our create `ReviewAssignmentAssignerJoin` mutation. */
export type CreateReviewAssignmentAssignerJoinPayload = {
  __typename?: 'CreateReviewAssignmentAssignerJoinPayload';
  /** Reads a single `UserList` that is related to this `ReviewAssignmentAssignerJoin`. */
  assigner?: Maybe<UserList>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignmentAssignerJoin`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewAssignmentAssignerJoin`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** The `ReviewAssignmentAssignerJoin` that was created by this mutation. */
  reviewAssignmentAssignerJoin?: Maybe<ReviewAssignmentAssignerJoin>;
  /** An edge for our `ReviewAssignmentAssignerJoin`. May be used by Relay 1. */
  reviewAssignmentAssignerJoinEdge?: Maybe<ReviewAssignmentAssignerJoinsEdge>;
};


/** The output of our create `ReviewAssignmentAssignerJoin` mutation. */
export type CreateReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};

/** All input for the create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewAssignment` to be created by this mutation. */
  reviewAssignment: ReviewAssignmentInput;
};

/** The output of our create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentPayload = {
  __typename?: 'CreateReviewAssignmentPayload';
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** Reads a single `UserList` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<UserList>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `TemplateStageReviewLevel` that is related to this `ReviewAssignment`. */
  level?: Maybe<TemplateStageReviewLevel>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `ReviewAssignment` that was created by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
  /** Reads a single `UserList` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<UserList>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Template` that is related to this `ReviewAssignment`. */
  template?: Maybe<Template>;
};


/** The output of our create `ReviewAssignment` mutation. */
export type CreateReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the create `ReviewDecision` mutation. */
export type CreateReviewDecisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewDecision` to be created by this mutation. */
  reviewDecision: ReviewDecisionInput;
};

/** The output of our create `ReviewDecision` mutation. */
export type CreateReviewDecisionPayload = {
  __typename?: 'CreateReviewDecisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** The `ReviewDecision` that was created by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our create `ReviewDecision` mutation. */
export type CreateReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the create `Review` mutation. */
export type CreateReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Review` to be created by this mutation. */
  review: ReviewInput;
};

/** The output of our create `Review` mutation. */
export type CreateReviewPayload = {
  __typename?: 'CreateReviewPayload';
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Review` that was created by this mutation. */
  review?: Maybe<Review>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
  /** Reads a single `UserList` that is related to this `Review`. */
  reviewer?: Maybe<UserList>;
};


/** The output of our create `Review` mutation. */
export type CreateReviewPayloadReviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the create `ReviewResponse` mutation. */
export type CreateReviewResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewResponse` to be created by this mutation. */
  reviewResponse: ReviewResponseInput;
};

/** The output of our create `ReviewResponse` mutation. */
export type CreateReviewResponsePayload = {
  __typename?: 'CreateReviewResponsePayload';
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** The `ReviewResponse` that was created by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our create `ReviewResponse` mutation. */
export type CreateReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `ReviewStatusHistory` to be created by this mutation. */
  reviewStatusHistory: ReviewStatusHistoryInput;
};

/** The output of our create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryPayload = {
  __typename?: 'CreateReviewStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** The `ReviewStatusHistory` that was created by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our create `ReviewStatusHistory` mutation. */
export type CreateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the create `SystemInfo` mutation. */
export type CreateSystemInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `SystemInfo` to be created by this mutation. */
  systemInfo: SystemInfoInput;
};

/** The output of our create `SystemInfo` mutation. */
export type CreateSystemInfoPayload = {
  __typename?: 'CreateSystemInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemInfo` that was created by this mutation. */
  systemInfo?: Maybe<SystemInfo>;
  /** An edge for our `SystemInfo`. May be used by Relay 1. */
  systemInfoEdge?: Maybe<SystemInfosEdge>;
};


/** The output of our create `SystemInfo` mutation. */
export type CreateSystemInfoPayloadSystemInfoEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemInfosOrderBy>>;
};

/** All input for the create `TemplateAction` mutation. */
export type CreateTemplateActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateAction` to be created by this mutation. */
  templateAction: TemplateActionInput;
};

/** The output of our create `TemplateAction` mutation. */
export type CreateTemplateActionPayload = {
  __typename?: 'CreateTemplateActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** The `TemplateAction` that was created by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our create `TemplateAction` mutation. */
export type CreateTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the create `TemplateCategory` mutation. */
export type CreateTemplateCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateCategory` to be created by this mutation. */
  templateCategory: TemplateCategoryInput;
};

/** The output of our create `TemplateCategory` mutation. */
export type CreateTemplateCategoryPayload = {
  __typename?: 'CreateTemplateCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TemplateCategory` that was created by this mutation. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `TemplateCategory`. May be used by Relay 1. */
  templateCategoryEdge?: Maybe<TemplateCategoriesEdge>;
};


/** The output of our create `TemplateCategory` mutation. */
export type CreateTemplateCategoryPayloadTemplateCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateCategoriesOrderBy>>;
};

/** All input for the create `TemplateElement` mutation. */
export type CreateTemplateElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateElement` to be created by this mutation. */
  templateElement: TemplateElementInput;
};

/** The output of our create `TemplateElement` mutation. */
export type CreateTemplateElementPayload = {
  __typename?: 'CreateTemplateElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** The `TemplateElement` that was created by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our create `TemplateElement` mutation. */
export type CreateTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the create `TemplateFilterJoin` mutation. */
export type CreateTemplateFilterJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateFilterJoin` to be created by this mutation. */
  templateFilterJoin: TemplateFilterJoinInput;
};

/** The output of our create `TemplateFilterJoin` mutation. */
export type CreateTemplateFilterJoinPayload = {
  __typename?: 'CreateTemplateFilterJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Filter` that is related to this `TemplateFilterJoin`. */
  filter?: Maybe<Filter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateFilterJoin`. */
  template?: Maybe<Template>;
  /** The `TemplateFilterJoin` that was created by this mutation. */
  templateFilterJoin?: Maybe<TemplateFilterJoin>;
  /** An edge for our `TemplateFilterJoin`. May be used by Relay 1. */
  templateFilterJoinEdge?: Maybe<TemplateFilterJoinsEdge>;
};


/** The output of our create `TemplateFilterJoin` mutation. */
export type CreateTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};

/** All input for the create `Template` mutation. */
export type CreateTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Template` to be created by this mutation. */
  template: TemplateInput;
};

/** The output of our create `Template` mutation. */
export type CreateTemplatePayload = {
  __typename?: 'CreateTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Template` that was created by this mutation. */
  template?: Maybe<Template>;
  /** Reads a single `TemplateCategory` that is related to this `Template`. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our create `Template` mutation. */
export type CreateTemplatePayloadTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the create `TemplatePermission` mutation. */
export type CreateTemplatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplatePermission` to be created by this mutation. */
  templatePermission: TemplatePermissionInput;
};

/** The output of our create `TemplatePermission` mutation. */
export type CreateTemplatePermissionPayload = {
  __typename?: 'CreateTemplatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** The `TemplatePermission` that was created by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our create `TemplatePermission` mutation. */
export type CreateTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the create `TemplateSection` mutation. */
export type CreateTemplateSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateSection` to be created by this mutation. */
  templateSection: TemplateSectionInput;
};

/** The output of our create `TemplateSection` mutation. */
export type CreateTemplateSectionPayload = {
  __typename?: 'CreateTemplateSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** The `TemplateSection` that was created by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our create `TemplateSection` mutation. */
export type CreateTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the create `TemplateStage` mutation. */
export type CreateTemplateStageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateStage` to be created by this mutation. */
  templateStage: TemplateStageInput;
};

/** The output of our create `TemplateStage` mutation. */
export type CreateTemplateStagePayload = {
  __typename?: 'CreateTemplateStagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** The `TemplateStage` that was created by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our create `TemplateStage` mutation. */
export type CreateTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the create `TemplateStageReviewLevel` mutation. */
export type CreateTemplateStageReviewLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TemplateStageReviewLevel` to be created by this mutation. */
  templateStageReviewLevel: TemplateStageReviewLevelInput;
};

/** The output of our create `TemplateStageReviewLevel` mutation. */
export type CreateTemplateStageReviewLevelPayload = {
  __typename?: 'CreateTemplateStageReviewLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `TemplateStageReviewLevel`. */
  stage?: Maybe<TemplateStage>;
  /** The `TemplateStageReviewLevel` that was created by this mutation. */
  templateStageReviewLevel?: Maybe<TemplateStageReviewLevel>;
  /** An edge for our `TemplateStageReviewLevel`. May be used by Relay 1. */
  templateStageReviewLevelEdge?: Maybe<TemplateStageReviewLevelsEdge>;
};


/** The output of our create `TemplateStageReviewLevel` mutation. */
export type CreateTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};

/** All input for the create `TriggerQueue` mutation. */
export type CreateTriggerQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TriggerQueue` to be created by this mutation. */
  triggerQueue: TriggerQueueInput;
};

/** The output of our create `TriggerQueue` mutation. */
export type CreateTriggerQueuePayload = {
  __typename?: 'CreateTriggerQueuePayload';
  /** Reads a single `Application` that is related to this `TriggerQueue`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TriggerQueue` that was created by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our create `TriggerQueue` mutation. */
export type CreateTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the create `TriggerSchedule` mutation. */
export type CreateTriggerScheduleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `TriggerSchedule` to be created by this mutation. */
  triggerSchedule: TriggerScheduleInput;
};

/** The output of our create `TriggerSchedule` mutation. */
export type CreateTriggerSchedulePayload = {
  __typename?: 'CreateTriggerSchedulePayload';
  /** Reads a single `Application` that is related to this `TriggerSchedule`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TriggerSchedule`. */
  template?: Maybe<Template>;
  /** The `TriggerSchedule` that was created by this mutation. */
  triggerSchedule?: Maybe<TriggerSchedule>;
  /** An edge for our `TriggerSchedule`. May be used by Relay 1. */
  triggerScheduleEdge?: Maybe<TriggerSchedulesEdge>;
};


/** The output of our create `TriggerSchedule` mutation. */
export type CreateTriggerSchedulePayloadTriggerScheduleEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};

/** All input for the create `UserApplicationJoin` mutation. */
export type CreateUserApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserApplicationJoin` to be created by this mutation. */
  userApplicationJoin: UserApplicationJoinInput;
};

/** The output of our create `UserApplicationJoin` mutation. */
export type CreateUserApplicationJoinPayload = {
  __typename?: 'CreateUserApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserApplicationJoin` that was created by this mutation. */
  userApplicationJoin?: Maybe<UserApplicationJoin>;
  /** An edge for our `UserApplicationJoin`. May be used by Relay 1. */
  userApplicationJoinEdge?: Maybe<UserApplicationJoinsEdge>;
};


/** The output of our create `UserApplicationJoin` mutation. */
export type CreateUserApplicationJoinPayloadUserApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};

/** All input for the create `User` mutation. */
export type CreateUserInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `User` to be created by this mutation. */
  user: UserInput;
};

/** All input for the create `UserList` mutation. */
export type CreateUserListInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserList` to be created by this mutation. */
  userList: UserListInput;
};

/** The output of our create `UserList` mutation. */
export type CreateUserListPayload = {
  __typename?: 'CreateUserListPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserList` that was created by this mutation. */
  userList?: Maybe<UserList>;
  /** An edge for our `UserList`. May be used by Relay 1. */
  userListEdge?: Maybe<UserListsEdge>;
};


/** The output of our create `UserList` mutation. */
export type CreateUserListPayloadUserListEdgeArgs = {
  orderBy?: InputMaybe<Array<UserListsOrderBy>>;
};

/** All input for the create `UserOrganisation` mutation. */
export type CreateUserOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `UserOrganisation` to be created by this mutation. */
  userOrganisation: UserOrganisationInput;
};

/** The output of our create `UserOrganisation` mutation. */
export type CreateUserOrganisationPayload = {
  __typename?: 'CreateUserOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** The `UserOrganisation` that was created by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our create `UserOrganisation` mutation. */
export type CreateUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

/** The output of our create `User` mutation. */
export type CreateUserPayload = {
  __typename?: 'CreateUserPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `User` that was created by this mutation. */
  user?: Maybe<User>;
  /** An edge for our `User`. May be used by Relay 1. */
  userEdge?: Maybe<UsersEdge>;
};


/** The output of our create `User` mutation. */
export type CreateUserPayloadUserEdgeArgs = {
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};

/** All input for the create `Verification` mutation. */
export type CreateVerificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The `Verification` to be created by this mutation. */
  verification: VerificationInput;
};

/** The output of our create `Verification` mutation. */
export type CreateVerificationPayload = {
  __typename?: 'CreateVerificationPayload';
  /** Reads a single `Application` that is related to this `Verification`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Verification` that was created by this mutation. */
  verification?: Maybe<Verification>;
  /** An edge for our `Verification`. May be used by Relay 1. */
  verificationEdge?: Maybe<VerificationsEdge>;
};


/** The output of our create `Verification` mutation. */
export type CreateVerificationPayloadVerificationEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

export type DataChangelog = Node & {
  __typename?: 'DataChangelog';
  /** Reads a single `Application` that is related to this `DataChangelog`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  comment?: Maybe<Scalars['String']['output']>;
  dataTable: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  newData?: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  oldData?: Maybe<Scalars['JSON']['output']>;
  /** Reads a single `Organisation` that is related to this `DataChangelog`. */
  org?: Maybe<Organisation>;
  orgId?: Maybe<Scalars['Int']['output']>;
  recordId: Scalars['Int']['output'];
  timestamp?: Maybe<Scalars['Datetime']['output']>;
  updateType: ChangelogType;
  userId?: Maybe<Scalars['Int']['output']>;
  username?: Maybe<Scalars['String']['output']>;
};

/** The `application` to be created by this mutation. */
export type DataChangelogApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `dataChangelog` to be created by this mutation. */
export type DataChangelogApplicationIdFkeyDataChangelogCreateInput = {
  applicationToApplicationId?: InputMaybe<DataChangelogApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  dataTable: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  newData?: InputMaybe<Scalars['JSON']['input']>;
  oldData?: InputMaybe<Scalars['JSON']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<DataChangelogOrgIdFkeyInput>;
  recordId: Scalars['Int']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  updateType: ChangelogType;
  userId?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `application` in the `DataChangelogInput` mutation. */
export type DataChangelogApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataChangelogApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `dataChangelog` in the `ApplicationInput` mutation. */
export type DataChangelogApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `dataChangelog` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataChangelogDataChangelogPkeyConnect>>;
  /** The primary key(s) for `dataChangelog` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataChangelogNodeIdConnect>>;
  /** A `DataChangelogInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataChangelogApplicationIdFkeyDataChangelogCreateInput>>;
  /** The primary key(s) for `dataChangelog` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataChangelogDataChangelogPkeyDelete>>;
  /** The primary key(s) for `dataChangelog` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataChangelogNodeIdDelete>>;
  /** Flag indicating whether all other `dataChangelog` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataChangelog` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyUsingDataChangelogPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataChangelog` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate>>;
};

/**
 * A condition to be used against `DataChangelog` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DataChangelogCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dataTable` field. */
  dataTable?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `newData` field. */
  newData?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `oldData` field. */
  oldData?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `recordId` field. */
  recordId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `updateType` field. */
  updateType?: InputMaybe<ChangelogType>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `dataChangelog` to look up the row to connect. */
export type DataChangelogDataChangelogPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataChangelog` to look up the row to delete. */
export type DataChangelogDataChangelogPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataChangelog` object types. All fields are combined with a logical ‘and.’ */
export type DataChangelogFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataChangelogFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dataTable` field. */
  dataTable?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `newData` field. */
  newData?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataChangelogFilter>;
  /** Filter by the object’s `oldData` field. */
  oldData?: InputMaybe<JsonFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataChangelogFilter>>;
  /** Filter by the object’s `org` relation. */
  org?: InputMaybe<OrganisationFilter>;
  /** A related `org` exists. */
  orgExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `recordId` field. */
  recordId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `updateType` field. */
  updateType?: InputMaybe<ChangelogTypeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataChangelog` */
export type DataChangelogInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataChangelogApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  dataTable: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  newData?: InputMaybe<Scalars['JSON']['input']>;
  oldData?: InputMaybe<Scalars['JSON']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<DataChangelogOrgIdFkeyInput>;
  recordId: Scalars['Int']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  updateType: ChangelogType;
  userId?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataChangelogNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataChangelog` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataChangelogNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataChangelog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `dataChangelog` to look up the row to update. */
export type DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyUsingDataChangelogPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataChangelog` being updated. */
  patch: UpdateDataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `dataChangelog` to look up the row to update. */
export type DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyUsingDataChangelogPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataChangelog` being updated. */
  patch: UpdateDataChangelogOnDataChangelogForDataChangelogOrgIdFkeyPatch;
};

/** The `dataChangelog` to be created by this mutation. */
export type DataChangelogOrgIdFkeyDataChangelogCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataChangelogApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  dataTable: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  newData?: InputMaybe<Scalars['JSON']['input']>;
  oldData?: InputMaybe<Scalars['JSON']['input']>;
  organisationToOrgId?: InputMaybe<DataChangelogOrgIdFkeyInput>;
  recordId: Scalars['Int']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  updateType: ChangelogType;
  userId?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `organisation` in the `DataChangelogInput` mutation. */
export type DataChangelogOrgIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataChangelogOrgIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `dataChangelog` in the `OrganisationInput` mutation. */
export type DataChangelogOrgIdFkeyInverseInput = {
  /** The primary key(s) for `dataChangelog` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataChangelogDataChangelogPkeyConnect>>;
  /** The primary key(s) for `dataChangelog` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataChangelogNodeIdConnect>>;
  /** A `DataChangelogInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataChangelogOrgIdFkeyDataChangelogCreateInput>>;
  /** The primary key(s) for `dataChangelog` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataChangelogDataChangelogPkeyDelete>>;
  /** The primary key(s) for `dataChangelog` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataChangelogNodeIdDelete>>;
  /** Flag indicating whether all other `dataChangelog` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataChangelog` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyUsingDataChangelogPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataChangelog` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type DataChangelogOrgIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** Represents an update to a `DataChangelog`. Fields that are set will be updated. */
export type DataChangelogPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataChangelogApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  dataTable?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  newData?: InputMaybe<Scalars['JSON']['input']>;
  oldData?: InputMaybe<Scalars['JSON']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<DataChangelogOrgIdFkeyInput>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  updateType?: InputMaybe<ChangelogType>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataChangelog` values. */
export type DataChangelogsConnection = {
  __typename?: 'DataChangelogsConnection';
  /** A list of edges which contains the `DataChangelog` and cursor to aid in pagination. */
  edges: Array<DataChangelogsEdge>;
  /** A list of `DataChangelog` objects. */
  nodes: Array<Maybe<DataChangelog>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataChangelog` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataChangelog` edge in the connection. */
export type DataChangelogsEdge = {
  __typename?: 'DataChangelogsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataChangelog` at the end of the edge. */
  node?: Maybe<DataChangelog>;
};

/** Methods to use when ordering `DataChangelog`. */
export enum DataChangelogsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  DataTableAsc = 'DATA_TABLE_ASC',
  DataTableDesc = 'DATA_TABLE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NewDataAsc = 'NEW_DATA_ASC',
  NewDataDesc = 'NEW_DATA_DESC',
  OldDataAsc = 'OLD_DATA_ASC',
  OldDataDesc = 'OLD_DATA_DESC',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecordIdAsc = 'RECORD_ID_ASC',
  RecordIdDesc = 'RECORD_ID_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  UpdateTypeAsc = 'UPDATE_TYPE_ASC',
  UpdateTypeDesc = 'UPDATE_TYPE_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type DataTable = Node & {
  __typename?: 'DataTable';
  dataViewCode?: Maybe<Scalars['String']['output']>;
  displayName?: Maybe<Scalars['String']['output']>;
  fieldMap?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['Int']['output'];
  isLookupTable?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  tableName: Scalars['String']['output'];
};

export type DataTableActiveIngredient = Node & {
  __typename?: 'DataTableActiveIngredient';
  id: Scalars['Int']['output'];
  latina?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `DataTableActiveIngredient` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableActiveIngredientCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `latina` field. */
  latina?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableActiveIngredient` object types. All fields are combined with a logical ‘and.’ */
export type DataTableActiveIngredientFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableActiveIngredientFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `latina` field. */
  latina?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableActiveIngredientFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableActiveIngredientFilter>>;
};

/** An input for mutations affecting `DataTableActiveIngredient` */
export type DataTableActiveIngredientInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  latina?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableActiveIngredient`. Fields that are set will be updated. */
export type DataTableActiveIngredientPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  latina?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableActiveIngredient` values. */
export type DataTableActiveIngredientsConnection = {
  __typename?: 'DataTableActiveIngredientsConnection';
  /** A list of edges which contains the `DataTableActiveIngredient` and cursor to aid in pagination. */
  edges: Array<DataTableActiveIngredientsEdge>;
  /** A list of `DataTableActiveIngredient` objects. */
  nodes: Array<Maybe<DataTableActiveIngredient>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableActiveIngredient` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableActiveIngredient` edge in the connection. */
export type DataTableActiveIngredientsEdge = {
  __typename?: 'DataTableActiveIngredientsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableActiveIngredient` at the end of the edge. */
  node?: Maybe<DataTableActiveIngredient>;
};

/** Methods to use when ordering `DataTableActiveIngredient`. */
export enum DataTableActiveIngredientsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LatinaAsc = 'LATINA_ASC',
  LatinaDesc = 'LATINA_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type DataTableAdministrationRoute = Node & {
  __typename?: 'DataTableAdministrationRoute';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  longDescription?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  shortDescription?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableAdministrationRoute` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableAdministrationRouteCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `longDescription` field. */
  longDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableAdministrationRoute` object types. All fields are combined with a logical ‘and.’ */
export type DataTableAdministrationRouteFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableAdministrationRouteFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `longDescription` field. */
  longDescription?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableAdministrationRouteFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableAdministrationRouteFilter>>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableAdministrationRoute` */
export type DataTableAdministrationRouteInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableAdministrationRoute`. Fields that are set will be updated. */
export type DataTableAdministrationRoutePatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableAdministrationRoute` values. */
export type DataTableAdministrationRoutesConnection = {
  __typename?: 'DataTableAdministrationRoutesConnection';
  /** A list of edges which contains the `DataTableAdministrationRoute` and cursor to aid in pagination. */
  edges: Array<DataTableAdministrationRoutesEdge>;
  /** A list of `DataTableAdministrationRoute` objects. */
  nodes: Array<Maybe<DataTableAdministrationRoute>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableAdministrationRoute` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableAdministrationRoute` edge in the connection. */
export type DataTableAdministrationRoutesEdge = {
  __typename?: 'DataTableAdministrationRoutesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableAdministrationRoute` at the end of the edge. */
  node?: Maybe<DataTableAdministrationRoute>;
};

/** Methods to use when ordering `DataTableAdministrationRoute`. */
export enum DataTableAdministrationRoutesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LongDescriptionAsc = 'LONG_DESCRIPTION_ASC',
  LongDescriptionDesc = 'LONG_DESCRIPTION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC'
}

export type DataTableAtcCode = Node & {
  __typename?: 'DataTableAtcCode';
  atcCode?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  whoAtcId?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableAtcCode` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DataTableAtcCodeCondition = {
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableAtcCode` object types. All fields are combined with a logical ‘and.’ */
export type DataTableAtcCodeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableAtcCodeFilter>>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableAtcCodeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableAtcCodeFilter>>;
  /** Filter by the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableAtcCode` */
export type DataTableAtcCodeInput = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableAtcCode`. Fields that are set will be updated. */
export type DataTableAtcCodePatch = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableAtcCode` values. */
export type DataTableAtcCodesConnection = {
  __typename?: 'DataTableAtcCodesConnection';
  /** A list of edges which contains the `DataTableAtcCode` and cursor to aid in pagination. */
  edges: Array<DataTableAtcCodesEdge>;
  /** A list of `DataTableAtcCode` objects. */
  nodes: Array<Maybe<DataTableAtcCode>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableAtcCode` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableAtcCode` edge in the connection. */
export type DataTableAtcCodesEdge = {
  __typename?: 'DataTableAtcCodesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableAtcCode` at the end of the edge. */
  node?: Maybe<DataTableAtcCode>;
};

/** Methods to use when ordering `DataTableAtcCode`. */
export enum DataTableAtcCodesOrderBy {
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WhoAtcIdAsc = 'WHO_ATC_ID_ASC',
  WhoAtcIdDesc = 'WHO_ATC_ID_DESC'
}

/**
 * A condition to be used against `DataTable` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DataTableCondition = {
  /** Checks for equality with the object’s `dataViewCode` field. */
  dataViewCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `displayName` field. */
  displayName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fieldMap` field. */
  fieldMap?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isLookupTable` field. */
  isLookupTable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['String']['input']>;
};

export type DataTableContainer = Node & {
  __typename?: 'DataTableContainer';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  longDescription?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  shortDescription?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableContainer` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DataTableContainerCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `longDescription` field. */
  longDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableContainer` object types. All fields are combined with a logical ‘and.’ */
export type DataTableContainerFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableContainerFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `longDescription` field. */
  longDescription?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableContainerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableContainerFilter>>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableContainer` */
export type DataTableContainerInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableContainer`. Fields that are set will be updated. */
export type DataTableContainerPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableContainer` values. */
export type DataTableContainersConnection = {
  __typename?: 'DataTableContainersConnection';
  /** A list of edges which contains the `DataTableContainer` and cursor to aid in pagination. */
  edges: Array<DataTableContainersEdge>;
  /** A list of `DataTableContainer` objects. */
  nodes: Array<Maybe<DataTableContainer>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableContainer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableContainer` edge in the connection. */
export type DataTableContainersEdge = {
  __typename?: 'DataTableContainersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableContainer` at the end of the edge. */
  node?: Maybe<DataTableContainer>;
};

/** Methods to use when ordering `DataTableContainer`. */
export enum DataTableContainersOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LongDescriptionAsc = 'LONG_DESCRIPTION_ASC',
  LongDescriptionDesc = 'LONG_DESCRIPTION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC'
}

/** A connection to a list of `DataTableCountry` values. */
export type DataTableCountriesConnection = {
  __typename?: 'DataTableCountriesConnection';
  /** A list of edges which contains the `DataTableCountry` and cursor to aid in pagination. */
  edges: Array<DataTableCountriesEdge>;
  /** A list of `DataTableCountry` objects. */
  nodes: Array<Maybe<DataTableCountry>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableCountry` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableCountry` edge in the connection. */
export type DataTableCountriesEdge = {
  __typename?: 'DataTableCountriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableCountry` at the end of the edge. */
  node?: Maybe<DataTableCountry>;
};

/** Methods to use when ordering `DataTableCountry`. */
export enum DataTableCountriesOrderBy {
  FlagAsc = 'FLAG_ASC',
  FlagDesc = 'FLAG_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameCommonAsc = 'NAME_COMMON_ASC',
  NameCommonDesc = 'NAME_COMMON_DESC',
  NameOfficialAsc = 'NAME_OFFICIAL_ASC',
  NameOfficialDesc = 'NAME_OFFICIAL_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  WhoSraPicsAsc = 'WHO_SRA_PICS_ASC',
  WhoSraPicsDesc = 'WHO_SRA_PICS_DESC'
}

export type DataTableCountry = Node & {
  __typename?: 'DataTableCountry';
  flag?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  nameCommon?: Maybe<Scalars['String']['output']>;
  nameOfficial?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  whoSraPics?: Maybe<Scalars['Boolean']['output']>;
};

/**
 * A condition to be used against `DataTableCountry` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DataTableCountryCondition = {
  /** Checks for equality with the object’s `flag` field. */
  flag?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `nameCommon` field. */
  nameCommon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nameOfficial` field. */
  nameOfficial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `whoSraPics` field. */
  whoSraPics?: InputMaybe<Scalars['Boolean']['input']>;
};

/** A filter to be used against `DataTableCountry` object types. All fields are combined with a logical ‘and.’ */
export type DataTableCountryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableCountryFilter>>;
  /** Filter by the object’s `flag` field. */
  flag?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `nameCommon` field. */
  nameCommon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nameOfficial` field. */
  nameOfficial?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableCountryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableCountryFilter>>;
  /** Filter by the object’s `whoSraPics` field. */
  whoSraPics?: InputMaybe<BooleanFilter>;
};

/** An input for mutations affecting `DataTableCountry` */
export type DataTableCountryInput = {
  flag?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  nameCommon?: InputMaybe<Scalars['String']['input']>;
  nameOfficial?: InputMaybe<Scalars['String']['input']>;
  whoSraPics?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Represents an update to a `DataTableCountry`. Fields that are set will be updated. */
export type DataTableCountryPatch = {
  flag?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  nameCommon?: InputMaybe<Scalars['String']['input']>;
  nameOfficial?: InputMaybe<Scalars['String']['input']>;
  whoSraPics?: InputMaybe<Scalars['Boolean']['input']>;
};

export type DataTableDosageForm = Node & {
  __typename?: 'DataTableDosageForm';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  longDescription?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  shortDescription?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableDosageForm` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type DataTableDosageFormCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `longDescription` field. */
  longDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableDosageForm` object types. All fields are combined with a logical ‘and.’ */
export type DataTableDosageFormFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableDosageFormFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `longDescription` field. */
  longDescription?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableDosageFormFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableDosageFormFilter>>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<StringFilter>;
};

export type DataTableDosageFormGroup = Node & {
  __typename?: 'DataTableDosageFormGroup';
  dosageFormGroups?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `DataTableDosageFormGroup` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableDosageFormGroupCondition = {
  /** Checks for equality with the object’s `dosageFormGroups` field. */
  dosageFormGroups?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `DataTableDosageFormGroup` object types. All fields are combined with a logical ‘and.’ */
export type DataTableDosageFormGroupFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableDosageFormGroupFilter>>;
  /** Filter by the object’s `dosageFormGroups` field. */
  dosageFormGroups?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableDosageFormGroupFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableDosageFormGroupFilter>>;
};

/** An input for mutations affecting `DataTableDosageFormGroup` */
export type DataTableDosageFormGroupInput = {
  dosageFormGroups?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Represents an update to a `DataTableDosageFormGroup`. Fields that are set will be updated. */
export type DataTableDosageFormGroupPatch = {
  dosageFormGroups?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DataTableDosageFormGroup` values. */
export type DataTableDosageFormGroupsConnection = {
  __typename?: 'DataTableDosageFormGroupsConnection';
  /** A list of edges which contains the `DataTableDosageFormGroup` and cursor to aid in pagination. */
  edges: Array<DataTableDosageFormGroupsEdge>;
  /** A list of `DataTableDosageFormGroup` objects. */
  nodes: Array<Maybe<DataTableDosageFormGroup>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableDosageFormGroup` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableDosageFormGroup` edge in the connection. */
export type DataTableDosageFormGroupsEdge = {
  __typename?: 'DataTableDosageFormGroupsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableDosageFormGroup` at the end of the edge. */
  node?: Maybe<DataTableDosageFormGroup>;
};

/** Methods to use when ordering `DataTableDosageFormGroup`. */
export enum DataTableDosageFormGroupsOrderBy {
  DosageFormGroupsAsc = 'DOSAGE_FORM_GROUPS_ASC',
  DosageFormGroupsDesc = 'DOSAGE_FORM_GROUPS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** An input for mutations affecting `DataTableDosageForm` */
export type DataTableDosageFormInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableDosageForm`. Fields that are set will be updated. */
export type DataTableDosageFormPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableDosageForm` values. */
export type DataTableDosageFormsConnection = {
  __typename?: 'DataTableDosageFormsConnection';
  /** A list of edges which contains the `DataTableDosageForm` and cursor to aid in pagination. */
  edges: Array<DataTableDosageFormsEdge>;
  /** A list of `DataTableDosageForm` objects. */
  nodes: Array<Maybe<DataTableDosageForm>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableDosageForm` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableDosageForm` edge in the connection. */
export type DataTableDosageFormsEdge = {
  __typename?: 'DataTableDosageFormsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableDosageForm` at the end of the edge. */
  node?: Maybe<DataTableDosageForm>;
};

/** Methods to use when ordering `DataTableDosageForm`. */
export enum DataTableDosageFormsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LongDescriptionAsc = 'LONG_DESCRIPTION_ASC',
  LongDescriptionDesc = 'LONG_DESCRIPTION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC'
}

/** A filter to be used against `DataTable` object types. All fields are combined with a logical ‘and.’ */
export type DataTableFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableFilter>>;
  /** Filter by the object’s `dataViewCode` field. */
  dataViewCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `displayName` field. */
  displayName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fieldMap` field. */
  fieldMap?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isLookupTable` field. */
  isLookupTable?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableFilter>>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<StringFilter>;
};

export type DataTableGenericIngredient = Node & {
  __typename?: 'DataTableGenericIngredient';
  atcCode?: Maybe<Scalars['String']['output']>;
  category?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  productEn?: Maybe<Scalars['String']['output']>;
  productFr?: Maybe<Scalars['String']['output']>;
  whoAtcId?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableGenericIngredient` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableGenericIngredientCondition = {
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `productEn` field. */
  productEn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `productFr` field. */
  productFr?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableGenericIngredient` object types. All fields are combined with a logical ‘and.’ */
export type DataTableGenericIngredientFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableGenericIngredientFilter>>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableGenericIngredientFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableGenericIngredientFilter>>;
  /** Filter by the object’s `productEn` field. */
  productEn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `productFr` field. */
  productFr?: InputMaybe<StringFilter>;
  /** Filter by the object’s `whoAtcId` field. */
  whoAtcId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableGenericIngredient` */
export type DataTableGenericIngredientInput = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  productEn?: InputMaybe<Scalars['String']['input']>;
  productFr?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableGenericIngredient`. Fields that are set will be updated. */
export type DataTableGenericIngredientPatch = {
  atcCode?: InputMaybe<Scalars['String']['input']>;
  category?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  productEn?: InputMaybe<Scalars['String']['input']>;
  productFr?: InputMaybe<Scalars['String']['input']>;
  whoAtcId?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableGenericIngredient` values. */
export type DataTableGenericIngredientsConnection = {
  __typename?: 'DataTableGenericIngredientsConnection';
  /** A list of edges which contains the `DataTableGenericIngredient` and cursor to aid in pagination. */
  edges: Array<DataTableGenericIngredientsEdge>;
  /** A list of `DataTableGenericIngredient` objects. */
  nodes: Array<Maybe<DataTableGenericIngredient>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableGenericIngredient` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableGenericIngredient` edge in the connection. */
export type DataTableGenericIngredientsEdge = {
  __typename?: 'DataTableGenericIngredientsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableGenericIngredient` at the end of the edge. */
  node?: Maybe<DataTableGenericIngredient>;
};

/** Methods to use when ordering `DataTableGenericIngredient`. */
export enum DataTableGenericIngredientsOrderBy {
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProductEnAsc = 'PRODUCT_EN_ASC',
  ProductEnDesc = 'PRODUCT_EN_DESC',
  ProductFrAsc = 'PRODUCT_FR_ASC',
  ProductFrDesc = 'PRODUCT_FR_DESC',
  WhoAtcIdAsc = 'WHO_ATC_ID_ASC',
  WhoAtcIdDesc = 'WHO_ATC_ID_DESC'
}

/** An input for mutations affecting `DataTable` */
export type DataTableInput = {
  dataViewCode?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  fieldMap?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLookupTable?: InputMaybe<Scalars['Boolean']['input']>;
  tableName: Scalars['String']['input'];
};

export type DataTableManufacturer = Node & {
  __typename?: 'DataTableManufacturer';
  address?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `DataTableManufacturerApplicationJoin`. */
  dataTableManufacturerApplicationJoins: DataTableManufacturerApplicationJoinsConnection;
  id: Scalars['Int']['output'];
  isAdditional?: Maybe<Scalars['Boolean']['output']>;
  manufacturer?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};


export type DataTableManufacturerDataTableManufacturerApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturerApplicationJoinCondition>;
  filter?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturerApplicationJoinsOrderBy>>;
};

/** The `dataTableManufacturerApplicationJoin` to be created by this mutation. */
export type DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInput>;
  dataTableManufacturerToDataTableManufacturerId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The `dataTableManufacturer` to be created by this mutation. */
export type DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdditional?: InputMaybe<Scalars['Boolean']['input']>;
  manufacturer?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `dataTableManufacturer` in the `DataTableManufacturerApplicationJoinInput` mutation. */
export type DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput = {
  /** The primary key(s) for `dataTableManufacturer` for the far side of the relationship. */
  connectById?: InputMaybe<DataTableManufacturerDataTableManufacturerPkeyConnect>;
  /** The primary key(s) for `dataTableManufacturer` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DataTableManufacturerNodeIdConnect>;
  /** A `DataTableManufacturerInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerCreateInput>;
  /** The primary key(s) for `dataTableManufacturer` for the far side of the relationship. */
  deleteById?: InputMaybe<DataTableManufacturerDataTableManufacturerPkeyDelete>;
  /** The primary key(s) for `dataTableManufacturer` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<DataTableManufacturerNodeIdDelete>;
  /** The primary key(s) and patch data for `dataTableManufacturer` for the far side of the relationship. */
  updateById?: InputMaybe<DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerPkeyUpdate>;
  /** The primary key(s) and patch data for `dataTableManufacturer` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `dataTableManufacturerApplicationJoin` in the `DataTableManufacturerInput` mutation. */
export type DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput = {
  /** The primary key(s) for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableManufacturerApplicationJoinNodeIdConnect>>;
  /** A `DataTableManufacturerApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableManufacturerApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableManufacturerApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate>>;
};

export type DataTableManufacturerApplicationJoin = Node & {
  __typename?: 'DataTableManufacturerApplicationJoin';
  /** Reads a single `Application` that is related to this `DataTableManufacturerApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  /** Reads a single `DataTableManufacturer` that is related to this `DataTableManufacturerApplicationJoin`. */
  dataTableManufacturer?: Maybe<DataTableManufacturer>;
  dataTableManufacturerId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** The `application` to be created by this mutation. */
export type DataTableManufacturerApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `dataTableManufacturerApplicationJoin` to be created by this mutation. */
export type DataTableManufacturerApplicationJoinApplicationIdFkeyDataTableManufacturerApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInput>;
  dataTableManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  dataTableManufacturerToDataTableManufacturerId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `application` in the `DataTableManufacturerApplicationJoinInput` mutation. */
export type DataTableManufacturerApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `dataTableManufacturerApplicationJoin` in the `ApplicationInput` mutation. */
export type DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableManufacturerApplicationJoinNodeIdConnect>>;
  /** A `DataTableManufacturerApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableManufacturerApplicationJoinApplicationIdFkeyDataTableManufacturerApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableManufacturerApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableManufacturerApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableManufacturerApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/**
 * A condition to be used against `DataTableManufacturerApplicationJoin` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableManufacturerApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dataTableManufacturerId` field. */
  dataTableManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `dataTableManufacturerApplicationJoin` to look up the row to connect. */
export type DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableManufacturerApplicationJoin` to look up the row to delete. */
export type DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTableManufacturerApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableManufacturerApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableManufacturerApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `dataTableManufacturer` relation. */
  dataTableManufacturer?: InputMaybe<DataTableManufacturerFilter>;
  /** Filter by the object’s `dataTableManufacturerId` field. */
  dataTableManufacturerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableManufacturerApplicationJoinFilter>>;
};

/** An input for mutations affecting `DataTableManufacturerApplicationJoin` */
export type DataTableManufacturerApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInput>;
  dataTableManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  dataTableManufacturerToDataTableManufacturerId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableManufacturerApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableManufacturerApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturer` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturer` being updated. */
  patch: DataTableManufacturerPatch;
};

/** The fields on `dataTableManufacturerApplicationJoin` to look up the row to update. */
export type DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerApplicationJoin` being updated. */
  patch: UpdateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `dataTableManufacturerApplicationJoin` to look up the row to update. */
export type DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerApplicationJoin` being updated. */
  patch: UpdateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch;
};

/** Represents an update to a `DataTableManufacturerApplicationJoin`. Fields that are set will be updated. */
export type DataTableManufacturerApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInput>;
  dataTableManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  dataTableManufacturerToDataTableManufacturerId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DataTableManufacturerApplicationJoin` values. */
export type DataTableManufacturerApplicationJoinsConnection = {
  __typename?: 'DataTableManufacturerApplicationJoinsConnection';
  /** A list of edges which contains the `DataTableManufacturerApplicationJoin` and cursor to aid in pagination. */
  edges: Array<DataTableManufacturerApplicationJoinsEdge>;
  /** A list of `DataTableManufacturerApplicationJoin` objects. */
  nodes: Array<Maybe<DataTableManufacturerApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableManufacturerApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableManufacturerApplicationJoin` edge in the connection. */
export type DataTableManufacturerApplicationJoinsEdge = {
  __typename?: 'DataTableManufacturerApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableManufacturerApplicationJoin` at the end of the edge. */
  node?: Maybe<DataTableManufacturerApplicationJoin>;
};

/** Methods to use when ordering `DataTableManufacturerApplicationJoin`. */
export enum DataTableManufacturerApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataTableManufacturerIdAsc = 'DATA_TABLE_MANUFACTURER_ID_ASC',
  DataTableManufacturerIdDesc = 'DATA_TABLE_MANUFACTURER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `DataTableManufacturer` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type DataTableManufacturerCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isAdditional` field. */
  isAdditional?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `manufacturer` field. */
  manufacturer?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `dataTableManufacturer` to look up the row to connect. */
export type DataTableManufacturerDataTableManufacturerPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableManufacturer` to look up the row to delete. */
export type DataTableManufacturerDataTableManufacturerPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTableManufacturer` object types. All fields are combined with a logical ‘and.’ */
export type DataTableManufacturerFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableManufacturerFilter>>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dataTableManufacturerApplicationJoins` relation. */
  dataTableManufacturerApplicationJoins?: InputMaybe<DataTableManufacturerToManyDataTableManufacturerApplicationJoinFilter>;
  /** Some related `dataTableManufacturerApplicationJoins` exist. */
  dataTableManufacturerApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isAdditional` field. */
  isAdditional?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `manufacturer` field. */
  manufacturer?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableManufacturerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableManufacturerFilter>>;
};

/** An input for mutations affecting `DataTableManufacturer` */
export type DataTableManufacturerInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdditional?: InputMaybe<Scalars['Boolean']['input']>;
  manufacturer?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableManufacturerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturer` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableManufacturerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturer` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerApplicationJoin` being updated. */
  patch: DataTableManufacturerApplicationJoinPatch;
};

/** The fields on `dataTableManufacturer` to look up the row to update. */
export type DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturer` being updated. */
  patch: UpdateDataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch;
};

/** Represents an update to a `DataTableManufacturer`. Fields that are set will be updated. */
export type DataTableManufacturerPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdditional?: InputMaybe<Scalars['Boolean']['input']>;
  manufacturer?: InputMaybe<Scalars['String']['input']>;
};

/** The `dataTableManufacturerRepresentativeApplicationJoin` to be created by this mutation. */
export type DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInput>;
  dataTableManufacturerRepresentativeToDataTableManufacturerRepresentativeId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The `dataTableManufacturerRepresentative` to be created by this mutation. */
export type DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeCreateInput = {
  additionalCertifications?: InputMaybe<Scalars['JSON']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput>;
  evaluationNotes?: InputMaybe<Scalars['String']['input']>;
  gmpByWhoCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpCountry1?: InputMaybe<Scalars['String']['input']>;
  gmpCountry2?: InputMaybe<Scalars['String']['input']>;
  gmpCountry3?: InputMaybe<Scalars['String']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  gmpExpiry1?: InputMaybe<Scalars['Date']['input']>;
  gmpExpiry2?: InputMaybe<Scalars['Date']['input']>;
  gmpExpiry3?: InputMaybe<Scalars['Date']['input']>;
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  letterOfAuthorization?: InputMaybe<Scalars['JSON']['input']>;
  manufacturerDatabaseId?: InputMaybe<Scalars['Int']['input']>;
  manufacturerRegistrationId?: InputMaybe<Scalars['String']['input']>;
  manufacturingCompanies?: InputMaybe<Scalars['JSON']['input']>;
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `dataTableManufacturerRepresentative` in the `DataTableManufacturerRepresentativeApplicationJoinInput` mutation. */
export type DataTableManufacturerRepreDataTableManufacturerReprFkeyInput = {
  /** The primary key(s) for `dataTableManufacturerRepresentative` for the far side of the relationship. */
  connectById?: InputMaybe<DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyConnect>;
  /** The primary key(s) for `dataTableManufacturerRepresentative` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DataTableManufacturerRepresentativeNodeIdConnect>;
  /** A `DataTableManufacturerRepresentativeInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeCreateInput>;
  /** The primary key(s) for `dataTableManufacturerRepresentative` for the far side of the relationship. */
  deleteById?: InputMaybe<DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyDelete>;
  /** The primary key(s) for `dataTableManufacturerRepresentative` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<DataTableManufacturerRepresentativeNodeIdDelete>;
  /** The primary key(s) and patch data for `dataTableManufacturerRepresentative` for the far side of the relationship. */
  updateById?: InputMaybe<DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativePkeyUpdate>;
  /** The primary key(s) and patch data for `dataTableManufacturerRepresentative` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `dataTableManufacturerRepresentativeApplicationJoin` in the `DataTableManufacturerRepresentativeInput` mutation. */
export type DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput = {
  /** The primary key(s) for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinNodeIdConnect>>;
  /** A `DataTableManufacturerRepresentativeApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableManufacturerRepresentativeApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate>>;
};

export type DataTableManufacturerRepresentative = Node & {
  __typename?: 'DataTableManufacturerRepresentative';
  additionalCertifications?: Maybe<Scalars['JSON']['output']>;
  address?: Maybe<Scalars['String']['output']>;
  applicantId?: Maybe<Scalars['Int']['output']>;
  companyId?: Maybe<Scalars['Int']['output']>;
  companyName?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `DataTableManufacturerRepresentativeApplicationJoin`. */
  dataTableManufacturerRepresentativeApplicationJoins: DataTableManufacturerRepresentativeApplicationJoinsConnection;
  evaluationNotes?: Maybe<Scalars['String']['output']>;
  gmpByWhoCertificate?: Maybe<Scalars['JSON']['output']>;
  gmpCertificate?: Maybe<Scalars['JSON']['output']>;
  gmpCountry1?: Maybe<Scalars['String']['output']>;
  gmpCountry2?: Maybe<Scalars['String']['output']>;
  gmpCountry3?: Maybe<Scalars['String']['output']>;
  gmpDetails?: Maybe<Scalars['JSON']['output']>;
  gmpExpiry1?: Maybe<Scalars['Date']['output']>;
  gmpExpiry2?: Maybe<Scalars['Date']['output']>;
  gmpExpiry3?: Maybe<Scalars['Date']['output']>;
  gmpScope?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  letterOfAuthorization?: Maybe<Scalars['JSON']['output']>;
  manufacturerDatabaseId?: Maybe<Scalars['Int']['output']>;
  manufacturerRegistrationId?: Maybe<Scalars['String']['output']>;
  manufacturingCompanies?: Maybe<Scalars['JSON']['output']>;
  manufacturingLicence?: Maybe<Scalars['JSON']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  prequalificationDate?: Maybe<Scalars['Datetime']['output']>;
};


export type DataTableManufacturerRepresentativeDataTableManufacturerRepresentativeApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinCondition>;
  filter?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinsOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type DataTableManufacturerRepresentativeApplApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `dataTableManufacturerRepresentativeApplicationJoin` to be created by this mutation. */
export type DataTableManufacturerRepresentativeApplApplicationIdFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInput>;
  dataTableManufacturerRepresentativeId?: InputMaybe<Scalars['Int']['input']>;
  dataTableManufacturerRepresentativeToDataTableManufacturerRepresentativeId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `application` in the `DataTableManufacturerRepresentativeApplicationJoinInput` mutation. */
export type DataTableManufacturerRepresentativeApplApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `dataTableManufacturerRepresentativeApplicationJoin` in the `ApplicationInput` mutation. */
export type DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinNodeIdConnect>>;
  /** A `DataTableManufacturerRepresentativeApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableManufacturerRepresentativeApplApplicationIdFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableManufacturerRepresentativeApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableManufacturerRepresentativeApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate>>;
};

export type DataTableManufacturerRepresentativeApplicationJoin = Node & {
  __typename?: 'DataTableManufacturerRepresentativeApplicationJoin';
  /** Reads a single `Application` that is related to this `DataTableManufacturerRepresentativeApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  /**
   * Reads a single `DataTableManufacturerRepresentative` that is related to this
   * `DataTableManufacturerRepresentativeApplicationJoin`.
   */
  dataTableManufacturerRepresentative?: Maybe<DataTableManufacturerRepresentative>;
  dataTableManufacturerRepresentativeId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against
 * `DataTableManufacturerRepresentativeApplicationJoin` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type DataTableManufacturerRepresentativeApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dataTableManufacturerRepresentativeId` field. */
  dataTableManufacturerRepresentativeId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `dataTableManufacturerRepresentativeApplicationJoin` to look up the row to connect. */
export type DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableManufacturerRepresentativeApplicationJoin` to look up the row to delete. */
export type DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTableManufacturerRepresentativeApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableManufacturerRepresentativeApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `dataTableManufacturerRepresentative` relation. */
  dataTableManufacturerRepresentative?: InputMaybe<DataTableManufacturerRepresentativeFilter>;
  /** Filter by the object’s `dataTableManufacturerRepresentativeId` field. */
  dataTableManufacturerRepresentativeId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinFilter>>;
};

/** An input for mutations affecting `DataTableManufacturerRepresentativeApplicationJoin` */
export type DataTableManufacturerRepresentativeApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInput>;
  dataTableManufacturerRepresentativeId?: InputMaybe<Scalars['Int']['input']>;
  dataTableManufacturerRepresentativeToDataTableManufacturerRepresentativeId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableManufacturerRepresentativeApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerRepresentativeApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableManufacturerRepresentativeApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerRepresentativeApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerRepresentative` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerRepresentative` being updated. */
  patch: DataTableManufacturerRepresentativePatch;
};

/** The fields on `dataTableManufacturerRepresentativeApplicationJoin` to look up the row to update. */
export type DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerRepresentativeApplicationJoin` being updated. */
  patch: UpdateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `dataTableManufacturerRepresentativeApplicationJoin` to look up the row to update. */
export type DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerRepresentativeApplicationJoin` being updated. */
  patch: UpdateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch;
};

/** Represents an update to a `DataTableManufacturerRepresentativeApplicationJoin`. Fields that are set will be updated. */
export type DataTableManufacturerRepresentativeApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInput>;
  dataTableManufacturerRepresentativeId?: InputMaybe<Scalars['Int']['input']>;
  dataTableManufacturerRepresentativeToDataTableManufacturerRepresentativeId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DataTableManufacturerRepresentativeApplicationJoin` values. */
export type DataTableManufacturerRepresentativeApplicationJoinsConnection = {
  __typename?: 'DataTableManufacturerRepresentativeApplicationJoinsConnection';
  /** A list of edges which contains the `DataTableManufacturerRepresentativeApplicationJoin` and cursor to aid in pagination. */
  edges: Array<DataTableManufacturerRepresentativeApplicationJoinsEdge>;
  /** A list of `DataTableManufacturerRepresentativeApplicationJoin` objects. */
  nodes: Array<Maybe<DataTableManufacturerRepresentativeApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableManufacturerRepresentativeApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableManufacturerRepresentativeApplicationJoin` edge in the connection. */
export type DataTableManufacturerRepresentativeApplicationJoinsEdge = {
  __typename?: 'DataTableManufacturerRepresentativeApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableManufacturerRepresentativeApplicationJoin` at the end of the edge. */
  node?: Maybe<DataTableManufacturerRepresentativeApplicationJoin>;
};

/** Methods to use when ordering `DataTableManufacturerRepresentativeApplicationJoin`. */
export enum DataTableManufacturerRepresentativeApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataTableManufacturerRepresentativeIdAsc = 'DATA_TABLE_MANUFACTURER_REPRESENTATIVE_ID_ASC',
  DataTableManufacturerRepresentativeIdDesc = 'DATA_TABLE_MANUFACTURER_REPRESENTATIVE_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `DataTableManufacturerRepresentative` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableManufacturerRepresentativeCondition = {
  /** Checks for equality with the object’s `additionalCertifications` field. */
  additionalCertifications?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `applicantId` field. */
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `companyName` field. */
  companyName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `evaluationNotes` field. */
  evaluationNotes?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gmpByWhoCertificate` field. */
  gmpByWhoCertificate?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `gmpCertificate` field. */
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `gmpCountry1` field. */
  gmpCountry1?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gmpCountry2` field. */
  gmpCountry2?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gmpCountry3` field. */
  gmpCountry3?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gmpDetails` field. */
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `gmpExpiry1` field. */
  gmpExpiry1?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `gmpExpiry2` field. */
  gmpExpiry2?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `gmpExpiry3` field. */
  gmpExpiry3?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `gmpScope` field. */
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `letterOfAuthorization` field. */
  letterOfAuthorization?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `manufacturerDatabaseId` field. */
  manufacturerDatabaseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `manufacturerRegistrationId` field. */
  manufacturerRegistrationId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `manufacturingCompanies` field. */
  manufacturingCompanies?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `manufacturingLicence` field. */
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prequalificationDate` field. */
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `dataTableManufacturerRepresentative` to look up the row to connect. */
export type DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableManufacturerRepresentative` to look up the row to delete. */
export type DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTableManufacturerRepresentative` object types. All fields are combined with a logical ‘and.’ */
export type DataTableManufacturerRepresentativeFilter = {
  /** Filter by the object’s `additionalCertifications` field. */
  additionalCertifications?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableManufacturerRepresentativeFilter>>;
  /** Filter by the object’s `applicantId` field. */
  applicantId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `companyName` field. */
  companyName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dataTableManufacturerRepresentativeApplicationJoins` relation. */
  dataTableManufacturerRepresentativeApplicationJoins?: InputMaybe<DataTableManufacturerRepresentativeToManyDataTableManufacturerRepresentativeApplicationJoinFilter>;
  /** Some related `dataTableManufacturerRepresentativeApplicationJoins` exist. */
  dataTableManufacturerRepresentativeApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `evaluationNotes` field. */
  evaluationNotes?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gmpByWhoCertificate` field. */
  gmpByWhoCertificate?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `gmpCertificate` field. */
  gmpCertificate?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `gmpCountry1` field. */
  gmpCountry1?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gmpCountry2` field. */
  gmpCountry2?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gmpCountry3` field. */
  gmpCountry3?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gmpDetails` field. */
  gmpDetails?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `gmpExpiry1` field. */
  gmpExpiry1?: InputMaybe<DateFilter>;
  /** Filter by the object’s `gmpExpiry2` field. */
  gmpExpiry2?: InputMaybe<DateFilter>;
  /** Filter by the object’s `gmpExpiry3` field. */
  gmpExpiry3?: InputMaybe<DateFilter>;
  /** Filter by the object’s `gmpScope` field. */
  gmpScope?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `letterOfAuthorization` field. */
  letterOfAuthorization?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `manufacturerDatabaseId` field. */
  manufacturerDatabaseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `manufacturerRegistrationId` field. */
  manufacturerRegistrationId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `manufacturingCompanies` field. */
  manufacturingCompanies?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `manufacturingLicence` field. */
  manufacturingLicence?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableManufacturerRepresentativeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableManufacturerRepresentativeFilter>>;
  /** Filter by the object’s `prequalificationDate` field. */
  prequalificationDate?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `DataTableManufacturerRepresentative` */
export type DataTableManufacturerRepresentativeInput = {
  additionalCertifications?: InputMaybe<Scalars['JSON']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput>;
  evaluationNotes?: InputMaybe<Scalars['String']['input']>;
  gmpByWhoCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpCountry1?: InputMaybe<Scalars['String']['input']>;
  gmpCountry2?: InputMaybe<Scalars['String']['input']>;
  gmpCountry3?: InputMaybe<Scalars['String']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  gmpExpiry1?: InputMaybe<Scalars['Date']['input']>;
  gmpExpiry2?: InputMaybe<Scalars['Date']['input']>;
  gmpExpiry3?: InputMaybe<Scalars['Date']['input']>;
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  letterOfAuthorization?: InputMaybe<Scalars['JSON']['input']>;
  manufacturerDatabaseId?: InputMaybe<Scalars['Int']['input']>;
  manufacturerRegistrationId?: InputMaybe<Scalars['String']['input']>;
  manufacturingCompanies?: InputMaybe<Scalars['JSON']['input']>;
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableManufacturerRepresentativeNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerRepresentative` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableManufacturerRepresentativeNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerRepresentative` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableManufacturerRepresentativeApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerRepresentativeApplicationJoin` being updated. */
  patch: DataTableManufacturerRepresentativeApplicationJoinPatch;
};

/** The fields on `dataTableManufacturerRepresentative` to look up the row to update. */
export type DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableManufacturerRepresentative` being updated. */
  patch: UpdateDataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch;
};

/** Represents an update to a `DataTableManufacturerRepresentative`. Fields that are set will be updated. */
export type DataTableManufacturerRepresentativePatch = {
  additionalCertifications?: InputMaybe<Scalars['JSON']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput>;
  evaluationNotes?: InputMaybe<Scalars['String']['input']>;
  gmpByWhoCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpCountry1?: InputMaybe<Scalars['String']['input']>;
  gmpCountry2?: InputMaybe<Scalars['String']['input']>;
  gmpCountry3?: InputMaybe<Scalars['String']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  gmpExpiry1?: InputMaybe<Scalars['Date']['input']>;
  gmpExpiry2?: InputMaybe<Scalars['Date']['input']>;
  gmpExpiry3?: InputMaybe<Scalars['Date']['input']>;
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  letterOfAuthorization?: InputMaybe<Scalars['JSON']['input']>;
  manufacturerDatabaseId?: InputMaybe<Scalars['Int']['input']>;
  manufacturerRegistrationId?: InputMaybe<Scalars['String']['input']>;
  manufacturingCompanies?: InputMaybe<Scalars['JSON']['input']>;
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `DataTableManufacturerRepresentativeApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableManufacturerRepresentativeToManyDataTableManufacturerRepresentativeApplicationJoinFilter = {
  /** Every related `DataTableManufacturerRepresentativeApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
  /** No related `DataTableManufacturerRepresentativeApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
  /** Some related `DataTableManufacturerRepresentativeApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
};

/** A connection to a list of `DataTableManufacturerRepresentative` values. */
export type DataTableManufacturerRepresentativesConnection = {
  __typename?: 'DataTableManufacturerRepresentativesConnection';
  /** A list of edges which contains the `DataTableManufacturerRepresentative` and cursor to aid in pagination. */
  edges: Array<DataTableManufacturerRepresentativesEdge>;
  /** A list of `DataTableManufacturerRepresentative` objects. */
  nodes: Array<Maybe<DataTableManufacturerRepresentative>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableManufacturerRepresentative` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableManufacturerRepresentative` edge in the connection. */
export type DataTableManufacturerRepresentativesEdge = {
  __typename?: 'DataTableManufacturerRepresentativesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableManufacturerRepresentative` at the end of the edge. */
  node?: Maybe<DataTableManufacturerRepresentative>;
};

/** Methods to use when ordering `DataTableManufacturerRepresentative`. */
export enum DataTableManufacturerRepresentativesOrderBy {
  AdditionalCertificationsAsc = 'ADDITIONAL_CERTIFICATIONS_ASC',
  AdditionalCertificationsDesc = 'ADDITIONAL_CERTIFICATIONS_DESC',
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  ApplicantIdAsc = 'APPLICANT_ID_ASC',
  ApplicantIdDesc = 'APPLICANT_ID_DESC',
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CompanyNameAsc = 'COMPANY_NAME_ASC',
  CompanyNameDesc = 'COMPANY_NAME_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  EvaluationNotesAsc = 'EVALUATION_NOTES_ASC',
  EvaluationNotesDesc = 'EVALUATION_NOTES_DESC',
  GmpByWhoCertificateAsc = 'GMP_BY_WHO_CERTIFICATE_ASC',
  GmpByWhoCertificateDesc = 'GMP_BY_WHO_CERTIFICATE_DESC',
  GmpCertificateAsc = 'GMP_CERTIFICATE_ASC',
  GmpCertificateDesc = 'GMP_CERTIFICATE_DESC',
  GmpCountry_1Asc = 'GMP_COUNTRY_1_ASC',
  GmpCountry_1Desc = 'GMP_COUNTRY_1_DESC',
  GmpCountry_2Asc = 'GMP_COUNTRY_2_ASC',
  GmpCountry_2Desc = 'GMP_COUNTRY_2_DESC',
  GmpCountry_3Asc = 'GMP_COUNTRY_3_ASC',
  GmpCountry_3Desc = 'GMP_COUNTRY_3_DESC',
  GmpDetailsAsc = 'GMP_DETAILS_ASC',
  GmpDetailsDesc = 'GMP_DETAILS_DESC',
  GmpExpiry_1Asc = 'GMP_EXPIRY_1_ASC',
  GmpExpiry_1Desc = 'GMP_EXPIRY_1_DESC',
  GmpExpiry_2Asc = 'GMP_EXPIRY_2_ASC',
  GmpExpiry_2Desc = 'GMP_EXPIRY_2_DESC',
  GmpExpiry_3Asc = 'GMP_EXPIRY_3_ASC',
  GmpExpiry_3Desc = 'GMP_EXPIRY_3_DESC',
  GmpScopeAsc = 'GMP_SCOPE_ASC',
  GmpScopeDesc = 'GMP_SCOPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  LetterOfAuthorizationAsc = 'LETTER_OF_AUTHORIZATION_ASC',
  LetterOfAuthorizationDesc = 'LETTER_OF_AUTHORIZATION_DESC',
  ManufacturerDatabaseIdAsc = 'MANUFACTURER_DATABASE_ID_ASC',
  ManufacturerDatabaseIdDesc = 'MANUFACTURER_DATABASE_ID_DESC',
  ManufacturerRegistrationIdAsc = 'MANUFACTURER_REGISTRATION_ID_ASC',
  ManufacturerRegistrationIdDesc = 'MANUFACTURER_REGISTRATION_ID_DESC',
  ManufacturingCompaniesAsc = 'MANUFACTURING_COMPANIES_ASC',
  ManufacturingCompaniesDesc = 'MANUFACTURING_COMPANIES_DESC',
  ManufacturingLicenceAsc = 'MANUFACTURING_LICENCE_ASC',
  ManufacturingLicenceDesc = 'MANUFACTURING_LICENCE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrequalificationDateAsc = 'PREQUALIFICATION_DATE_ASC',
  PrequalificationDateDesc = 'PREQUALIFICATION_DATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A filter to be used against many `DataTableManufacturerApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableManufacturerToManyDataTableManufacturerApplicationJoinFilter = {
  /** Every related `DataTableManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
  /** No related `DataTableManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
  /** Some related `DataTableManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
};

/** A connection to a list of `DataTableManufacturer` values. */
export type DataTableManufacturersConnection = {
  __typename?: 'DataTableManufacturersConnection';
  /** A list of edges which contains the `DataTableManufacturer` and cursor to aid in pagination. */
  edges: Array<DataTableManufacturersEdge>;
  /** A list of `DataTableManufacturer` objects. */
  nodes: Array<Maybe<DataTableManufacturer>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableManufacturer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableManufacturer` edge in the connection. */
export type DataTableManufacturersEdge = {
  __typename?: 'DataTableManufacturersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableManufacturer` at the end of the edge. */
  node?: Maybe<DataTableManufacturer>;
};

/** Methods to use when ordering `DataTableManufacturer`. */
export enum DataTableManufacturersOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsAdditionalAsc = 'IS_ADDITIONAL_ASC',
  IsAdditionalDesc = 'IS_ADDITIONAL_DESC',
  ManufacturerAsc = 'MANUFACTURER_ASC',
  ManufacturerDesc = 'MANUFACTURER_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** Represents an update to a `DataTable`. Fields that are set will be updated. */
export type DataTablePatch = {
  dataViewCode?: InputMaybe<Scalars['String']['input']>;
  displayName?: InputMaybe<Scalars['String']['input']>;
  fieldMap?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLookupTable?: InputMaybe<Scalars['Boolean']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
};

export type DataTablePermitChemical = Node & {
  __typename?: 'DataTablePermitChemical';
  chemicals?: Maybe<Scalars['JSON']['output']>;
  chemicalsFilterData?: Maybe<Scalars['String']['output']>;
  companyId?: Maybe<Scalars['Int']['output']>;
  companyName?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `DataTablePermitChemicalApplicationJoin`. */
  dataTablePermitChemicalApplicationJoins: DataTablePermitChemicalApplicationJoinsConnection;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  permitNo?: Maybe<Scalars['String']['output']>;
  registrationDate?: Maybe<Scalars['Datetime']['output']>;
};


export type DataTablePermitChemicalDataTablePermitChemicalApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePermitChemicalApplicationJoinCondition>;
  filter?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinsOrderBy>>;
};

/** The `dataTablePermitChemicalApplicationJoin` to be created by this mutation. */
export type DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput>;
  dataTablePermitChemicalToDataTablePermitChemicalId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The `dataTablePermitChemical` to be created by this mutation. */
export type DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalCreateInput = {
  chemicals?: InputMaybe<Scalars['JSON']['input']>;
  chemicalsFilterData?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  permitNo?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `dataTablePermitChemical` in the `DataTablePermitChemicalApplicationJoinInput` mutation. */
export type DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput = {
  /** The primary key(s) for `dataTablePermitChemical` for the far side of the relationship. */
  connectById?: InputMaybe<DataTablePermitChemicalDataTablePermitChemicalPkeyConnect>;
  /** The primary key(s) for `dataTablePermitChemical` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DataTablePermitChemicalNodeIdConnect>;
  /** A `DataTablePermitChemicalInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalCreateInput>;
  /** The primary key(s) for `dataTablePermitChemical` for the far side of the relationship. */
  deleteById?: InputMaybe<DataTablePermitChemicalDataTablePermitChemicalPkeyDelete>;
  /** The primary key(s) for `dataTablePermitChemical` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<DataTablePermitChemicalNodeIdDelete>;
  /** The primary key(s) and patch data for `dataTablePermitChemical` for the far side of the relationship. */
  updateById?: InputMaybe<DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalPkeyUpdate>;
  /** The primary key(s) and patch data for `dataTablePermitChemical` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `dataTablePermitChemicalApplicationJoin` in the `DataTablePermitChemicalInput` mutation. */
export type DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput = {
  /** The primary key(s) for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinNodeIdConnect>>;
  /** A `DataTablePermitChemicalApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTablePermitChemicalApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate>>;
};

export type DataTablePermitChemicalApplicationJoin = Node & {
  __typename?: 'DataTablePermitChemicalApplicationJoin';
  /** Reads a single `Application` that is related to this `DataTablePermitChemicalApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  /** Reads a single `DataTablePermitChemical` that is related to this `DataTablePermitChemicalApplicationJoin`. */
  dataTablePermitChemical?: Maybe<DataTablePermitChemical>;
  dataTablePermitChemicalId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** The `application` to be created by this mutation. */
export type DataTablePermitChemicalApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `dataTablePermitChemicalApplicationJoin` to be created by this mutation. */
export type DataTablePermitChemicalApplicationJoinApplicationIdFkeyDataTablePermitChemicalApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput>;
  dataTablePermitChemicalId?: InputMaybe<Scalars['Int']['input']>;
  dataTablePermitChemicalToDataTablePermitChemicalId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `application` in the `DataTablePermitChemicalApplicationJoinInput` mutation. */
export type DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `dataTablePermitChemicalApplicationJoin` in the `ApplicationInput` mutation. */
export type DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinNodeIdConnect>>;
  /** A `DataTablePermitChemicalApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinApplicationIdFkeyDataTablePermitChemicalApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTablePermitChemicalApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTablePermitChemicalApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/**
 * A condition to be used against `DataTablePermitChemicalApplicationJoin` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTablePermitChemicalApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dataTablePermitChemicalId` field. */
  dataTablePermitChemicalId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `dataTablePermitChemicalApplicationJoin` to look up the row to connect. */
export type DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTablePermitChemicalApplicationJoin` to look up the row to delete. */
export type DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTablePermitChemicalApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTablePermitChemicalApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `dataTablePermitChemical` relation. */
  dataTablePermitChemical?: InputMaybe<DataTablePermitChemicalFilter>;
  /** Filter by the object’s `dataTablePermitChemicalId` field. */
  dataTablePermitChemicalId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinFilter>>;
};

/** An input for mutations affecting `DataTablePermitChemicalApplicationJoin` */
export type DataTablePermitChemicalApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput>;
  dataTablePermitChemicalId?: InputMaybe<Scalars['Int']['input']>;
  dataTablePermitChemicalToDataTablePermitChemicalId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTablePermitChemicalApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTablePermitChemicalApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTablePermitChemicalApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTablePermitChemicalApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTablePermitChemical` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTablePermitChemical` being updated. */
  patch: DataTablePermitChemicalPatch;
};

/** The fields on `dataTablePermitChemicalApplicationJoin` to look up the row to update. */
export type DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTablePermitChemicalApplicationJoin` being updated. */
  patch: UpdateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `dataTablePermitChemicalApplicationJoin` to look up the row to update. */
export type DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTablePermitChemicalApplicationJoin` being updated. */
  patch: UpdateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch;
};

/** Represents an update to a `DataTablePermitChemicalApplicationJoin`. Fields that are set will be updated. */
export type DataTablePermitChemicalApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput>;
  dataTablePermitChemicalId?: InputMaybe<Scalars['Int']['input']>;
  dataTablePermitChemicalToDataTablePermitChemicalId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DataTablePermitChemicalApplicationJoin` values. */
export type DataTablePermitChemicalApplicationJoinsConnection = {
  __typename?: 'DataTablePermitChemicalApplicationJoinsConnection';
  /** A list of edges which contains the `DataTablePermitChemicalApplicationJoin` and cursor to aid in pagination. */
  edges: Array<DataTablePermitChemicalApplicationJoinsEdge>;
  /** A list of `DataTablePermitChemicalApplicationJoin` objects. */
  nodes: Array<Maybe<DataTablePermitChemicalApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTablePermitChemicalApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTablePermitChemicalApplicationJoin` edge in the connection. */
export type DataTablePermitChemicalApplicationJoinsEdge = {
  __typename?: 'DataTablePermitChemicalApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTablePermitChemicalApplicationJoin` at the end of the edge. */
  node?: Maybe<DataTablePermitChemicalApplicationJoin>;
};

/** Methods to use when ordering `DataTablePermitChemicalApplicationJoin`. */
export enum DataTablePermitChemicalApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataTablePermitChemicalIdAsc = 'DATA_TABLE_PERMIT_CHEMICAL_ID_ASC',
  DataTablePermitChemicalIdDesc = 'DATA_TABLE_PERMIT_CHEMICAL_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `DataTablePermitChemical` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTablePermitChemicalCondition = {
  /** Checks for equality with the object’s `chemicals` field. */
  chemicals?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `chemicalsFilterData` field. */
  chemicalsFilterData?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `companyName` field. */
  companyName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permitNo` field. */
  permitNo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `dataTablePermitChemical` to look up the row to connect. */
export type DataTablePermitChemicalDataTablePermitChemicalPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTablePermitChemical` to look up the row to delete. */
export type DataTablePermitChemicalDataTablePermitChemicalPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTablePermitChemical` object types. All fields are combined with a logical ‘and.’ */
export type DataTablePermitChemicalFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTablePermitChemicalFilter>>;
  /** Filter by the object’s `chemicals` field. */
  chemicals?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `chemicalsFilterData` field. */
  chemicalsFilterData?: InputMaybe<StringFilter>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `companyName` field. */
  companyName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dataTablePermitChemicalApplicationJoins` relation. */
  dataTablePermitChemicalApplicationJoins?: InputMaybe<DataTablePermitChemicalToManyDataTablePermitChemicalApplicationJoinFilter>;
  /** Some related `dataTablePermitChemicalApplicationJoins` exist. */
  dataTablePermitChemicalApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTablePermitChemicalFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTablePermitChemicalFilter>>;
  /** Filter by the object’s `permitNo` field. */
  permitNo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `DataTablePermitChemical` */
export type DataTablePermitChemicalInput = {
  chemicals?: InputMaybe<Scalars['JSON']['input']>;
  chemicalsFilterData?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  permitNo?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTablePermitChemicalNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTablePermitChemical` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTablePermitChemicalNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTablePermitChemical` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTablePermitChemicalApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTablePermitChemicalApplicationJoin` being updated. */
  patch: DataTablePermitChemicalApplicationJoinPatch;
};

/** The fields on `dataTablePermitChemical` to look up the row to update. */
export type DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTablePermitChemical` being updated. */
  patch: UpdateDataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch;
};

/** Represents an update to a `DataTablePermitChemical`. Fields that are set will be updated. */
export type DataTablePermitChemicalPatch = {
  chemicals?: InputMaybe<Scalars['JSON']['input']>;
  chemicalsFilterData?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  permitNo?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `DataTablePermitChemicalApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTablePermitChemicalToManyDataTablePermitChemicalApplicationJoinFilter = {
  /** Every related `DataTablePermitChemicalApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
  /** No related `DataTablePermitChemicalApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
  /** Some related `DataTablePermitChemicalApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
};

/** A connection to a list of `DataTablePermitChemical` values. */
export type DataTablePermitChemicalsConnection = {
  __typename?: 'DataTablePermitChemicalsConnection';
  /** A list of edges which contains the `DataTablePermitChemical` and cursor to aid in pagination. */
  edges: Array<DataTablePermitChemicalsEdge>;
  /** A list of `DataTablePermitChemical` objects. */
  nodes: Array<Maybe<DataTablePermitChemical>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTablePermitChemical` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTablePermitChemical` edge in the connection. */
export type DataTablePermitChemicalsEdge = {
  __typename?: 'DataTablePermitChemicalsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTablePermitChemical` at the end of the edge. */
  node?: Maybe<DataTablePermitChemical>;
};

/** Methods to use when ordering `DataTablePermitChemical`. */
export enum DataTablePermitChemicalsOrderBy {
  ChemicalsAsc = 'CHEMICALS_ASC',
  ChemicalsDesc = 'CHEMICALS_DESC',
  ChemicalsFilterDataAsc = 'CHEMICALS_FILTER_DATA_ASC',
  ChemicalsFilterDataDesc = 'CHEMICALS_FILTER_DATA_DESC',
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CompanyNameAsc = 'COMPANY_NAME_ASC',
  CompanyNameDesc = 'COMPANY_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PermitNoAsc = 'PERMIT_NO_ASC',
  PermitNoDesc = 'PERMIT_NO_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RegistrationDateAsc = 'REGISTRATION_DATE_ASC',
  RegistrationDateDesc = 'REGISTRATION_DATE_DESC'
}

export type DataTablePreRegisteredProductsProvisional = Node & {
  __typename?: 'DataTablePreRegisteredProductsProvisional';
  activeIngredients?: Maybe<Scalars['JSON']['output']>;
  activeIngredientsResponse?: Maybe<Scalars['JSON']['output']>;
  authority?: Maybe<Scalars['String']['output']>;
  componentsOriginal?: Maybe<Scalars['JSON']['output']>;
  containerType?: Maybe<Scalars['String']['output']>;
  dosageForm?: Maybe<Scalars['String']['output']>;
  effectiveDate?: Maybe<Scalars['Date']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  indications?: Maybe<Scalars['String']['output']>;
  manufacturers?: Maybe<Scalars['JSON']['output']>;
  manufacturersResponse?: Maybe<Scalars['JSON']['output']>;
  multipleFormulations?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  packSizes?: Maybe<Scalars['JSON']['output']>;
  packSizesResponse?: Maybe<Scalars['JSON']['output']>;
  productIdOriginal?: Maybe<Scalars['String']['output']>;
  productIdUnique?: Maybe<Scalars['String']['output']>;
  productType?: Maybe<Scalars['String']['output']>;
  routeOfAdministration?: Maybe<Scalars['String']['output']>;
  shelfLife?: Maybe<Scalars['String']['output']>;
  sponsorName?: Maybe<Scalars['String']['output']>;
  storageConditions?: Maybe<Scalars['String']['output']>;
  tradeName?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTablePreRegisteredProductsProvisional`
 * object types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTablePreRegisteredProductsProvisionalCondition = {
  /** Checks for equality with the object’s `activeIngredients` field. */
  activeIngredients?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `activeIngredientsResponse` field. */
  activeIngredientsResponse?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `authority` field. */
  authority?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `componentsOriginal` field. */
  componentsOriginal?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `containerType` field. */
  containerType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `effectiveDate` field. */
  effectiveDate?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `fullName` field. */
  fullName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `indications` field. */
  indications?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `manufacturers` field. */
  manufacturers?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `manufacturersResponse` field. */
  manufacturersResponse?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `multipleFormulations` field. */
  multipleFormulations?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `packSizes` field. */
  packSizes?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `packSizesResponse` field. */
  packSizesResponse?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `productIdOriginal` field. */
  productIdOriginal?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `productIdUnique` field. */
  productIdUnique?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `productType` field. */
  productType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `routeOfAdministration` field. */
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shelfLife` field. */
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sponsorName` field. */
  sponsorName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `storageConditions` field. */
  storageConditions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tradeName` field. */
  tradeName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTablePreRegisteredProductsProvisional` object types. All fields are combined with a logical ‘and.’ */
export type DataTablePreRegisteredProductsProvisionalFilter = {
  /** Filter by the object’s `activeIngredients` field. */
  activeIngredients?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `activeIngredientsResponse` field. */
  activeIngredientsResponse?: InputMaybe<JsonFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTablePreRegisteredProductsProvisionalFilter>>;
  /** Filter by the object’s `authority` field. */
  authority?: InputMaybe<StringFilter>;
  /** Filter by the object’s `componentsOriginal` field. */
  componentsOriginal?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `containerType` field. */
  containerType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<StringFilter>;
  /** Filter by the object’s `effectiveDate` field. */
  effectiveDate?: InputMaybe<DateFilter>;
  /** Filter by the object’s `fullName` field. */
  fullName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `indications` field. */
  indications?: InputMaybe<StringFilter>;
  /** Filter by the object’s `manufacturers` field. */
  manufacturers?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `manufacturersResponse` field. */
  manufacturersResponse?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `multipleFormulations` field. */
  multipleFormulations?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTablePreRegisteredProductsProvisionalFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTablePreRegisteredProductsProvisionalFilter>>;
  /** Filter by the object’s `packSizes` field. */
  packSizes?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `packSizesResponse` field. */
  packSizesResponse?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `productIdOriginal` field. */
  productIdOriginal?: InputMaybe<StringFilter>;
  /** Filter by the object’s `productIdUnique` field. */
  productIdUnique?: InputMaybe<StringFilter>;
  /** Filter by the object’s `productType` field. */
  productType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `routeOfAdministration` field. */
  routeOfAdministration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shelfLife` field. */
  shelfLife?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sponsorName` field. */
  sponsorName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `storageConditions` field. */
  storageConditions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tradeName` field. */
  tradeName?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTablePreRegisteredProductsProvisional` */
export type DataTablePreRegisteredProductsProvisionalInput = {
  activeIngredients?: InputMaybe<Scalars['JSON']['input']>;
  activeIngredientsResponse?: InputMaybe<Scalars['JSON']['input']>;
  authority?: InputMaybe<Scalars['String']['input']>;
  componentsOriginal?: InputMaybe<Scalars['JSON']['input']>;
  containerType?: InputMaybe<Scalars['String']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  effectiveDate?: InputMaybe<Scalars['Date']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  indications?: InputMaybe<Scalars['String']['input']>;
  manufacturers?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersResponse?: InputMaybe<Scalars['JSON']['input']>;
  multipleFormulations?: InputMaybe<Scalars['Boolean']['input']>;
  packSizes?: InputMaybe<Scalars['JSON']['input']>;
  packSizesResponse?: InputMaybe<Scalars['JSON']['input']>;
  productIdOriginal?: InputMaybe<Scalars['String']['input']>;
  productIdUnique?: InputMaybe<Scalars['String']['input']>;
  productType?: InputMaybe<Scalars['String']['input']>;
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  sponsorName?: InputMaybe<Scalars['String']['input']>;
  storageConditions?: InputMaybe<Scalars['String']['input']>;
  tradeName?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTablePreRegisteredProductsProvisional`. Fields that are set will be updated. */
export type DataTablePreRegisteredProductsProvisionalPatch = {
  activeIngredients?: InputMaybe<Scalars['JSON']['input']>;
  activeIngredientsResponse?: InputMaybe<Scalars['JSON']['input']>;
  authority?: InputMaybe<Scalars['String']['input']>;
  componentsOriginal?: InputMaybe<Scalars['JSON']['input']>;
  containerType?: InputMaybe<Scalars['String']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  effectiveDate?: InputMaybe<Scalars['Date']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  indications?: InputMaybe<Scalars['String']['input']>;
  manufacturers?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersResponse?: InputMaybe<Scalars['JSON']['input']>;
  multipleFormulations?: InputMaybe<Scalars['Boolean']['input']>;
  packSizes?: InputMaybe<Scalars['JSON']['input']>;
  packSizesResponse?: InputMaybe<Scalars['JSON']['input']>;
  productIdOriginal?: InputMaybe<Scalars['String']['input']>;
  productIdUnique?: InputMaybe<Scalars['String']['input']>;
  productType?: InputMaybe<Scalars['String']['input']>;
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  sponsorName?: InputMaybe<Scalars['String']['input']>;
  storageConditions?: InputMaybe<Scalars['String']['input']>;
  tradeName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTablePreRegisteredProductsProvisional` values. */
export type DataTablePreRegisteredProductsProvisionalsConnection = {
  __typename?: 'DataTablePreRegisteredProductsProvisionalsConnection';
  /** A list of edges which contains the `DataTablePreRegisteredProductsProvisional` and cursor to aid in pagination. */
  edges: Array<DataTablePreRegisteredProductsProvisionalsEdge>;
  /** A list of `DataTablePreRegisteredProductsProvisional` objects. */
  nodes: Array<Maybe<DataTablePreRegisteredProductsProvisional>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTablePreRegisteredProductsProvisional` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTablePreRegisteredProductsProvisional` edge in the connection. */
export type DataTablePreRegisteredProductsProvisionalsEdge = {
  __typename?: 'DataTablePreRegisteredProductsProvisionalsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTablePreRegisteredProductsProvisional` at the end of the edge. */
  node?: Maybe<DataTablePreRegisteredProductsProvisional>;
};

/** Methods to use when ordering `DataTablePreRegisteredProductsProvisional`. */
export enum DataTablePreRegisteredProductsProvisionalsOrderBy {
  ActiveIngredientsAsc = 'ACTIVE_INGREDIENTS_ASC',
  ActiveIngredientsDesc = 'ACTIVE_INGREDIENTS_DESC',
  ActiveIngredientsResponseAsc = 'ACTIVE_INGREDIENTS_RESPONSE_ASC',
  ActiveIngredientsResponseDesc = 'ACTIVE_INGREDIENTS_RESPONSE_DESC',
  AuthorityAsc = 'AUTHORITY_ASC',
  AuthorityDesc = 'AUTHORITY_DESC',
  ComponentsOriginalAsc = 'COMPONENTS_ORIGINAL_ASC',
  ComponentsOriginalDesc = 'COMPONENTS_ORIGINAL_DESC',
  ContainerTypeAsc = 'CONTAINER_TYPE_ASC',
  ContainerTypeDesc = 'CONTAINER_TYPE_DESC',
  DosageFormAsc = 'DOSAGE_FORM_ASC',
  DosageFormDesc = 'DOSAGE_FORM_DESC',
  EffectiveDateAsc = 'EFFECTIVE_DATE_ASC',
  EffectiveDateDesc = 'EFFECTIVE_DATE_DESC',
  FullNameAsc = 'FULL_NAME_ASC',
  FullNameDesc = 'FULL_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IndicationsAsc = 'INDICATIONS_ASC',
  IndicationsDesc = 'INDICATIONS_DESC',
  ManufacturersAsc = 'MANUFACTURERS_ASC',
  ManufacturersDesc = 'MANUFACTURERS_DESC',
  ManufacturersResponseAsc = 'MANUFACTURERS_RESPONSE_ASC',
  ManufacturersResponseDesc = 'MANUFACTURERS_RESPONSE_DESC',
  MultipleFormulationsAsc = 'MULTIPLE_FORMULATIONS_ASC',
  MultipleFormulationsDesc = 'MULTIPLE_FORMULATIONS_DESC',
  Natural = 'NATURAL',
  PackSizesAsc = 'PACK_SIZES_ASC',
  PackSizesDesc = 'PACK_SIZES_DESC',
  PackSizesResponseAsc = 'PACK_SIZES_RESPONSE_ASC',
  PackSizesResponseDesc = 'PACK_SIZES_RESPONSE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProductIdOriginalAsc = 'PRODUCT_ID_ORIGINAL_ASC',
  ProductIdOriginalDesc = 'PRODUCT_ID_ORIGINAL_DESC',
  ProductIdUniqueAsc = 'PRODUCT_ID_UNIQUE_ASC',
  ProductIdUniqueDesc = 'PRODUCT_ID_UNIQUE_DESC',
  ProductTypeAsc = 'PRODUCT_TYPE_ASC',
  ProductTypeDesc = 'PRODUCT_TYPE_DESC',
  RouteOfAdministrationAsc = 'ROUTE_OF_ADMINISTRATION_ASC',
  RouteOfAdministrationDesc = 'ROUTE_OF_ADMINISTRATION_DESC',
  ShelfLifeAsc = 'SHELF_LIFE_ASC',
  ShelfLifeDesc = 'SHELF_LIFE_DESC',
  SponsorNameAsc = 'SPONSOR_NAME_ASC',
  SponsorNameDesc = 'SPONSOR_NAME_DESC',
  StorageConditionsAsc = 'STORAGE_CONDITIONS_ASC',
  StorageConditionsDesc = 'STORAGE_CONDITIONS_DESC',
  TradeNameAsc = 'TRADE_NAME_ASC',
  TradeNameDesc = 'TRADE_NAME_DESC'
}

/** The `dataTablePrequalManufacturerApplicationJoin` to be created by this mutation. */
export type DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInput>;
  dataTablePrequalManufacturerToDataTablePrequalManufacturerId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The `dataTablePrequalManufacturer` to be created by this mutation. */
export type DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput>;
  dateIssued?: InputMaybe<Scalars['String']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lookupId?: InputMaybe<Scalars['Int']['input']>;
  manufacturerId?: InputMaybe<Scalars['String']['input']>;
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permitNo?: InputMaybe<Scalars['String']['input']>;
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `dataTablePrequalManufacturer` in the `DataTablePrequalManufacturerApplicationJoinInput` mutation. */
export type DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput = {
  /** The primary key(s) for `dataTablePrequalManufacturer` for the far side of the relationship. */
  connectById?: InputMaybe<DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyConnect>;
  /** The primary key(s) for `dataTablePrequalManufacturer` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DataTablePrequalManufacturerNodeIdConnect>;
  /** A `DataTablePrequalManufacturerInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerCreateInput>;
  /** The primary key(s) for `dataTablePrequalManufacturer` for the far side of the relationship. */
  deleteById?: InputMaybe<DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyDelete>;
  /** The primary key(s) for `dataTablePrequalManufacturer` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<DataTablePrequalManufacturerNodeIdDelete>;
  /** The primary key(s) and patch data for `dataTablePrequalManufacturer` for the far side of the relationship. */
  updateById?: InputMaybe<DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerPkeyUpdate>;
  /** The primary key(s) and patch data for `dataTablePrequalManufacturer` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `dataTablePrequalManufacturerApplicationJoin` in the `DataTablePrequalManufacturerInput` mutation. */
export type DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput = {
  /** The primary key(s) for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinNodeIdConnect>>;
  /** A `DataTablePrequalManufacturerApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTablePrequalManufacturerApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate>>;
};

export type DataTablePrequalManufacturer = Node & {
  __typename?: 'DataTablePrequalManufacturer';
  address?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `DataTablePrequalManufacturerApplicationJoin`. */
  dataTablePrequalManufacturerApplicationJoins: DataTablePrequalManufacturerApplicationJoinsConnection;
  dateIssued?: Maybe<Scalars['String']['output']>;
  gmpDetails?: Maybe<Scalars['JSON']['output']>;
  gmpScope?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  lookupId?: Maybe<Scalars['Int']['output']>;
  manufacturerId?: Maybe<Scalars['String']['output']>;
  manufacturingLicence?: Maybe<Scalars['JSON']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  permitNo?: Maybe<Scalars['String']['output']>;
  prequalificationDate?: Maybe<Scalars['Datetime']['output']>;
};


export type DataTablePrequalManufacturerDataTablePrequalManufacturerApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePrequalManufacturerApplicationJoinCondition>;
  filter?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinsOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type DataTablePrequalManufacturerApplicationApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `dataTablePrequalManufacturerApplicationJoin` to be created by this mutation. */
export type DataTablePrequalManufacturerApplicationApplicationIdFkeyDataTablePrequalManufacturerApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInput>;
  dataTablePrequalManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  dataTablePrequalManufacturerToDataTablePrequalManufacturerId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `application` in the `DataTablePrequalManufacturerApplicationJoinInput` mutation. */
export type DataTablePrequalManufacturerApplicationApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `dataTablePrequalManufacturerApplicationJoin` in the `ApplicationInput` mutation. */
export type DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinNodeIdConnect>>;
  /** A `DataTablePrequalManufacturerApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTablePrequalManufacturerApplicationApplicationIdFkeyDataTablePrequalManufacturerApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTablePrequalManufacturerApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTablePrequalManufacturerApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate>>;
};

export type DataTablePrequalManufacturerApplicationJoin = Node & {
  __typename?: 'DataTablePrequalManufacturerApplicationJoin';
  /** Reads a single `Application` that is related to this `DataTablePrequalManufacturerApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  /** Reads a single `DataTablePrequalManufacturer` that is related to this `DataTablePrequalManufacturerApplicationJoin`. */
  dataTablePrequalManufacturer?: Maybe<DataTablePrequalManufacturer>;
  dataTablePrequalManufacturerId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `DataTablePrequalManufacturerApplicationJoin`
 * object types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTablePrequalManufacturerApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dataTablePrequalManufacturerId` field. */
  dataTablePrequalManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `dataTablePrequalManufacturerApplicationJoin` to look up the row to connect. */
export type DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTablePrequalManufacturerApplicationJoin` to look up the row to delete. */
export type DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTablePrequalManufacturerApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTablePrequalManufacturerApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `dataTablePrequalManufacturer` relation. */
  dataTablePrequalManufacturer?: InputMaybe<DataTablePrequalManufacturerFilter>;
  /** Filter by the object’s `dataTablePrequalManufacturerId` field. */
  dataTablePrequalManufacturerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinFilter>>;
};

/** An input for mutations affecting `DataTablePrequalManufacturerApplicationJoin` */
export type DataTablePrequalManufacturerApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInput>;
  dataTablePrequalManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  dataTablePrequalManufacturerToDataTablePrequalManufacturerId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTablePrequalManufacturerApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTablePrequalManufacturerApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTablePrequalManufacturerApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTablePrequalManufacturerApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTablePrequalManufacturer` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTablePrequalManufacturer` being updated. */
  patch: DataTablePrequalManufacturerPatch;
};

/** The fields on `dataTablePrequalManufacturerApplicationJoin` to look up the row to update. */
export type DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTablePrequalManufacturerApplicationJoin` being updated. */
  patch: UpdateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `dataTablePrequalManufacturerApplicationJoin` to look up the row to update. */
export type DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTablePrequalManufacturerApplicationJoin` being updated. */
  patch: UpdateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch;
};

/** Represents an update to a `DataTablePrequalManufacturerApplicationJoin`. Fields that are set will be updated. */
export type DataTablePrequalManufacturerApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInput>;
  dataTablePrequalManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  dataTablePrequalManufacturerToDataTablePrequalManufacturerId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DataTablePrequalManufacturerApplicationJoin` values. */
export type DataTablePrequalManufacturerApplicationJoinsConnection = {
  __typename?: 'DataTablePrequalManufacturerApplicationJoinsConnection';
  /** A list of edges which contains the `DataTablePrequalManufacturerApplicationJoin` and cursor to aid in pagination. */
  edges: Array<DataTablePrequalManufacturerApplicationJoinsEdge>;
  /** A list of `DataTablePrequalManufacturerApplicationJoin` objects. */
  nodes: Array<Maybe<DataTablePrequalManufacturerApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTablePrequalManufacturerApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTablePrequalManufacturerApplicationJoin` edge in the connection. */
export type DataTablePrequalManufacturerApplicationJoinsEdge = {
  __typename?: 'DataTablePrequalManufacturerApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTablePrequalManufacturerApplicationJoin` at the end of the edge. */
  node?: Maybe<DataTablePrequalManufacturerApplicationJoin>;
};

/** Methods to use when ordering `DataTablePrequalManufacturerApplicationJoin`. */
export enum DataTablePrequalManufacturerApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataTablePrequalManufacturerIdAsc = 'DATA_TABLE_PREQUAL_MANUFACTURER_ID_ASC',
  DataTablePrequalManufacturerIdDesc = 'DATA_TABLE_PREQUAL_MANUFACTURER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `DataTablePrequalManufacturer` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTablePrequalManufacturerCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dateIssued` field. */
  dateIssued?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gmpDetails` field. */
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `gmpScope` field. */
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `lookupId` field. */
  lookupId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `manufacturerId` field. */
  manufacturerId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `manufacturingLicence` field. */
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permitNo` field. */
  permitNo?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prequalificationDate` field. */
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `dataTablePrequalManufacturer` to look up the row to connect. */
export type DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTablePrequalManufacturer` to look up the row to delete. */
export type DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTablePrequalManufacturer` object types. All fields are combined with a logical ‘and.’ */
export type DataTablePrequalManufacturerFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTablePrequalManufacturerFilter>>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dataTablePrequalManufacturerApplicationJoins` relation. */
  dataTablePrequalManufacturerApplicationJoins?: InputMaybe<DataTablePrequalManufacturerToManyDataTablePrequalManufacturerApplicationJoinFilter>;
  /** Some related `dataTablePrequalManufacturerApplicationJoins` exist. */
  dataTablePrequalManufacturerApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dateIssued` field. */
  dateIssued?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gmpDetails` field. */
  gmpDetails?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `gmpScope` field. */
  gmpScope?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lookupId` field. */
  lookupId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `manufacturerId` field. */
  manufacturerId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `manufacturingLicence` field. */
  manufacturingLicence?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTablePrequalManufacturerFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTablePrequalManufacturerFilter>>;
  /** Filter by the object’s `permitNo` field. */
  permitNo?: InputMaybe<StringFilter>;
  /** Filter by the object’s `prequalificationDate` field. */
  prequalificationDate?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `DataTablePrequalManufacturer` */
export type DataTablePrequalManufacturerInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput>;
  dateIssued?: InputMaybe<Scalars['String']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lookupId?: InputMaybe<Scalars['Int']['input']>;
  manufacturerId?: InputMaybe<Scalars['String']['input']>;
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permitNo?: InputMaybe<Scalars['String']['input']>;
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTablePrequalManufacturerNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTablePrequalManufacturer` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTablePrequalManufacturerNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTablePrequalManufacturer` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTablePrequalManufacturerApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTablePrequalManufacturerApplicationJoin` being updated. */
  patch: DataTablePrequalManufacturerApplicationJoinPatch;
};

/** The fields on `dataTablePrequalManufacturer` to look up the row to update. */
export type DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTablePrequalManufacturer` being updated. */
  patch: UpdateDataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch;
};

/** Represents an update to a `DataTablePrequalManufacturer`. Fields that are set will be updated. */
export type DataTablePrequalManufacturerPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput>;
  dateIssued?: InputMaybe<Scalars['String']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lookupId?: InputMaybe<Scalars['Int']['input']>;
  manufacturerId?: InputMaybe<Scalars['String']['input']>;
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permitNo?: InputMaybe<Scalars['String']['input']>;
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `DataTablePrequalManufacturerApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTablePrequalManufacturerToManyDataTablePrequalManufacturerApplicationJoinFilter = {
  /** Every related `DataTablePrequalManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
  /** No related `DataTablePrequalManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
  /** Some related `DataTablePrequalManufacturerApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
};

/** A connection to a list of `DataTablePrequalManufacturer` values. */
export type DataTablePrequalManufacturersConnection = {
  __typename?: 'DataTablePrequalManufacturersConnection';
  /** A list of edges which contains the `DataTablePrequalManufacturer` and cursor to aid in pagination. */
  edges: Array<DataTablePrequalManufacturersEdge>;
  /** A list of `DataTablePrequalManufacturer` objects. */
  nodes: Array<Maybe<DataTablePrequalManufacturer>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTablePrequalManufacturer` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTablePrequalManufacturer` edge in the connection. */
export type DataTablePrequalManufacturersEdge = {
  __typename?: 'DataTablePrequalManufacturersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTablePrequalManufacturer` at the end of the edge. */
  node?: Maybe<DataTablePrequalManufacturer>;
};

/** Methods to use when ordering `DataTablePrequalManufacturer`. */
export enum DataTablePrequalManufacturersOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  DateIssuedAsc = 'DATE_ISSUED_ASC',
  DateIssuedDesc = 'DATE_ISSUED_DESC',
  GmpDetailsAsc = 'GMP_DETAILS_ASC',
  GmpDetailsDesc = 'GMP_DETAILS_DESC',
  GmpScopeAsc = 'GMP_SCOPE_ASC',
  GmpScopeDesc = 'GMP_SCOPE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  LookupIdAsc = 'LOOKUP_ID_ASC',
  LookupIdDesc = 'LOOKUP_ID_DESC',
  ManufacturerIdAsc = 'MANUFACTURER_ID_ASC',
  ManufacturerIdDesc = 'MANUFACTURER_ID_DESC',
  ManufacturingLicenceAsc = 'MANUFACTURING_LICENCE_ASC',
  ManufacturingLicenceDesc = 'MANUFACTURING_LICENCE_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PermitNoAsc = 'PERMIT_NO_ASC',
  PermitNoDesc = 'PERMIT_NO_DESC',
  PrequalificationDateAsc = 'PREQUALIFICATION_DATE_ASC',
  PrequalificationDateDesc = 'PREQUALIFICATION_DATE_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type DataTableProcessingStep = Node & {
  __typename?: 'DataTableProcessingStep';
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  processingStep?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableProcessingStep` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableProcessingStepCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `processingStep` field. */
  processingStep?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableProcessingStep` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProcessingStepFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProcessingStepFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProcessingStepFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProcessingStepFilter>>;
  /** Filter by the object’s `processingStep` field. */
  processingStep?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableProcessingStep` */
export type DataTableProcessingStepInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  processingStep?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableProcessingStep`. Fields that are set will be updated. */
export type DataTableProcessingStepPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  processingStep?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableProcessingStep` values. */
export type DataTableProcessingStepsConnection = {
  __typename?: 'DataTableProcessingStepsConnection';
  /** A list of edges which contains the `DataTableProcessingStep` and cursor to aid in pagination. */
  edges: Array<DataTableProcessingStepsEdge>;
  /** A list of `DataTableProcessingStep` objects. */
  nodes: Array<Maybe<DataTableProcessingStep>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProcessingStep` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProcessingStep` edge in the connection. */
export type DataTableProcessingStepsEdge = {
  __typename?: 'DataTableProcessingStepsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProcessingStep` at the end of the edge. */
  node?: Maybe<DataTableProcessingStep>;
};

/** Methods to use when ordering `DataTableProcessingStep`. */
export enum DataTableProcessingStepsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProcessingStepAsc = 'PROCESSING_STEP_ASC',
  ProcessingStepDesc = 'PROCESSING_STEP_DESC'
}

export type DataTableProduct = Node & {
  __typename?: 'DataTableProduct';
  activeIngredientsManufacturers?: Maybe<Scalars['String']['output']>;
  activeSubstances?: Maybe<Scalars['JSON']['output']>;
  administrationUnit?: Maybe<Scalars['String']['output']>;
  atcCategory?: Maybe<Scalars['String']['output']>;
  atcCode?: Maybe<Scalars['String']['output']>;
  companyAddress?: Maybe<Scalars['String']['output']>;
  companyId?: Maybe<Scalars['Int']['output']>;
  companyName?: Maybe<Scalars['String']['output']>;
  companyPhone?: Maybe<Scalars['String']['output']>;
  componentFormulation?: Maybe<Scalars['String']['output']>;
  dosageForm?: Maybe<Scalars['String']['output']>;
  dosageFormDescription?: Maybe<Scalars['String']['output']>;
  expiryDate?: Maybe<Scalars['Datetime']['output']>;
  finishedProductManufacturers?: Maybe<Scalars['String']['output']>;
  formulations?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  importerAddress?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  nationalMedicalClassification?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  packagingDescription?: Maybe<Scalars['String']['output']>;
  packagingSizes?: Maybe<Scalars['JSON']['output']>;
  primaryContainer?: Maybe<Scalars['String']['output']>;
  productOrigin?: Maybe<Scalars['String']['output']>;
  proposedIndications?: Maybe<Scalars['String']['output']>;
  registrationDate?: Maybe<Scalars['Datetime']['output']>;
  registrationSerial?: Maybe<Scalars['String']['output']>;
  routeOfAdministration?: Maybe<Scalars['String']['output']>;
  shelfLife?: Maybe<Scalars['String']['output']>;
  sra?: Maybe<Scalars['String']['output']>;
  storageTemperature?: Maybe<Scalars['String']['output']>;
};

export type DataTableProductApplicationJoin = Node & {
  __typename?: 'DataTableProductApplicationJoin';
  /** Reads a single `Application` that is related to this `DataTableProductApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  dataTableProductId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/** The `application` to be created by this mutation. */
export type DataTableProductApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `dataTableProductApplicationJoin` to be created by this mutation. */
export type DataTableProductApplicationJoinApplicationIdFkeyDataTableProductApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `application` in the `DataTableProductApplicationJoinInput` mutation. */
export type DataTableProductApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `dataTableProductApplicationJoin` in the `ApplicationInput` mutation. */
export type DataTableProductApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableProductApplicationJoinNodeIdConnect>>;
  /** A `DataTableProductApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableProductApplicationJoinApplicationIdFkeyDataTableProductApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableProductApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableProductApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableProductApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableProductApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableProductApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/**
 * A condition to be used against `DataTableProductApplicationJoin` object types.
 * All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableProductApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dataTableProductId` field. */
  dataTableProductId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `dataTableProductApplicationJoin` to look up the row to connect. */
export type DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableProductApplicationJoin` to look up the row to delete. */
export type DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTableProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProductApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProductApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `dataTableProductId` field. */
  dataTableProductId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProductApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProductApplicationJoinFilter>>;
};

/** An input for mutations affecting `DataTableProductApplicationJoin` */
export type DataTableProductApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductId: Scalars['Int']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableProductApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableProductApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableProductApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableProductApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `dataTableProductApplicationJoin` to look up the row to update. */
export type DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
  patch: UpdateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
};

/** Represents an update to a `DataTableProductApplicationJoin`. Fields that are set will be updated. */
export type DataTableProductApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DataTableProductApplicationJoin` values. */
export type DataTableProductApplicationJoinsConnection = {
  __typename?: 'DataTableProductApplicationJoinsConnection';
  /** A list of edges which contains the `DataTableProductApplicationJoin` and cursor to aid in pagination. */
  edges: Array<DataTableProductApplicationJoinsEdge>;
  /** A list of `DataTableProductApplicationJoin` objects. */
  nodes: Array<Maybe<DataTableProductApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProductApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProductApplicationJoin` edge in the connection. */
export type DataTableProductApplicationJoinsEdge = {
  __typename?: 'DataTableProductApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProductApplicationJoin` at the end of the edge. */
  node?: Maybe<DataTableProductApplicationJoin>;
};

/** Methods to use when ordering `DataTableProductApplicationJoin`. */
export enum DataTableProductApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataTableProductIdAsc = 'DATA_TABLE_PRODUCT_ID_ASC',
  DataTableProductIdDesc = 'DATA_TABLE_PRODUCT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `DataTableProduct` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type DataTableProductCondition = {
  /** Checks for equality with the object’s `activeIngredientsManufacturers` field. */
  activeIngredientsManufacturers?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `activeSubstances` field. */
  activeSubstances?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `administrationUnit` field. */
  administrationUnit?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `atcCategory` field. */
  atcCategory?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `companyAddress` field. */
  companyAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `companyName` field. */
  companyName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `companyPhone` field. */
  companyPhone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `componentFormulation` field. */
  componentFormulation?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dosageFormDescription` field. */
  dosageFormDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expiryDate` field. */
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `finishedProductManufacturers` field. */
  finishedProductManufacturers?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `formulations` field. */
  formulations?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `importerAddress` field. */
  importerAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `nationalMedicalClassification` field. */
  nationalMedicalClassification?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `packagingDescription` field. */
  packagingDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `packagingSizes` field. */
  packagingSizes?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `primaryContainer` field. */
  primaryContainer?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `productOrigin` field. */
  productOrigin?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `proposedIndications` field. */
  proposedIndications?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `registrationSerial` field. */
  registrationSerial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `routeOfAdministration` field. */
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shelfLife` field. */
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sra` field. */
  sra?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `storageTemperature` field. */
  storageTemperature?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableProduct` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProductFilter = {
  /** Filter by the object’s `activeIngredientsManufacturers` field. */
  activeIngredientsManufacturers?: InputMaybe<StringFilter>;
  /** Filter by the object’s `activeSubstances` field. */
  activeSubstances?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `administrationUnit` field. */
  administrationUnit?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProductFilter>>;
  /** Filter by the object’s `atcCategory` field. */
  atcCategory?: InputMaybe<StringFilter>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `companyAddress` field. */
  companyAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `companyName` field. */
  companyName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `companyPhone` field. */
  companyPhone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `componentFormulation` field. */
  componentFormulation?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dosageFormDescription` field. */
  dosageFormDescription?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expiryDate` field. */
  expiryDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `finishedProductManufacturers` field. */
  finishedProductManufacturers?: InputMaybe<StringFilter>;
  /** Filter by the object’s `formulations` field. */
  formulations?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `importerAddress` field. */
  importerAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Filter by the object’s `nationalMedicalClassification` field. */
  nationalMedicalClassification?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProductFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProductFilter>>;
  /** Filter by the object’s `packagingDescription` field. */
  packagingDescription?: InputMaybe<StringFilter>;
  /** Filter by the object’s `packagingSizes` field. */
  packagingSizes?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `primaryContainer` field. */
  primaryContainer?: InputMaybe<StringFilter>;
  /** Filter by the object’s `productOrigin` field. */
  productOrigin?: InputMaybe<StringFilter>;
  /** Filter by the object’s `proposedIndications` field. */
  proposedIndications?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `registrationSerial` field. */
  registrationSerial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `routeOfAdministration` field. */
  routeOfAdministration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shelfLife` field. */
  shelfLife?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sra` field. */
  sra?: InputMaybe<StringFilter>;
  /** Filter by the object’s `storageTemperature` field. */
  storageTemperature?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableProduct` */
export type DataTableProductInput = {
  activeIngredientsManufacturers?: InputMaybe<Scalars['String']['input']>;
  activeSubstances?: InputMaybe<Scalars['JSON']['input']>;
  administrationUnit?: InputMaybe<Scalars['String']['input']>;
  atcCategory?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['String']['input']>;
  companyAddress?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  companyPhone?: InputMaybe<Scalars['String']['input']>;
  componentFormulation?: InputMaybe<Scalars['String']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  dosageFormDescription?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  finishedProductManufacturers?: InputMaybe<Scalars['String']['input']>;
  formulations?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  importerAddress?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nationalMedicalClassification?: InputMaybe<Scalars['String']['input']>;
  packagingDescription?: InputMaybe<Scalars['String']['input']>;
  packagingSizes?: InputMaybe<Scalars['JSON']['input']>;
  primaryContainer?: InputMaybe<Scalars['String']['input']>;
  productOrigin?: InputMaybe<Scalars['String']['input']>;
  proposedIndications?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationSerial?: InputMaybe<Scalars['String']['input']>;
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  sra?: InputMaybe<Scalars['String']['input']>;
  storageTemperature?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableProduct`. Fields that are set will be updated. */
export type DataTableProductPatch = {
  activeIngredientsManufacturers?: InputMaybe<Scalars['String']['input']>;
  activeSubstances?: InputMaybe<Scalars['JSON']['input']>;
  administrationUnit?: InputMaybe<Scalars['String']['input']>;
  atcCategory?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['String']['input']>;
  companyAddress?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  companyPhone?: InputMaybe<Scalars['String']['input']>;
  componentFormulation?: InputMaybe<Scalars['String']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  dosageFormDescription?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  finishedProductManufacturers?: InputMaybe<Scalars['String']['input']>;
  formulations?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  importerAddress?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nationalMedicalClassification?: InputMaybe<Scalars['String']['input']>;
  packagingDescription?: InputMaybe<Scalars['String']['input']>;
  packagingSizes?: InputMaybe<Scalars['JSON']['input']>;
  primaryContainer?: InputMaybe<Scalars['String']['input']>;
  productOrigin?: InputMaybe<Scalars['String']['input']>;
  proposedIndications?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationSerial?: InputMaybe<Scalars['String']['input']>;
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  sra?: InputMaybe<Scalars['String']['input']>;
  storageTemperature?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableProduct` values. */
export type DataTableProductsConnection = {
  __typename?: 'DataTableProductsConnection';
  /** A list of edges which contains the `DataTableProduct` and cursor to aid in pagination. */
  edges: Array<DataTableProductsEdge>;
  /** A list of `DataTableProduct` objects. */
  nodes: Array<Maybe<DataTableProduct>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProduct` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProduct` edge in the connection. */
export type DataTableProductsEdge = {
  __typename?: 'DataTableProductsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProduct` at the end of the edge. */
  node?: Maybe<DataTableProduct>;
};

/** Methods to use when ordering `DataTableProduct`. */
export enum DataTableProductsOrderBy {
  ActiveIngredientsManufacturersAsc = 'ACTIVE_INGREDIENTS_MANUFACTURERS_ASC',
  ActiveIngredientsManufacturersDesc = 'ACTIVE_INGREDIENTS_MANUFACTURERS_DESC',
  ActiveSubstancesAsc = 'ACTIVE_SUBSTANCES_ASC',
  ActiveSubstancesDesc = 'ACTIVE_SUBSTANCES_DESC',
  AdministrationUnitAsc = 'ADMINISTRATION_UNIT_ASC',
  AdministrationUnitDesc = 'ADMINISTRATION_UNIT_DESC',
  AtcCategoryAsc = 'ATC_CATEGORY_ASC',
  AtcCategoryDesc = 'ATC_CATEGORY_DESC',
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CompanyAddressAsc = 'COMPANY_ADDRESS_ASC',
  CompanyAddressDesc = 'COMPANY_ADDRESS_DESC',
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CompanyNameAsc = 'COMPANY_NAME_ASC',
  CompanyNameDesc = 'COMPANY_NAME_DESC',
  CompanyPhoneAsc = 'COMPANY_PHONE_ASC',
  CompanyPhoneDesc = 'COMPANY_PHONE_DESC',
  ComponentFormulationAsc = 'COMPONENT_FORMULATION_ASC',
  ComponentFormulationDesc = 'COMPONENT_FORMULATION_DESC',
  DosageFormAsc = 'DOSAGE_FORM_ASC',
  DosageFormDesc = 'DOSAGE_FORM_DESC',
  DosageFormDescriptionAsc = 'DOSAGE_FORM_DESCRIPTION_ASC',
  DosageFormDescriptionDesc = 'DOSAGE_FORM_DESCRIPTION_DESC',
  ExpiryDateAsc = 'EXPIRY_DATE_ASC',
  ExpiryDateDesc = 'EXPIRY_DATE_DESC',
  FinishedProductManufacturersAsc = 'FINISHED_PRODUCT_MANUFACTURERS_ASC',
  FinishedProductManufacturersDesc = 'FINISHED_PRODUCT_MANUFACTURERS_DESC',
  FormulationsAsc = 'FORMULATIONS_ASC',
  FormulationsDesc = 'FORMULATIONS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  ImporterAddressAsc = 'IMPORTER_ADDRESS_ASC',
  ImporterAddressDesc = 'IMPORTER_ADDRESS_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  NationalMedicalClassificationAsc = 'NATIONAL_MEDICAL_CLASSIFICATION_ASC',
  NationalMedicalClassificationDesc = 'NATIONAL_MEDICAL_CLASSIFICATION_DESC',
  Natural = 'NATURAL',
  PackagingDescriptionAsc = 'PACKAGING_DESCRIPTION_ASC',
  PackagingDescriptionDesc = 'PACKAGING_DESCRIPTION_DESC',
  PackagingSizesAsc = 'PACKAGING_SIZES_ASC',
  PackagingSizesDesc = 'PACKAGING_SIZES_DESC',
  PrimaryContainerAsc = 'PRIMARY_CONTAINER_ASC',
  PrimaryContainerDesc = 'PRIMARY_CONTAINER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProductOriginAsc = 'PRODUCT_ORIGIN_ASC',
  ProductOriginDesc = 'PRODUCT_ORIGIN_DESC',
  ProposedIndicationsAsc = 'PROPOSED_INDICATIONS_ASC',
  ProposedIndicationsDesc = 'PROPOSED_INDICATIONS_DESC',
  RegistrationDateAsc = 'REGISTRATION_DATE_ASC',
  RegistrationDateDesc = 'REGISTRATION_DATE_DESC',
  RegistrationSerialAsc = 'REGISTRATION_SERIAL_ASC',
  RegistrationSerialDesc = 'REGISTRATION_SERIAL_DESC',
  RouteOfAdministrationAsc = 'ROUTE_OF_ADMINISTRATION_ASC',
  RouteOfAdministrationDesc = 'ROUTE_OF_ADMINISTRATION_DESC',
  ShelfLifeAsc = 'SHELF_LIFE_ASC',
  ShelfLifeDesc = 'SHELF_LIFE_DESC',
  SraAsc = 'SRA_ASC',
  SraDesc = 'SRA_DESC',
  StorageTemperatureAsc = 'STORAGE_TEMPERATURE_ASC',
  StorageTemperatureDesc = 'STORAGE_TEMPERATURE_DESC'
}

/** The `dataTableProvisionalProductApplicationJoin` to be created by this mutation. */
export type DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInput>;
  dataTableProvisionalProductToDataTableProvisionalProductId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The `dataTableProvisionalProduct` to be created by this mutation. */
export type DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductCreateInput = {
  activeIngredients?: InputMaybe<Scalars['JSON']['input']>;
  activeIngredientsFilterData?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  approval?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['JSON']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  evaluationComment?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  letterOfAuthorisation?: InputMaybe<Scalars['JSON']['input']>;
  loaSource?: InputMaybe<Scalars['String']['input']>;
  manufacturerPrequalified?: InputMaybe<Scalars['JSON']['input']>;
  manufacturers?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersFilterData?: InputMaybe<Scalars['String']['input']>;
  medicalProductClassification?: InputMaybe<Scalars['String']['input']>;
  originalId?: InputMaybe<Scalars['String']['input']>;
  packagingSizes?: InputMaybe<Scalars['JSON']['input']>;
  packagingSizesFilterData?: InputMaybe<Scalars['String']['input']>;
  packagingSizesForm?: InputMaybe<Scalars['JSON']['input']>;
  pharmacopeia?: InputMaybe<Scalars['String']['input']>;
  prequalified?: InputMaybe<Scalars['Boolean']['input']>;
  prodRegCertificate?: InputMaybe<Scalars['JSON']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  registeredIn?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationSerial?: InputMaybe<Scalars['String']['input']>;
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  sponsorName?: InputMaybe<Scalars['String']['input']>;
  storageConditions?: InputMaybe<Scalars['String']['input']>;
  tradeName?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `dataTableProvisionalProduct` in the `DataTableProvisionalProductApplicationJoinInput` mutation. */
export type DataTableProvisionalProducDataTableProvisionalProduFkeyInput = {
  /** The primary key(s) for `dataTableProvisionalProduct` for the far side of the relationship. */
  connectById?: InputMaybe<DataTableProvisionalProductDataTableProvisionalProductPkeyConnect>;
  /** The primary key(s) for `dataTableProvisionalProduct` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<DataTableProvisionalProductNodeIdConnect>;
  /** A `DataTableProvisionalProductInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductCreateInput>;
  /** The primary key(s) for `dataTableProvisionalProduct` for the far side of the relationship. */
  deleteById?: InputMaybe<DataTableProvisionalProductDataTableProvisionalProductPkeyDelete>;
  /** The primary key(s) for `dataTableProvisionalProduct` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<DataTableProvisionalProductNodeIdDelete>;
  /** The primary key(s) and patch data for `dataTableProvisionalProduct` for the far side of the relationship. */
  updateById?: InputMaybe<DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductPkeyUpdate>;
  /** The primary key(s) and patch data for `dataTableProvisionalProduct` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `dataTableProvisionalProductApplicationJoin` in the `DataTableProvisionalProductInput` mutation. */
export type DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput = {
  /** The primary key(s) for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinNodeIdConnect>>;
  /** A `DataTableProvisionalProductApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableProvisionalProductApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate>>;
};

export type DataTableProvisionalProduct = Node & {
  __typename?: 'DataTableProvisionalProduct';
  activeIngredients?: Maybe<Scalars['JSON']['output']>;
  activeIngredientsFilterData?: Maybe<Scalars['String']['output']>;
  applicantId?: Maybe<Scalars['Int']['output']>;
  approval?: Maybe<Scalars['String']['output']>;
  atcCode?: Maybe<Scalars['JSON']['output']>;
  companyId?: Maybe<Scalars['Int']['output']>;
  companyName?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `DataTableProvisionalProductApplicationJoin`. */
  dataTableProvisionalProductApplicationJoins: DataTableProvisionalProductApplicationJoinsConnection;
  dosageForm?: Maybe<Scalars['String']['output']>;
  evaluationComment?: Maybe<Scalars['String']['output']>;
  expiryDate?: Maybe<Scalars['Datetime']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  gmpCertificate?: Maybe<Scalars['JSON']['output']>;
  gmpDetails?: Maybe<Scalars['JSON']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  letterOfAuthorisation?: Maybe<Scalars['JSON']['output']>;
  loaSource?: Maybe<Scalars['String']['output']>;
  manufacturerPrequalified?: Maybe<Scalars['JSON']['output']>;
  manufacturers?: Maybe<Scalars['JSON']['output']>;
  manufacturersFilterData?: Maybe<Scalars['String']['output']>;
  medicalProductClassification?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  originalId?: Maybe<Scalars['String']['output']>;
  packagingSizes?: Maybe<Scalars['JSON']['output']>;
  packagingSizesFilterData?: Maybe<Scalars['String']['output']>;
  packagingSizesForm?: Maybe<Scalars['JSON']['output']>;
  pharmacopeia?: Maybe<Scalars['String']['output']>;
  prequalified?: Maybe<Scalars['Boolean']['output']>;
  prodRegCertificate?: Maybe<Scalars['JSON']['output']>;
  productId?: Maybe<Scalars['String']['output']>;
  registeredIn?: Maybe<Scalars['String']['output']>;
  registrationDate?: Maybe<Scalars['Datetime']['output']>;
  registrationSerial?: Maybe<Scalars['String']['output']>;
  routeOfAdministration?: Maybe<Scalars['String']['output']>;
  shelfLife?: Maybe<Scalars['String']['output']>;
  sponsorName?: Maybe<Scalars['String']['output']>;
  storageConditions?: Maybe<Scalars['String']['output']>;
  tradeName?: Maybe<Scalars['String']['output']>;
};


export type DataTableProvisionalProductDataTableProvisionalProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProvisionalProductApplicationJoinCondition>;
  filter?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinsOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type DataTableProvisionalProductApplicationApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `dataTableProvisionalProductApplicationJoin` to be created by this mutation. */
export type DataTableProvisionalProductApplicationApplicationIdFkeyDataTableProvisionalProductApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInput>;
  dataTableProvisionalProductId?: InputMaybe<Scalars['Int']['input']>;
  dataTableProvisionalProductToDataTableProvisionalProductId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `application` in the `DataTableProvisionalProductApplicationJoinInput` mutation. */
export type DataTableProvisionalProductApplicationApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `dataTableProvisionalProductApplicationJoin` in the `ApplicationInput` mutation. */
export type DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinNodeIdConnect>>;
  /** A `DataTableProvisionalProductApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<DataTableProvisionalProductApplicationApplicationIdFkeyDataTableProvisionalProductApplicationJoinCreateInput>>;
  /** The primary key(s) for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `dataTableProvisionalProductApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `dataTableProvisionalProductApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate>>;
};

export type DataTableProvisionalProductApplicationJoin = Node & {
  __typename?: 'DataTableProvisionalProductApplicationJoin';
  /** Reads a single `Application` that is related to this `DataTableProvisionalProductApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  /** Reads a single `DataTableProvisionalProduct` that is related to this `DataTableProvisionalProductApplicationJoin`. */
  dataTableProvisionalProduct?: Maybe<DataTableProvisionalProduct>;
  dataTableProvisionalProductId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

/**
 * A condition to be used against `DataTableProvisionalProductApplicationJoin`
 * object types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableProvisionalProductApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `dataTableProvisionalProductId` field. */
  dataTableProvisionalProductId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `dataTableProvisionalProductApplicationJoin` to look up the row to connect. */
export type DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableProvisionalProductApplicationJoin` to look up the row to delete. */
export type DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTableProvisionalProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProvisionalProductApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `dataTableProvisionalProduct` relation. */
  dataTableProvisionalProduct?: InputMaybe<DataTableProvisionalProductFilter>;
  /** Filter by the object’s `dataTableProvisionalProductId` field. */
  dataTableProvisionalProductId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinFilter>>;
};

/** An input for mutations affecting `DataTableProvisionalProductApplicationJoin` */
export type DataTableProvisionalProductApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInput>;
  dataTableProvisionalProductId?: InputMaybe<Scalars['Int']['input']>;
  dataTableProvisionalProductToDataTableProvisionalProductId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableProvisionalProductApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableProvisionalProductApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableProvisionalProductApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableProvisionalProductApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableProvisionalProduct` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableProvisionalProduct` being updated. */
  patch: DataTableProvisionalProductPatch;
};

/** The fields on `dataTableProvisionalProductApplicationJoin` to look up the row to update. */
export type DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableProvisionalProductApplicationJoin` being updated. */
  patch: UpdateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `dataTableProvisionalProductApplicationJoin` to look up the row to update. */
export type DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableProvisionalProductApplicationJoin` being updated. */
  patch: UpdateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch;
};

/** Represents an update to a `DataTableProvisionalProductApplicationJoin`. Fields that are set will be updated. */
export type DataTableProvisionalProductApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInput>;
  dataTableProvisionalProductId?: InputMaybe<Scalars['Int']['input']>;
  dataTableProvisionalProductToDataTableProvisionalProductId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `DataTableProvisionalProductApplicationJoin` values. */
export type DataTableProvisionalProductApplicationJoinsConnection = {
  __typename?: 'DataTableProvisionalProductApplicationJoinsConnection';
  /** A list of edges which contains the `DataTableProvisionalProductApplicationJoin` and cursor to aid in pagination. */
  edges: Array<DataTableProvisionalProductApplicationJoinsEdge>;
  /** A list of `DataTableProvisionalProductApplicationJoin` objects. */
  nodes: Array<Maybe<DataTableProvisionalProductApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProvisionalProductApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProvisionalProductApplicationJoin` edge in the connection. */
export type DataTableProvisionalProductApplicationJoinsEdge = {
  __typename?: 'DataTableProvisionalProductApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProvisionalProductApplicationJoin` at the end of the edge. */
  node?: Maybe<DataTableProvisionalProductApplicationJoin>;
};

/** Methods to use when ordering `DataTableProvisionalProductApplicationJoin`. */
export enum DataTableProvisionalProductApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataTableProvisionalProductIdAsc = 'DATA_TABLE_PROVISIONAL_PRODUCT_ID_ASC',
  DataTableProvisionalProductIdDesc = 'DATA_TABLE_PROVISIONAL_PRODUCT_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `DataTableProvisionalProduct` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableProvisionalProductCondition = {
  /** Checks for equality with the object’s `activeIngredients` field. */
  activeIngredients?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `activeIngredientsFilterData` field. */
  activeIngredientsFilterData?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `applicantId` field. */
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `approval` field. */
  approval?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `atcCode` field. */
  atcCode?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `companyId` field. */
  companyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `companyName` field. */
  companyName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `evaluationComment` field. */
  evaluationComment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `expiryDate` field. */
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `fullName` field. */
  fullName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `gmpCertificate` field. */
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `gmpDetails` field. */
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `letterOfAuthorisation` field. */
  letterOfAuthorisation?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `loaSource` field. */
  loaSource?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `manufacturerPrequalified` field. */
  manufacturerPrequalified?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `manufacturers` field. */
  manufacturers?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `manufacturersFilterData` field. */
  manufacturersFilterData?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `medicalProductClassification` field. */
  medicalProductClassification?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `originalId` field. */
  originalId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `packagingSizes` field. */
  packagingSizes?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `packagingSizesFilterData` field. */
  packagingSizesFilterData?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `packagingSizesForm` field. */
  packagingSizesForm?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `pharmacopeia` field. */
  pharmacopeia?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `prequalified` field. */
  prequalified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `prodRegCertificate` field. */
  prodRegCertificate?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `productId` field. */
  productId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registeredIn` field. */
  registeredIn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `registrationSerial` field. */
  registrationSerial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `routeOfAdministration` field. */
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shelfLife` field. */
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `sponsorName` field. */
  sponsorName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `storageConditions` field. */
  storageConditions?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tradeName` field. */
  tradeName?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `dataTableProvisionalProduct` to look up the row to connect. */
export type DataTableProvisionalProductDataTableProvisionalProductPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `dataTableProvisionalProduct` to look up the row to delete. */
export type DataTableProvisionalProductDataTableProvisionalProductPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against `DataTableProvisionalProduct` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProvisionalProductFilter = {
  /** Filter by the object’s `activeIngredients` field. */
  activeIngredients?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `activeIngredientsFilterData` field. */
  activeIngredientsFilterData?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableProvisionalProductFilter>>;
  /** Filter by the object’s `applicantId` field. */
  applicantId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `approval` field. */
  approval?: InputMaybe<StringFilter>;
  /** Filter by the object’s `atcCode` field. */
  atcCode?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `companyId` field. */
  companyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `companyName` field. */
  companyName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dataTableProvisionalProductApplicationJoins` relation. */
  dataTableProvisionalProductApplicationJoins?: InputMaybe<DataTableProvisionalProductToManyDataTableProvisionalProductApplicationJoinFilter>;
  /** Some related `dataTableProvisionalProductApplicationJoins` exist. */
  dataTableProvisionalProductApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<StringFilter>;
  /** Filter by the object’s `evaluationComment` field. */
  evaluationComment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `expiryDate` field. */
  expiryDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `fullName` field. */
  fullName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `gmpCertificate` field. */
  gmpCertificate?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `gmpDetails` field. */
  gmpDetails?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `letterOfAuthorisation` field. */
  letterOfAuthorisation?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `loaSource` field. */
  loaSource?: InputMaybe<StringFilter>;
  /** Filter by the object’s `manufacturerPrequalified` field. */
  manufacturerPrequalified?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `manufacturers` field. */
  manufacturers?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `manufacturersFilterData` field. */
  manufacturersFilterData?: InputMaybe<StringFilter>;
  /** Filter by the object’s `medicalProductClassification` field. */
  medicalProductClassification?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableProvisionalProductFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableProvisionalProductFilter>>;
  /** Filter by the object’s `originalId` field. */
  originalId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `packagingSizes` field. */
  packagingSizes?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `packagingSizesFilterData` field. */
  packagingSizesFilterData?: InputMaybe<StringFilter>;
  /** Filter by the object’s `packagingSizesForm` field. */
  packagingSizesForm?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `pharmacopeia` field. */
  pharmacopeia?: InputMaybe<StringFilter>;
  /** Filter by the object’s `prequalified` field. */
  prequalified?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `prodRegCertificate` field. */
  prodRegCertificate?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `productId` field. */
  productId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registeredIn` field. */
  registeredIn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationDate` field. */
  registrationDate?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `registrationSerial` field. */
  registrationSerial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `routeOfAdministration` field. */
  routeOfAdministration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `shelfLife` field. */
  shelfLife?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sponsorName` field. */
  sponsorName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `storageConditions` field. */
  storageConditions?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tradeName` field. */
  tradeName?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableProvisionalProduct` */
export type DataTableProvisionalProductInput = {
  activeIngredients?: InputMaybe<Scalars['JSON']['input']>;
  activeIngredientsFilterData?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  approval?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['JSON']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  evaluationComment?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  letterOfAuthorisation?: InputMaybe<Scalars['JSON']['input']>;
  loaSource?: InputMaybe<Scalars['String']['input']>;
  manufacturerPrequalified?: InputMaybe<Scalars['JSON']['input']>;
  manufacturers?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersFilterData?: InputMaybe<Scalars['String']['input']>;
  medicalProductClassification?: InputMaybe<Scalars['String']['input']>;
  originalId?: InputMaybe<Scalars['String']['input']>;
  packagingSizes?: InputMaybe<Scalars['JSON']['input']>;
  packagingSizesFilterData?: InputMaybe<Scalars['String']['input']>;
  packagingSizesForm?: InputMaybe<Scalars['JSON']['input']>;
  pharmacopeia?: InputMaybe<Scalars['String']['input']>;
  prequalified?: InputMaybe<Scalars['Boolean']['input']>;
  prodRegCertificate?: InputMaybe<Scalars['JSON']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  registeredIn?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationSerial?: InputMaybe<Scalars['String']['input']>;
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  sponsorName?: InputMaybe<Scalars['String']['input']>;
  storageConditions?: InputMaybe<Scalars['String']['input']>;
  tradeName?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type DataTableProvisionalProductNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `dataTableProvisionalProduct` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type DataTableProvisionalProductNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `dataTableProvisionalProduct` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataTableProvisionalProductApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataTableProvisionalProductApplicationJoin` being updated. */
  patch: DataTableProvisionalProductApplicationJoinPatch;
};

/** The fields on `dataTableProvisionalProduct` to look up the row to update. */
export type DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `dataTableProvisionalProduct` being updated. */
  patch: UpdateDataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch;
};

/** Represents an update to a `DataTableProvisionalProduct`. Fields that are set will be updated. */
export type DataTableProvisionalProductPatch = {
  activeIngredients?: InputMaybe<Scalars['JSON']['input']>;
  activeIngredientsFilterData?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  approval?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['JSON']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  evaluationComment?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  letterOfAuthorisation?: InputMaybe<Scalars['JSON']['input']>;
  loaSource?: InputMaybe<Scalars['String']['input']>;
  manufacturerPrequalified?: InputMaybe<Scalars['JSON']['input']>;
  manufacturers?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersFilterData?: InputMaybe<Scalars['String']['input']>;
  medicalProductClassification?: InputMaybe<Scalars['String']['input']>;
  originalId?: InputMaybe<Scalars['String']['input']>;
  packagingSizes?: InputMaybe<Scalars['JSON']['input']>;
  packagingSizesFilterData?: InputMaybe<Scalars['String']['input']>;
  packagingSizesForm?: InputMaybe<Scalars['JSON']['input']>;
  pharmacopeia?: InputMaybe<Scalars['String']['input']>;
  prequalified?: InputMaybe<Scalars['Boolean']['input']>;
  prodRegCertificate?: InputMaybe<Scalars['JSON']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  registeredIn?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationSerial?: InputMaybe<Scalars['String']['input']>;
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  sponsorName?: InputMaybe<Scalars['String']['input']>;
  storageConditions?: InputMaybe<Scalars['String']['input']>;
  tradeName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against many `DataTableProvisionalProductApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type DataTableProvisionalProductToManyDataTableProvisionalProductApplicationJoinFilter = {
  /** Every related `DataTableProvisionalProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
  /** No related `DataTableProvisionalProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
  /** Some related `DataTableProvisionalProductApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
};

/** A connection to a list of `DataTableProvisionalProduct` values. */
export type DataTableProvisionalProductsConnection = {
  __typename?: 'DataTableProvisionalProductsConnection';
  /** A list of edges which contains the `DataTableProvisionalProduct` and cursor to aid in pagination. */
  edges: Array<DataTableProvisionalProductsEdge>;
  /** A list of `DataTableProvisionalProduct` objects. */
  nodes: Array<Maybe<DataTableProvisionalProduct>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableProvisionalProduct` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableProvisionalProduct` edge in the connection. */
export type DataTableProvisionalProductsEdge = {
  __typename?: 'DataTableProvisionalProductsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableProvisionalProduct` at the end of the edge. */
  node?: Maybe<DataTableProvisionalProduct>;
};

/** Methods to use when ordering `DataTableProvisionalProduct`. */
export enum DataTableProvisionalProductsOrderBy {
  ActiveIngredientsAsc = 'ACTIVE_INGREDIENTS_ASC',
  ActiveIngredientsDesc = 'ACTIVE_INGREDIENTS_DESC',
  ActiveIngredientsFilterDataAsc = 'ACTIVE_INGREDIENTS_FILTER_DATA_ASC',
  ActiveIngredientsFilterDataDesc = 'ACTIVE_INGREDIENTS_FILTER_DATA_DESC',
  ApplicantIdAsc = 'APPLICANT_ID_ASC',
  ApplicantIdDesc = 'APPLICANT_ID_DESC',
  ApprovalAsc = 'APPROVAL_ASC',
  ApprovalDesc = 'APPROVAL_DESC',
  AtcCodeAsc = 'ATC_CODE_ASC',
  AtcCodeDesc = 'ATC_CODE_DESC',
  CompanyIdAsc = 'COMPANY_ID_ASC',
  CompanyIdDesc = 'COMPANY_ID_DESC',
  CompanyNameAsc = 'COMPANY_NAME_ASC',
  CompanyNameDesc = 'COMPANY_NAME_DESC',
  DosageFormAsc = 'DOSAGE_FORM_ASC',
  DosageFormDesc = 'DOSAGE_FORM_DESC',
  EvaluationCommentAsc = 'EVALUATION_COMMENT_ASC',
  EvaluationCommentDesc = 'EVALUATION_COMMENT_DESC',
  ExpiryDateAsc = 'EXPIRY_DATE_ASC',
  ExpiryDateDesc = 'EXPIRY_DATE_DESC',
  FullNameAsc = 'FULL_NAME_ASC',
  FullNameDesc = 'FULL_NAME_DESC',
  GmpCertificateAsc = 'GMP_CERTIFICATE_ASC',
  GmpCertificateDesc = 'GMP_CERTIFICATE_DESC',
  GmpDetailsAsc = 'GMP_DETAILS_ASC',
  GmpDetailsDesc = 'GMP_DETAILS_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  LetterOfAuthorisationAsc = 'LETTER_OF_AUTHORISATION_ASC',
  LetterOfAuthorisationDesc = 'LETTER_OF_AUTHORISATION_DESC',
  LoaSourceAsc = 'LOA_SOURCE_ASC',
  LoaSourceDesc = 'LOA_SOURCE_DESC',
  ManufacturersAsc = 'MANUFACTURERS_ASC',
  ManufacturersDesc = 'MANUFACTURERS_DESC',
  ManufacturersFilterDataAsc = 'MANUFACTURERS_FILTER_DATA_ASC',
  ManufacturersFilterDataDesc = 'MANUFACTURERS_FILTER_DATA_DESC',
  ManufacturerPrequalifiedAsc = 'MANUFACTURER_PREQUALIFIED_ASC',
  ManufacturerPrequalifiedDesc = 'MANUFACTURER_PREQUALIFIED_DESC',
  MedicalProductClassificationAsc = 'MEDICAL_PRODUCT_CLASSIFICATION_ASC',
  MedicalProductClassificationDesc = 'MEDICAL_PRODUCT_CLASSIFICATION_DESC',
  Natural = 'NATURAL',
  OriginalIdAsc = 'ORIGINAL_ID_ASC',
  OriginalIdDesc = 'ORIGINAL_ID_DESC',
  PackagingSizesAsc = 'PACKAGING_SIZES_ASC',
  PackagingSizesDesc = 'PACKAGING_SIZES_DESC',
  PackagingSizesFilterDataAsc = 'PACKAGING_SIZES_FILTER_DATA_ASC',
  PackagingSizesFilterDataDesc = 'PACKAGING_SIZES_FILTER_DATA_DESC',
  PackagingSizesFormAsc = 'PACKAGING_SIZES_FORM_ASC',
  PackagingSizesFormDesc = 'PACKAGING_SIZES_FORM_DESC',
  PharmacopeiaAsc = 'PHARMACOPEIA_ASC',
  PharmacopeiaDesc = 'PHARMACOPEIA_DESC',
  PrequalifiedAsc = 'PREQUALIFIED_ASC',
  PrequalifiedDesc = 'PREQUALIFIED_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProductIdAsc = 'PRODUCT_ID_ASC',
  ProductIdDesc = 'PRODUCT_ID_DESC',
  ProdRegCertificateAsc = 'PROD_REG_CERTIFICATE_ASC',
  ProdRegCertificateDesc = 'PROD_REG_CERTIFICATE_DESC',
  RegisteredInAsc = 'REGISTERED_IN_ASC',
  RegisteredInDesc = 'REGISTERED_IN_DESC',
  RegistrationDateAsc = 'REGISTRATION_DATE_ASC',
  RegistrationDateDesc = 'REGISTRATION_DATE_DESC',
  RegistrationSerialAsc = 'REGISTRATION_SERIAL_ASC',
  RegistrationSerialDesc = 'REGISTRATION_SERIAL_DESC',
  RouteOfAdministrationAsc = 'ROUTE_OF_ADMINISTRATION_ASC',
  RouteOfAdministrationDesc = 'ROUTE_OF_ADMINISTRATION_DESC',
  ShelfLifeAsc = 'SHELF_LIFE_ASC',
  ShelfLifeDesc = 'SHELF_LIFE_DESC',
  SponsorNameAsc = 'SPONSOR_NAME_ASC',
  SponsorNameDesc = 'SPONSOR_NAME_DESC',
  StorageConditionsAsc = 'STORAGE_CONDITIONS_ASC',
  StorageConditionsDesc = 'STORAGE_CONDITIONS_DESC',
  TradeNameAsc = 'TRADE_NAME_ASC',
  TradeNameDesc = 'TRADE_NAME_DESC'
}

export type DataTableScheduledChemical = Node & {
  __typename?: 'DataTableScheduledChemical';
  chemical?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  schedule?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableScheduledChemical` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableScheduledChemicalCondition = {
  /** Checks for equality with the object’s `chemical` field. */
  chemical?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `schedule` field. */
  schedule?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableScheduledChemical` object types. All fields are combined with a logical ‘and.’ */
export type DataTableScheduledChemicalFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableScheduledChemicalFilter>>;
  /** Filter by the object’s `chemical` field. */
  chemical?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableScheduledChemicalFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableScheduledChemicalFilter>>;
  /** Filter by the object’s `schedule` field. */
  schedule?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableScheduledChemical` */
export type DataTableScheduledChemicalInput = {
  chemical?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  schedule?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableScheduledChemical`. Fields that are set will be updated. */
export type DataTableScheduledChemicalPatch = {
  chemical?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  schedule?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableScheduledChemical` values. */
export type DataTableScheduledChemicalsConnection = {
  __typename?: 'DataTableScheduledChemicalsConnection';
  /** A list of edges which contains the `DataTableScheduledChemical` and cursor to aid in pagination. */
  edges: Array<DataTableScheduledChemicalsEdge>;
  /** A list of `DataTableScheduledChemical` objects. */
  nodes: Array<Maybe<DataTableScheduledChemical>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableScheduledChemical` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableScheduledChemical` edge in the connection. */
export type DataTableScheduledChemicalsEdge = {
  __typename?: 'DataTableScheduledChemicalsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableScheduledChemical` at the end of the edge. */
  node?: Maybe<DataTableScheduledChemical>;
};

/** Methods to use when ordering `DataTableScheduledChemical`. */
export enum DataTableScheduledChemicalsOrderBy {
  ChemicalAsc = 'CHEMICAL_ASC',
  ChemicalDesc = 'CHEMICAL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ScheduleAsc = 'SCHEDULE_ASC',
  ScheduleDesc = 'SCHEDULE_DESC'
}

export type DataTableStorageCondition = Node & {
  __typename?: 'DataTableStorageCondition';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  longDescription?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  shortDescription?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableStorageCondition` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableStorageConditionCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `longDescription` field. */
  longDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableStorageCondition` object types. All fields are combined with a logical ‘and.’ */
export type DataTableStorageConditionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableStorageConditionFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `longDescription` field. */
  longDescription?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableStorageConditionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableStorageConditionFilter>>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableStorageCondition` */
export type DataTableStorageConditionInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableStorageCondition`. Fields that are set will be updated. */
export type DataTableStorageConditionPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableStorageCondition` values. */
export type DataTableStorageConditionsConnection = {
  __typename?: 'DataTableStorageConditionsConnection';
  /** A list of edges which contains the `DataTableStorageCondition` and cursor to aid in pagination. */
  edges: Array<DataTableStorageConditionsEdge>;
  /** A list of `DataTableStorageCondition` objects. */
  nodes: Array<Maybe<DataTableStorageCondition>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableStorageCondition` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableStorageCondition` edge in the connection. */
export type DataTableStorageConditionsEdge = {
  __typename?: 'DataTableStorageConditionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableStorageCondition` at the end of the edge. */
  node?: Maybe<DataTableStorageCondition>;
};

/** Methods to use when ordering `DataTableStorageCondition`. */
export enum DataTableStorageConditionsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LongDescriptionAsc = 'LONG_DESCRIPTION_ASC',
  LongDescriptionDesc = 'LONG_DESCRIPTION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC'
}

export type DataTableStorageConditionsSimplified = Node & {
  __typename?: 'DataTableStorageConditionsSimplified';
  id: Scalars['Int']['output'];
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  portugueseName?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableStorageConditionsSimplified` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableStorageConditionsSimplifiedCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `portugueseName` field. */
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableStorageConditionsSimplified` object types. All fields are combined with a logical ‘and.’ */
export type DataTableStorageConditionsSimplifiedFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableStorageConditionsSimplifiedFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableStorageConditionsSimplifiedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableStorageConditionsSimplifiedFilter>>;
  /** Filter by the object’s `portugueseName` field. */
  portugueseName?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableStorageConditionsSimplified` */
export type DataTableStorageConditionsSimplifiedInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableStorageConditionsSimplified`. Fields that are set will be updated. */
export type DataTableStorageConditionsSimplifiedPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  portugueseName?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableStorageConditionsSimplified` values. */
export type DataTableStorageConditionsSimplifiedsConnection = {
  __typename?: 'DataTableStorageConditionsSimplifiedsConnection';
  /** A list of edges which contains the `DataTableStorageConditionsSimplified` and cursor to aid in pagination. */
  edges: Array<DataTableStorageConditionsSimplifiedsEdge>;
  /** A list of `DataTableStorageConditionsSimplified` objects. */
  nodes: Array<Maybe<DataTableStorageConditionsSimplified>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableStorageConditionsSimplified` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableStorageConditionsSimplified` edge in the connection. */
export type DataTableStorageConditionsSimplifiedsEdge = {
  __typename?: 'DataTableStorageConditionsSimplifiedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableStorageConditionsSimplified` at the end of the edge. */
  node?: Maybe<DataTableStorageConditionsSimplified>;
};

/** Methods to use when ordering `DataTableStorageConditionsSimplified`. */
export enum DataTableStorageConditionsSimplifiedsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PortugueseNameAsc = 'PORTUGUESE_NAME_ASC',
  PortugueseNameDesc = 'PORTUGUESE_NAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

export type DataTableUnitsOfProportion = Node & {
  __typename?: 'DataTableUnitsOfProportion';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  longDescription?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  shortDescription?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableUnitsOfProportion` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableUnitsOfProportionCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `longDescription` field. */
  longDescription?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableUnitsOfProportion` object types. All fields are combined with a logical ‘and.’ */
export type DataTableUnitsOfProportionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableUnitsOfProportionFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `longDescription` field. */
  longDescription?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableUnitsOfProportionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableUnitsOfProportionFilter>>;
  /** Filter by the object’s `shortDescription` field. */
  shortDescription?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableUnitsOfProportion` */
export type DataTableUnitsOfProportionInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableUnitsOfProportion`. Fields that are set will be updated. */
export type DataTableUnitsOfProportionPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  longDescription?: InputMaybe<Scalars['String']['input']>;
  shortDescription?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableUnitsOfProportion` values. */
export type DataTableUnitsOfProportionsConnection = {
  __typename?: 'DataTableUnitsOfProportionsConnection';
  /** A list of edges which contains the `DataTableUnitsOfProportion` and cursor to aid in pagination. */
  edges: Array<DataTableUnitsOfProportionsEdge>;
  /** A list of `DataTableUnitsOfProportion` objects. */
  nodes: Array<Maybe<DataTableUnitsOfProportion>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableUnitsOfProportion` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableUnitsOfProportion` edge in the connection. */
export type DataTableUnitsOfProportionsEdge = {
  __typename?: 'DataTableUnitsOfProportionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableUnitsOfProportion` at the end of the edge. */
  node?: Maybe<DataTableUnitsOfProportion>;
};

/** Methods to use when ordering `DataTableUnitsOfProportion`. */
export enum DataTableUnitsOfProportionsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LongDescriptionAsc = 'LONG_DESCRIPTION_ASC',
  LongDescriptionDesc = 'LONG_DESCRIPTION_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ShortDescriptionAsc = 'SHORT_DESCRIPTION_ASC',
  ShortDescriptionDesc = 'SHORT_DESCRIPTION_DESC'
}

export type DataTableWorldHealthOrganisationPqListOfFpp = Node & {
  __typename?: 'DataTableWorldHealthOrganisationPqListOfFpp';
  applicant?: Maybe<Scalars['String']['output']>;
  basisOfAlternativeListing?: Maybe<Scalars['String']['output']>;
  basisOfListing?: Maybe<Scalars['String']['output']>;
  dosageForm?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  innDosageFormAndStrength?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  productType?: Maybe<Scalars['String']['output']>;
  therapeuticArea?: Maybe<Scalars['String']['output']>;
  whoReferenceNumber?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `DataTableWorldHealthOrganisationPqListOfFpp`
 * object types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type DataTableWorldHealthOrganisationPqListOfFppCondition = {
  /** Checks for equality with the object’s `applicant` field. */
  applicant?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `basisOfAlternativeListing` field. */
  basisOfAlternativeListing?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `basisOfListing` field. */
  basisOfListing?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `innDosageFormAndStrength` field. */
  innDosageFormAndStrength?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `productType` field. */
  productType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `therapeuticArea` field. */
  therapeuticArea?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `whoReferenceNumber` field. */
  whoReferenceNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataTableWorldHealthOrganisationPqListOfFpp` object types. All fields are combined with a logical ‘and.’ */
export type DataTableWorldHealthOrganisationPqListOfFppFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataTableWorldHealthOrganisationPqListOfFppFilter>>;
  /** Filter by the object’s `applicant` field. */
  applicant?: InputMaybe<StringFilter>;
  /** Filter by the object’s `basisOfAlternativeListing` field. */
  basisOfAlternativeListing?: InputMaybe<StringFilter>;
  /** Filter by the object’s `basisOfListing` field. */
  basisOfListing?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dosageForm` field. */
  dosageForm?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `innDosageFormAndStrength` field. */
  innDosageFormAndStrength?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataTableWorldHealthOrganisationPqListOfFppFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataTableWorldHealthOrganisationPqListOfFppFilter>>;
  /** Filter by the object’s `productType` field. */
  productType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `therapeuticArea` field. */
  therapeuticArea?: InputMaybe<StringFilter>;
  /** Filter by the object’s `whoReferenceNumber` field. */
  whoReferenceNumber?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataTableWorldHealthOrganisationPqListOfFpp` */
export type DataTableWorldHealthOrganisationPqListOfFppInput = {
  applicant?: InputMaybe<Scalars['String']['input']>;
  basisOfAlternativeListing?: InputMaybe<Scalars['String']['input']>;
  basisOfListing?: InputMaybe<Scalars['String']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  innDosageFormAndStrength?: InputMaybe<Scalars['String']['input']>;
  productType?: InputMaybe<Scalars['String']['input']>;
  therapeuticArea?: InputMaybe<Scalars['String']['input']>;
  whoReferenceNumber?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataTableWorldHealthOrganisationPqListOfFpp`. Fields that are set will be updated. */
export type DataTableWorldHealthOrganisationPqListOfFppPatch = {
  applicant?: InputMaybe<Scalars['String']['input']>;
  basisOfAlternativeListing?: InputMaybe<Scalars['String']['input']>;
  basisOfListing?: InputMaybe<Scalars['String']['input']>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  innDosageFormAndStrength?: InputMaybe<Scalars['String']['input']>;
  productType?: InputMaybe<Scalars['String']['input']>;
  therapeuticArea?: InputMaybe<Scalars['String']['input']>;
  whoReferenceNumber?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataTableWorldHealthOrganisationPqListOfFpp` values. */
export type DataTableWorldHealthOrganisationPqListOfFppsConnection = {
  __typename?: 'DataTableWorldHealthOrganisationPqListOfFppsConnection';
  /** A list of edges which contains the `DataTableWorldHealthOrganisationPqListOfFpp` and cursor to aid in pagination. */
  edges: Array<DataTableWorldHealthOrganisationPqListOfFppsEdge>;
  /** A list of `DataTableWorldHealthOrganisationPqListOfFpp` objects. */
  nodes: Array<Maybe<DataTableWorldHealthOrganisationPqListOfFpp>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTableWorldHealthOrganisationPqListOfFpp` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTableWorldHealthOrganisationPqListOfFpp` edge in the connection. */
export type DataTableWorldHealthOrganisationPqListOfFppsEdge = {
  __typename?: 'DataTableWorldHealthOrganisationPqListOfFppsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTableWorldHealthOrganisationPqListOfFpp` at the end of the edge. */
  node?: Maybe<DataTableWorldHealthOrganisationPqListOfFpp>;
};

/** Methods to use when ordering `DataTableWorldHealthOrganisationPqListOfFpp`. */
export enum DataTableWorldHealthOrganisationPqListOfFppsOrderBy {
  ApplicantAsc = 'APPLICANT_ASC',
  ApplicantDesc = 'APPLICANT_DESC',
  BasisOfAlternativeListingAsc = 'BASIS_OF_ALTERNATIVE_LISTING_ASC',
  BasisOfAlternativeListingDesc = 'BASIS_OF_ALTERNATIVE_LISTING_DESC',
  BasisOfListingAsc = 'BASIS_OF_LISTING_ASC',
  BasisOfListingDesc = 'BASIS_OF_LISTING_DESC',
  DosageFormAsc = 'DOSAGE_FORM_ASC',
  DosageFormDesc = 'DOSAGE_FORM_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  InnDosageFormAndStrengthAsc = 'INN_DOSAGE_FORM_AND_STRENGTH_ASC',
  InnDosageFormAndStrengthDesc = 'INN_DOSAGE_FORM_AND_STRENGTH_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProductTypeAsc = 'PRODUCT_TYPE_ASC',
  ProductTypeDesc = 'PRODUCT_TYPE_DESC',
  TherapeuticAreaAsc = 'THERAPEUTIC_AREA_ASC',
  TherapeuticAreaDesc = 'THERAPEUTIC_AREA_DESC',
  WhoReferenceNumberAsc = 'WHO_REFERENCE_NUMBER_ASC',
  WhoReferenceNumberDesc = 'WHO_REFERENCE_NUMBER_DESC'
}

/** A connection to a list of `DataTable` values. */
export type DataTablesConnection = {
  __typename?: 'DataTablesConnection';
  /** A list of edges which contains the `DataTable` and cursor to aid in pagination. */
  edges: Array<DataTablesEdge>;
  /** A list of `DataTable` objects. */
  nodes: Array<Maybe<DataTable>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataTable` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataTable` edge in the connection. */
export type DataTablesEdge = {
  __typename?: 'DataTablesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataTable` at the end of the edge. */
  node?: Maybe<DataTable>;
};

/** Methods to use when ordering `DataTable`. */
export enum DataTablesOrderBy {
  DataViewCodeAsc = 'DATA_VIEW_CODE_ASC',
  DataViewCodeDesc = 'DATA_VIEW_CODE_DESC',
  DisplayNameAsc = 'DISPLAY_NAME_ASC',
  DisplayNameDesc = 'DISPLAY_NAME_DESC',
  FieldMapAsc = 'FIELD_MAP_ASC',
  FieldMapDesc = 'FIELD_MAP_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsLookupTableAsc = 'IS_LOOKUP_TABLE_ASC',
  IsLookupTableDesc = 'IS_LOOKUP_TABLE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC'
}

export type DataView = Node & {
  __typename?: 'DataView';
  code: Scalars['String']['output'];
  defaultFilterString?: Maybe<Scalars['String']['output']>;
  defaultSortColumn?: Maybe<Scalars['String']['output']>;
  detailViewExcludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  detailViewHeaderColumn: Scalars['String']['output'];
  detailViewIncludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  enabled: Scalars['Boolean']['output'];
  filterExcludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  filterIncludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  id: Scalars['Int']['output'];
  identifier: Scalars['String']['output'];
  menuName?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  permissionNames?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  priority?: Maybe<Scalars['Int']['output']>;
  rawDataExcludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  rawDataIncludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  rowRestrictions?: Maybe<Scalars['JSON']['output']>;
  showLinkedApplications: Scalars['Boolean']['output'];
  submenu?: Maybe<Scalars['String']['output']>;
  tableName: Scalars['String']['output'];
  tableSearchColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  tableViewExcludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  tableViewIncludeColumns?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  title?: Maybe<Scalars['String']['output']>;
};

export type DataViewColumnDefinition = Node & {
  __typename?: 'DataViewColumnDefinition';
  additionalFormatting?: Maybe<Scalars['JSON']['output']>;
  columnName: Scalars['String']['output'];
  elementParameters?: Maybe<Scalars['JSON']['output']>;
  elementTypePluginCode?: Maybe<Scalars['String']['output']>;
  filterDataType?: Maybe<Scalars['String']['output']>;
  filterExpression?: Maybe<Scalars['JSON']['output']>;
  filterParameters?: Maybe<Scalars['JSON']['output']>;
  hideIfNull?: Maybe<Scalars['Boolean']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  sortColumn?: Maybe<Scalars['String']['output']>;
  tableName?: Maybe<Scalars['String']['output']>;
  title?: Maybe<Scalars['String']['output']>;
  valueExpression?: Maybe<Scalars['JSON']['output']>;
};

/**
 * A condition to be used against `DataViewColumnDefinition` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type DataViewColumnDefinitionCondition = {
  /** Checks for equality with the object’s `additionalFormatting` field. */
  additionalFormatting?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `columnName` field. */
  columnName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `elementParameters` field. */
  elementParameters?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterDataType` field. */
  filterDataType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filterExpression` field. */
  filterExpression?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `filterParameters` field. */
  filterParameters?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `hideIfNull` field. */
  hideIfNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `sortColumn` field. */
  sortColumn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `valueExpression` field. */
  valueExpression?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `DataViewColumnDefinition` object types. All fields are combined with a logical ‘and.’ */
export type DataViewColumnDefinitionFilter = {
  /** Filter by the object’s `additionalFormatting` field. */
  additionalFormatting?: InputMaybe<JsonFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataViewColumnDefinitionFilter>>;
  /** Filter by the object’s `columnName` field. */
  columnName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `elementParameters` field. */
  elementParameters?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterDataType` field. */
  filterDataType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filterExpression` field. */
  filterExpression?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `filterParameters` field. */
  filterParameters?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `hideIfNull` field. */
  hideIfNull?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataViewColumnDefinitionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataViewColumnDefinitionFilter>>;
  /** Filter by the object’s `sortColumn` field. */
  sortColumn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `valueExpression` field. */
  valueExpression?: InputMaybe<JsonFilter>;
};

/** An input for mutations affecting `DataViewColumnDefinition` */
export type DataViewColumnDefinitionInput = {
  additionalFormatting?: InputMaybe<Scalars['JSON']['input']>;
  columnName: Scalars['String']['input'];
  elementParameters?: InputMaybe<Scalars['JSON']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  filterDataType?: InputMaybe<Scalars['String']['input']>;
  filterExpression?: InputMaybe<Scalars['JSON']['input']>;
  filterParameters?: InputMaybe<Scalars['JSON']['input']>;
  hideIfNull?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sortColumn?: InputMaybe<Scalars['String']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  valueExpression?: InputMaybe<Scalars['JSON']['input']>;
};

/** Represents an update to a `DataViewColumnDefinition`. Fields that are set will be updated. */
export type DataViewColumnDefinitionPatch = {
  additionalFormatting?: InputMaybe<Scalars['JSON']['input']>;
  columnName?: InputMaybe<Scalars['String']['input']>;
  elementParameters?: InputMaybe<Scalars['JSON']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  filterDataType?: InputMaybe<Scalars['String']['input']>;
  filterExpression?: InputMaybe<Scalars['JSON']['input']>;
  filterParameters?: InputMaybe<Scalars['JSON']['input']>;
  hideIfNull?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  sortColumn?: InputMaybe<Scalars['String']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  valueExpression?: InputMaybe<Scalars['JSON']['input']>;
};

/** A connection to a list of `DataViewColumnDefinition` values. */
export type DataViewColumnDefinitionsConnection = {
  __typename?: 'DataViewColumnDefinitionsConnection';
  /** A list of edges which contains the `DataViewColumnDefinition` and cursor to aid in pagination. */
  edges: Array<DataViewColumnDefinitionsEdge>;
  /** A list of `DataViewColumnDefinition` objects. */
  nodes: Array<Maybe<DataViewColumnDefinition>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataViewColumnDefinition` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataViewColumnDefinition` edge in the connection. */
export type DataViewColumnDefinitionsEdge = {
  __typename?: 'DataViewColumnDefinitionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataViewColumnDefinition` at the end of the edge. */
  node?: Maybe<DataViewColumnDefinition>;
};

/** Methods to use when ordering `DataViewColumnDefinition`. */
export enum DataViewColumnDefinitionsOrderBy {
  AdditionalFormattingAsc = 'ADDITIONAL_FORMATTING_ASC',
  AdditionalFormattingDesc = 'ADDITIONAL_FORMATTING_DESC',
  ColumnNameAsc = 'COLUMN_NAME_ASC',
  ColumnNameDesc = 'COLUMN_NAME_DESC',
  ElementParametersAsc = 'ELEMENT_PARAMETERS_ASC',
  ElementParametersDesc = 'ELEMENT_PARAMETERS_DESC',
  ElementTypePluginCodeAsc = 'ELEMENT_TYPE_PLUGIN_CODE_ASC',
  ElementTypePluginCodeDesc = 'ELEMENT_TYPE_PLUGIN_CODE_DESC',
  FilterDataTypeAsc = 'FILTER_DATA_TYPE_ASC',
  FilterDataTypeDesc = 'FILTER_DATA_TYPE_DESC',
  FilterExpressionAsc = 'FILTER_EXPRESSION_ASC',
  FilterExpressionDesc = 'FILTER_EXPRESSION_DESC',
  FilterParametersAsc = 'FILTER_PARAMETERS_ASC',
  FilterParametersDesc = 'FILTER_PARAMETERS_DESC',
  HideIfNullAsc = 'HIDE_IF_NULL_ASC',
  HideIfNullDesc = 'HIDE_IF_NULL_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SortColumnAsc = 'SORT_COLUMN_ASC',
  SortColumnDesc = 'SORT_COLUMN_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  ValueExpressionAsc = 'VALUE_EXPRESSION_ASC',
  ValueExpressionDesc = 'VALUE_EXPRESSION_DESC'
}

/**
 * A condition to be used against `DataView` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type DataViewCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `defaultFilterString` field. */
  defaultFilterString?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `defaultSortColumn` field. */
  defaultSortColumn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detailViewExcludeColumns` field. */
  detailViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `detailViewHeaderColumn` field. */
  detailViewHeaderColumn?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `detailViewIncludeColumns` field. */
  detailViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `enabled` field. */
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `filterExcludeColumns` field. */
  filterExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `filterIncludeColumns` field. */
  filterIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `identifier` field. */
  identifier?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `menuName` field. */
  menuName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissionNames` field. */
  permissionNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `rawDataExcludeColumns` field. */
  rawDataExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `rawDataIncludeColumns` field. */
  rawDataIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `rowRestrictions` field. */
  rowRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `showLinkedApplications` field. */
  showLinkedApplications?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `submenu` field. */
  submenu?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tableSearchColumns` field. */
  tableSearchColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `tableViewExcludeColumns` field. */
  tableViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `tableViewIncludeColumns` field. */
  tableViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `DataView` object types. All fields are combined with a logical ‘and.’ */
export type DataViewFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<DataViewFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `defaultFilterString` field. */
  defaultFilterString?: InputMaybe<StringFilter>;
  /** Filter by the object’s `defaultSortColumn` field. */
  defaultSortColumn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detailViewExcludeColumns` field. */
  detailViewExcludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `detailViewHeaderColumn` field. */
  detailViewHeaderColumn?: InputMaybe<StringFilter>;
  /** Filter by the object’s `detailViewIncludeColumns` field. */
  detailViewIncludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `enabled` field. */
  enabled?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `filterExcludeColumns` field. */
  filterExcludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `filterIncludeColumns` field. */
  filterIncludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `identifier` field. */
  identifier?: InputMaybe<StringFilter>;
  /** Filter by the object’s `menuName` field. */
  menuName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<DataViewFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<DataViewFilter>>;
  /** Filter by the object’s `permissionNames` field. */
  permissionNames?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `priority` field. */
  priority?: InputMaybe<IntFilter>;
  /** Filter by the object’s `rawDataExcludeColumns` field. */
  rawDataExcludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `rawDataIncludeColumns` field. */
  rawDataIncludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `rowRestrictions` field. */
  rowRestrictions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `showLinkedApplications` field. */
  showLinkedApplications?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `submenu` field. */
  submenu?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tableSearchColumns` field. */
  tableSearchColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `tableViewExcludeColumns` field. */
  tableViewExcludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `tableViewIncludeColumns` field. */
  tableViewIncludeColumns?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `DataView` */
export type DataViewInput = {
  code: Scalars['String']['input'];
  defaultFilterString?: InputMaybe<Scalars['String']['input']>;
  defaultSortColumn?: InputMaybe<Scalars['String']['input']>;
  detailViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  detailViewHeaderColumn: Scalars['String']['input'];
  detailViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  filterExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  identifier: Scalars['String']['input'];
  menuName?: InputMaybe<Scalars['String']['input']>;
  permissionNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  rawDataExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  rawDataIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  rowRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  showLinkedApplications?: InputMaybe<Scalars['Boolean']['input']>;
  submenu?: InputMaybe<Scalars['String']['input']>;
  tableName: Scalars['String']['input'];
  tableSearchColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tableViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tableViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Represents an update to a `DataView`. Fields that are set will be updated. */
export type DataViewPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  defaultFilterString?: InputMaybe<Scalars['String']['input']>;
  defaultSortColumn?: InputMaybe<Scalars['String']['input']>;
  detailViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  detailViewHeaderColumn?: InputMaybe<Scalars['String']['input']>;
  detailViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  enabled?: InputMaybe<Scalars['Boolean']['input']>;
  filterExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filterIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  identifier?: InputMaybe<Scalars['String']['input']>;
  menuName?: InputMaybe<Scalars['String']['input']>;
  permissionNames?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  rawDataExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  rawDataIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  rowRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  showLinkedApplications?: InputMaybe<Scalars['Boolean']['input']>;
  submenu?: InputMaybe<Scalars['String']['input']>;
  tableName?: InputMaybe<Scalars['String']['input']>;
  tableSearchColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tableViewExcludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  tableViewIncludeColumns?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A connection to a list of `DataView` values. */
export type DataViewsConnection = {
  __typename?: 'DataViewsConnection';
  /** A list of edges which contains the `DataView` and cursor to aid in pagination. */
  edges: Array<DataViewsEdge>;
  /** A list of `DataView` objects. */
  nodes: Array<Maybe<DataView>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `DataView` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `DataView` edge in the connection. */
export type DataViewsEdge = {
  __typename?: 'DataViewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `DataView` at the end of the edge. */
  node?: Maybe<DataView>;
};

/** Methods to use when ordering `DataView`. */
export enum DataViewsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  DefaultFilterStringAsc = 'DEFAULT_FILTER_STRING_ASC',
  DefaultFilterStringDesc = 'DEFAULT_FILTER_STRING_DESC',
  DefaultSortColumnAsc = 'DEFAULT_SORT_COLUMN_ASC',
  DefaultSortColumnDesc = 'DEFAULT_SORT_COLUMN_DESC',
  DetailViewExcludeColumnsAsc = 'DETAIL_VIEW_EXCLUDE_COLUMNS_ASC',
  DetailViewExcludeColumnsDesc = 'DETAIL_VIEW_EXCLUDE_COLUMNS_DESC',
  DetailViewHeaderColumnAsc = 'DETAIL_VIEW_HEADER_COLUMN_ASC',
  DetailViewHeaderColumnDesc = 'DETAIL_VIEW_HEADER_COLUMN_DESC',
  DetailViewIncludeColumnsAsc = 'DETAIL_VIEW_INCLUDE_COLUMNS_ASC',
  DetailViewIncludeColumnsDesc = 'DETAIL_VIEW_INCLUDE_COLUMNS_DESC',
  EnabledAsc = 'ENABLED_ASC',
  EnabledDesc = 'ENABLED_DESC',
  FilterExcludeColumnsAsc = 'FILTER_EXCLUDE_COLUMNS_ASC',
  FilterExcludeColumnsDesc = 'FILTER_EXCLUDE_COLUMNS_DESC',
  FilterIncludeColumnsAsc = 'FILTER_INCLUDE_COLUMNS_ASC',
  FilterIncludeColumnsDesc = 'FILTER_INCLUDE_COLUMNS_DESC',
  IdentifierAsc = 'IDENTIFIER_ASC',
  IdentifierDesc = 'IDENTIFIER_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  MenuNameAsc = 'MENU_NAME_ASC',
  MenuNameDesc = 'MENU_NAME_DESC',
  Natural = 'NATURAL',
  PermissionNamesAsc = 'PERMISSION_NAMES_ASC',
  PermissionNamesDesc = 'PERMISSION_NAMES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PriorityAsc = 'PRIORITY_ASC',
  PriorityDesc = 'PRIORITY_DESC',
  RawDataExcludeColumnsAsc = 'RAW_DATA_EXCLUDE_COLUMNS_ASC',
  RawDataExcludeColumnsDesc = 'RAW_DATA_EXCLUDE_COLUMNS_DESC',
  RawDataIncludeColumnsAsc = 'RAW_DATA_INCLUDE_COLUMNS_ASC',
  RawDataIncludeColumnsDesc = 'RAW_DATA_INCLUDE_COLUMNS_DESC',
  RowRestrictionsAsc = 'ROW_RESTRICTIONS_ASC',
  RowRestrictionsDesc = 'ROW_RESTRICTIONS_DESC',
  ShowLinkedApplicationsAsc = 'SHOW_LINKED_APPLICATIONS_ASC',
  ShowLinkedApplicationsDesc = 'SHOW_LINKED_APPLICATIONS_DESC',
  SubmenuAsc = 'SUBMENU_ASC',
  SubmenuDesc = 'SUBMENU_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC',
  TableSearchColumnsAsc = 'TABLE_SEARCH_COLUMNS_ASC',
  TableSearchColumnsDesc = 'TABLE_SEARCH_COLUMNS_DESC',
  TableViewExcludeColumnsAsc = 'TABLE_VIEW_EXCLUDE_COLUMNS_ASC',
  TableViewExcludeColumnsDesc = 'TABLE_VIEW_EXCLUDE_COLUMNS_DESC',
  TableViewIncludeColumnsAsc = 'TABLE_VIEW_INCLUDE_COLUMNS_ASC',
  TableViewIncludeColumnsDesc = 'TABLE_VIEW_INCLUDE_COLUMNS_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

/** A filter to be used against Date fields. All fields are combined with a logical ‘and.’ */
export type DateFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Date']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Date']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Date']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Date']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Date']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Date']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Date']['input']>>;
};

/** A filter to be used against Datetime fields. All fields are combined with a logical ‘and.’ */
export type DatetimeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Datetime']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Datetime']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Datetime']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Datetime']['input']>>;
};

export enum Decision {
  ChangesRequested = 'CHANGES_REQUESTED',
  Conform = 'CONFORM',
  ListOfQuestions = 'LIST_OF_QUESTIONS',
  NonConform = 'NON_CONFORM',
  NoDecision = 'NO_DECISION'
}

/** A filter to be used against Decision fields. All fields are combined with a logical ‘and.’ */
export type DecisionFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Decision>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Decision>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Decision>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Decision>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Decision>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Decision>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Decision>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Decision>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Decision>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Decision>>;
};

/** All input for the `deleteActionPluginByCode` mutation. */
export type DeleteActionPluginByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** All input for the `deleteActionPluginByNodeId` mutation. */
export type DeleteActionPluginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActionPlugin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteActionPlugin` mutation. */
export type DeleteActionPluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ActionPlugin` mutation. */
export type DeleteActionPluginPayload = {
  __typename?: 'DeleteActionPluginPayload';
  /** The `ActionPlugin` that was deleted by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedActionPluginNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ActionPlugin` mutation. */
export type DeleteActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the `deleteActionQueueByNodeId` mutation. */
export type DeleteActionQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActionQueue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteActionQueue` mutation. */
export type DeleteActionQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ActionQueue` mutation. */
export type DeleteActionQueuePayload = {
  __typename?: 'DeleteActionQueuePayload';
  /** The `ActionQueue` that was deleted by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
  /** Reads a single `Application` that is related to this `ActionQueue`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedActionQueueNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
};


/** The output of our delete `ActionQueue` mutation. */
export type DeleteActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the `deleteActivityLogByNodeId` mutation. */
export type DeleteActivityLogByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActivityLog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteActivityLog` mutation. */
export type DeleteActivityLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ActivityLog` mutation. */
export type DeleteActivityLogPayload = {
  __typename?: 'DeleteActivityLogPayload';
  /** The `ActivityLog` that was deleted by this mutation. */
  activityLog?: Maybe<ActivityLog>;
  /** An edge for our `ActivityLog`. May be used by Relay 1. */
  activityLogEdge?: Maybe<ActivityLogsEdge>;
  /** Reads a single `Application` that is related to this `ActivityLog`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedActivityLogNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ActivityLog` mutation. */
export type DeleteActivityLogPayloadActivityLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};

/** All input for the `deleteApplicationByNodeId` mutation. */
export type DeleteApplicationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Application` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationByOutcomeRegistration` mutation. */
export type DeleteApplicationByOutcomeRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  outcomeRegistration: Scalars['String']['input'];
};

/** All input for the `deleteApplicationBySerial` mutation. */
export type DeleteApplicationBySerialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  serial: Scalars['String']['input'];
};

/** All input for the `deleteApplication` mutation. */
export type DeleteApplicationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteApplicationNoteByNodeId` mutation. */
export type DeleteApplicationNoteByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationNote` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationNote` mutation. */
export type DeleteApplicationNoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationNote` mutation. */
export type DeleteApplicationNotePayload = {
  __typename?: 'DeleteApplicationNotePayload';
  /** Reads a single `Application` that is related to this `ApplicationNote`. */
  application?: Maybe<Application>;
  /** The `ApplicationNote` that was deleted by this mutation. */
  applicationNote?: Maybe<ApplicationNote>;
  /** An edge for our `ApplicationNote`. May be used by Relay 1. */
  applicationNoteEdge?: Maybe<ApplicationNotesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationNoteNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `ApplicationNote`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserList` that is related to this `ApplicationNote`. */
  user?: Maybe<UserList>;
};


/** The output of our delete `ApplicationNote` mutation. */
export type DeleteApplicationNotePayloadApplicationNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};

/** The output of our delete `Application` mutation. */
export type DeleteApplicationPayload = {
  __typename?: 'DeleteApplicationPayload';
  /** The `Application` that was deleted by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `UserList` that is related to this `Application`. */
  user?: Maybe<UserList>;
};


/** The output of our delete `Application` mutation. */
export type DeleteApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the `deleteApplicationResponseByNodeId` mutation. */
export type DeleteApplicationResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationResponse` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationResponse` mutation. */
export type DeleteApplicationResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationResponse` mutation. */
export type DeleteApplicationResponsePayload = {
  __typename?: 'DeleteApplicationResponsePayload';
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** The `ApplicationResponse` that was deleted by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationResponseNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our delete `ApplicationResponse` mutation. */
export type DeleteApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the `deleteApplicationReviewerActionByNodeId` mutation. */
export type DeleteApplicationReviewerActionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationReviewerAction` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationReviewerActionByUserIdAndApplicationId` mutation. */
export type DeleteApplicationReviewerActionByUserIdAndApplicationIdInput = {
  applicationId: Scalars['Int']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  userId: Scalars['Int']['input'];
};

/** All input for the `deleteApplicationReviewerAction` mutation. */
export type DeleteApplicationReviewerActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationReviewerAction` mutation. */
export type DeleteApplicationReviewerActionPayload = {
  __typename?: 'DeleteApplicationReviewerActionPayload';
  /** Reads a single `Application` that is related to this `ApplicationReviewerAction`. */
  application?: Maybe<Application>;
  /** The `ApplicationReviewerAction` that was deleted by this mutation. */
  applicationReviewerAction?: Maybe<ApplicationReviewerAction>;
  /** An edge for our `ApplicationReviewerAction`. May be used by Relay 1. */
  applicationReviewerActionEdge?: Maybe<ApplicationReviewerActionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationReviewerActionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ApplicationReviewerAction` mutation. */
export type DeleteApplicationReviewerActionPayloadApplicationReviewerActionEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationReviewerActionsOrderBy>>;
};

/** All input for the `deleteApplicationStageHistoryByNodeId` mutation. */
export type DeleteApplicationStageHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationStageHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryPayload = {
  __typename?: 'DeleteApplicationStageHistoryPayload';
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** The `ApplicationStageHistory` that was deleted by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationStageHistoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
};


/** The output of our delete `ApplicationStageHistory` mutation. */
export type DeleteApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the `deleteApplicationStatusHistoryByNodeId` mutation. */
export type DeleteApplicationStatusHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationStatusHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryPayload = {
  __typename?: 'DeleteApplicationStatusHistoryPayload';
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** The `ApplicationStatusHistory` that was deleted by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedApplicationStatusHistoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ApplicationStatusHistory` mutation. */
export type DeleteApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the `deleteCounterByName` mutation. */
export type DeleteCounterByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteCounterByNodeId` mutation. */
export type DeleteCounterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Counter` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteCounter` mutation. */
export type DeleteCounterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Counter` mutation. */
export type DeleteCounterPayload = {
  __typename?: 'DeleteCounterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Counter` that was deleted by this mutation. */
  counter?: Maybe<Counter>;
  /** An edge for our `Counter`. May be used by Relay 1. */
  counterEdge?: Maybe<CountersEdge>;
  deletedCounterNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Counter` mutation. */
export type DeleteCounterPayloadCounterEdgeArgs = {
  orderBy?: InputMaybe<Array<CountersOrderBy>>;
};

/** All input for the `deleteDataChangelogByNodeId` mutation. */
export type DeleteDataChangelogByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataChangelog` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataChangelog` mutation. */
export type DeleteDataChangelogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataChangelog` mutation. */
export type DeleteDataChangelogPayload = {
  __typename?: 'DeleteDataChangelogPayload';
  /** Reads a single `Application` that is related to this `DataChangelog`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataChangelog` that was deleted by this mutation. */
  dataChangelog?: Maybe<DataChangelog>;
  /** An edge for our `DataChangelog`. May be used by Relay 1. */
  dataChangelogEdge?: Maybe<DataChangelogsEdge>;
  deletedDataChangelogNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `DataChangelog`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataChangelog` mutation. */
export type DeleteDataChangelogPayloadDataChangelogEdgeArgs = {
  orderBy?: InputMaybe<Array<DataChangelogsOrderBy>>;
};

/** All input for the `deleteDataTableActiveIngredientByNodeId` mutation. */
export type DeleteDataTableActiveIngredientByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableActiveIngredient` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableActiveIngredient` mutation. */
export type DeleteDataTableActiveIngredientInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableActiveIngredient` mutation. */
export type DeleteDataTableActiveIngredientPayload = {
  __typename?: 'DeleteDataTableActiveIngredientPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableActiveIngredient` that was deleted by this mutation. */
  dataTableActiveIngredient?: Maybe<DataTableActiveIngredient>;
  /** An edge for our `DataTableActiveIngredient`. May be used by Relay 1. */
  dataTableActiveIngredientEdge?: Maybe<DataTableActiveIngredientsEdge>;
  deletedDataTableActiveIngredientNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableActiveIngredient` mutation. */
export type DeleteDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableActiveIngredientsOrderBy>>;
};

/** All input for the `deleteDataTableAdministrationRouteByNodeId` mutation. */
export type DeleteDataTableAdministrationRouteByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAdministrationRoute` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableAdministrationRoute` mutation. */
export type DeleteDataTableAdministrationRouteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableAdministrationRoute` mutation. */
export type DeleteDataTableAdministrationRoutePayload = {
  __typename?: 'DeleteDataTableAdministrationRoutePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAdministrationRoute` that was deleted by this mutation. */
  dataTableAdministrationRoute?: Maybe<DataTableAdministrationRoute>;
  /** An edge for our `DataTableAdministrationRoute`. May be used by Relay 1. */
  dataTableAdministrationRouteEdge?: Maybe<DataTableAdministrationRoutesEdge>;
  deletedDataTableAdministrationRouteNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableAdministrationRoute` mutation. */
export type DeleteDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAdministrationRoutesOrderBy>>;
};

/** All input for the `deleteDataTableAtcCodeByNodeId` mutation. */
export type DeleteDataTableAtcCodeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAtcCode` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableAtcCode` mutation. */
export type DeleteDataTableAtcCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableAtcCode` mutation. */
export type DeleteDataTableAtcCodePayload = {
  __typename?: 'DeleteDataTableAtcCodePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcCode` that was deleted by this mutation. */
  dataTableAtcCode?: Maybe<DataTableAtcCode>;
  /** An edge for our `DataTableAtcCode`. May be used by Relay 1. */
  dataTableAtcCodeEdge?: Maybe<DataTableAtcCodesEdge>;
  deletedDataTableAtcCodeNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableAtcCode` mutation. */
export type DeleteDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcCodesOrderBy>>;
};

/** All input for the `deleteDataTableByNodeId` mutation. */
export type DeleteDataTableByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTable` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableByTableName` mutation. */
export type DeleteDataTableByTableNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  tableName: Scalars['String']['input'];
};

/** All input for the `deleteDataTableContainerByNodeId` mutation. */
export type DeleteDataTableContainerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableContainer` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableContainer` mutation. */
export type DeleteDataTableContainerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableContainer` mutation. */
export type DeleteDataTableContainerPayload = {
  __typename?: 'DeleteDataTableContainerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableContainer` that was deleted by this mutation. */
  dataTableContainer?: Maybe<DataTableContainer>;
  /** An edge for our `DataTableContainer`. May be used by Relay 1. */
  dataTableContainerEdge?: Maybe<DataTableContainersEdge>;
  deletedDataTableContainerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableContainer` mutation. */
export type DeleteDataTableContainerPayloadDataTableContainerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableContainersOrderBy>>;
};

/** All input for the `deleteDataTableCountryByNodeId` mutation. */
export type DeleteDataTableCountryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableCountry` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableCountry` mutation. */
export type DeleteDataTableCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableCountry` mutation. */
export type DeleteDataTableCountryPayload = {
  __typename?: 'DeleteDataTableCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableCountry` that was deleted by this mutation. */
  dataTableCountry?: Maybe<DataTableCountry>;
  /** An edge for our `DataTableCountry`. May be used by Relay 1. */
  dataTableCountryEdge?: Maybe<DataTableCountriesEdge>;
  deletedDataTableCountryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableCountry` mutation. */
export type DeleteDataTableCountryPayloadDataTableCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableCountriesOrderBy>>;
};

/** All input for the `deleteDataTableDosageFormByNodeId` mutation. */
export type DeleteDataTableDosageFormByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableDosageForm` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableDosageFormGroupByNodeId` mutation. */
export type DeleteDataTableDosageFormGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableDosageFormGroup` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableDosageFormGroup` mutation. */
export type DeleteDataTableDosageFormGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableDosageFormGroup` mutation. */
export type DeleteDataTableDosageFormGroupPayload = {
  __typename?: 'DeleteDataTableDosageFormGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageFormGroup` that was deleted by this mutation. */
  dataTableDosageFormGroup?: Maybe<DataTableDosageFormGroup>;
  /** An edge for our `DataTableDosageFormGroup`. May be used by Relay 1. */
  dataTableDosageFormGroupEdge?: Maybe<DataTableDosageFormGroupsEdge>;
  deletedDataTableDosageFormGroupNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableDosageFormGroup` mutation. */
export type DeleteDataTableDosageFormGroupPayloadDataTableDosageFormGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormGroupsOrderBy>>;
};

/** All input for the `deleteDataTableDosageForm` mutation. */
export type DeleteDataTableDosageFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableDosageForm` mutation. */
export type DeleteDataTableDosageFormPayload = {
  __typename?: 'DeleteDataTableDosageFormPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageForm` that was deleted by this mutation. */
  dataTableDosageForm?: Maybe<DataTableDosageForm>;
  /** An edge for our `DataTableDosageForm`. May be used by Relay 1. */
  dataTableDosageFormEdge?: Maybe<DataTableDosageFormsEdge>;
  deletedDataTableDosageFormNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableDosageForm` mutation. */
export type DeleteDataTableDosageFormPayloadDataTableDosageFormEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormsOrderBy>>;
};

/** All input for the `deleteDataTableGenericIngredientByNodeId` mutation. */
export type DeleteDataTableGenericIngredientByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableGenericIngredient` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableGenericIngredient` mutation. */
export type DeleteDataTableGenericIngredientInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableGenericIngredient` mutation. */
export type DeleteDataTableGenericIngredientPayload = {
  __typename?: 'DeleteDataTableGenericIngredientPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableGenericIngredient` that was deleted by this mutation. */
  dataTableGenericIngredient?: Maybe<DataTableGenericIngredient>;
  /** An edge for our `DataTableGenericIngredient`. May be used by Relay 1. */
  dataTableGenericIngredientEdge?: Maybe<DataTableGenericIngredientsEdge>;
  deletedDataTableGenericIngredientNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableGenericIngredient` mutation. */
export type DeleteDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableGenericIngredientsOrderBy>>;
};

/** All input for the `deleteDataTable` mutation. */
export type DeleteDataTableInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** All input for the `deleteDataTableManufacturerApplicationJoinByNodeId` mutation. */
export type DeleteDataTableManufacturerApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturerApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableManufacturerApplicationJoin` mutation. */
export type DeleteDataTableManufacturerApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableManufacturerApplicationJoin` mutation. */
export type DeleteDataTableManufacturerApplicationJoinPayload = {
  __typename?: 'DeleteDataTableManufacturerApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableManufacturerApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableManufacturer` that is related to this `DataTableManufacturerApplicationJoin`. */
  dataTableManufacturer?: Maybe<DataTableManufacturer>;
  /** The `DataTableManufacturerApplicationJoin` that was deleted by this mutation. */
  dataTableManufacturerApplicationJoin?: Maybe<DataTableManufacturerApplicationJoin>;
  /** An edge for our `DataTableManufacturerApplicationJoin`. May be used by Relay 1. */
  dataTableManufacturerApplicationJoinEdge?: Maybe<DataTableManufacturerApplicationJoinsEdge>;
  deletedDataTableManufacturerApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableManufacturerApplicationJoin` mutation. */
export type DeleteDataTableManufacturerApplicationJoinPayloadDataTableManufacturerApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerApplicationJoinsOrderBy>>;
};

/** All input for the `deleteDataTableManufacturerByNodeId` mutation. */
export type DeleteDataTableManufacturerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturer` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableManufacturer` mutation. */
export type DeleteDataTableManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableManufacturer` mutation. */
export type DeleteDataTableManufacturerPayload = {
  __typename?: 'DeleteDataTableManufacturerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturer` that was deleted by this mutation. */
  dataTableManufacturer?: Maybe<DataTableManufacturer>;
  /** An edge for our `DataTableManufacturer`. May be used by Relay 1. */
  dataTableManufacturerEdge?: Maybe<DataTableManufacturersEdge>;
  deletedDataTableManufacturerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableManufacturer` mutation. */
export type DeleteDataTableManufacturerPayloadDataTableManufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturersOrderBy>>;
};

/** All input for the `deleteDataTableManufacturerRepresentativeApplicationJoinByNodeId` mutation. */
export type DeleteDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturerRepresentativeApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type DeleteDataTableManufacturerRepresentativeApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type DeleteDataTableManufacturerRepresentativeApplicationJoinPayload = {
  __typename?: 'DeleteDataTableManufacturerRepresentativeApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableManufacturerRepresentativeApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * Reads a single `DataTableManufacturerRepresentative` that is related to this
   * `DataTableManufacturerRepresentativeApplicationJoin`.
   */
  dataTableManufacturerRepresentative?: Maybe<DataTableManufacturerRepresentative>;
  /** The `DataTableManufacturerRepresentativeApplicationJoin` that was deleted by this mutation. */
  dataTableManufacturerRepresentativeApplicationJoin?: Maybe<DataTableManufacturerRepresentativeApplicationJoin>;
  /** An edge for our `DataTableManufacturerRepresentativeApplicationJoin`. May be used by Relay 1. */
  dataTableManufacturerRepresentativeApplicationJoinEdge?: Maybe<DataTableManufacturerRepresentativeApplicationJoinsEdge>;
  deletedDataTableManufacturerRepresentativeApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type DeleteDataTableManufacturerRepresentativeApplicationJoinPayloadDataTableManufacturerRepresentativeApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinsOrderBy>>;
};

/** All input for the `deleteDataTableManufacturerRepresentativeByNodeId` mutation. */
export type DeleteDataTableManufacturerRepresentativeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturerRepresentative` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableManufacturerRepresentative` mutation. */
export type DeleteDataTableManufacturerRepresentativeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableManufacturerRepresentative` mutation. */
export type DeleteDataTableManufacturerRepresentativePayload = {
  __typename?: 'DeleteDataTableManufacturerRepresentativePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturerRepresentative` that was deleted by this mutation. */
  dataTableManufacturerRepresentative?: Maybe<DataTableManufacturerRepresentative>;
  /** An edge for our `DataTableManufacturerRepresentative`. May be used by Relay 1. */
  dataTableManufacturerRepresentativeEdge?: Maybe<DataTableManufacturerRepresentativesEdge>;
  deletedDataTableManufacturerRepresentativeNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableManufacturerRepresentative` mutation. */
export type DeleteDataTableManufacturerRepresentativePayloadDataTableManufacturerRepresentativeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativesOrderBy>>;
};

/** The output of our delete `DataTable` mutation. */
export type DeleteDataTablePayload = {
  __typename?: 'DeleteDataTablePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTable` that was deleted by this mutation. */
  dataTable?: Maybe<DataTable>;
  /** An edge for our `DataTable`. May be used by Relay 1. */
  dataTableEdge?: Maybe<DataTablesEdge>;
  deletedDataTableNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTable` mutation. */
export type DeleteDataTablePayloadDataTableEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablesOrderBy>>;
};

/** All input for the `deleteDataTablePermitChemicalApplicationJoinByNodeId` mutation. */
export type DeleteDataTablePermitChemicalApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePermitChemicalApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTablePermitChemicalApplicationJoin` mutation. */
export type DeleteDataTablePermitChemicalApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTablePermitChemicalApplicationJoin` mutation. */
export type DeleteDataTablePermitChemicalApplicationJoinPayload = {
  __typename?: 'DeleteDataTablePermitChemicalApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTablePermitChemicalApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTablePermitChemical` that is related to this `DataTablePermitChemicalApplicationJoin`. */
  dataTablePermitChemical?: Maybe<DataTablePermitChemical>;
  /** The `DataTablePermitChemicalApplicationJoin` that was deleted by this mutation. */
  dataTablePermitChemicalApplicationJoin?: Maybe<DataTablePermitChemicalApplicationJoin>;
  /** An edge for our `DataTablePermitChemicalApplicationJoin`. May be used by Relay 1. */
  dataTablePermitChemicalApplicationJoinEdge?: Maybe<DataTablePermitChemicalApplicationJoinsEdge>;
  deletedDataTablePermitChemicalApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTablePermitChemicalApplicationJoin` mutation. */
export type DeleteDataTablePermitChemicalApplicationJoinPayloadDataTablePermitChemicalApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinsOrderBy>>;
};

/** All input for the `deleteDataTablePermitChemicalByNodeId` mutation. */
export type DeleteDataTablePermitChemicalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePermitChemical` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTablePermitChemical` mutation. */
export type DeleteDataTablePermitChemicalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTablePermitChemical` mutation. */
export type DeleteDataTablePermitChemicalPayload = {
  __typename?: 'DeleteDataTablePermitChemicalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePermitChemical` that was deleted by this mutation. */
  dataTablePermitChemical?: Maybe<DataTablePermitChemical>;
  /** An edge for our `DataTablePermitChemical`. May be used by Relay 1. */
  dataTablePermitChemicalEdge?: Maybe<DataTablePermitChemicalsEdge>;
  deletedDataTablePermitChemicalNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTablePermitChemical` mutation. */
export type DeleteDataTablePermitChemicalPayloadDataTablePermitChemicalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePermitChemicalsOrderBy>>;
};

/** All input for the `deleteDataTablePreRegisteredProductsProvisionalByNodeId` mutation. */
export type DeleteDataTablePreRegisteredProductsProvisionalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePreRegisteredProductsProvisional` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTablePreRegisteredProductsProvisional` mutation. */
export type DeleteDataTablePreRegisteredProductsProvisionalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTablePreRegisteredProductsProvisional` mutation. */
export type DeleteDataTablePreRegisteredProductsProvisionalPayload = {
  __typename?: 'DeleteDataTablePreRegisteredProductsProvisionalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePreRegisteredProductsProvisional` that was deleted by this mutation. */
  dataTablePreRegisteredProductsProvisional?: Maybe<DataTablePreRegisteredProductsProvisional>;
  /** An edge for our `DataTablePreRegisteredProductsProvisional`. May be used by Relay 1. */
  dataTablePreRegisteredProductsProvisionalEdge?: Maybe<DataTablePreRegisteredProductsProvisionalsEdge>;
  deletedDataTablePreRegisteredProductsProvisionalNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTablePreRegisteredProductsProvisional` mutation. */
export type DeleteDataTablePreRegisteredProductsProvisionalPayloadDataTablePreRegisteredProductsProvisionalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePreRegisteredProductsProvisionalsOrderBy>>;
};

/** All input for the `deleteDataTablePrequalManufacturerApplicationJoinByNodeId` mutation. */
export type DeleteDataTablePrequalManufacturerApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePrequalManufacturerApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTablePrequalManufacturerApplicationJoin` mutation. */
export type DeleteDataTablePrequalManufacturerApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTablePrequalManufacturerApplicationJoin` mutation. */
export type DeleteDataTablePrequalManufacturerApplicationJoinPayload = {
  __typename?: 'DeleteDataTablePrequalManufacturerApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTablePrequalManufacturerApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTablePrequalManufacturer` that is related to this `DataTablePrequalManufacturerApplicationJoin`. */
  dataTablePrequalManufacturer?: Maybe<DataTablePrequalManufacturer>;
  /** The `DataTablePrequalManufacturerApplicationJoin` that was deleted by this mutation. */
  dataTablePrequalManufacturerApplicationJoin?: Maybe<DataTablePrequalManufacturerApplicationJoin>;
  /** An edge for our `DataTablePrequalManufacturerApplicationJoin`. May be used by Relay 1. */
  dataTablePrequalManufacturerApplicationJoinEdge?: Maybe<DataTablePrequalManufacturerApplicationJoinsEdge>;
  deletedDataTablePrequalManufacturerApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTablePrequalManufacturerApplicationJoin` mutation. */
export type DeleteDataTablePrequalManufacturerApplicationJoinPayloadDataTablePrequalManufacturerApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinsOrderBy>>;
};

/** All input for the `deleteDataTablePrequalManufacturerByNodeId` mutation. */
export type DeleteDataTablePrequalManufacturerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePrequalManufacturer` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTablePrequalManufacturer` mutation. */
export type DeleteDataTablePrequalManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTablePrequalManufacturer` mutation. */
export type DeleteDataTablePrequalManufacturerPayload = {
  __typename?: 'DeleteDataTablePrequalManufacturerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePrequalManufacturer` that was deleted by this mutation. */
  dataTablePrequalManufacturer?: Maybe<DataTablePrequalManufacturer>;
  /** An edge for our `DataTablePrequalManufacturer`. May be used by Relay 1. */
  dataTablePrequalManufacturerEdge?: Maybe<DataTablePrequalManufacturersEdge>;
  deletedDataTablePrequalManufacturerNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTablePrequalManufacturer` mutation. */
export type DeleteDataTablePrequalManufacturerPayloadDataTablePrequalManufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturersOrderBy>>;
};

/** All input for the `deleteDataTableProcessingStepByNodeId` mutation. */
export type DeleteDataTableProcessingStepByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProcessingStep` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProcessingStep` mutation. */
export type DeleteDataTableProcessingStepInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProcessingStep` mutation. */
export type DeleteDataTableProcessingStepPayload = {
  __typename?: 'DeleteDataTableProcessingStepPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProcessingStep` that was deleted by this mutation. */
  dataTableProcessingStep?: Maybe<DataTableProcessingStep>;
  /** An edge for our `DataTableProcessingStep`. May be used by Relay 1. */
  dataTableProcessingStepEdge?: Maybe<DataTableProcessingStepsEdge>;
  deletedDataTableProcessingStepNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProcessingStep` mutation. */
export type DeleteDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProcessingStepsOrderBy>>;
};

/** All input for the `deleteDataTableProductApplicationJoinByNodeId` mutation. */
export type DeleteDataTableProductApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProductApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProductApplicationJoin` mutation. */
export type DeleteDataTableProductApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProductApplicationJoin` mutation. */
export type DeleteDataTableProductApplicationJoinPayload = {
  __typename?: 'DeleteDataTableProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProductApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProductApplicationJoin` that was deleted by this mutation. */
  dataTableProductApplicationJoin?: Maybe<DataTableProductApplicationJoin>;
  /** An edge for our `DataTableProductApplicationJoin`. May be used by Relay 1. */
  dataTableProductApplicationJoinEdge?: Maybe<DataTableProductApplicationJoinsEdge>;
  deletedDataTableProductApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProductApplicationJoin` mutation. */
export type DeleteDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};

/** All input for the `deleteDataTableProductByNodeId` mutation. */
export type DeleteDataTableProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProduct` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProduct` mutation. */
export type DeleteDataTableProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProduct` mutation. */
export type DeleteDataTableProductPayload = {
  __typename?: 'DeleteDataTableProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProduct` that was deleted by this mutation. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** An edge for our `DataTableProduct`. May be used by Relay 1. */
  dataTableProductEdge?: Maybe<DataTableProductsEdge>;
  deletedDataTableProductNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProduct` mutation. */
export type DeleteDataTableProductPayloadDataTableProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductsOrderBy>>;
};

/** All input for the `deleteDataTableProvisionalProductApplicationJoinByNodeId` mutation. */
export type DeleteDataTableProvisionalProductApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProvisionalProductApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProvisionalProductApplicationJoin` mutation. */
export type DeleteDataTableProvisionalProductApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProvisionalProductApplicationJoin` mutation. */
export type DeleteDataTableProvisionalProductApplicationJoinPayload = {
  __typename?: 'DeleteDataTableProvisionalProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProvisionalProductApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableProvisionalProduct` that is related to this `DataTableProvisionalProductApplicationJoin`. */
  dataTableProvisionalProduct?: Maybe<DataTableProvisionalProduct>;
  /** The `DataTableProvisionalProductApplicationJoin` that was deleted by this mutation. */
  dataTableProvisionalProductApplicationJoin?: Maybe<DataTableProvisionalProductApplicationJoin>;
  /** An edge for our `DataTableProvisionalProductApplicationJoin`. May be used by Relay 1. */
  dataTableProvisionalProductApplicationJoinEdge?: Maybe<DataTableProvisionalProductApplicationJoinsEdge>;
  deletedDataTableProvisionalProductApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProvisionalProductApplicationJoin` mutation. */
export type DeleteDataTableProvisionalProductApplicationJoinPayloadDataTableProvisionalProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinsOrderBy>>;
};

/** All input for the `deleteDataTableProvisionalProductByNodeId` mutation. */
export type DeleteDataTableProvisionalProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProvisionalProduct` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableProvisionalProduct` mutation. */
export type DeleteDataTableProvisionalProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableProvisionalProduct` mutation. */
export type DeleteDataTableProvisionalProductPayload = {
  __typename?: 'DeleteDataTableProvisionalProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProvisionalProduct` that was deleted by this mutation. */
  dataTableProvisionalProduct?: Maybe<DataTableProvisionalProduct>;
  /** An edge for our `DataTableProvisionalProduct`. May be used by Relay 1. */
  dataTableProvisionalProductEdge?: Maybe<DataTableProvisionalProductsEdge>;
  deletedDataTableProvisionalProductNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableProvisionalProduct` mutation. */
export type DeleteDataTableProvisionalProductPayloadDataTableProvisionalProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvisionalProductsOrderBy>>;
};

/** All input for the `deleteDataTableScheduledChemicalByNodeId` mutation. */
export type DeleteDataTableScheduledChemicalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableScheduledChemical` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableScheduledChemical` mutation. */
export type DeleteDataTableScheduledChemicalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableScheduledChemical` mutation. */
export type DeleteDataTableScheduledChemicalPayload = {
  __typename?: 'DeleteDataTableScheduledChemicalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableScheduledChemical` that was deleted by this mutation. */
  dataTableScheduledChemical?: Maybe<DataTableScheduledChemical>;
  /** An edge for our `DataTableScheduledChemical`. May be used by Relay 1. */
  dataTableScheduledChemicalEdge?: Maybe<DataTableScheduledChemicalsEdge>;
  deletedDataTableScheduledChemicalNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableScheduledChemical` mutation. */
export type DeleteDataTableScheduledChemicalPayloadDataTableScheduledChemicalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableScheduledChemicalsOrderBy>>;
};

/** All input for the `deleteDataTableStorageConditionByNodeId` mutation. */
export type DeleteDataTableStorageConditionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableStorageCondition` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableStorageCondition` mutation. */
export type DeleteDataTableStorageConditionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableStorageCondition` mutation. */
export type DeleteDataTableStorageConditionPayload = {
  __typename?: 'DeleteDataTableStorageConditionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageCondition` that was deleted by this mutation. */
  dataTableStorageCondition?: Maybe<DataTableStorageCondition>;
  /** An edge for our `DataTableStorageCondition`. May be used by Relay 1. */
  dataTableStorageConditionEdge?: Maybe<DataTableStorageConditionsEdge>;
  deletedDataTableStorageConditionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableStorageCondition` mutation. */
export type DeleteDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsOrderBy>>;
};

/** All input for the `deleteDataTableStorageConditionsSimplifiedByNodeId` mutation. */
export type DeleteDataTableStorageConditionsSimplifiedByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableStorageConditionsSimplified` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableStorageConditionsSimplified` mutation. */
export type DeleteDataTableStorageConditionsSimplifiedInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableStorageConditionsSimplified` mutation. */
export type DeleteDataTableStorageConditionsSimplifiedPayload = {
  __typename?: 'DeleteDataTableStorageConditionsSimplifiedPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageConditionsSimplified` that was deleted by this mutation. */
  dataTableStorageConditionsSimplified?: Maybe<DataTableStorageConditionsSimplified>;
  /** An edge for our `DataTableStorageConditionsSimplified`. May be used by Relay 1. */
  dataTableStorageConditionsSimplifiedEdge?: Maybe<DataTableStorageConditionsSimplifiedsEdge>;
  deletedDataTableStorageConditionsSimplifiedNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableStorageConditionsSimplified` mutation. */
export type DeleteDataTableStorageConditionsSimplifiedPayloadDataTableStorageConditionsSimplifiedEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsSimplifiedsOrderBy>>;
};

/** All input for the `deleteDataTableUnitsOfProportionByNodeId` mutation. */
export type DeleteDataTableUnitsOfProportionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableUnitsOfProportion` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableUnitsOfProportion` mutation. */
export type DeleteDataTableUnitsOfProportionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableUnitsOfProportion` mutation. */
export type DeleteDataTableUnitsOfProportionPayload = {
  __typename?: 'DeleteDataTableUnitsOfProportionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableUnitsOfProportion` that was deleted by this mutation. */
  dataTableUnitsOfProportion?: Maybe<DataTableUnitsOfProportion>;
  /** An edge for our `DataTableUnitsOfProportion`. May be used by Relay 1. */
  dataTableUnitsOfProportionEdge?: Maybe<DataTableUnitsOfProportionsEdge>;
  deletedDataTableUnitsOfProportionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableUnitsOfProportion` mutation. */
export type DeleteDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableUnitsOfProportionsOrderBy>>;
};

/** All input for the `deleteDataTableWorldHealthOrganisationPqListOfFppByNodeId` mutation. */
export type DeleteDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableWorldHealthOrganisationPqListOfFpp` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type DeleteDataTableWorldHealthOrganisationPqListOfFppInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type DeleteDataTableWorldHealthOrganisationPqListOfFppPayload = {
  __typename?: 'DeleteDataTableWorldHealthOrganisationPqListOfFppPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableWorldHealthOrganisationPqListOfFpp` that was deleted by this mutation. */
  dataTableWorldHealthOrganisationPqListOfFpp?: Maybe<DataTableWorldHealthOrganisationPqListOfFpp>;
  /** An edge for our `DataTableWorldHealthOrganisationPqListOfFpp`. May be used by Relay 1. */
  dataTableWorldHealthOrganisationPqListOfFppEdge?: Maybe<DataTableWorldHealthOrganisationPqListOfFppsEdge>;
  deletedDataTableWorldHealthOrganisationPqListOfFppNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type DeleteDataTableWorldHealthOrganisationPqListOfFppPayloadDataTableWorldHealthOrganisationPqListOfFppEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableWorldHealthOrganisationPqListOfFppsOrderBy>>;
};

/** All input for the `deleteDataViewByIdentifier` mutation. */
export type DeleteDataViewByIdentifierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  identifier: Scalars['String']['input'];
};

/** All input for the `deleteDataViewByNodeId` mutation. */
export type DeleteDataViewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataView` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataViewColumnDefinitionByNodeId` mutation. */
export type DeleteDataViewColumnDefinitionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataViewColumnDefinition` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteDataViewColumnDefinitionByTableNameAndColumnName` mutation. */
export type DeleteDataViewColumnDefinitionByTableNameAndColumnNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  columnName: Scalars['String']['input'];
  tableName: Scalars['String']['input'];
};

/** All input for the `deleteDataViewColumnDefinition` mutation. */
export type DeleteDataViewColumnDefinitionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataViewColumnDefinition` mutation. */
export type DeleteDataViewColumnDefinitionPayload = {
  __typename?: 'DeleteDataViewColumnDefinitionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataViewColumnDefinition` that was deleted by this mutation. */
  dataViewColumnDefinition?: Maybe<DataViewColumnDefinition>;
  /** An edge for our `DataViewColumnDefinition`. May be used by Relay 1. */
  dataViewColumnDefinitionEdge?: Maybe<DataViewColumnDefinitionsEdge>;
  deletedDataViewColumnDefinitionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataViewColumnDefinition` mutation. */
export type DeleteDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewColumnDefinitionsOrderBy>>;
};

/** All input for the `deleteDataView` mutation. */
export type DeleteDataViewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `DataView` mutation. */
export type DeleteDataViewPayload = {
  __typename?: 'DeleteDataViewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataView` that was deleted by this mutation. */
  dataView?: Maybe<DataView>;
  /** An edge for our `DataView`. May be used by Relay 1. */
  dataViewEdge?: Maybe<DataViewsEdge>;
  deletedDataViewNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `DataView` mutation. */
export type DeleteDataViewPayloadDataViewEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewsOrderBy>>;
};

/** All input for the `deleteElementTypePluginByNodeId` mutation. */
export type DeleteElementTypePluginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ElementTypePlugin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteElementTypePlugin` mutation. */
export type DeleteElementTypePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** The output of our delete `ElementTypePlugin` mutation. */
export type DeleteElementTypePluginPayload = {
  __typename?: 'DeleteElementTypePluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedElementTypePluginNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `ElementTypePlugin` that was deleted by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `ElementTypePlugin` mutation. */
export type DeleteElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the `deleteFileByNodeId` mutation. */
export type DeleteFileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `File` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFileByUniqueId` mutation. */
export type DeleteFileByUniqueIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uniqueId: Scalars['String']['input'];
};

/** All input for the `deleteFile` mutation. */
export type DeleteFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `File` mutation. */
export type DeleteFilePayload = {
  __typename?: 'DeleteFilePayload';
  /** Reads a single `Application` that is related to this `File`. */
  applicationByApplicationSerial?: Maybe<Application>;
  /** Reads a single `ApplicationNote` that is related to this `File`. */
  applicationNote?: Maybe<ApplicationNote>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFileNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `File` that was deleted by this mutation. */
  file?: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `File`. */
  template?: Maybe<Template>;
};


/** The output of our delete `File` mutation. */
export type DeleteFilePayloadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};

/** All input for the `deleteFilterByCode` mutation. */
export type DeleteFilterByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** All input for the `deleteFilterByNodeId` mutation. */
export type DeleteFilterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Filter` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteFilter` mutation. */
export type DeleteFilterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Filter` mutation. */
export type DeleteFilterPayload = {
  __typename?: 'DeleteFilterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedFilterNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Filter` that was deleted by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Filter` mutation. */
export type DeleteFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the `deleteGrafanaDashboardImageByNodeId` mutation. */
export type DeleteGrafanaDashboardImageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `GrafanaDashboardImage` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteGrafanaDashboardImage` mutation. */
export type DeleteGrafanaDashboardImageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};

/** The output of our delete `GrafanaDashboardImage` mutation. */
export type DeleteGrafanaDashboardImagePayload = {
  __typename?: 'DeleteGrafanaDashboardImagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedGrafanaDashboardImageNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `GrafanaDashboardImage` that was deleted by this mutation. */
  grafanaDashboardImage?: Maybe<GrafanaDashboardImage>;
  /** An edge for our `GrafanaDashboardImage`. May be used by Relay 1. */
  grafanaDashboardImageEdge?: Maybe<GrafanaDashboardImagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `GrafanaDashboardImage` mutation. */
export type DeleteGrafanaDashboardImagePayloadGrafanaDashboardImageEdgeArgs = {
  orderBy?: InputMaybe<Array<GrafanaDashboardImagesOrderBy>>;
};

/** All input for the `deleteNotificationByNodeId` mutation. */
export type DeleteNotificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Notification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteNotification` mutation. */
export type DeleteNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayload = {
  __typename?: 'DeleteNotificationPayload';
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedNotificationNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Notification` that was deleted by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
};


/** The output of our delete `Notification` mutation. */
export type DeleteNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the `deleteOrganisationApplicationJoinByNodeId` mutation. */
export type DeleteOrganisationApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganisationApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganisationApplicationJoin` mutation. */
export type DeleteOrganisationApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `OrganisationApplicationJoin` mutation. */
export type DeleteOrganisationApplicationJoinPayload = {
  __typename?: 'DeleteOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `OrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedOrganisationApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `OrganisationApplicationJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `OrganisationApplicationJoin` that was deleted by this mutation. */
  organisationApplicationJoin?: Maybe<OrganisationApplicationJoin>;
  /** An edge for our `OrganisationApplicationJoin`. May be used by Relay 1. */
  organisationApplicationJoinEdge?: Maybe<OrganisationApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `OrganisationApplicationJoin` mutation. */
export type DeleteOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};

/** All input for the `deleteOrganisationByName` mutation. */
export type DeleteOrganisationByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deleteOrganisationByNodeId` mutation. */
export type DeleteOrganisationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organisation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteOrganisationByRegistration` mutation. */
export type DeleteOrganisationByRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  registration: Scalars['String']['input'];
};

/** All input for the `deleteOrganisation` mutation. */
export type DeleteOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Organisation` mutation. */
export type DeleteOrganisationPayload = {
  __typename?: 'DeleteOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedOrganisationNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `Organisation` that was deleted by this mutation. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `Organisation` mutation. */
export type DeleteOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationsOrderBy>>;
};

/** All input for the `deletePermissionJoinByNodeId` mutation. */
export type DeletePermissionJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePermissionJoin` mutation. */
export type DeletePermissionJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `PermissionJoin` mutation. */
export type DeletePermissionJoinPayload = {
  __typename?: 'DeletePermissionJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPermissionJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `PermissionJoin` that was deleted by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserList` that is related to this `PermissionJoin`. */
  user?: Maybe<UserList>;
};


/** The output of our delete `PermissionJoin` mutation. */
export type DeletePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the `deletePermissionNameByName` mutation. */
export type DeletePermissionNameByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deletePermissionNameByNodeId` mutation. */
export type DeletePermissionNameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionName` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePermissionName` mutation. */
export type DeletePermissionNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `PermissionName` mutation. */
export type DeletePermissionNamePayload = {
  __typename?: 'DeletePermissionNamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPermissionNameNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `PermissionName` that was deleted by this mutation. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PermissionName` mutation. */
export type DeletePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the `deletePermissionPolicyByName` mutation. */
export type DeletePermissionPolicyByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** All input for the `deletePermissionPolicyByNodeId` mutation. */
export type DeletePermissionPolicyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionPolicy` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deletePermissionPolicy` mutation. */
export type DeletePermissionPolicyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `PermissionPolicy` mutation. */
export type DeletePermissionPolicyPayload = {
  __typename?: 'DeletePermissionPolicyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedPermissionPolicyNodeId?: Maybe<Scalars['ID']['output']>;
  /** The `PermissionPolicy` that was deleted by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our delete `PermissionPolicy` mutation. */
export type DeletePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the `deleteReviewAssignmentAssignerJoinByNodeId` mutation. */
export type DeleteReviewAssignmentAssignerJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignmentAssignerJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewAssignmentAssignerJoin` mutation. */
export type DeleteReviewAssignmentAssignerJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewAssignmentAssignerJoin` mutation. */
export type DeleteReviewAssignmentAssignerJoinPayload = {
  __typename?: 'DeleteReviewAssignmentAssignerJoinPayload';
  /** Reads a single `UserList` that is related to this `ReviewAssignmentAssignerJoin`. */
  assigner?: Maybe<UserList>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewAssignmentAssignerJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignmentAssignerJoin`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewAssignmentAssignerJoin`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** The `ReviewAssignmentAssignerJoin` that was deleted by this mutation. */
  reviewAssignmentAssignerJoin?: Maybe<ReviewAssignmentAssignerJoin>;
  /** An edge for our `ReviewAssignmentAssignerJoin`. May be used by Relay 1. */
  reviewAssignmentAssignerJoinEdge?: Maybe<ReviewAssignmentAssignerJoinsEdge>;
};


/** The output of our delete `ReviewAssignmentAssignerJoin` mutation. */
export type DeleteReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};

/** All input for the `deleteReviewAssignmentByNodeId` mutation. */
export type DeleteReviewAssignmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewAssignment` mutation. */
export type DeleteReviewAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewAssignment` mutation. */
export type DeleteReviewAssignmentPayload = {
  __typename?: 'DeleteReviewAssignmentPayload';
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** Reads a single `UserList` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<UserList>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewAssignmentNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `TemplateStageReviewLevel` that is related to this `ReviewAssignment`. */
  level?: Maybe<TemplateStageReviewLevel>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `ReviewAssignment` that was deleted by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
  /** Reads a single `UserList` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<UserList>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Template` that is related to this `ReviewAssignment`. */
  template?: Maybe<Template>;
};


/** The output of our delete `ReviewAssignment` mutation. */
export type DeleteReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the `deleteReviewByNodeId` mutation. */
export type DeleteReviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Review` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewByReviewAssignmentId` mutation. */
export type DeleteReviewByReviewAssignmentIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** All input for the `deleteReviewDecisionByNodeId` mutation. */
export type DeleteReviewDecisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewDecision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewDecision` mutation. */
export type DeleteReviewDecisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewDecision` mutation. */
export type DeleteReviewDecisionPayload = {
  __typename?: 'DeleteReviewDecisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewDecisionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** The `ReviewDecision` that was deleted by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our delete `ReviewDecision` mutation. */
export type DeleteReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the `deleteReview` mutation. */
export type DeleteReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Review` mutation. */
export type DeleteReviewPayload = {
  __typename?: 'DeleteReviewPayload';
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Review` that was deleted by this mutation. */
  review?: Maybe<Review>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
  /** Reads a single `UserList` that is related to this `Review`. */
  reviewer?: Maybe<UserList>;
};


/** The output of our delete `Review` mutation. */
export type DeleteReviewPayloadReviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the `deleteReviewResponseByNodeId` mutation. */
export type DeleteReviewResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewResponse` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewResponse` mutation. */
export type DeleteReviewResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewResponse` mutation. */
export type DeleteReviewResponsePayload = {
  __typename?: 'DeleteReviewResponsePayload';
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewResponseNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** The `ReviewResponse` that was deleted by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our delete `ReviewResponse` mutation. */
export type DeleteReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the `deleteReviewStatusHistoryByNodeId` mutation. */
export type DeleteReviewStatusHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewStatusHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `ReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryPayload = {
  __typename?: 'DeleteReviewStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedReviewStatusHistoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** The `ReviewStatusHistory` that was deleted by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our delete `ReviewStatusHistory` mutation. */
export type DeleteReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the `deleteSystemInfoByNodeId` mutation. */
export type DeleteSystemInfoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SystemInfo` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteSystemInfo` mutation. */
export type DeleteSystemInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `SystemInfo` mutation. */
export type DeleteSystemInfoPayload = {
  __typename?: 'DeleteSystemInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedSystemInfoNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemInfo` that was deleted by this mutation. */
  systemInfo?: Maybe<SystemInfo>;
  /** An edge for our `SystemInfo`. May be used by Relay 1. */
  systemInfoEdge?: Maybe<SystemInfosEdge>;
};


/** The output of our delete `SystemInfo` mutation. */
export type DeleteSystemInfoPayloadSystemInfoEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemInfosOrderBy>>;
};

/** All input for the `deleteTemplateActionByNodeId` mutation. */
export type DeleteTemplateActionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateAction` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateAction` mutation. */
export type DeleteTemplateActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateAction` mutation. */
export type DeleteTemplateActionPayload = {
  __typename?: 'DeleteTemplateActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateActionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** The `TemplateAction` that was deleted by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our delete `TemplateAction` mutation. */
export type DeleteTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the `deleteTemplateByCodeAndVersionId` mutation. */
export type DeleteTemplateByCodeAndVersionIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};

/** All input for the `deleteTemplateByNodeId` mutation. */
export type DeleteTemplateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Template` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateCategoryByCode` mutation. */
export type DeleteTemplateCategoryByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
};

/** All input for the `deleteTemplateCategoryByNodeId` mutation. */
export type DeleteTemplateCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateCategory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateCategory` mutation. */
export type DeleteTemplateCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateCategory` mutation. */
export type DeleteTemplateCategoryPayload = {
  __typename?: 'DeleteTemplateCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateCategoryNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TemplateCategory` that was deleted by this mutation. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `TemplateCategory`. May be used by Relay 1. */
  templateCategoryEdge?: Maybe<TemplateCategoriesEdge>;
};


/** The output of our delete `TemplateCategory` mutation. */
export type DeleteTemplateCategoryPayloadTemplateCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateCategoriesOrderBy>>;
};

/** All input for the `deleteTemplateElementByNodeId` mutation. */
export type DeleteTemplateElementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateElement` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateElementByTemplateCodeAndCodeAndTemplateVersion` mutation. */
export type DeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** All input for the `deleteTemplateElement` mutation. */
export type DeleteTemplateElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateElement` mutation. */
export type DeleteTemplateElementPayload = {
  __typename?: 'DeleteTemplateElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateElementNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** The `TemplateElement` that was deleted by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our delete `TemplateElement` mutation. */
export type DeleteTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the `deleteTemplateFilterJoinByNodeId` mutation. */
export type DeleteTemplateFilterJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateFilterJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateFilterJoin` mutation. */
export type DeleteTemplateFilterJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateFilterJoin` mutation. */
export type DeleteTemplateFilterJoinPayload = {
  __typename?: 'DeleteTemplateFilterJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateFilterJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Filter` that is related to this `TemplateFilterJoin`. */
  filter?: Maybe<Filter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateFilterJoin`. */
  template?: Maybe<Template>;
  /** The `TemplateFilterJoin` that was deleted by this mutation. */
  templateFilterJoin?: Maybe<TemplateFilterJoin>;
  /** An edge for our `TemplateFilterJoin`. May be used by Relay 1. */
  templateFilterJoinEdge?: Maybe<TemplateFilterJoinsEdge>;
};


/** The output of our delete `TemplateFilterJoin` mutation. */
export type DeleteTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};

/** All input for the `deleteTemplate` mutation. */
export type DeleteTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayload = {
  __typename?: 'DeleteTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Template` that was deleted by this mutation. */
  template?: Maybe<Template>;
  /** Reads a single `TemplateCategory` that is related to this `Template`. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our delete `Template` mutation. */
export type DeleteTemplatePayloadTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the `deleteTemplatePermissionByNodeId` mutation. */
export type DeleteTemplatePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplatePermission` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplatePermission` mutation. */
export type DeleteTemplatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplatePermission` mutation. */
export type DeleteTemplatePermissionPayload = {
  __typename?: 'DeleteTemplatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplatePermissionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** The `TemplatePermission` that was deleted by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our delete `TemplatePermission` mutation. */
export type DeleteTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the `deleteTemplateSectionByNodeId` mutation. */
export type DeleteTemplateSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateSection` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateSectionByTemplateIdAndCode` mutation. */
export type DeleteTemplateSectionByTemplateIdAndCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  templateId: Scalars['Int']['input'];
};

/** All input for the `deleteTemplateSection` mutation. */
export type DeleteTemplateSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateSection` mutation. */
export type DeleteTemplateSectionPayload = {
  __typename?: 'DeleteTemplateSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateSectionNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** The `TemplateSection` that was deleted by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our delete `TemplateSection` mutation. */
export type DeleteTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the `deleteTemplateStageByNodeId` mutation. */
export type DeleteTemplateStageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateStage` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateStage` mutation. */
export type DeleteTemplateStageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateStage` mutation. */
export type DeleteTemplateStagePayload = {
  __typename?: 'DeleteTemplateStagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateStageNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** The `TemplateStage` that was deleted by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our delete `TemplateStage` mutation. */
export type DeleteTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the `deleteTemplateStageReviewLevelByNodeId` mutation. */
export type DeleteTemplateStageReviewLevelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateStageReviewLevel` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTemplateStageReviewLevel` mutation. */
export type DeleteTemplateStageReviewLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TemplateStageReviewLevel` mutation. */
export type DeleteTemplateStageReviewLevelPayload = {
  __typename?: 'DeleteTemplateStageReviewLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTemplateStageReviewLevelNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `TemplateStageReviewLevel`. */
  stage?: Maybe<TemplateStage>;
  /** The `TemplateStageReviewLevel` that was deleted by this mutation. */
  templateStageReviewLevel?: Maybe<TemplateStageReviewLevel>;
  /** An edge for our `TemplateStageReviewLevel`. May be used by Relay 1. */
  templateStageReviewLevelEdge?: Maybe<TemplateStageReviewLevelsEdge>;
};


/** The output of our delete `TemplateStageReviewLevel` mutation. */
export type DeleteTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};

/** All input for the `deleteTriggerQueueByNodeId` mutation. */
export type DeleteTriggerQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TriggerQueue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTriggerQueue` mutation. */
export type DeleteTriggerQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TriggerQueue` mutation. */
export type DeleteTriggerQueuePayload = {
  __typename?: 'DeleteTriggerQueuePayload';
  /** Reads a single `Application` that is related to this `TriggerQueue`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTriggerQueueNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TriggerQueue` that was deleted by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our delete `TriggerQueue` mutation. */
export type DeleteTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the `deleteTriggerScheduleByNodeId` mutation. */
export type DeleteTriggerScheduleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TriggerSchedule` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteTriggerSchedule` mutation. */
export type DeleteTriggerScheduleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `TriggerSchedule` mutation. */
export type DeleteTriggerSchedulePayload = {
  __typename?: 'DeleteTriggerSchedulePayload';
  /** Reads a single `Application` that is related to this `TriggerSchedule`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedTriggerScheduleNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TriggerSchedule`. */
  template?: Maybe<Template>;
  /** The `TriggerSchedule` that was deleted by this mutation. */
  triggerSchedule?: Maybe<TriggerSchedule>;
  /** An edge for our `TriggerSchedule`. May be used by Relay 1. */
  triggerScheduleEdge?: Maybe<TriggerSchedulesEdge>;
};


/** The output of our delete `TriggerSchedule` mutation. */
export type DeleteTriggerSchedulePayloadTriggerScheduleEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};

/** All input for the `deleteUserApplicationJoinByNodeId` mutation. */
export type DeleteUserApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserApplicationJoin` mutation. */
export type DeleteUserApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `UserApplicationJoin` mutation. */
export type DeleteUserApplicationJoinPayload = {
  __typename?: 'DeleteUserApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserApplicationJoinNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserApplicationJoin` that was deleted by this mutation. */
  userApplicationJoin?: Maybe<UserApplicationJoin>;
  /** An edge for our `UserApplicationJoin`. May be used by Relay 1. */
  userApplicationJoinEdge?: Maybe<UserApplicationJoinsEdge>;
};


/** The output of our delete `UserApplicationJoin` mutation. */
export type DeleteUserApplicationJoinPayloadUserApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};

/** All input for the `deleteUserOrganisationByNodeId` mutation. */
export type DeleteUserOrganisationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserOrganisation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteUserOrganisation` mutation. */
export type DeleteUserOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `UserOrganisation` mutation. */
export type DeleteUserOrganisationPayload = {
  __typename?: 'DeleteUserOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedUserOrganisationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** The `UserOrganisation` that was deleted by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our delete `UserOrganisation` mutation. */
export type DeleteUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

/** All input for the `deleteVerificationByNodeId` mutation. */
export type DeleteVerificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Verification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** All input for the `deleteVerificationByUniqueId` mutation. */
export type DeleteVerificationByUniqueIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  uniqueId: Scalars['String']['input'];
};

/** All input for the `deleteVerification` mutation. */
export type DeleteVerificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
};

/** The output of our delete `Verification` mutation. */
export type DeleteVerificationPayload = {
  __typename?: 'DeleteVerificationPayload';
  /** Reads a single `Application` that is related to this `Verification`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  deletedVerificationNodeId?: Maybe<Scalars['ID']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Verification` that was deleted by this mutation. */
  verification?: Maybe<Verification>;
  /** An edge for our `Verification`. May be used by Relay 1. */
  verificationEdge?: Maybe<VerificationsEdge>;
};


/** The output of our delete `Verification` mutation. */
export type DeleteVerificationPayloadVerificationEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

/** All input for the `deleteWholeApplication` mutation. */
export type DeleteWholeApplicationInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
};

/** The output of our `deleteWholeApplication` mutation. */
export type DeleteWholeApplicationPayload = {
  __typename?: 'DeleteWholeApplicationPayload';
  boolean?: Maybe<Scalars['Boolean']['output']>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};

export type ElementTypePlugin = Node & {
  __typename?: 'ElementTypePlugin';
  category?: Maybe<TemplateElementCategory>;
  code: Scalars['String']['output'];
  configComponentName?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  displayComponentName?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  path?: Maybe<Scalars['String']['output']>;
  requiredParameters?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/**
 * A condition to be used against `ElementTypePlugin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ElementTypePluginCondition = {
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<TemplateElementCategory>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `configComponentName` field. */
  configComponentName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `displayComponentName` field. */
  displayComponentName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `path` field. */
  path?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `requiredParameters` field. */
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A filter to be used against `ElementTypePlugin` object types. All fields are combined with a logical ‘and.’ */
export type ElementTypePluginFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ElementTypePluginFilter>>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<TemplateElementCategoryFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `configComponentName` field. */
  configComponentName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `displayComponentName` field. */
  displayComponentName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ElementTypePluginFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ElementTypePluginFilter>>;
  /** Filter by the object’s `path` field. */
  path?: InputMaybe<StringFilter>;
  /** Filter by the object’s `requiredParameters` field. */
  requiredParameters?: InputMaybe<StringListFilter>;
};

/** An input for mutations affecting `ElementTypePlugin` */
export type ElementTypePluginInput = {
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  configComponentName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayComponentName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** Represents an update to a `ElementTypePlugin`. Fields that are set will be updated. */
export type ElementTypePluginPatch = {
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  configComponentName?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  displayComponentName?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  path?: InputMaybe<Scalars['String']['input']>;
  requiredParameters?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

/** A connection to a list of `ElementTypePlugin` values. */
export type ElementTypePluginsConnection = {
  __typename?: 'ElementTypePluginsConnection';
  /** A list of edges which contains the `ElementTypePlugin` and cursor to aid in pagination. */
  edges: Array<ElementTypePluginsEdge>;
  /** A list of `ElementTypePlugin` objects. */
  nodes: Array<Maybe<ElementTypePlugin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ElementTypePlugin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ElementTypePlugin` edge in the connection. */
export type ElementTypePluginsEdge = {
  __typename?: 'ElementTypePluginsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ElementTypePlugin` at the end of the edge. */
  node?: Maybe<ElementTypePlugin>;
};

/** Methods to use when ordering `ElementTypePlugin`. */
export enum ElementTypePluginsOrderBy {
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  ConfigComponentNameAsc = 'CONFIG_COMPONENT_NAME_ASC',
  ConfigComponentNameDesc = 'CONFIG_COMPONENT_NAME_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  DisplayComponentNameAsc = 'DISPLAY_COMPONENT_NAME_ASC',
  DisplayComponentNameDesc = 'DISPLAY_COMPONENT_NAME_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PathAsc = 'PATH_ASC',
  PathDesc = 'PATH_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RequiredParametersAsc = 'REQUIRED_PARAMETERS_ASC',
  RequiredParametersDesc = 'REQUIRED_PARAMETERS_DESC'
}

export enum EventType {
  Assignment = 'ASSIGNMENT',
  Extension = 'EXTENSION',
  Outcome = 'OUTCOME',
  Permission = 'PERMISSION',
  Review = 'REVIEW',
  ReviewDecision = 'REVIEW_DECISION',
  Stage = 'STAGE',
  Status = 'STATUS'
}

/** A filter to be used against EventType fields. All fields are combined with a logical ‘and.’ */
export type EventTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<EventType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<EventType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<EventType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<EventType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<EventType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<EventType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<EventType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<EventType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<EventType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<EventType>>;
};

/** The `application` to be created by this mutation. */
export type FakePublicApplicationForeignKey0ApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `userList` in the `ApplicationInput` mutation. */
export type FakePublicApplicationForeignKey0Input = {
  /** A `UserListInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicApplicationForeignKey0UserListCreateInput>;
};

/** Input for the nested mutation of `application` in the `UserListInput` mutation. */
export type FakePublicApplicationForeignKey0InverseInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationApplicationPkeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNodeIdConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyConnect>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyConnect>>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicApplicationForeignKey0ApplicationCreateInput>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationApplicationPkeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNodeIdDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<Array<ApplicationApplicationOutcomeRegistrationKeyDelete>>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<Array<ApplicationApplicationSerialKeyDelete>>;
  /** Flag indicating whether all other `application` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationPkeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserListOnApplicationForFakePublicApplicationForeignKey0NodeIdUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<Array<ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationOutcomeRegistrationKeyUpdate>>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<Array<ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationSerialKeyUpdate>>;
};

/** The `userList` to be created by this mutation. */
export type FakePublicApplicationForeignKey0UserListCreateInput = {
  applicationNotesUsingId?: InputMaybe<FakePublicApplicationNoteForeignKey0InverseInput>;
  applicationsUsingId?: InputMaybe<FakePublicApplicationForeignKey0InverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<FakePublicPermissionJoinForeignKey0InverseInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey1InverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey0InverseInput>;
  reviewsUsingId?: InputMaybe<FakePublicReviewForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The `applicationNote` to be created by this mutation. */
export type FakePublicApplicationNoteForeignKey0ApplicationNoteCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** Input for the nested mutation of `userList` in the `ApplicationNoteInput` mutation. */
export type FakePublicApplicationNoteForeignKey0Input = {
  /** A `UserListInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicApplicationNoteForeignKey0UserListCreateInput>;
};

/** Input for the nested mutation of `applicationNote` in the `UserListInput` mutation. */
export type FakePublicApplicationNoteForeignKey0InverseInput = {
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyConnect>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdConnect>>;
  /** A `ApplicationNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicApplicationNoteForeignKey0ApplicationNoteCreateInput>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ApplicationNoteApplicationNotePkeyDelete>>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ApplicationNoteNodeIdDelete>>;
  /** Flag indicating whether all other `applicationNote` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0UsingApplicationNotePkeyUpdate>>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserListOnApplicationNoteForFakePublicApplicationNoteForeignKey0NodeIdUpdate>>;
};

/** The `userList` to be created by this mutation. */
export type FakePublicApplicationNoteForeignKey0UserListCreateInput = {
  applicationNotesUsingId?: InputMaybe<FakePublicApplicationNoteForeignKey0InverseInput>;
  applicationsUsingId?: InputMaybe<FakePublicApplicationForeignKey0InverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<FakePublicPermissionJoinForeignKey0InverseInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey1InverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey0InverseInput>;
  reviewsUsingId?: InputMaybe<FakePublicReviewForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `userList` in the `PermissionJoinInput` mutation. */
export type FakePublicPermissionJoinForeignKey0Input = {
  /** A `UserListInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicPermissionJoinForeignKey0UserListCreateInput>;
};

/** Input for the nested mutation of `permissionJoin` in the `UserListInput` mutation. */
export type FakePublicPermissionJoinForeignKey0InverseInput = {
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PermissionJoinNodeIdConnect>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicPermissionJoinForeignKey0PermissionJoinCreateInput>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PermissionJoinNodeIdDelete>>;
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0UsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserListOnPermissionJoinForFakePublicPermissionJoinForeignKey0NodeIdUpdate>>;
};

/** The `permissionJoin` to be created by this mutation. */
export type FakePublicPermissionJoinForeignKey0PermissionJoinCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userListToUserId?: InputMaybe<FakePublicPermissionJoinForeignKey0Input>;
};

/** The `userList` to be created by this mutation. */
export type FakePublicPermissionJoinForeignKey0UserListCreateInput = {
  applicationNotesUsingId?: InputMaybe<FakePublicApplicationNoteForeignKey0InverseInput>;
  applicationsUsingId?: InputMaybe<FakePublicApplicationForeignKey0InverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<FakePublicPermissionJoinForeignKey0InverseInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey1InverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey0InverseInput>;
  reviewsUsingId?: InputMaybe<FakePublicReviewForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `userList` in the `ReviewAssignmentAssignerJoinInput` mutation. */
export type FakePublicReviewAssignmentAssignerJoinForeignKey0Input = {
  /** A `UserListInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0UserListCreateInput>;
};

/** Input for the nested mutation of `reviewAssignmentAssignerJoin` in the `UserListInput` mutation. */
export type FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput = {
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdConnect>>;
  /** A `ReviewAssignmentAssignerJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicReviewAssignmentAssignerJoinForeignKey0ReviewAssignmentAssignerJoinCreateInput>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignmentAssignerJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0UsingReviewAssignmentAssignerJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserListOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0NodeIdUpdate>>;
};

/** The `reviewAssignmentAssignerJoin` to be created by this mutation. */
export type FakePublicReviewAssignmentAssignerJoinForeignKey0ReviewAssignmentAssignerJoinCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0Input>;
};

/** The `userList` to be created by this mutation. */
export type FakePublicReviewAssignmentAssignerJoinForeignKey0UserListCreateInput = {
  applicationNotesUsingId?: InputMaybe<FakePublicApplicationNoteForeignKey0InverseInput>;
  applicationsUsingId?: InputMaybe<FakePublicApplicationForeignKey0InverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<FakePublicPermissionJoinForeignKey0InverseInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey1InverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey0InverseInput>;
  reviewsUsingId?: InputMaybe<FakePublicReviewForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `userList` in the `ReviewAssignmentInput` mutation. */
export type FakePublicReviewAssignmentForeignKey0Input = {
  /** A `UserListInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicReviewAssignmentForeignKey0UserListCreateInput>;
};

/** Input for the nested mutation of `reviewAssignment` in the `UserListInput` mutation. */
export type FakePublicReviewAssignmentForeignKey0InverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicReviewAssignmentForeignKey0ReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0UsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0NodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type FakePublicReviewAssignmentForeignKey0ReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** The `userList` to be created by this mutation. */
export type FakePublicReviewAssignmentForeignKey0UserListCreateInput = {
  applicationNotesUsingId?: InputMaybe<FakePublicApplicationNoteForeignKey0InverseInput>;
  applicationsUsingId?: InputMaybe<FakePublicApplicationForeignKey0InverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<FakePublicPermissionJoinForeignKey0InverseInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey1InverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey0InverseInput>;
  reviewsUsingId?: InputMaybe<FakePublicReviewForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `userList` in the `ReviewAssignmentInput` mutation. */
export type FakePublicReviewAssignmentForeignKey1Input = {
  /** A `UserListInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicReviewAssignmentForeignKey1UserListCreateInput>;
};

/** Input for the nested mutation of `reviewAssignment` in the `UserListInput` mutation. */
export type FakePublicReviewAssignmentForeignKey1InverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicReviewAssignmentForeignKey1ReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1UsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1NodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type FakePublicReviewAssignmentForeignKey1ReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** The `userList` to be created by this mutation. */
export type FakePublicReviewAssignmentForeignKey1UserListCreateInput = {
  applicationNotesUsingId?: InputMaybe<FakePublicApplicationNoteForeignKey0InverseInput>;
  applicationsUsingId?: InputMaybe<FakePublicApplicationForeignKey0InverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<FakePublicPermissionJoinForeignKey0InverseInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey1InverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey0InverseInput>;
  reviewsUsingId?: InputMaybe<FakePublicReviewForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `userList` in the `ReviewInput` mutation. */
export type FakePublicReviewForeignKey0Input = {
  /** A `UserListInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicReviewForeignKey0UserListCreateInput>;
};

/** Input for the nested mutation of `review` in the `UserListInput` mutation. */
export type FakePublicReviewForeignKey0InverseInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewReviewPkeyConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewNodeIdConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<Array<ReviewReviewReviewAssignmentIdKeyConnect>>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicReviewForeignKey0ReviewCreateInput>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewReviewPkeyDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewNodeIdDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<Array<ReviewReviewReviewAssignmentIdKeyDelete>>;
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewPkeyUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserListOnReviewForFakePublicReviewForeignKey0NodeIdUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<Array<ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewReviewAssignmentIdKeyUpdate>>;
};

/** The `review` to be created by this mutation. */
export type FakePublicReviewForeignKey0ReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** The `userList` to be created by this mutation. */
export type FakePublicReviewForeignKey0UserListCreateInput = {
  applicationNotesUsingId?: InputMaybe<FakePublicApplicationNoteForeignKey0InverseInput>;
  applicationsUsingId?: InputMaybe<FakePublicApplicationForeignKey0InverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<FakePublicPermissionJoinForeignKey0InverseInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey1InverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey0InverseInput>;
  reviewsUsingId?: InputMaybe<FakePublicReviewForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `user` in the `UserOrganisationInput` mutation. */
export type FakePublicUserOrganisationForeignKey0Input = {
  /** A `UserInput` object that will be created and connected to this object. */
  create?: InputMaybe<FakePublicUserOrganisationForeignKey0UserListAdminCreateInput>;
};

/** Input for the nested mutation of `userOrganisation` in the `UserInput` mutation. */
export type FakePublicUserOrganisationForeignKey0InverseInput = {
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserOrganisationUserOrganisationPkeyConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserOrganisationNodeIdConnect>>;
  /** A `UserOrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FakePublicUserOrganisationForeignKey0UserOrganisationCreateInput>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserOrganisationUserOrganisationPkeyDelete>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserOrganisationNodeIdDelete>>;
  /** Flag indicating whether all other `userOrganisation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0UsingUserOrganisationPkeyUpdate>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<UserOnUserOrganisationForFakePublicUserOrganisationForeignKey0NodeIdUpdate>>;
};

/** The `user` to be created by this mutation. */
export type FakePublicUserOrganisationForeignKey0UserListAdminCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  userOrganisations?: InputMaybe<FakePublicUserOrganisationForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The `userOrganisation` to be created by this mutation. */
export type FakePublicUserOrganisationForeignKey0UserOrganisationCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<FakePublicUserOrganisationForeignKey0Input>;
};

export type File = Node & {
  __typename?: 'File';
  /** Reads a single `Application` that is related to this `File`. */
  applicationByApplicationSerial?: Maybe<Application>;
  /** Reads a single `ApplicationNote` that is related to this `File`. */
  applicationNote?: Maybe<ApplicationNote>;
  applicationNoteId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  applicationResponseId?: Maybe<Scalars['Int']['output']>;
  applicationSerial?: Maybe<Scalars['String']['output']>;
  archivePath?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  filePath: Scalars['String']['output'];
  fileSize?: Maybe<Scalars['BigInt']['output']>;
  id: Scalars['Int']['output'];
  isExternalReferenceDoc: Scalars['Boolean']['output'];
  isInternalReferenceDoc: Scalars['Boolean']['output'];
  isOutputDoc: Scalars['Boolean']['output'];
  mimetype?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  originalFilename: Scalars['String']['output'];
  submitted?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `Template` that is related to this `File`. */
  template?: Maybe<Template>;
  templateId?: Maybe<Scalars['Int']['output']>;
  thumbnailPath?: Maybe<Scalars['String']['output']>;
  timestamp: Scalars['Datetime']['output'];
  toBeDeleted: Scalars['Boolean']['output'];
  uniqueId: Scalars['String']['output'];
  userId?: Maybe<Scalars['Int']['output']>;
};

/** The `applicationNote` to be created by this mutation. */
export type FileApplicationNoteIdFkeyApplicationNoteCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment: Scalars['String']['input'];
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** The `file` to be created by this mutation. */
export type FileApplicationNoteIdFkeyFileCreateInput = {
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `applicationNote` in the `FileInput` mutation. */
export type FileApplicationNoteIdFkeyInput = {
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationNoteApplicationNotePkeyConnect>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNoteNodeIdConnect>;
  /** A `ApplicationNoteInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileApplicationNoteIdFkeyApplicationNoteCreateInput>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationNoteApplicationNotePkeyDelete>;
  /** The primary key(s) for `applicationNote` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNoteNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationNoteOnFileForFileApplicationNoteIdFkeyUsingApplicationNotePkeyUpdate>;
  /** The primary key(s) and patch data for `applicationNote` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileApplicationNoteIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `file` in the `ApplicationNoteInput` mutation. */
export type FileApplicationNoteIdFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileApplicationNoteIdFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileApplicationNoteIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationNoteOnFileForFileApplicationNoteIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileApplicationNoteIdFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** The `applicationResponse` to be created by this mutation. */
export type FileApplicationResponseIdFkeyApplicationResponseCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** The `file` to be created by this mutation. */
export type FileApplicationResponseIdFkeyFileCreateInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `applicationResponse` in the `FileInput` mutation. */
export type FileApplicationResponseIdFkeyInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationResponseApplicationResponsePkeyConnect>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationResponseNodeIdConnect>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileApplicationResponseIdFkeyApplicationResponseCreateInput>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationResponseApplicationResponsePkeyDelete>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `file` in the `ApplicationResponseInput` mutation. */
export type FileApplicationResponseIdFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileApplicationResponseIdFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileApplicationResponseIdFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** The `application` to be created by this mutation. */
export type FileApplicationSerialFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** The `file` to be created by this mutation. */
export type FileApplicationSerialFkeyFileCreateInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `application` in the `FileInput` mutation. */
export type FileApplicationSerialFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileApplicationSerialFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileApplicationSerialFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `file` in the `ApplicationInput` mutation. */
export type FileApplicationSerialFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileApplicationSerialFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileApplicationSerialFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnFileForFileApplicationSerialFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileApplicationSerialFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** A condition to be used against `File` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FileCondition = {
  /** Checks for equality with the object’s `applicationNoteId` field. */
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `applicationResponseId` field. */
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `applicationSerial` field. */
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `archivePath` field. */
  archivePath?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `filePath` field. */
  filePath?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fileSize` field. */
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isExternalReferenceDoc` field. */
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isInternalReferenceDoc` field. */
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isOutputDoc` field. */
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `mimetype` field. */
  mimetype?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `originalFilename` field. */
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `submitted` field. */
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `thumbnailPath` field. */
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `toBeDeleted` field. */
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `uniqueId` field. */
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `file` to look up the row to connect. */
export type FileFilePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `file` to look up the row to delete. */
export type FileFilePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `file` to look up the row to connect. */
export type FileFileUniqueIdKeyConnect = {
  uniqueId: Scalars['String']['input'];
};

/** The fields on `file` to look up the row to delete. */
export type FileFileUniqueIdKeyDelete = {
  uniqueId: Scalars['String']['input'];
};

/** A filter to be used against `File` object types. All fields are combined with a logical ‘and.’ */
export type FileFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FileFilter>>;
  /** Filter by the object’s `applicationByApplicationSerial` relation. */
  applicationByApplicationSerial?: InputMaybe<ApplicationFilter>;
  /** A related `applicationByApplicationSerial` exists. */
  applicationByApplicationSerialExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationNote` relation. */
  applicationNote?: InputMaybe<ApplicationNoteFilter>;
  /** A related `applicationNote` exists. */
  applicationNoteExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationNoteId` field. */
  applicationNoteId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationResponse` relation. */
  applicationResponse?: InputMaybe<ApplicationResponseFilter>;
  /** A related `applicationResponse` exists. */
  applicationResponseExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationResponseId` field. */
  applicationResponseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `applicationSerial` field. */
  applicationSerial?: InputMaybe<StringFilter>;
  /** Filter by the object’s `archivePath` field. */
  archivePath?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `filePath` field. */
  filePath?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fileSize` field. */
  fileSize?: InputMaybe<BigIntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isExternalReferenceDoc` field. */
  isExternalReferenceDoc?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isInternalReferenceDoc` field. */
  isInternalReferenceDoc?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isOutputDoc` field. */
  isOutputDoc?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `mimetype` field. */
  mimetype?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FileFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FileFilter>>;
  /** Filter by the object’s `originalFilename` field. */
  originalFilename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `submitted` field. */
  submitted?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `thumbnailPath` field. */
  thumbnailPath?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `toBeDeleted` field. */
  toBeDeleted?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `uniqueId` field. */
  uniqueId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `File` */
export type FileInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type FileNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FileNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `file` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileApplicationNoteIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationNoteIdFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationNoteIdFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationNoteIdFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationNoteIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationResponseIdFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileApplicationSerialFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationSerialFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationSerialFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileApplicationSerialFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileApplicationSerialFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FileOnFileForFileTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileTemplateIdFkeyUsingFilePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileTemplateIdFkeyPatch;
};

/** The fields on `file` to look up the row to update. */
export type FileOnFileForFileTemplateIdFkeyUsingFileUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: UpdateFileOnFileForFileTemplateIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** Represents an update to a `File`. Fields that are set will be updated. */
export type FilePatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `file` to be created by this mutation. */
export type FileTemplateIdFkeyFileCreateInput = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath: Scalars['String']['input'];
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename: Scalars['String']['input'];
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId: Scalars['String']['input'];
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `template` in the `FileInput` mutation. */
export type FileTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<FileTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnFileForFileTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnFileForFileTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<FileOnFileForFileTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `file` in the `TemplateInput` mutation. */
export type FileTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectById?: InputMaybe<Array<FileFilePkeyConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<FileNodeIdConnect>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyConnect>>;
  /** A `FileInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<FileTemplateIdFkeyFileCreateInput>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<FileFilePkeyDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<FileNodeIdDelete>>;
  /** The primary key(s) for `file` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<FileFileUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `file` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateById?: InputMaybe<Array<FileOnFileForFileTemplateIdFkeyUsingFilePkeyUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnFileForFileTemplateIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `file` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<FileOnFileForFileTemplateIdFkeyUsingFileUniqueIdKeyUpdate>>;
};

/** The `template` to be created by this mutation. */
export type FileTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `File` values. */
export type FilesConnection = {
  __typename?: 'FilesConnection';
  /** A list of edges which contains the `File` and cursor to aid in pagination. */
  edges: Array<FilesEdge>;
  /** A list of `File` objects. */
  nodes: Array<Maybe<File>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `File` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `File` edge in the connection. */
export type FilesEdge = {
  __typename?: 'FilesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `File` at the end of the edge. */
  node?: Maybe<File>;
};

/** Methods to use when ordering `File`. */
export enum FilesOrderBy {
  ApplicationNoteIdAsc = 'APPLICATION_NOTE_ID_ASC',
  ApplicationNoteIdDesc = 'APPLICATION_NOTE_ID_DESC',
  ApplicationResponseIdAsc = 'APPLICATION_RESPONSE_ID_ASC',
  ApplicationResponseIdDesc = 'APPLICATION_RESPONSE_ID_DESC',
  ApplicationSerialAsc = 'APPLICATION_SERIAL_ASC',
  ApplicationSerialDesc = 'APPLICATION_SERIAL_DESC',
  ArchivePathAsc = 'ARCHIVE_PATH_ASC',
  ArchivePathDesc = 'ARCHIVE_PATH_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  FilePathAsc = 'FILE_PATH_ASC',
  FilePathDesc = 'FILE_PATH_DESC',
  FileSizeAsc = 'FILE_SIZE_ASC',
  FileSizeDesc = 'FILE_SIZE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsExternalReferenceDocAsc = 'IS_EXTERNAL_REFERENCE_DOC_ASC',
  IsExternalReferenceDocDesc = 'IS_EXTERNAL_REFERENCE_DOC_DESC',
  IsInternalReferenceDocAsc = 'IS_INTERNAL_REFERENCE_DOC_ASC',
  IsInternalReferenceDocDesc = 'IS_INTERNAL_REFERENCE_DOC_DESC',
  IsOutputDocAsc = 'IS_OUTPUT_DOC_ASC',
  IsOutputDocDesc = 'IS_OUTPUT_DOC_DESC',
  MimetypeAsc = 'MIMETYPE_ASC',
  MimetypeDesc = 'MIMETYPE_DESC',
  Natural = 'NATURAL',
  OriginalFilenameAsc = 'ORIGINAL_FILENAME_ASC',
  OriginalFilenameDesc = 'ORIGINAL_FILENAME_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SubmittedAsc = 'SUBMITTED_ASC',
  SubmittedDesc = 'SUBMITTED_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  ThumbnailPathAsc = 'THUMBNAIL_PATH_ASC',
  ThumbnailPathDesc = 'THUMBNAIL_PATH_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  ToBeDeletedAsc = 'TO_BE_DELETED_ASC',
  ToBeDeletedDesc = 'TO_BE_DELETED_DESC',
  UniqueIdAsc = 'UNIQUE_ID_ASC',
  UniqueIdDesc = 'UNIQUE_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Filter = Node & {
  __typename?: 'Filter';
  code: Scalars['String']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  query?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `TemplateFilterJoin`. */
  templateFilterJoins: TemplateFilterJoinsConnection;
  title?: Maybe<Scalars['String']['output']>;
  userRole?: Maybe<PermissionPolicyType>;
};


export type FilterTemplateFilterJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateFilterJoinCondition>;
  filter?: InputMaybe<TemplateFilterJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};

/** A condition to be used against `Filter` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type FilterCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `query` field. */
  query?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** A filter to be used against `Filter` object types. All fields are combined with a logical ‘and.’ */
export type FilterFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<FilterFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<FilterFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<FilterFilter>>;
  /** Filter by the object’s `query` field. */
  query?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `templateFilterJoins` relation. */
  templateFilterJoins?: InputMaybe<FilterToManyTemplateFilterJoinFilter>;
  /** Some related `templateFilterJoins` exist. */
  templateFilterJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: InputMaybe<PermissionPolicyTypeFilter>;
};

/** The fields on `filter` to look up the row to connect. */
export type FilterFilterCodeKeyConnect = {
  code: Scalars['String']['input'];
};

/** The fields on `filter` to look up the row to delete. */
export type FilterFilterCodeKeyDelete = {
  code: Scalars['String']['input'];
};

/** The fields on `filter` to look up the row to connect. */
export type FilterFilterPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `filter` to look up the row to delete. */
export type FilterFilterPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** An input for mutations affecting `Filter` */
export type FilterInput = {
  code: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['JSON']['input']>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** The globally unique `ID` look up for the row to connect. */
export type FilterNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `filter` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type FilterNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `filter` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateFilterJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
  patch: TemplateFilterJoinPatch;
};

/** The fields on `filter` to look up the row to update. */
export type FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterCodeKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `filter` being updated. */
  patch: UpdateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
};

/** The fields on `filter` to look up the row to update. */
export type FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `filter` being updated. */
  patch: UpdateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
};

/** Represents an update to a `Filter`. Fields that are set will be updated. */
export type FilterPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['JSON']['input']>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** A filter to be used against many `TemplateFilterJoin` object types. All fields are combined with a logical ‘and.’ */
export type FilterToManyTemplateFilterJoinFilter = {
  /** Every related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateFilterJoinFilter>;
  /** No related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateFilterJoinFilter>;
  /** Some related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateFilterJoinFilter>;
};

/** A connection to a list of `Filter` values. */
export type FiltersConnection = {
  __typename?: 'FiltersConnection';
  /** A list of edges which contains the `Filter` and cursor to aid in pagination. */
  edges: Array<FiltersEdge>;
  /** A list of `Filter` objects. */
  nodes: Array<Maybe<Filter>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Filter` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Filter` edge in the connection. */
export type FiltersEdge = {
  __typename?: 'FiltersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Filter` at the end of the edge. */
  node?: Maybe<Filter>;
};

/** Methods to use when ordering `Filter`. */
export enum FiltersOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  QueryAsc = 'QUERY_ASC',
  QueryDesc = 'QUERY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

export type GrafanaDashboardImage = Node & {
  __typename?: 'GrafanaDashboardImage';
  data?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  updatedDate?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `GrafanaDashboardImage` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type GrafanaDashboardImageCondition = {
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `updatedDate` field. */
  updatedDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `GrafanaDashboardImage` object types. All fields are combined with a logical ‘and.’ */
export type GrafanaDashboardImageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<GrafanaDashboardImageFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<GrafanaDashboardImageFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<GrafanaDashboardImageFilter>>;
  /** Filter by the object’s `updatedDate` field. */
  updatedDate?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `GrafanaDashboardImage` */
export type GrafanaDashboardImageInput = {
  data?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  updatedDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `GrafanaDashboardImage`. Fields that are set will be updated. */
export type GrafanaDashboardImagePatch = {
  data?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `GrafanaDashboardImage` values. */
export type GrafanaDashboardImagesConnection = {
  __typename?: 'GrafanaDashboardImagesConnection';
  /** A list of edges which contains the `GrafanaDashboardImage` and cursor to aid in pagination. */
  edges: Array<GrafanaDashboardImagesEdge>;
  /** A list of `GrafanaDashboardImage` objects. */
  nodes: Array<Maybe<GrafanaDashboardImage>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `GrafanaDashboardImage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `GrafanaDashboardImage` edge in the connection. */
export type GrafanaDashboardImagesEdge = {
  __typename?: 'GrafanaDashboardImagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `GrafanaDashboardImage` at the end of the edge. */
  node?: Maybe<GrafanaDashboardImage>;
};

/** Methods to use when ordering `GrafanaDashboardImage`. */
export enum GrafanaDashboardImagesOrderBy {
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UpdatedDateAsc = 'UPDATED_DATE_ASC',
  UpdatedDateDesc = 'UPDATED_DATE_DESC'
}

/** A filter to be used against Int fields. All fields are combined with a logical ‘and.’ */
export type IntFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['Int']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['Int']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['Int']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['Int']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['Int']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** A filter to be used against JSON fields. All fields are combined with a logical ‘and.’ */
export type JsonFilter = {
  /** Contained by the specified JSON. */
  containedBy?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains the specified JSON. */
  contains?: InputMaybe<Scalars['JSON']['input']>;
  /** Contains all of the specified keys. */
  containsAllKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains any of the specified keys. */
  containsAnyKeys?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified key. */
  containsKey?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['JSON']['input']>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['JSON']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['JSON']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['JSON']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['JSON']['input']>>;
};

/** The root mutation type which contains root level fields which mutate data. */
export type Mutation = {
  __typename?: 'Mutation';
  /** Creates a single `ActionPlugin`. */
  createActionPlugin?: Maybe<CreateActionPluginPayload>;
  /** Creates a single `ActionQueue`. */
  createActionQueue?: Maybe<CreateActionQueuePayload>;
  /** Creates a single `ActivityLog`. */
  createActivityLog?: Maybe<CreateActivityLogPayload>;
  /** Creates a single `AllowedSelfAssignableSectionsShape`. */
  createAllowedSelfAssignableSectionsShape?: Maybe<CreateAllowedSelfAssignableSectionsShapePayload>;
  /** Creates a single `Application`. */
  createApplication?: Maybe<CreateApplicationPayload>;
  /** Creates a single `ApplicationListShape`. */
  createApplicationListShape?: Maybe<CreateApplicationListShapePayload>;
  /** Creates a single `ApplicationNote`. */
  createApplicationNote?: Maybe<CreateApplicationNotePayload>;
  /** Creates a single `ApplicationResponse`. */
  createApplicationResponse?: Maybe<CreateApplicationResponsePayload>;
  /** Creates a single `ApplicationReviewerAction`. */
  createApplicationReviewerAction?: Maybe<CreateApplicationReviewerActionPayload>;
  /** Creates a single `ApplicationStageHistory`. */
  createApplicationStageHistory?: Maybe<CreateApplicationStageHistoryPayload>;
  /** Creates a single `ApplicationStatusHistory`. */
  createApplicationStatusHistory?: Maybe<CreateApplicationStatusHistoryPayload>;
  /** Creates a single `Counter`. */
  createCounter?: Maybe<CreateCounterPayload>;
  /** Creates a single `DataChangelog`. */
  createDataChangelog?: Maybe<CreateDataChangelogPayload>;
  /** Creates a single `DataTable`. */
  createDataTable?: Maybe<CreateDataTablePayload>;
  /** Creates a single `DataTableActiveIngredient`. */
  createDataTableActiveIngredient?: Maybe<CreateDataTableActiveIngredientPayload>;
  /** Creates a single `DataTableAdministrationRoute`. */
  createDataTableAdministrationRoute?: Maybe<CreateDataTableAdministrationRoutePayload>;
  /** Creates a single `DataTableAtcCode`. */
  createDataTableAtcCode?: Maybe<CreateDataTableAtcCodePayload>;
  /** Creates a single `DataTableContainer`. */
  createDataTableContainer?: Maybe<CreateDataTableContainerPayload>;
  /** Creates a single `DataTableCountry`. */
  createDataTableCountry?: Maybe<CreateDataTableCountryPayload>;
  /** Creates a single `DataTableDosageForm`. */
  createDataTableDosageForm?: Maybe<CreateDataTableDosageFormPayload>;
  /** Creates a single `DataTableDosageFormGroup`. */
  createDataTableDosageFormGroup?: Maybe<CreateDataTableDosageFormGroupPayload>;
  /** Creates a single `DataTableGenericIngredient`. */
  createDataTableGenericIngredient?: Maybe<CreateDataTableGenericIngredientPayload>;
  /** Creates a single `DataTableManufacturer`. */
  createDataTableManufacturer?: Maybe<CreateDataTableManufacturerPayload>;
  /** Creates a single `DataTableManufacturerApplicationJoin`. */
  createDataTableManufacturerApplicationJoin?: Maybe<CreateDataTableManufacturerApplicationJoinPayload>;
  /** Creates a single `DataTableManufacturerRepresentative`. */
  createDataTableManufacturerRepresentative?: Maybe<CreateDataTableManufacturerRepresentativePayload>;
  /** Creates a single `DataTableManufacturerRepresentativeApplicationJoin`. */
  createDataTableManufacturerRepresentativeApplicationJoin?: Maybe<CreateDataTableManufacturerRepresentativeApplicationJoinPayload>;
  /** Creates a single `DataTablePermitChemical`. */
  createDataTablePermitChemical?: Maybe<CreateDataTablePermitChemicalPayload>;
  /** Creates a single `DataTablePermitChemicalApplicationJoin`. */
  createDataTablePermitChemicalApplicationJoin?: Maybe<CreateDataTablePermitChemicalApplicationJoinPayload>;
  /** Creates a single `DataTablePreRegisteredProductsProvisional`. */
  createDataTablePreRegisteredProductsProvisional?: Maybe<CreateDataTablePreRegisteredProductsProvisionalPayload>;
  /** Creates a single `DataTablePrequalManufacturer`. */
  createDataTablePrequalManufacturer?: Maybe<CreateDataTablePrequalManufacturerPayload>;
  /** Creates a single `DataTablePrequalManufacturerApplicationJoin`. */
  createDataTablePrequalManufacturerApplicationJoin?: Maybe<CreateDataTablePrequalManufacturerApplicationJoinPayload>;
  /** Creates a single `DataTableProcessingStep`. */
  createDataTableProcessingStep?: Maybe<CreateDataTableProcessingStepPayload>;
  /** Creates a single `DataTableProduct`. */
  createDataTableProduct?: Maybe<CreateDataTableProductPayload>;
  /** Creates a single `DataTableProductApplicationJoin`. */
  createDataTableProductApplicationJoin?: Maybe<CreateDataTableProductApplicationJoinPayload>;
  /** Creates a single `DataTableProvisionalProduct`. */
  createDataTableProvisionalProduct?: Maybe<CreateDataTableProvisionalProductPayload>;
  /** Creates a single `DataTableProvisionalProductApplicationJoin`. */
  createDataTableProvisionalProductApplicationJoin?: Maybe<CreateDataTableProvisionalProductApplicationJoinPayload>;
  /** Creates a single `DataTableScheduledChemical`. */
  createDataTableScheduledChemical?: Maybe<CreateDataTableScheduledChemicalPayload>;
  /** Creates a single `DataTableStorageCondition`. */
  createDataTableStorageCondition?: Maybe<CreateDataTableStorageConditionPayload>;
  /** Creates a single `DataTableStorageConditionsSimplified`. */
  createDataTableStorageConditionsSimplified?: Maybe<CreateDataTableStorageConditionsSimplifiedPayload>;
  /** Creates a single `DataTableUnitsOfProportion`. */
  createDataTableUnitsOfProportion?: Maybe<CreateDataTableUnitsOfProportionPayload>;
  /** Creates a single `DataTableWorldHealthOrganisationPqListOfFpp`. */
  createDataTableWorldHealthOrganisationPqListOfFpp?: Maybe<CreateDataTableWorldHealthOrganisationPqListOfFppPayload>;
  /** Creates a single `DataView`. */
  createDataView?: Maybe<CreateDataViewPayload>;
  /** Creates a single `DataViewColumnDefinition`. */
  createDataViewColumnDefinition?: Maybe<CreateDataViewColumnDefinitionPayload>;
  /** Creates a single `ElementTypePlugin`. */
  createElementTypePlugin?: Maybe<CreateElementTypePluginPayload>;
  /** Creates a single `File`. */
  createFile?: Maybe<CreateFilePayload>;
  /** Creates a single `Filter`. */
  createFilter?: Maybe<CreateFilterPayload>;
  /** Creates a single `GrafanaDashboardImage`. */
  createGrafanaDashboardImage?: Maybe<CreateGrafanaDashboardImagePayload>;
  /** Creates a single `Notification`. */
  createNotification?: Maybe<CreateNotificationPayload>;
  /** Creates a single `Organisation`. */
  createOrganisation?: Maybe<CreateOrganisationPayload>;
  /** Creates a single `OrganisationApplicationJoin`. */
  createOrganisationApplicationJoin?: Maybe<CreateOrganisationApplicationJoinPayload>;
  /** Creates a single `PermissionJoin`. */
  createPermissionJoin?: Maybe<CreatePermissionJoinPayload>;
  /** Creates a single `PermissionName`. */
  createPermissionName?: Maybe<CreatePermissionNamePayload>;
  /** Creates a single `PermissionPolicy`. */
  createPermissionPolicy?: Maybe<CreatePermissionPolicyPayload>;
  /** Creates a single `Review`. */
  createReview?: Maybe<CreateReviewPayload>;
  /** Creates a single `ReviewAssignment`. */
  createReviewAssignment?: Maybe<CreateReviewAssignmentPayload>;
  /** Creates a single `ReviewAssignmentAssignedSectionsShape`. */
  createReviewAssignmentAssignedSectionsShape?: Maybe<CreateReviewAssignmentAssignedSectionsShapePayload>;
  /** Creates a single `ReviewAssignmentAssignerJoin`. */
  createReviewAssignmentAssignerJoin?: Maybe<CreateReviewAssignmentAssignerJoinPayload>;
  /** Creates a single `ReviewDecision`. */
  createReviewDecision?: Maybe<CreateReviewDecisionPayload>;
  /** Creates a single `ReviewResponse`. */
  createReviewResponse?: Maybe<CreateReviewResponsePayload>;
  /** Creates a single `ReviewStatusHistory`. */
  createReviewStatusHistory?: Maybe<CreateReviewStatusHistoryPayload>;
  /** Creates a single `SystemInfo`. */
  createSystemInfo?: Maybe<CreateSystemInfoPayload>;
  /** Creates a single `Template`. */
  createTemplate?: Maybe<CreateTemplatePayload>;
  /** Creates a single `TemplateAction`. */
  createTemplateAction?: Maybe<CreateTemplateActionPayload>;
  /** Creates a single `TemplateCategory`. */
  createTemplateCategory?: Maybe<CreateTemplateCategoryPayload>;
  /** Creates a single `TemplateElement`. */
  createTemplateElement?: Maybe<CreateTemplateElementPayload>;
  /** Creates a single `TemplateFilterJoin`. */
  createTemplateFilterJoin?: Maybe<CreateTemplateFilterJoinPayload>;
  /** Creates a single `TemplatePermission`. */
  createTemplatePermission?: Maybe<CreateTemplatePermissionPayload>;
  /** Creates a single `TemplateSection`. */
  createTemplateSection?: Maybe<CreateTemplateSectionPayload>;
  /** Creates a single `TemplateStage`. */
  createTemplateStage?: Maybe<CreateTemplateStagePayload>;
  /** Creates a single `TemplateStageReviewLevel`. */
  createTemplateStageReviewLevel?: Maybe<CreateTemplateStageReviewLevelPayload>;
  /** Creates a single `TriggerQueue`. */
  createTriggerQueue?: Maybe<CreateTriggerQueuePayload>;
  /** Creates a single `TriggerSchedule`. */
  createTriggerSchedule?: Maybe<CreateTriggerSchedulePayload>;
  /** Creates a single `User`. */
  createUser?: Maybe<CreateUserPayload>;
  /** Creates a single `UserApplicationJoin`. */
  createUserApplicationJoin?: Maybe<CreateUserApplicationJoinPayload>;
  /** Creates a single `UserList`. */
  createUserList?: Maybe<CreateUserListPayload>;
  /** Creates a single `UserOrganisation`. */
  createUserOrganisation?: Maybe<CreateUserOrganisationPayload>;
  /** Creates a single `Verification`. */
  createVerification?: Maybe<CreateVerificationPayload>;
  /** Deletes a single `ActionPlugin` using a unique key. */
  deleteActionPlugin?: Maybe<DeleteActionPluginPayload>;
  /** Deletes a single `ActionPlugin` using a unique key. */
  deleteActionPluginByCode?: Maybe<DeleteActionPluginPayload>;
  /** Deletes a single `ActionPlugin` using its globally unique id. */
  deleteActionPluginByNodeId?: Maybe<DeleteActionPluginPayload>;
  /** Deletes a single `ActionQueue` using a unique key. */
  deleteActionQueue?: Maybe<DeleteActionQueuePayload>;
  /** Deletes a single `ActionQueue` using its globally unique id. */
  deleteActionQueueByNodeId?: Maybe<DeleteActionQueuePayload>;
  /** Deletes a single `ActivityLog` using a unique key. */
  deleteActivityLog?: Maybe<DeleteActivityLogPayload>;
  /** Deletes a single `ActivityLog` using its globally unique id. */
  deleteActivityLogByNodeId?: Maybe<DeleteActivityLogPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplication?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using its globally unique id. */
  deleteApplicationByNodeId?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplicationByOutcomeRegistration?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `Application` using a unique key. */
  deleteApplicationBySerial?: Maybe<DeleteApplicationPayload>;
  /** Deletes a single `ApplicationNote` using a unique key. */
  deleteApplicationNote?: Maybe<DeleteApplicationNotePayload>;
  /** Deletes a single `ApplicationNote` using its globally unique id. */
  deleteApplicationNoteByNodeId?: Maybe<DeleteApplicationNotePayload>;
  /** Deletes a single `ApplicationResponse` using a unique key. */
  deleteApplicationResponse?: Maybe<DeleteApplicationResponsePayload>;
  /** Deletes a single `ApplicationResponse` using its globally unique id. */
  deleteApplicationResponseByNodeId?: Maybe<DeleteApplicationResponsePayload>;
  /** Deletes a single `ApplicationReviewerAction` using a unique key. */
  deleteApplicationReviewerAction?: Maybe<DeleteApplicationReviewerActionPayload>;
  /** Deletes a single `ApplicationReviewerAction` using its globally unique id. */
  deleteApplicationReviewerActionByNodeId?: Maybe<DeleteApplicationReviewerActionPayload>;
  /** Deletes a single `ApplicationReviewerAction` using a unique key. */
  deleteApplicationReviewerActionByUserIdAndApplicationId?: Maybe<DeleteApplicationReviewerActionPayload>;
  /** Deletes a single `ApplicationStageHistory` using a unique key. */
  deleteApplicationStageHistory?: Maybe<DeleteApplicationStageHistoryPayload>;
  /** Deletes a single `ApplicationStageHistory` using its globally unique id. */
  deleteApplicationStageHistoryByNodeId?: Maybe<DeleteApplicationStageHistoryPayload>;
  /** Deletes a single `ApplicationStatusHistory` using a unique key. */
  deleteApplicationStatusHistory?: Maybe<DeleteApplicationStatusHistoryPayload>;
  /** Deletes a single `ApplicationStatusHistory` using its globally unique id. */
  deleteApplicationStatusHistoryByNodeId?: Maybe<DeleteApplicationStatusHistoryPayload>;
  /** Deletes a single `Counter` using a unique key. */
  deleteCounter?: Maybe<DeleteCounterPayload>;
  /** Deletes a single `Counter` using a unique key. */
  deleteCounterByName?: Maybe<DeleteCounterPayload>;
  /** Deletes a single `Counter` using its globally unique id. */
  deleteCounterByNodeId?: Maybe<DeleteCounterPayload>;
  /** Deletes a single `DataChangelog` using a unique key. */
  deleteDataChangelog?: Maybe<DeleteDataChangelogPayload>;
  /** Deletes a single `DataChangelog` using its globally unique id. */
  deleteDataChangelogByNodeId?: Maybe<DeleteDataChangelogPayload>;
  /** Deletes a single `DataTable` using a unique key. */
  deleteDataTable?: Maybe<DeleteDataTablePayload>;
  /** Deletes a single `DataTableActiveIngredient` using a unique key. */
  deleteDataTableActiveIngredient?: Maybe<DeleteDataTableActiveIngredientPayload>;
  /** Deletes a single `DataTableActiveIngredient` using its globally unique id. */
  deleteDataTableActiveIngredientByNodeId?: Maybe<DeleteDataTableActiveIngredientPayload>;
  /** Deletes a single `DataTableAdministrationRoute` using a unique key. */
  deleteDataTableAdministrationRoute?: Maybe<DeleteDataTableAdministrationRoutePayload>;
  /** Deletes a single `DataTableAdministrationRoute` using its globally unique id. */
  deleteDataTableAdministrationRouteByNodeId?: Maybe<DeleteDataTableAdministrationRoutePayload>;
  /** Deletes a single `DataTableAtcCode` using a unique key. */
  deleteDataTableAtcCode?: Maybe<DeleteDataTableAtcCodePayload>;
  /** Deletes a single `DataTableAtcCode` using its globally unique id. */
  deleteDataTableAtcCodeByNodeId?: Maybe<DeleteDataTableAtcCodePayload>;
  /** Deletes a single `DataTable` using its globally unique id. */
  deleteDataTableByNodeId?: Maybe<DeleteDataTablePayload>;
  /** Deletes a single `DataTable` using a unique key. */
  deleteDataTableByTableName?: Maybe<DeleteDataTablePayload>;
  /** Deletes a single `DataTableContainer` using a unique key. */
  deleteDataTableContainer?: Maybe<DeleteDataTableContainerPayload>;
  /** Deletes a single `DataTableContainer` using its globally unique id. */
  deleteDataTableContainerByNodeId?: Maybe<DeleteDataTableContainerPayload>;
  /** Deletes a single `DataTableCountry` using a unique key. */
  deleteDataTableCountry?: Maybe<DeleteDataTableCountryPayload>;
  /** Deletes a single `DataTableCountry` using its globally unique id. */
  deleteDataTableCountryByNodeId?: Maybe<DeleteDataTableCountryPayload>;
  /** Deletes a single `DataTableDosageForm` using a unique key. */
  deleteDataTableDosageForm?: Maybe<DeleteDataTableDosageFormPayload>;
  /** Deletes a single `DataTableDosageForm` using its globally unique id. */
  deleteDataTableDosageFormByNodeId?: Maybe<DeleteDataTableDosageFormPayload>;
  /** Deletes a single `DataTableDosageFormGroup` using a unique key. */
  deleteDataTableDosageFormGroup?: Maybe<DeleteDataTableDosageFormGroupPayload>;
  /** Deletes a single `DataTableDosageFormGroup` using its globally unique id. */
  deleteDataTableDosageFormGroupByNodeId?: Maybe<DeleteDataTableDosageFormGroupPayload>;
  /** Deletes a single `DataTableGenericIngredient` using a unique key. */
  deleteDataTableGenericIngredient?: Maybe<DeleteDataTableGenericIngredientPayload>;
  /** Deletes a single `DataTableGenericIngredient` using its globally unique id. */
  deleteDataTableGenericIngredientByNodeId?: Maybe<DeleteDataTableGenericIngredientPayload>;
  /** Deletes a single `DataTableManufacturer` using a unique key. */
  deleteDataTableManufacturer?: Maybe<DeleteDataTableManufacturerPayload>;
  /** Deletes a single `DataTableManufacturerApplicationJoin` using a unique key. */
  deleteDataTableManufacturerApplicationJoin?: Maybe<DeleteDataTableManufacturerApplicationJoinPayload>;
  /** Deletes a single `DataTableManufacturerApplicationJoin` using its globally unique id. */
  deleteDataTableManufacturerApplicationJoinByNodeId?: Maybe<DeleteDataTableManufacturerApplicationJoinPayload>;
  /** Deletes a single `DataTableManufacturer` using its globally unique id. */
  deleteDataTableManufacturerByNodeId?: Maybe<DeleteDataTableManufacturerPayload>;
  /** Deletes a single `DataTableManufacturerRepresentative` using a unique key. */
  deleteDataTableManufacturerRepresentative?: Maybe<DeleteDataTableManufacturerRepresentativePayload>;
  /** Deletes a single `DataTableManufacturerRepresentativeApplicationJoin` using a unique key. */
  deleteDataTableManufacturerRepresentativeApplicationJoin?: Maybe<DeleteDataTableManufacturerRepresentativeApplicationJoinPayload>;
  /** Deletes a single `DataTableManufacturerRepresentativeApplicationJoin` using its globally unique id. */
  deleteDataTableManufacturerRepresentativeApplicationJoinByNodeId?: Maybe<DeleteDataTableManufacturerRepresentativeApplicationJoinPayload>;
  /** Deletes a single `DataTableManufacturerRepresentative` using its globally unique id. */
  deleteDataTableManufacturerRepresentativeByNodeId?: Maybe<DeleteDataTableManufacturerRepresentativePayload>;
  /** Deletes a single `DataTablePermitChemical` using a unique key. */
  deleteDataTablePermitChemical?: Maybe<DeleteDataTablePermitChemicalPayload>;
  /** Deletes a single `DataTablePermitChemicalApplicationJoin` using a unique key. */
  deleteDataTablePermitChemicalApplicationJoin?: Maybe<DeleteDataTablePermitChemicalApplicationJoinPayload>;
  /** Deletes a single `DataTablePermitChemicalApplicationJoin` using its globally unique id. */
  deleteDataTablePermitChemicalApplicationJoinByNodeId?: Maybe<DeleteDataTablePermitChemicalApplicationJoinPayload>;
  /** Deletes a single `DataTablePermitChemical` using its globally unique id. */
  deleteDataTablePermitChemicalByNodeId?: Maybe<DeleteDataTablePermitChemicalPayload>;
  /** Deletes a single `DataTablePreRegisteredProductsProvisional` using a unique key. */
  deleteDataTablePreRegisteredProductsProvisional?: Maybe<DeleteDataTablePreRegisteredProductsProvisionalPayload>;
  /** Deletes a single `DataTablePreRegisteredProductsProvisional` using its globally unique id. */
  deleteDataTablePreRegisteredProductsProvisionalByNodeId?: Maybe<DeleteDataTablePreRegisteredProductsProvisionalPayload>;
  /** Deletes a single `DataTablePrequalManufacturer` using a unique key. */
  deleteDataTablePrequalManufacturer?: Maybe<DeleteDataTablePrequalManufacturerPayload>;
  /** Deletes a single `DataTablePrequalManufacturerApplicationJoin` using a unique key. */
  deleteDataTablePrequalManufacturerApplicationJoin?: Maybe<DeleteDataTablePrequalManufacturerApplicationJoinPayload>;
  /** Deletes a single `DataTablePrequalManufacturerApplicationJoin` using its globally unique id. */
  deleteDataTablePrequalManufacturerApplicationJoinByNodeId?: Maybe<DeleteDataTablePrequalManufacturerApplicationJoinPayload>;
  /** Deletes a single `DataTablePrequalManufacturer` using its globally unique id. */
  deleteDataTablePrequalManufacturerByNodeId?: Maybe<DeleteDataTablePrequalManufacturerPayload>;
  /** Deletes a single `DataTableProcessingStep` using a unique key. */
  deleteDataTableProcessingStep?: Maybe<DeleteDataTableProcessingStepPayload>;
  /** Deletes a single `DataTableProcessingStep` using its globally unique id. */
  deleteDataTableProcessingStepByNodeId?: Maybe<DeleteDataTableProcessingStepPayload>;
  /** Deletes a single `DataTableProduct` using a unique key. */
  deleteDataTableProduct?: Maybe<DeleteDataTableProductPayload>;
  /** Deletes a single `DataTableProductApplicationJoin` using a unique key. */
  deleteDataTableProductApplicationJoin?: Maybe<DeleteDataTableProductApplicationJoinPayload>;
  /** Deletes a single `DataTableProductApplicationJoin` using its globally unique id. */
  deleteDataTableProductApplicationJoinByNodeId?: Maybe<DeleteDataTableProductApplicationJoinPayload>;
  /** Deletes a single `DataTableProduct` using its globally unique id. */
  deleteDataTableProductByNodeId?: Maybe<DeleteDataTableProductPayload>;
  /** Deletes a single `DataTableProvisionalProduct` using a unique key. */
  deleteDataTableProvisionalProduct?: Maybe<DeleteDataTableProvisionalProductPayload>;
  /** Deletes a single `DataTableProvisionalProductApplicationJoin` using a unique key. */
  deleteDataTableProvisionalProductApplicationJoin?: Maybe<DeleteDataTableProvisionalProductApplicationJoinPayload>;
  /** Deletes a single `DataTableProvisionalProductApplicationJoin` using its globally unique id. */
  deleteDataTableProvisionalProductApplicationJoinByNodeId?: Maybe<DeleteDataTableProvisionalProductApplicationJoinPayload>;
  /** Deletes a single `DataTableProvisionalProduct` using its globally unique id. */
  deleteDataTableProvisionalProductByNodeId?: Maybe<DeleteDataTableProvisionalProductPayload>;
  /** Deletes a single `DataTableScheduledChemical` using a unique key. */
  deleteDataTableScheduledChemical?: Maybe<DeleteDataTableScheduledChemicalPayload>;
  /** Deletes a single `DataTableScheduledChemical` using its globally unique id. */
  deleteDataTableScheduledChemicalByNodeId?: Maybe<DeleteDataTableScheduledChemicalPayload>;
  /** Deletes a single `DataTableStorageCondition` using a unique key. */
  deleteDataTableStorageCondition?: Maybe<DeleteDataTableStorageConditionPayload>;
  /** Deletes a single `DataTableStorageCondition` using its globally unique id. */
  deleteDataTableStorageConditionByNodeId?: Maybe<DeleteDataTableStorageConditionPayload>;
  /** Deletes a single `DataTableStorageConditionsSimplified` using a unique key. */
  deleteDataTableStorageConditionsSimplified?: Maybe<DeleteDataTableStorageConditionsSimplifiedPayload>;
  /** Deletes a single `DataTableStorageConditionsSimplified` using its globally unique id. */
  deleteDataTableStorageConditionsSimplifiedByNodeId?: Maybe<DeleteDataTableStorageConditionsSimplifiedPayload>;
  /** Deletes a single `DataTableUnitsOfProportion` using a unique key. */
  deleteDataTableUnitsOfProportion?: Maybe<DeleteDataTableUnitsOfProportionPayload>;
  /** Deletes a single `DataTableUnitsOfProportion` using its globally unique id. */
  deleteDataTableUnitsOfProportionByNodeId?: Maybe<DeleteDataTableUnitsOfProportionPayload>;
  /** Deletes a single `DataTableWorldHealthOrganisationPqListOfFpp` using a unique key. */
  deleteDataTableWorldHealthOrganisationPqListOfFpp?: Maybe<DeleteDataTableWorldHealthOrganisationPqListOfFppPayload>;
  /** Deletes a single `DataTableWorldHealthOrganisationPqListOfFpp` using its globally unique id. */
  deleteDataTableWorldHealthOrganisationPqListOfFppByNodeId?: Maybe<DeleteDataTableWorldHealthOrganisationPqListOfFppPayload>;
  /** Deletes a single `DataView` using a unique key. */
  deleteDataView?: Maybe<DeleteDataViewPayload>;
  /** Deletes a single `DataView` using a unique key. */
  deleteDataViewByIdentifier?: Maybe<DeleteDataViewPayload>;
  /** Deletes a single `DataView` using its globally unique id. */
  deleteDataViewByNodeId?: Maybe<DeleteDataViewPayload>;
  /** Deletes a single `DataViewColumnDefinition` using a unique key. */
  deleteDataViewColumnDefinition?: Maybe<DeleteDataViewColumnDefinitionPayload>;
  /** Deletes a single `DataViewColumnDefinition` using its globally unique id. */
  deleteDataViewColumnDefinitionByNodeId?: Maybe<DeleteDataViewColumnDefinitionPayload>;
  /** Deletes a single `DataViewColumnDefinition` using a unique key. */
  deleteDataViewColumnDefinitionByTableNameAndColumnName?: Maybe<DeleteDataViewColumnDefinitionPayload>;
  /** Deletes a single `ElementTypePlugin` using a unique key. */
  deleteElementTypePlugin?: Maybe<DeleteElementTypePluginPayload>;
  /** Deletes a single `ElementTypePlugin` using its globally unique id. */
  deleteElementTypePluginByNodeId?: Maybe<DeleteElementTypePluginPayload>;
  /** Deletes a single `File` using a unique key. */
  deleteFile?: Maybe<DeleteFilePayload>;
  /** Deletes a single `File` using its globally unique id. */
  deleteFileByNodeId?: Maybe<DeleteFilePayload>;
  /** Deletes a single `File` using a unique key. */
  deleteFileByUniqueId?: Maybe<DeleteFilePayload>;
  /** Deletes a single `Filter` using a unique key. */
  deleteFilter?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `Filter` using a unique key. */
  deleteFilterByCode?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `Filter` using its globally unique id. */
  deleteFilterByNodeId?: Maybe<DeleteFilterPayload>;
  /** Deletes a single `GrafanaDashboardImage` using a unique key. */
  deleteGrafanaDashboardImage?: Maybe<DeleteGrafanaDashboardImagePayload>;
  /** Deletes a single `GrafanaDashboardImage` using its globally unique id. */
  deleteGrafanaDashboardImageByNodeId?: Maybe<DeleteGrafanaDashboardImagePayload>;
  /** Deletes a single `Notification` using a unique key. */
  deleteNotification?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Notification` using its globally unique id. */
  deleteNotificationByNodeId?: Maybe<DeleteNotificationPayload>;
  /** Deletes a single `Organisation` using a unique key. */
  deleteOrganisation?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `OrganisationApplicationJoin` using a unique key. */
  deleteOrganisationApplicationJoin?: Maybe<DeleteOrganisationApplicationJoinPayload>;
  /** Deletes a single `OrganisationApplicationJoin` using its globally unique id. */
  deleteOrganisationApplicationJoinByNodeId?: Maybe<DeleteOrganisationApplicationJoinPayload>;
  /** Deletes a single `Organisation` using a unique key. */
  deleteOrganisationByName?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `Organisation` using its globally unique id. */
  deleteOrganisationByNodeId?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `Organisation` using a unique key. */
  deleteOrganisationByRegistration?: Maybe<DeleteOrganisationPayload>;
  /** Deletes a single `PermissionJoin` using a unique key. */
  deletePermissionJoin?: Maybe<DeletePermissionJoinPayload>;
  /** Deletes a single `PermissionJoin` using its globally unique id. */
  deletePermissionJoinByNodeId?: Maybe<DeletePermissionJoinPayload>;
  /** Deletes a single `PermissionName` using a unique key. */
  deletePermissionName?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionName` using a unique key. */
  deletePermissionNameByName?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionName` using its globally unique id. */
  deletePermissionNameByNodeId?: Maybe<DeletePermissionNamePayload>;
  /** Deletes a single `PermissionPolicy` using a unique key. */
  deletePermissionPolicy?: Maybe<DeletePermissionPolicyPayload>;
  /** Deletes a single `PermissionPolicy` using a unique key. */
  deletePermissionPolicyByName?: Maybe<DeletePermissionPolicyPayload>;
  /** Deletes a single `PermissionPolicy` using its globally unique id. */
  deletePermissionPolicyByNodeId?: Maybe<DeletePermissionPolicyPayload>;
  /** Deletes a single `Review` using a unique key. */
  deleteReview?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `ReviewAssignment` using a unique key. */
  deleteReviewAssignment?: Maybe<DeleteReviewAssignmentPayload>;
  /** Deletes a single `ReviewAssignmentAssignerJoin` using a unique key. */
  deleteReviewAssignmentAssignerJoin?: Maybe<DeleteReviewAssignmentAssignerJoinPayload>;
  /** Deletes a single `ReviewAssignmentAssignerJoin` using its globally unique id. */
  deleteReviewAssignmentAssignerJoinByNodeId?: Maybe<DeleteReviewAssignmentAssignerJoinPayload>;
  /** Deletes a single `ReviewAssignment` using its globally unique id. */
  deleteReviewAssignmentByNodeId?: Maybe<DeleteReviewAssignmentPayload>;
  /** Deletes a single `Review` using its globally unique id. */
  deleteReviewByNodeId?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `Review` using a unique key. */
  deleteReviewByReviewAssignmentId?: Maybe<DeleteReviewPayload>;
  /** Deletes a single `ReviewDecision` using a unique key. */
  deleteReviewDecision?: Maybe<DeleteReviewDecisionPayload>;
  /** Deletes a single `ReviewDecision` using its globally unique id. */
  deleteReviewDecisionByNodeId?: Maybe<DeleteReviewDecisionPayload>;
  /** Deletes a single `ReviewResponse` using a unique key. */
  deleteReviewResponse?: Maybe<DeleteReviewResponsePayload>;
  /** Deletes a single `ReviewResponse` using its globally unique id. */
  deleteReviewResponseByNodeId?: Maybe<DeleteReviewResponsePayload>;
  /** Deletes a single `ReviewStatusHistory` using a unique key. */
  deleteReviewStatusHistory?: Maybe<DeleteReviewStatusHistoryPayload>;
  /** Deletes a single `ReviewStatusHistory` using its globally unique id. */
  deleteReviewStatusHistoryByNodeId?: Maybe<DeleteReviewStatusHistoryPayload>;
  /** Deletes a single `SystemInfo` using a unique key. */
  deleteSystemInfo?: Maybe<DeleteSystemInfoPayload>;
  /** Deletes a single `SystemInfo` using its globally unique id. */
  deleteSystemInfoByNodeId?: Maybe<DeleteSystemInfoPayload>;
  /** Deletes a single `Template` using a unique key. */
  deleteTemplate?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `TemplateAction` using a unique key. */
  deleteTemplateAction?: Maybe<DeleteTemplateActionPayload>;
  /** Deletes a single `TemplateAction` using its globally unique id. */
  deleteTemplateActionByNodeId?: Maybe<DeleteTemplateActionPayload>;
  /** Deletes a single `Template` using a unique key. */
  deleteTemplateByCodeAndVersionId?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `Template` using its globally unique id. */
  deleteTemplateByNodeId?: Maybe<DeleteTemplatePayload>;
  /** Deletes a single `TemplateCategory` using a unique key. */
  deleteTemplateCategory?: Maybe<DeleteTemplateCategoryPayload>;
  /** Deletes a single `TemplateCategory` using a unique key. */
  deleteTemplateCategoryByCode?: Maybe<DeleteTemplateCategoryPayload>;
  /** Deletes a single `TemplateCategory` using its globally unique id. */
  deleteTemplateCategoryByNodeId?: Maybe<DeleteTemplateCategoryPayload>;
  /** Deletes a single `TemplateElement` using a unique key. */
  deleteTemplateElement?: Maybe<DeleteTemplateElementPayload>;
  /** Deletes a single `TemplateElement` using its globally unique id. */
  deleteTemplateElementByNodeId?: Maybe<DeleteTemplateElementPayload>;
  /** Deletes a single `TemplateElement` using a unique key. */
  deleteTemplateElementByTemplateCodeAndCodeAndTemplateVersion?: Maybe<DeleteTemplateElementPayload>;
  /** Deletes a single `TemplateFilterJoin` using a unique key. */
  deleteTemplateFilterJoin?: Maybe<DeleteTemplateFilterJoinPayload>;
  /** Deletes a single `TemplateFilterJoin` using its globally unique id. */
  deleteTemplateFilterJoinByNodeId?: Maybe<DeleteTemplateFilterJoinPayload>;
  /** Deletes a single `TemplatePermission` using a unique key. */
  deleteTemplatePermission?: Maybe<DeleteTemplatePermissionPayload>;
  /** Deletes a single `TemplatePermission` using its globally unique id. */
  deleteTemplatePermissionByNodeId?: Maybe<DeleteTemplatePermissionPayload>;
  /** Deletes a single `TemplateSection` using a unique key. */
  deleteTemplateSection?: Maybe<DeleteTemplateSectionPayload>;
  /** Deletes a single `TemplateSection` using its globally unique id. */
  deleteTemplateSectionByNodeId?: Maybe<DeleteTemplateSectionPayload>;
  /** Deletes a single `TemplateSection` using a unique key. */
  deleteTemplateSectionByTemplateIdAndCode?: Maybe<DeleteTemplateSectionPayload>;
  /** Deletes a single `TemplateStage` using a unique key. */
  deleteTemplateStage?: Maybe<DeleteTemplateStagePayload>;
  /** Deletes a single `TemplateStage` using its globally unique id. */
  deleteTemplateStageByNodeId?: Maybe<DeleteTemplateStagePayload>;
  /** Deletes a single `TemplateStageReviewLevel` using a unique key. */
  deleteTemplateStageReviewLevel?: Maybe<DeleteTemplateStageReviewLevelPayload>;
  /** Deletes a single `TemplateStageReviewLevel` using its globally unique id. */
  deleteTemplateStageReviewLevelByNodeId?: Maybe<DeleteTemplateStageReviewLevelPayload>;
  /** Deletes a single `TriggerQueue` using a unique key. */
  deleteTriggerQueue?: Maybe<DeleteTriggerQueuePayload>;
  /** Deletes a single `TriggerQueue` using its globally unique id. */
  deleteTriggerQueueByNodeId?: Maybe<DeleteTriggerQueuePayload>;
  /** Deletes a single `TriggerSchedule` using a unique key. */
  deleteTriggerSchedule?: Maybe<DeleteTriggerSchedulePayload>;
  /** Deletes a single `TriggerSchedule` using its globally unique id. */
  deleteTriggerScheduleByNodeId?: Maybe<DeleteTriggerSchedulePayload>;
  /** Deletes a single `UserApplicationJoin` using a unique key. */
  deleteUserApplicationJoin?: Maybe<DeleteUserApplicationJoinPayload>;
  /** Deletes a single `UserApplicationJoin` using its globally unique id. */
  deleteUserApplicationJoinByNodeId?: Maybe<DeleteUserApplicationJoinPayload>;
  /** Deletes a single `UserOrganisation` using a unique key. */
  deleteUserOrganisation?: Maybe<DeleteUserOrganisationPayload>;
  /** Deletes a single `UserOrganisation` using its globally unique id. */
  deleteUserOrganisationByNodeId?: Maybe<DeleteUserOrganisationPayload>;
  /** Deletes a single `Verification` using a unique key. */
  deleteVerification?: Maybe<DeleteVerificationPayload>;
  /** Deletes a single `Verification` using its globally unique id. */
  deleteVerificationByNodeId?: Maybe<DeleteVerificationPayload>;
  /** Deletes a single `Verification` using a unique key. */
  deleteVerificationByUniqueId?: Maybe<DeleteVerificationPayload>;
  deleteWholeApplication?: Maybe<DeleteWholeApplicationPayload>;
  /** Updates a single `ActionPlugin` using a unique key and a patch. */
  updateActionPlugin?: Maybe<UpdateActionPluginPayload>;
  /** Updates a single `ActionPlugin` using a unique key and a patch. */
  updateActionPluginByCode?: Maybe<UpdateActionPluginPayload>;
  /** Updates a single `ActionPlugin` using its globally unique id and a patch. */
  updateActionPluginByNodeId?: Maybe<UpdateActionPluginPayload>;
  /** Updates a single `ActionQueue` using a unique key and a patch. */
  updateActionQueue?: Maybe<UpdateActionQueuePayload>;
  /** Updates a single `ActionQueue` using its globally unique id and a patch. */
  updateActionQueueByNodeId?: Maybe<UpdateActionQueuePayload>;
  /** Updates a single `ActivityLog` using a unique key and a patch. */
  updateActivityLog?: Maybe<UpdateActivityLogPayload>;
  /** Updates a single `ActivityLog` using its globally unique id and a patch. */
  updateActivityLogByNodeId?: Maybe<UpdateActivityLogPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplication?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using its globally unique id and a patch. */
  updateApplicationByNodeId?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplicationByOutcomeRegistration?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `Application` using a unique key and a patch. */
  updateApplicationBySerial?: Maybe<UpdateApplicationPayload>;
  /** Updates a single `ApplicationNote` using a unique key and a patch. */
  updateApplicationNote?: Maybe<UpdateApplicationNotePayload>;
  /** Updates a single `ApplicationNote` using its globally unique id and a patch. */
  updateApplicationNoteByNodeId?: Maybe<UpdateApplicationNotePayload>;
  /** Updates a single `ApplicationResponse` using a unique key and a patch. */
  updateApplicationResponse?: Maybe<UpdateApplicationResponsePayload>;
  /** Updates a single `ApplicationResponse` using its globally unique id and a patch. */
  updateApplicationResponseByNodeId?: Maybe<UpdateApplicationResponsePayload>;
  /** Updates a single `ApplicationReviewerAction` using a unique key and a patch. */
  updateApplicationReviewerAction?: Maybe<UpdateApplicationReviewerActionPayload>;
  /** Updates a single `ApplicationReviewerAction` using its globally unique id and a patch. */
  updateApplicationReviewerActionByNodeId?: Maybe<UpdateApplicationReviewerActionPayload>;
  /** Updates a single `ApplicationReviewerAction` using a unique key and a patch. */
  updateApplicationReviewerActionByUserIdAndApplicationId?: Maybe<UpdateApplicationReviewerActionPayload>;
  /** Updates a single `ApplicationStageHistory` using a unique key and a patch. */
  updateApplicationStageHistory?: Maybe<UpdateApplicationStageHistoryPayload>;
  /** Updates a single `ApplicationStageHistory` using its globally unique id and a patch. */
  updateApplicationStageHistoryByNodeId?: Maybe<UpdateApplicationStageHistoryPayload>;
  /** Updates a single `ApplicationStatusHistory` using a unique key and a patch. */
  updateApplicationStatusHistory?: Maybe<UpdateApplicationStatusHistoryPayload>;
  /** Updates a single `ApplicationStatusHistory` using its globally unique id and a patch. */
  updateApplicationStatusHistoryByNodeId?: Maybe<UpdateApplicationStatusHistoryPayload>;
  /** Updates a single `Counter` using a unique key and a patch. */
  updateCounter?: Maybe<UpdateCounterPayload>;
  /** Updates a single `Counter` using a unique key and a patch. */
  updateCounterByName?: Maybe<UpdateCounterPayload>;
  /** Updates a single `Counter` using its globally unique id and a patch. */
  updateCounterByNodeId?: Maybe<UpdateCounterPayload>;
  /** Updates a single `DataChangelog` using a unique key and a patch. */
  updateDataChangelog?: Maybe<UpdateDataChangelogPayload>;
  /** Updates a single `DataChangelog` using its globally unique id and a patch. */
  updateDataChangelogByNodeId?: Maybe<UpdateDataChangelogPayload>;
  /** Updates a single `DataTable` using a unique key and a patch. */
  updateDataTable?: Maybe<UpdateDataTablePayload>;
  /** Updates a single `DataTableActiveIngredient` using a unique key and a patch. */
  updateDataTableActiveIngredient?: Maybe<UpdateDataTableActiveIngredientPayload>;
  /** Updates a single `DataTableActiveIngredient` using its globally unique id and a patch. */
  updateDataTableActiveIngredientByNodeId?: Maybe<UpdateDataTableActiveIngredientPayload>;
  /** Updates a single `DataTableAdministrationRoute` using a unique key and a patch. */
  updateDataTableAdministrationRoute?: Maybe<UpdateDataTableAdministrationRoutePayload>;
  /** Updates a single `DataTableAdministrationRoute` using its globally unique id and a patch. */
  updateDataTableAdministrationRouteByNodeId?: Maybe<UpdateDataTableAdministrationRoutePayload>;
  /** Updates a single `DataTableAtcCode` using a unique key and a patch. */
  updateDataTableAtcCode?: Maybe<UpdateDataTableAtcCodePayload>;
  /** Updates a single `DataTableAtcCode` using its globally unique id and a patch. */
  updateDataTableAtcCodeByNodeId?: Maybe<UpdateDataTableAtcCodePayload>;
  /** Updates a single `DataTable` using its globally unique id and a patch. */
  updateDataTableByNodeId?: Maybe<UpdateDataTablePayload>;
  /** Updates a single `DataTable` using a unique key and a patch. */
  updateDataTableByTableName?: Maybe<UpdateDataTablePayload>;
  /** Updates a single `DataTableContainer` using a unique key and a patch. */
  updateDataTableContainer?: Maybe<UpdateDataTableContainerPayload>;
  /** Updates a single `DataTableContainer` using its globally unique id and a patch. */
  updateDataTableContainerByNodeId?: Maybe<UpdateDataTableContainerPayload>;
  /** Updates a single `DataTableCountry` using a unique key and a patch. */
  updateDataTableCountry?: Maybe<UpdateDataTableCountryPayload>;
  /** Updates a single `DataTableCountry` using its globally unique id and a patch. */
  updateDataTableCountryByNodeId?: Maybe<UpdateDataTableCountryPayload>;
  /** Updates a single `DataTableDosageForm` using a unique key and a patch. */
  updateDataTableDosageForm?: Maybe<UpdateDataTableDosageFormPayload>;
  /** Updates a single `DataTableDosageForm` using its globally unique id and a patch. */
  updateDataTableDosageFormByNodeId?: Maybe<UpdateDataTableDosageFormPayload>;
  /** Updates a single `DataTableDosageFormGroup` using a unique key and a patch. */
  updateDataTableDosageFormGroup?: Maybe<UpdateDataTableDosageFormGroupPayload>;
  /** Updates a single `DataTableDosageFormGroup` using its globally unique id and a patch. */
  updateDataTableDosageFormGroupByNodeId?: Maybe<UpdateDataTableDosageFormGroupPayload>;
  /** Updates a single `DataTableGenericIngredient` using a unique key and a patch. */
  updateDataTableGenericIngredient?: Maybe<UpdateDataTableGenericIngredientPayload>;
  /** Updates a single `DataTableGenericIngredient` using its globally unique id and a patch. */
  updateDataTableGenericIngredientByNodeId?: Maybe<UpdateDataTableGenericIngredientPayload>;
  /** Updates a single `DataTableManufacturer` using a unique key and a patch. */
  updateDataTableManufacturer?: Maybe<UpdateDataTableManufacturerPayload>;
  /** Updates a single `DataTableManufacturerApplicationJoin` using a unique key and a patch. */
  updateDataTableManufacturerApplicationJoin?: Maybe<UpdateDataTableManufacturerApplicationJoinPayload>;
  /** Updates a single `DataTableManufacturerApplicationJoin` using its globally unique id and a patch. */
  updateDataTableManufacturerApplicationJoinByNodeId?: Maybe<UpdateDataTableManufacturerApplicationJoinPayload>;
  /** Updates a single `DataTableManufacturer` using its globally unique id and a patch. */
  updateDataTableManufacturerByNodeId?: Maybe<UpdateDataTableManufacturerPayload>;
  /** Updates a single `DataTableManufacturerRepresentative` using a unique key and a patch. */
  updateDataTableManufacturerRepresentative?: Maybe<UpdateDataTableManufacturerRepresentativePayload>;
  /** Updates a single `DataTableManufacturerRepresentativeApplicationJoin` using a unique key and a patch. */
  updateDataTableManufacturerRepresentativeApplicationJoin?: Maybe<UpdateDataTableManufacturerRepresentativeApplicationJoinPayload>;
  /** Updates a single `DataTableManufacturerRepresentativeApplicationJoin` using its globally unique id and a patch. */
  updateDataTableManufacturerRepresentativeApplicationJoinByNodeId?: Maybe<UpdateDataTableManufacturerRepresentativeApplicationJoinPayload>;
  /** Updates a single `DataTableManufacturerRepresentative` using its globally unique id and a patch. */
  updateDataTableManufacturerRepresentativeByNodeId?: Maybe<UpdateDataTableManufacturerRepresentativePayload>;
  /** Updates a single `DataTablePermitChemical` using a unique key and a patch. */
  updateDataTablePermitChemical?: Maybe<UpdateDataTablePermitChemicalPayload>;
  /** Updates a single `DataTablePermitChemicalApplicationJoin` using a unique key and a patch. */
  updateDataTablePermitChemicalApplicationJoin?: Maybe<UpdateDataTablePermitChemicalApplicationJoinPayload>;
  /** Updates a single `DataTablePermitChemicalApplicationJoin` using its globally unique id and a patch. */
  updateDataTablePermitChemicalApplicationJoinByNodeId?: Maybe<UpdateDataTablePermitChemicalApplicationJoinPayload>;
  /** Updates a single `DataTablePermitChemical` using its globally unique id and a patch. */
  updateDataTablePermitChemicalByNodeId?: Maybe<UpdateDataTablePermitChemicalPayload>;
  /** Updates a single `DataTablePreRegisteredProductsProvisional` using a unique key and a patch. */
  updateDataTablePreRegisteredProductsProvisional?: Maybe<UpdateDataTablePreRegisteredProductsProvisionalPayload>;
  /** Updates a single `DataTablePreRegisteredProductsProvisional` using its globally unique id and a patch. */
  updateDataTablePreRegisteredProductsProvisionalByNodeId?: Maybe<UpdateDataTablePreRegisteredProductsProvisionalPayload>;
  /** Updates a single `DataTablePrequalManufacturer` using a unique key and a patch. */
  updateDataTablePrequalManufacturer?: Maybe<UpdateDataTablePrequalManufacturerPayload>;
  /** Updates a single `DataTablePrequalManufacturerApplicationJoin` using a unique key and a patch. */
  updateDataTablePrequalManufacturerApplicationJoin?: Maybe<UpdateDataTablePrequalManufacturerApplicationJoinPayload>;
  /** Updates a single `DataTablePrequalManufacturerApplicationJoin` using its globally unique id and a patch. */
  updateDataTablePrequalManufacturerApplicationJoinByNodeId?: Maybe<UpdateDataTablePrequalManufacturerApplicationJoinPayload>;
  /** Updates a single `DataTablePrequalManufacturer` using its globally unique id and a patch. */
  updateDataTablePrequalManufacturerByNodeId?: Maybe<UpdateDataTablePrequalManufacturerPayload>;
  /** Updates a single `DataTableProcessingStep` using a unique key and a patch. */
  updateDataTableProcessingStep?: Maybe<UpdateDataTableProcessingStepPayload>;
  /** Updates a single `DataTableProcessingStep` using its globally unique id and a patch. */
  updateDataTableProcessingStepByNodeId?: Maybe<UpdateDataTableProcessingStepPayload>;
  /** Updates a single `DataTableProduct` using a unique key and a patch. */
  updateDataTableProduct?: Maybe<UpdateDataTableProductPayload>;
  /** Updates a single `DataTableProductApplicationJoin` using a unique key and a patch. */
  updateDataTableProductApplicationJoin?: Maybe<UpdateDataTableProductApplicationJoinPayload>;
  /** Updates a single `DataTableProductApplicationJoin` using its globally unique id and a patch. */
  updateDataTableProductApplicationJoinByNodeId?: Maybe<UpdateDataTableProductApplicationJoinPayload>;
  /** Updates a single `DataTableProduct` using its globally unique id and a patch. */
  updateDataTableProductByNodeId?: Maybe<UpdateDataTableProductPayload>;
  /** Updates a single `DataTableProvisionalProduct` using a unique key and a patch. */
  updateDataTableProvisionalProduct?: Maybe<UpdateDataTableProvisionalProductPayload>;
  /** Updates a single `DataTableProvisionalProductApplicationJoin` using a unique key and a patch. */
  updateDataTableProvisionalProductApplicationJoin?: Maybe<UpdateDataTableProvisionalProductApplicationJoinPayload>;
  /** Updates a single `DataTableProvisionalProductApplicationJoin` using its globally unique id and a patch. */
  updateDataTableProvisionalProductApplicationJoinByNodeId?: Maybe<UpdateDataTableProvisionalProductApplicationJoinPayload>;
  /** Updates a single `DataTableProvisionalProduct` using its globally unique id and a patch. */
  updateDataTableProvisionalProductByNodeId?: Maybe<UpdateDataTableProvisionalProductPayload>;
  /** Updates a single `DataTableScheduledChemical` using a unique key and a patch. */
  updateDataTableScheduledChemical?: Maybe<UpdateDataTableScheduledChemicalPayload>;
  /** Updates a single `DataTableScheduledChemical` using its globally unique id and a patch. */
  updateDataTableScheduledChemicalByNodeId?: Maybe<UpdateDataTableScheduledChemicalPayload>;
  /** Updates a single `DataTableStorageCondition` using a unique key and a patch. */
  updateDataTableStorageCondition?: Maybe<UpdateDataTableStorageConditionPayload>;
  /** Updates a single `DataTableStorageCondition` using its globally unique id and a patch. */
  updateDataTableStorageConditionByNodeId?: Maybe<UpdateDataTableStorageConditionPayload>;
  /** Updates a single `DataTableStorageConditionsSimplified` using a unique key and a patch. */
  updateDataTableStorageConditionsSimplified?: Maybe<UpdateDataTableStorageConditionsSimplifiedPayload>;
  /** Updates a single `DataTableStorageConditionsSimplified` using its globally unique id and a patch. */
  updateDataTableStorageConditionsSimplifiedByNodeId?: Maybe<UpdateDataTableStorageConditionsSimplifiedPayload>;
  /** Updates a single `DataTableUnitsOfProportion` using a unique key and a patch. */
  updateDataTableUnitsOfProportion?: Maybe<UpdateDataTableUnitsOfProportionPayload>;
  /** Updates a single `DataTableUnitsOfProportion` using its globally unique id and a patch. */
  updateDataTableUnitsOfProportionByNodeId?: Maybe<UpdateDataTableUnitsOfProportionPayload>;
  /** Updates a single `DataTableWorldHealthOrganisationPqListOfFpp` using a unique key and a patch. */
  updateDataTableWorldHealthOrganisationPqListOfFpp?: Maybe<UpdateDataTableWorldHealthOrganisationPqListOfFppPayload>;
  /** Updates a single `DataTableWorldHealthOrganisationPqListOfFpp` using its globally unique id and a patch. */
  updateDataTableWorldHealthOrganisationPqListOfFppByNodeId?: Maybe<UpdateDataTableWorldHealthOrganisationPqListOfFppPayload>;
  /** Updates a single `DataView` using a unique key and a patch. */
  updateDataView?: Maybe<UpdateDataViewPayload>;
  /** Updates a single `DataView` using a unique key and a patch. */
  updateDataViewByIdentifier?: Maybe<UpdateDataViewPayload>;
  /** Updates a single `DataView` using its globally unique id and a patch. */
  updateDataViewByNodeId?: Maybe<UpdateDataViewPayload>;
  /** Updates a single `DataViewColumnDefinition` using a unique key and a patch. */
  updateDataViewColumnDefinition?: Maybe<UpdateDataViewColumnDefinitionPayload>;
  /** Updates a single `DataViewColumnDefinition` using its globally unique id and a patch. */
  updateDataViewColumnDefinitionByNodeId?: Maybe<UpdateDataViewColumnDefinitionPayload>;
  /** Updates a single `DataViewColumnDefinition` using a unique key and a patch. */
  updateDataViewColumnDefinitionByTableNameAndColumnName?: Maybe<UpdateDataViewColumnDefinitionPayload>;
  /** Updates a single `ElementTypePlugin` using a unique key and a patch. */
  updateElementTypePlugin?: Maybe<UpdateElementTypePluginPayload>;
  /** Updates a single `ElementTypePlugin` using its globally unique id and a patch. */
  updateElementTypePluginByNodeId?: Maybe<UpdateElementTypePluginPayload>;
  /** Updates a single `File` using a unique key and a patch. */
  updateFile?: Maybe<UpdateFilePayload>;
  /** Updates a single `File` using its globally unique id and a patch. */
  updateFileByNodeId?: Maybe<UpdateFilePayload>;
  /** Updates a single `File` using a unique key and a patch. */
  updateFileByUniqueId?: Maybe<UpdateFilePayload>;
  /** Updates a single `Filter` using a unique key and a patch. */
  updateFilter?: Maybe<UpdateFilterPayload>;
  /** Updates a single `Filter` using a unique key and a patch. */
  updateFilterByCode?: Maybe<UpdateFilterPayload>;
  /** Updates a single `Filter` using its globally unique id and a patch. */
  updateFilterByNodeId?: Maybe<UpdateFilterPayload>;
  /** Updates a single `GrafanaDashboardImage` using a unique key and a patch. */
  updateGrafanaDashboardImage?: Maybe<UpdateGrafanaDashboardImagePayload>;
  /** Updates a single `GrafanaDashboardImage` using its globally unique id and a patch. */
  updateGrafanaDashboardImageByNodeId?: Maybe<UpdateGrafanaDashboardImagePayload>;
  /** Updates a single `Notification` using a unique key and a patch. */
  updateNotification?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Notification` using its globally unique id and a patch. */
  updateNotificationByNodeId?: Maybe<UpdateNotificationPayload>;
  /** Updates a single `Organisation` using a unique key and a patch. */
  updateOrganisation?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `OrganisationApplicationJoin` using a unique key and a patch. */
  updateOrganisationApplicationJoin?: Maybe<UpdateOrganisationApplicationJoinPayload>;
  /** Updates a single `OrganisationApplicationJoin` using its globally unique id and a patch. */
  updateOrganisationApplicationJoinByNodeId?: Maybe<UpdateOrganisationApplicationJoinPayload>;
  /** Updates a single `Organisation` using a unique key and a patch. */
  updateOrganisationByName?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `Organisation` using its globally unique id and a patch. */
  updateOrganisationByNodeId?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `Organisation` using a unique key and a patch. */
  updateOrganisationByRegistration?: Maybe<UpdateOrganisationPayload>;
  /** Updates a single `PermissionJoin` using a unique key and a patch. */
  updatePermissionJoin?: Maybe<UpdatePermissionJoinPayload>;
  /** Updates a single `PermissionJoin` using its globally unique id and a patch. */
  updatePermissionJoinByNodeId?: Maybe<UpdatePermissionJoinPayload>;
  /** Updates a single `PermissionName` using a unique key and a patch. */
  updatePermissionName?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionName` using a unique key and a patch. */
  updatePermissionNameByName?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionName` using its globally unique id and a patch. */
  updatePermissionNameByNodeId?: Maybe<UpdatePermissionNamePayload>;
  /** Updates a single `PermissionPolicy` using a unique key and a patch. */
  updatePermissionPolicy?: Maybe<UpdatePermissionPolicyPayload>;
  /** Updates a single `PermissionPolicy` using a unique key and a patch. */
  updatePermissionPolicyByName?: Maybe<UpdatePermissionPolicyPayload>;
  /** Updates a single `PermissionPolicy` using its globally unique id and a patch. */
  updatePermissionPolicyByNodeId?: Maybe<UpdatePermissionPolicyPayload>;
  /** Updates a single `Review` using a unique key and a patch. */
  updateReview?: Maybe<UpdateReviewPayload>;
  /** Updates a single `ReviewAssignment` using a unique key and a patch. */
  updateReviewAssignment?: Maybe<UpdateReviewAssignmentPayload>;
  /** Updates a single `ReviewAssignmentAssignerJoin` using a unique key and a patch. */
  updateReviewAssignmentAssignerJoin?: Maybe<UpdateReviewAssignmentAssignerJoinPayload>;
  /** Updates a single `ReviewAssignmentAssignerJoin` using its globally unique id and a patch. */
  updateReviewAssignmentAssignerJoinByNodeId?: Maybe<UpdateReviewAssignmentAssignerJoinPayload>;
  /** Updates a single `ReviewAssignment` using its globally unique id and a patch. */
  updateReviewAssignmentByNodeId?: Maybe<UpdateReviewAssignmentPayload>;
  /** Updates a single `Review` using its globally unique id and a patch. */
  updateReviewByNodeId?: Maybe<UpdateReviewPayload>;
  /** Updates a single `Review` using a unique key and a patch. */
  updateReviewByReviewAssignmentId?: Maybe<UpdateReviewPayload>;
  /** Updates a single `ReviewDecision` using a unique key and a patch. */
  updateReviewDecision?: Maybe<UpdateReviewDecisionPayload>;
  /** Updates a single `ReviewDecision` using its globally unique id and a patch. */
  updateReviewDecisionByNodeId?: Maybe<UpdateReviewDecisionPayload>;
  /** Updates a single `ReviewResponse` using a unique key and a patch. */
  updateReviewResponse?: Maybe<UpdateReviewResponsePayload>;
  /** Updates a single `ReviewResponse` using its globally unique id and a patch. */
  updateReviewResponseByNodeId?: Maybe<UpdateReviewResponsePayload>;
  /** Updates a single `ReviewStatusHistory` using a unique key and a patch. */
  updateReviewStatusHistory?: Maybe<UpdateReviewStatusHistoryPayload>;
  /** Updates a single `ReviewStatusHistory` using its globally unique id and a patch. */
  updateReviewStatusHistoryByNodeId?: Maybe<UpdateReviewStatusHistoryPayload>;
  /** Updates a single `SystemInfo` using a unique key and a patch. */
  updateSystemInfo?: Maybe<UpdateSystemInfoPayload>;
  /** Updates a single `SystemInfo` using its globally unique id and a patch. */
  updateSystemInfoByNodeId?: Maybe<UpdateSystemInfoPayload>;
  /** Updates a single `Template` using a unique key and a patch. */
  updateTemplate?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `TemplateAction` using a unique key and a patch. */
  updateTemplateAction?: Maybe<UpdateTemplateActionPayload>;
  /** Updates a single `TemplateAction` using its globally unique id and a patch. */
  updateTemplateActionByNodeId?: Maybe<UpdateTemplateActionPayload>;
  /** Updates a single `Template` using a unique key and a patch. */
  updateTemplateByCodeAndVersionId?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `Template` using its globally unique id and a patch. */
  updateTemplateByNodeId?: Maybe<UpdateTemplatePayload>;
  /** Updates a single `TemplateCategory` using a unique key and a patch. */
  updateTemplateCategory?: Maybe<UpdateTemplateCategoryPayload>;
  /** Updates a single `TemplateCategory` using a unique key and a patch. */
  updateTemplateCategoryByCode?: Maybe<UpdateTemplateCategoryPayload>;
  /** Updates a single `TemplateCategory` using its globally unique id and a patch. */
  updateTemplateCategoryByNodeId?: Maybe<UpdateTemplateCategoryPayload>;
  /** Updates a single `TemplateElement` using a unique key and a patch. */
  updateTemplateElement?: Maybe<UpdateTemplateElementPayload>;
  /** Updates a single `TemplateElement` using its globally unique id and a patch. */
  updateTemplateElementByNodeId?: Maybe<UpdateTemplateElementPayload>;
  /** Updates a single `TemplateElement` using a unique key and a patch. */
  updateTemplateElementByTemplateCodeAndCodeAndTemplateVersion?: Maybe<UpdateTemplateElementPayload>;
  /** Updates a single `TemplateFilterJoin` using a unique key and a patch. */
  updateTemplateFilterJoin?: Maybe<UpdateTemplateFilterJoinPayload>;
  /** Updates a single `TemplateFilterJoin` using its globally unique id and a patch. */
  updateTemplateFilterJoinByNodeId?: Maybe<UpdateTemplateFilterJoinPayload>;
  /** Updates a single `TemplatePermission` using a unique key and a patch. */
  updateTemplatePermission?: Maybe<UpdateTemplatePermissionPayload>;
  /** Updates a single `TemplatePermission` using its globally unique id and a patch. */
  updateTemplatePermissionByNodeId?: Maybe<UpdateTemplatePermissionPayload>;
  /** Updates a single `TemplateSection` using a unique key and a patch. */
  updateTemplateSection?: Maybe<UpdateTemplateSectionPayload>;
  /** Updates a single `TemplateSection` using its globally unique id and a patch. */
  updateTemplateSectionByNodeId?: Maybe<UpdateTemplateSectionPayload>;
  /** Updates a single `TemplateSection` using a unique key and a patch. */
  updateTemplateSectionByTemplateIdAndCode?: Maybe<UpdateTemplateSectionPayload>;
  /** Updates a single `TemplateStage` using a unique key and a patch. */
  updateTemplateStage?: Maybe<UpdateTemplateStagePayload>;
  /** Updates a single `TemplateStage` using its globally unique id and a patch. */
  updateTemplateStageByNodeId?: Maybe<UpdateTemplateStagePayload>;
  /** Updates a single `TemplateStageReviewLevel` using a unique key and a patch. */
  updateTemplateStageReviewLevel?: Maybe<UpdateTemplateStageReviewLevelPayload>;
  /** Updates a single `TemplateStageReviewLevel` using its globally unique id and a patch. */
  updateTemplateStageReviewLevelByNodeId?: Maybe<UpdateTemplateStageReviewLevelPayload>;
  /** Updates a single `TriggerQueue` using a unique key and a patch. */
  updateTriggerQueue?: Maybe<UpdateTriggerQueuePayload>;
  /** Updates a single `TriggerQueue` using its globally unique id and a patch. */
  updateTriggerQueueByNodeId?: Maybe<UpdateTriggerQueuePayload>;
  /** Updates a single `TriggerSchedule` using a unique key and a patch. */
  updateTriggerSchedule?: Maybe<UpdateTriggerSchedulePayload>;
  /** Updates a single `TriggerSchedule` using its globally unique id and a patch. */
  updateTriggerScheduleByNodeId?: Maybe<UpdateTriggerSchedulePayload>;
  /** Updates a single `UserApplicationJoin` using a unique key and a patch. */
  updateUserApplicationJoin?: Maybe<UpdateUserApplicationJoinPayload>;
  /** Updates a single `UserApplicationJoin` using its globally unique id and a patch. */
  updateUserApplicationJoinByNodeId?: Maybe<UpdateUserApplicationJoinPayload>;
  /** Updates a single `UserOrganisation` using a unique key and a patch. */
  updateUserOrganisation?: Maybe<UpdateUserOrganisationPayload>;
  /** Updates a single `UserOrganisation` using its globally unique id and a patch. */
  updateUserOrganisationByNodeId?: Maybe<UpdateUserOrganisationPayload>;
  /** Updates a single `Verification` using a unique key and a patch. */
  updateVerification?: Maybe<UpdateVerificationPayload>;
  /** Updates a single `Verification` using its globally unique id and a patch. */
  updateVerificationByNodeId?: Maybe<UpdateVerificationPayload>;
  /** Updates a single `Verification` using a unique key and a patch. */
  updateVerificationByUniqueId?: Maybe<UpdateVerificationPayload>;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActionPluginArgs = {
  input: CreateActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActionQueueArgs = {
  input: CreateActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateActivityLogArgs = {
  input: CreateActivityLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateAllowedSelfAssignableSectionsShapeArgs = {
  input: CreateAllowedSelfAssignableSectionsShapeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationArgs = {
  input: CreateApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationListShapeArgs = {
  input: CreateApplicationListShapeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationNoteArgs = {
  input: CreateApplicationNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationResponseArgs = {
  input: CreateApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationReviewerActionArgs = {
  input: CreateApplicationReviewerActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationStageHistoryArgs = {
  input: CreateApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateApplicationStatusHistoryArgs = {
  input: CreateApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateCounterArgs = {
  input: CreateCounterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataChangelogArgs = {
  input: CreateDataChangelogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableArgs = {
  input: CreateDataTableInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableActiveIngredientArgs = {
  input: CreateDataTableActiveIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableAdministrationRouteArgs = {
  input: CreateDataTableAdministrationRouteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableAtcCodeArgs = {
  input: CreateDataTableAtcCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableContainerArgs = {
  input: CreateDataTableContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableCountryArgs = {
  input: CreateDataTableCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableDosageFormArgs = {
  input: CreateDataTableDosageFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableDosageFormGroupArgs = {
  input: CreateDataTableDosageFormGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableGenericIngredientArgs = {
  input: CreateDataTableGenericIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableManufacturerArgs = {
  input: CreateDataTableManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableManufacturerApplicationJoinArgs = {
  input: CreateDataTableManufacturerApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableManufacturerRepresentativeArgs = {
  input: CreateDataTableManufacturerRepresentativeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableManufacturerRepresentativeApplicationJoinArgs = {
  input: CreateDataTableManufacturerRepresentativeApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTablePermitChemicalArgs = {
  input: CreateDataTablePermitChemicalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTablePermitChemicalApplicationJoinArgs = {
  input: CreateDataTablePermitChemicalApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTablePreRegisteredProductsProvisionalArgs = {
  input: CreateDataTablePreRegisteredProductsProvisionalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTablePrequalManufacturerArgs = {
  input: CreateDataTablePrequalManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTablePrequalManufacturerApplicationJoinArgs = {
  input: CreateDataTablePrequalManufacturerApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProcessingStepArgs = {
  input: CreateDataTableProcessingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProductArgs = {
  input: CreateDataTableProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProductApplicationJoinArgs = {
  input: CreateDataTableProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProvisionalProductArgs = {
  input: CreateDataTableProvisionalProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableProvisionalProductApplicationJoinArgs = {
  input: CreateDataTableProvisionalProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableScheduledChemicalArgs = {
  input: CreateDataTableScheduledChemicalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableStorageConditionArgs = {
  input: CreateDataTableStorageConditionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableStorageConditionsSimplifiedArgs = {
  input: CreateDataTableStorageConditionsSimplifiedInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableUnitsOfProportionArgs = {
  input: CreateDataTableUnitsOfProportionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataTableWorldHealthOrganisationPqListOfFppArgs = {
  input: CreateDataTableWorldHealthOrganisationPqListOfFppInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataViewArgs = {
  input: CreateDataViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateDataViewColumnDefinitionArgs = {
  input: CreateDataViewColumnDefinitionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateElementTypePluginArgs = {
  input: CreateElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFileArgs = {
  input: CreateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateFilterArgs = {
  input: CreateFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateGrafanaDashboardImageArgs = {
  input: CreateGrafanaDashboardImageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateNotificationArgs = {
  input: CreateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganisationArgs = {
  input: CreateOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateOrganisationApplicationJoinArgs = {
  input: CreateOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionJoinArgs = {
  input: CreatePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionNameArgs = {
  input: CreatePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreatePermissionPolicyArgs = {
  input: CreatePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewArgs = {
  input: CreateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewAssignmentArgs = {
  input: CreateReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewAssignmentAssignedSectionsShapeArgs = {
  input: CreateReviewAssignmentAssignedSectionsShapeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewAssignmentAssignerJoinArgs = {
  input: CreateReviewAssignmentAssignerJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewDecisionArgs = {
  input: CreateReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewResponseArgs = {
  input: CreateReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateReviewStatusHistoryArgs = {
  input: CreateReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateSystemInfoArgs = {
  input: CreateSystemInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateArgs = {
  input: CreateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateActionArgs = {
  input: CreateTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateCategoryArgs = {
  input: CreateTemplateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateElementArgs = {
  input: CreateTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateFilterJoinArgs = {
  input: CreateTemplateFilterJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplatePermissionArgs = {
  input: CreateTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateSectionArgs = {
  input: CreateTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateStageArgs = {
  input: CreateTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTemplateStageReviewLevelArgs = {
  input: CreateTemplateStageReviewLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTriggerQueueArgs = {
  input: CreateTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateTriggerScheduleArgs = {
  input: CreateTriggerScheduleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserArgs = {
  input: CreateUserInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserApplicationJoinArgs = {
  input: CreateUserApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserListArgs = {
  input: CreateUserListInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateUserOrganisationArgs = {
  input: CreateUserOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationCreateVerificationArgs = {
  input: CreateVerificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionPluginArgs = {
  input: DeleteActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionPluginByCodeArgs = {
  input: DeleteActionPluginByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionPluginByNodeIdArgs = {
  input: DeleteActionPluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionQueueArgs = {
  input: DeleteActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActionQueueByNodeIdArgs = {
  input: DeleteActionQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActivityLogArgs = {
  input: DeleteActivityLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteActivityLogByNodeIdArgs = {
  input: DeleteActivityLogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationArgs = {
  input: DeleteApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationByNodeIdArgs = {
  input: DeleteApplicationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationByOutcomeRegistrationArgs = {
  input: DeleteApplicationByOutcomeRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationBySerialArgs = {
  input: DeleteApplicationBySerialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationNoteArgs = {
  input: DeleteApplicationNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationNoteByNodeIdArgs = {
  input: DeleteApplicationNoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationResponseArgs = {
  input: DeleteApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationResponseByNodeIdArgs = {
  input: DeleteApplicationResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationReviewerActionArgs = {
  input: DeleteApplicationReviewerActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationReviewerActionByNodeIdArgs = {
  input: DeleteApplicationReviewerActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationReviewerActionByUserIdAndApplicationIdArgs = {
  input: DeleteApplicationReviewerActionByUserIdAndApplicationIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStageHistoryArgs = {
  input: DeleteApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStageHistoryByNodeIdArgs = {
  input: DeleteApplicationStageHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStatusHistoryArgs = {
  input: DeleteApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteApplicationStatusHistoryByNodeIdArgs = {
  input: DeleteApplicationStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCounterArgs = {
  input: DeleteCounterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCounterByNameArgs = {
  input: DeleteCounterByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteCounterByNodeIdArgs = {
  input: DeleteCounterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataChangelogArgs = {
  input: DeleteDataChangelogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataChangelogByNodeIdArgs = {
  input: DeleteDataChangelogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableArgs = {
  input: DeleteDataTableInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableActiveIngredientArgs = {
  input: DeleteDataTableActiveIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableActiveIngredientByNodeIdArgs = {
  input: DeleteDataTableActiveIngredientByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAdministrationRouteArgs = {
  input: DeleteDataTableAdministrationRouteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAdministrationRouteByNodeIdArgs = {
  input: DeleteDataTableAdministrationRouteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAtcCodeArgs = {
  input: DeleteDataTableAtcCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableAtcCodeByNodeIdArgs = {
  input: DeleteDataTableAtcCodeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableByNodeIdArgs = {
  input: DeleteDataTableByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableByTableNameArgs = {
  input: DeleteDataTableByTableNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableContainerArgs = {
  input: DeleteDataTableContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableContainerByNodeIdArgs = {
  input: DeleteDataTableContainerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableCountryArgs = {
  input: DeleteDataTableCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableCountryByNodeIdArgs = {
  input: DeleteDataTableCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableDosageFormArgs = {
  input: DeleteDataTableDosageFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableDosageFormByNodeIdArgs = {
  input: DeleteDataTableDosageFormByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableDosageFormGroupArgs = {
  input: DeleteDataTableDosageFormGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableDosageFormGroupByNodeIdArgs = {
  input: DeleteDataTableDosageFormGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableGenericIngredientArgs = {
  input: DeleteDataTableGenericIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableGenericIngredientByNodeIdArgs = {
  input: DeleteDataTableGenericIngredientByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturerArgs = {
  input: DeleteDataTableManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturerApplicationJoinArgs = {
  input: DeleteDataTableManufacturerApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturerApplicationJoinByNodeIdArgs = {
  input: DeleteDataTableManufacturerApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturerByNodeIdArgs = {
  input: DeleteDataTableManufacturerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturerRepresentativeArgs = {
  input: DeleteDataTableManufacturerRepresentativeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturerRepresentativeApplicationJoinArgs = {
  input: DeleteDataTableManufacturerRepresentativeApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturerRepresentativeApplicationJoinByNodeIdArgs = {
  input: DeleteDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableManufacturerRepresentativeByNodeIdArgs = {
  input: DeleteDataTableManufacturerRepresentativeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePermitChemicalArgs = {
  input: DeleteDataTablePermitChemicalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePermitChemicalApplicationJoinArgs = {
  input: DeleteDataTablePermitChemicalApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePermitChemicalApplicationJoinByNodeIdArgs = {
  input: DeleteDataTablePermitChemicalApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePermitChemicalByNodeIdArgs = {
  input: DeleteDataTablePermitChemicalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePreRegisteredProductsProvisionalArgs = {
  input: DeleteDataTablePreRegisteredProductsProvisionalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePreRegisteredProductsProvisionalByNodeIdArgs = {
  input: DeleteDataTablePreRegisteredProductsProvisionalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePrequalManufacturerArgs = {
  input: DeleteDataTablePrequalManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePrequalManufacturerApplicationJoinArgs = {
  input: DeleteDataTablePrequalManufacturerApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePrequalManufacturerApplicationJoinByNodeIdArgs = {
  input: DeleteDataTablePrequalManufacturerApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTablePrequalManufacturerByNodeIdArgs = {
  input: DeleteDataTablePrequalManufacturerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProcessingStepArgs = {
  input: DeleteDataTableProcessingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProcessingStepByNodeIdArgs = {
  input: DeleteDataTableProcessingStepByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProductArgs = {
  input: DeleteDataTableProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProductApplicationJoinArgs = {
  input: DeleteDataTableProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProductApplicationJoinByNodeIdArgs = {
  input: DeleteDataTableProductApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProductByNodeIdArgs = {
  input: DeleteDataTableProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProvisionalProductArgs = {
  input: DeleteDataTableProvisionalProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProvisionalProductApplicationJoinArgs = {
  input: DeleteDataTableProvisionalProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProvisionalProductApplicationJoinByNodeIdArgs = {
  input: DeleteDataTableProvisionalProductApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableProvisionalProductByNodeIdArgs = {
  input: DeleteDataTableProvisionalProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableScheduledChemicalArgs = {
  input: DeleteDataTableScheduledChemicalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableScheduledChemicalByNodeIdArgs = {
  input: DeleteDataTableScheduledChemicalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableStorageConditionArgs = {
  input: DeleteDataTableStorageConditionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableStorageConditionByNodeIdArgs = {
  input: DeleteDataTableStorageConditionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableStorageConditionsSimplifiedArgs = {
  input: DeleteDataTableStorageConditionsSimplifiedInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableStorageConditionsSimplifiedByNodeIdArgs = {
  input: DeleteDataTableStorageConditionsSimplifiedByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableUnitsOfProportionArgs = {
  input: DeleteDataTableUnitsOfProportionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableUnitsOfProportionByNodeIdArgs = {
  input: DeleteDataTableUnitsOfProportionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableWorldHealthOrganisationPqListOfFppArgs = {
  input: DeleteDataTableWorldHealthOrganisationPqListOfFppInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataTableWorldHealthOrganisationPqListOfFppByNodeIdArgs = {
  input: DeleteDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewArgs = {
  input: DeleteDataViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewByIdentifierArgs = {
  input: DeleteDataViewByIdentifierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewByNodeIdArgs = {
  input: DeleteDataViewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewColumnDefinitionArgs = {
  input: DeleteDataViewColumnDefinitionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewColumnDefinitionByNodeIdArgs = {
  input: DeleteDataViewColumnDefinitionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteDataViewColumnDefinitionByTableNameAndColumnNameArgs = {
  input: DeleteDataViewColumnDefinitionByTableNameAndColumnNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElementTypePluginArgs = {
  input: DeleteElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteElementTypePluginByNodeIdArgs = {
  input: DeleteElementTypePluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileArgs = {
  input: DeleteFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileByNodeIdArgs = {
  input: DeleteFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFileByUniqueIdArgs = {
  input: DeleteFileByUniqueIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterArgs = {
  input: DeleteFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterByCodeArgs = {
  input: DeleteFilterByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteFilterByNodeIdArgs = {
  input: DeleteFilterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGrafanaDashboardImageArgs = {
  input: DeleteGrafanaDashboardImageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteGrafanaDashboardImageByNodeIdArgs = {
  input: DeleteGrafanaDashboardImageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationArgs = {
  input: DeleteNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteNotificationByNodeIdArgs = {
  input: DeleteNotificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationArgs = {
  input: DeleteOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationApplicationJoinArgs = {
  input: DeleteOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationApplicationJoinByNodeIdArgs = {
  input: DeleteOrganisationApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationByNameArgs = {
  input: DeleteOrganisationByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationByNodeIdArgs = {
  input: DeleteOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteOrganisationByRegistrationArgs = {
  input: DeleteOrganisationByRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionJoinArgs = {
  input: DeletePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionJoinByNodeIdArgs = {
  input: DeletePermissionJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameArgs = {
  input: DeletePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameByNameArgs = {
  input: DeletePermissionNameByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionNameByNodeIdArgs = {
  input: DeletePermissionNameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionPolicyArgs = {
  input: DeletePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionPolicyByNameArgs = {
  input: DeletePermissionPolicyByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeletePermissionPolicyByNodeIdArgs = {
  input: DeletePermissionPolicyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewArgs = {
  input: DeleteReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentArgs = {
  input: DeleteReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentAssignerJoinArgs = {
  input: DeleteReviewAssignmentAssignerJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentAssignerJoinByNodeIdArgs = {
  input: DeleteReviewAssignmentAssignerJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewAssignmentByNodeIdArgs = {
  input: DeleteReviewAssignmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewByNodeIdArgs = {
  input: DeleteReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewByReviewAssignmentIdArgs = {
  input: DeleteReviewByReviewAssignmentIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewDecisionArgs = {
  input: DeleteReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewDecisionByNodeIdArgs = {
  input: DeleteReviewDecisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewResponseArgs = {
  input: DeleteReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewResponseByNodeIdArgs = {
  input: DeleteReviewResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewStatusHistoryArgs = {
  input: DeleteReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteReviewStatusHistoryByNodeIdArgs = {
  input: DeleteReviewStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSystemInfoArgs = {
  input: DeleteSystemInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteSystemInfoByNodeIdArgs = {
  input: DeleteSystemInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateArgs = {
  input: DeleteTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateActionArgs = {
  input: DeleteTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateActionByNodeIdArgs = {
  input: DeleteTemplateActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateByCodeAndVersionIdArgs = {
  input: DeleteTemplateByCodeAndVersionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateByNodeIdArgs = {
  input: DeleteTemplateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateCategoryArgs = {
  input: DeleteTemplateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateCategoryByCodeArgs = {
  input: DeleteTemplateCategoryByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateCategoryByNodeIdArgs = {
  input: DeleteTemplateCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateElementArgs = {
  input: DeleteTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateElementByNodeIdArgs = {
  input: DeleteTemplateElementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs = {
  input: DeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateFilterJoinArgs = {
  input: DeleteTemplateFilterJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateFilterJoinByNodeIdArgs = {
  input: DeleteTemplateFilterJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplatePermissionArgs = {
  input: DeleteTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplatePermissionByNodeIdArgs = {
  input: DeleteTemplatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateSectionArgs = {
  input: DeleteTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateSectionByNodeIdArgs = {
  input: DeleteTemplateSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateSectionByTemplateIdAndCodeArgs = {
  input: DeleteTemplateSectionByTemplateIdAndCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageArgs = {
  input: DeleteTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageByNodeIdArgs = {
  input: DeleteTemplateStageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageReviewLevelArgs = {
  input: DeleteTemplateStageReviewLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTemplateStageReviewLevelByNodeIdArgs = {
  input: DeleteTemplateStageReviewLevelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerQueueArgs = {
  input: DeleteTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerQueueByNodeIdArgs = {
  input: DeleteTriggerQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerScheduleArgs = {
  input: DeleteTriggerScheduleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteTriggerScheduleByNodeIdArgs = {
  input: DeleteTriggerScheduleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserApplicationJoinArgs = {
  input: DeleteUserApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserApplicationJoinByNodeIdArgs = {
  input: DeleteUserApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationArgs = {
  input: DeleteUserOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteUserOrganisationByNodeIdArgs = {
  input: DeleteUserOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationArgs = {
  input: DeleteVerificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationByNodeIdArgs = {
  input: DeleteVerificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteVerificationByUniqueIdArgs = {
  input: DeleteVerificationByUniqueIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationDeleteWholeApplicationArgs = {
  input: DeleteWholeApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionPluginArgs = {
  input: UpdateActionPluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionPluginByCodeArgs = {
  input: UpdateActionPluginByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionPluginByNodeIdArgs = {
  input: UpdateActionPluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionQueueArgs = {
  input: UpdateActionQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActionQueueByNodeIdArgs = {
  input: UpdateActionQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActivityLogArgs = {
  input: UpdateActivityLogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateActivityLogByNodeIdArgs = {
  input: UpdateActivityLogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationArgs = {
  input: UpdateApplicationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationByNodeIdArgs = {
  input: UpdateApplicationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationByOutcomeRegistrationArgs = {
  input: UpdateApplicationByOutcomeRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationBySerialArgs = {
  input: UpdateApplicationBySerialInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationNoteArgs = {
  input: UpdateApplicationNoteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationNoteByNodeIdArgs = {
  input: UpdateApplicationNoteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationResponseArgs = {
  input: UpdateApplicationResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationResponseByNodeIdArgs = {
  input: UpdateApplicationResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationReviewerActionArgs = {
  input: UpdateApplicationReviewerActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationReviewerActionByNodeIdArgs = {
  input: UpdateApplicationReviewerActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationReviewerActionByUserIdAndApplicationIdArgs = {
  input: UpdateApplicationReviewerActionByUserIdAndApplicationIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStageHistoryArgs = {
  input: UpdateApplicationStageHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStageHistoryByNodeIdArgs = {
  input: UpdateApplicationStageHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStatusHistoryArgs = {
  input: UpdateApplicationStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateApplicationStatusHistoryByNodeIdArgs = {
  input: UpdateApplicationStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCounterArgs = {
  input: UpdateCounterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCounterByNameArgs = {
  input: UpdateCounterByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateCounterByNodeIdArgs = {
  input: UpdateCounterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataChangelogArgs = {
  input: UpdateDataChangelogInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataChangelogByNodeIdArgs = {
  input: UpdateDataChangelogByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableArgs = {
  input: UpdateDataTableInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableActiveIngredientArgs = {
  input: UpdateDataTableActiveIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableActiveIngredientByNodeIdArgs = {
  input: UpdateDataTableActiveIngredientByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAdministrationRouteArgs = {
  input: UpdateDataTableAdministrationRouteInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAdministrationRouteByNodeIdArgs = {
  input: UpdateDataTableAdministrationRouteByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAtcCodeArgs = {
  input: UpdateDataTableAtcCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableAtcCodeByNodeIdArgs = {
  input: UpdateDataTableAtcCodeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableByNodeIdArgs = {
  input: UpdateDataTableByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableByTableNameArgs = {
  input: UpdateDataTableByTableNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableContainerArgs = {
  input: UpdateDataTableContainerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableContainerByNodeIdArgs = {
  input: UpdateDataTableContainerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableCountryArgs = {
  input: UpdateDataTableCountryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableCountryByNodeIdArgs = {
  input: UpdateDataTableCountryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableDosageFormArgs = {
  input: UpdateDataTableDosageFormInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableDosageFormByNodeIdArgs = {
  input: UpdateDataTableDosageFormByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableDosageFormGroupArgs = {
  input: UpdateDataTableDosageFormGroupInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableDosageFormGroupByNodeIdArgs = {
  input: UpdateDataTableDosageFormGroupByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableGenericIngredientArgs = {
  input: UpdateDataTableGenericIngredientInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableGenericIngredientByNodeIdArgs = {
  input: UpdateDataTableGenericIngredientByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturerArgs = {
  input: UpdateDataTableManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturerApplicationJoinArgs = {
  input: UpdateDataTableManufacturerApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturerApplicationJoinByNodeIdArgs = {
  input: UpdateDataTableManufacturerApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturerByNodeIdArgs = {
  input: UpdateDataTableManufacturerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturerRepresentativeArgs = {
  input: UpdateDataTableManufacturerRepresentativeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturerRepresentativeApplicationJoinArgs = {
  input: UpdateDataTableManufacturerRepresentativeApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturerRepresentativeApplicationJoinByNodeIdArgs = {
  input: UpdateDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableManufacturerRepresentativeByNodeIdArgs = {
  input: UpdateDataTableManufacturerRepresentativeByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePermitChemicalArgs = {
  input: UpdateDataTablePermitChemicalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePermitChemicalApplicationJoinArgs = {
  input: UpdateDataTablePermitChemicalApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePermitChemicalApplicationJoinByNodeIdArgs = {
  input: UpdateDataTablePermitChemicalApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePermitChemicalByNodeIdArgs = {
  input: UpdateDataTablePermitChemicalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePreRegisteredProductsProvisionalArgs = {
  input: UpdateDataTablePreRegisteredProductsProvisionalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePreRegisteredProductsProvisionalByNodeIdArgs = {
  input: UpdateDataTablePreRegisteredProductsProvisionalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePrequalManufacturerArgs = {
  input: UpdateDataTablePrequalManufacturerInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePrequalManufacturerApplicationJoinArgs = {
  input: UpdateDataTablePrequalManufacturerApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePrequalManufacturerApplicationJoinByNodeIdArgs = {
  input: UpdateDataTablePrequalManufacturerApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTablePrequalManufacturerByNodeIdArgs = {
  input: UpdateDataTablePrequalManufacturerByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProcessingStepArgs = {
  input: UpdateDataTableProcessingStepInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProcessingStepByNodeIdArgs = {
  input: UpdateDataTableProcessingStepByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProductArgs = {
  input: UpdateDataTableProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProductApplicationJoinArgs = {
  input: UpdateDataTableProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProductApplicationJoinByNodeIdArgs = {
  input: UpdateDataTableProductApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProductByNodeIdArgs = {
  input: UpdateDataTableProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProvisionalProductArgs = {
  input: UpdateDataTableProvisionalProductInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProvisionalProductApplicationJoinArgs = {
  input: UpdateDataTableProvisionalProductApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProvisionalProductApplicationJoinByNodeIdArgs = {
  input: UpdateDataTableProvisionalProductApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableProvisionalProductByNodeIdArgs = {
  input: UpdateDataTableProvisionalProductByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableScheduledChemicalArgs = {
  input: UpdateDataTableScheduledChemicalInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableScheduledChemicalByNodeIdArgs = {
  input: UpdateDataTableScheduledChemicalByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableStorageConditionArgs = {
  input: UpdateDataTableStorageConditionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableStorageConditionByNodeIdArgs = {
  input: UpdateDataTableStorageConditionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableStorageConditionsSimplifiedArgs = {
  input: UpdateDataTableStorageConditionsSimplifiedInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableStorageConditionsSimplifiedByNodeIdArgs = {
  input: UpdateDataTableStorageConditionsSimplifiedByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableUnitsOfProportionArgs = {
  input: UpdateDataTableUnitsOfProportionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableUnitsOfProportionByNodeIdArgs = {
  input: UpdateDataTableUnitsOfProportionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableWorldHealthOrganisationPqListOfFppArgs = {
  input: UpdateDataTableWorldHealthOrganisationPqListOfFppInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataTableWorldHealthOrganisationPqListOfFppByNodeIdArgs = {
  input: UpdateDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewArgs = {
  input: UpdateDataViewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewByIdentifierArgs = {
  input: UpdateDataViewByIdentifierInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewByNodeIdArgs = {
  input: UpdateDataViewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewColumnDefinitionArgs = {
  input: UpdateDataViewColumnDefinitionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewColumnDefinitionByNodeIdArgs = {
  input: UpdateDataViewColumnDefinitionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateDataViewColumnDefinitionByTableNameAndColumnNameArgs = {
  input: UpdateDataViewColumnDefinitionByTableNameAndColumnNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElementTypePluginArgs = {
  input: UpdateElementTypePluginInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateElementTypePluginByNodeIdArgs = {
  input: UpdateElementTypePluginByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileArgs = {
  input: UpdateFileInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileByNodeIdArgs = {
  input: UpdateFileByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFileByUniqueIdArgs = {
  input: UpdateFileByUniqueIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterArgs = {
  input: UpdateFilterInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterByCodeArgs = {
  input: UpdateFilterByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateFilterByNodeIdArgs = {
  input: UpdateFilterByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGrafanaDashboardImageArgs = {
  input: UpdateGrafanaDashboardImageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateGrafanaDashboardImageByNodeIdArgs = {
  input: UpdateGrafanaDashboardImageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationArgs = {
  input: UpdateNotificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateNotificationByNodeIdArgs = {
  input: UpdateNotificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationArgs = {
  input: UpdateOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationApplicationJoinArgs = {
  input: UpdateOrganisationApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationApplicationJoinByNodeIdArgs = {
  input: UpdateOrganisationApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationByNameArgs = {
  input: UpdateOrganisationByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationByNodeIdArgs = {
  input: UpdateOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateOrganisationByRegistrationArgs = {
  input: UpdateOrganisationByRegistrationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionJoinArgs = {
  input: UpdatePermissionJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionJoinByNodeIdArgs = {
  input: UpdatePermissionJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameArgs = {
  input: UpdatePermissionNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameByNameArgs = {
  input: UpdatePermissionNameByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionNameByNodeIdArgs = {
  input: UpdatePermissionNameByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionPolicyArgs = {
  input: UpdatePermissionPolicyInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionPolicyByNameArgs = {
  input: UpdatePermissionPolicyByNameInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdatePermissionPolicyByNodeIdArgs = {
  input: UpdatePermissionPolicyByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewArgs = {
  input: UpdateReviewInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentArgs = {
  input: UpdateReviewAssignmentInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentAssignerJoinArgs = {
  input: UpdateReviewAssignmentAssignerJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentAssignerJoinByNodeIdArgs = {
  input: UpdateReviewAssignmentAssignerJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewAssignmentByNodeIdArgs = {
  input: UpdateReviewAssignmentByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewByNodeIdArgs = {
  input: UpdateReviewByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewByReviewAssignmentIdArgs = {
  input: UpdateReviewByReviewAssignmentIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewDecisionArgs = {
  input: UpdateReviewDecisionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewDecisionByNodeIdArgs = {
  input: UpdateReviewDecisionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewResponseArgs = {
  input: UpdateReviewResponseInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewResponseByNodeIdArgs = {
  input: UpdateReviewResponseByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewStatusHistoryArgs = {
  input: UpdateReviewStatusHistoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateReviewStatusHistoryByNodeIdArgs = {
  input: UpdateReviewStatusHistoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSystemInfoArgs = {
  input: UpdateSystemInfoInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateSystemInfoByNodeIdArgs = {
  input: UpdateSystemInfoByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateArgs = {
  input: UpdateTemplateInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateActionArgs = {
  input: UpdateTemplateActionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateActionByNodeIdArgs = {
  input: UpdateTemplateActionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateByCodeAndVersionIdArgs = {
  input: UpdateTemplateByCodeAndVersionIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateByNodeIdArgs = {
  input: UpdateTemplateByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateCategoryArgs = {
  input: UpdateTemplateCategoryInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateCategoryByCodeArgs = {
  input: UpdateTemplateCategoryByCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateCategoryByNodeIdArgs = {
  input: UpdateTemplateCategoryByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateElementArgs = {
  input: UpdateTemplateElementInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateElementByNodeIdArgs = {
  input: UpdateTemplateElementByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs = {
  input: UpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateFilterJoinArgs = {
  input: UpdateTemplateFilterJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateFilterJoinByNodeIdArgs = {
  input: UpdateTemplateFilterJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplatePermissionArgs = {
  input: UpdateTemplatePermissionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplatePermissionByNodeIdArgs = {
  input: UpdateTemplatePermissionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateSectionArgs = {
  input: UpdateTemplateSectionInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateSectionByNodeIdArgs = {
  input: UpdateTemplateSectionByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateSectionByTemplateIdAndCodeArgs = {
  input: UpdateTemplateSectionByTemplateIdAndCodeInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageArgs = {
  input: UpdateTemplateStageInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageByNodeIdArgs = {
  input: UpdateTemplateStageByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageReviewLevelArgs = {
  input: UpdateTemplateStageReviewLevelInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTemplateStageReviewLevelByNodeIdArgs = {
  input: UpdateTemplateStageReviewLevelByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerQueueArgs = {
  input: UpdateTriggerQueueInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerQueueByNodeIdArgs = {
  input: UpdateTriggerQueueByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerScheduleArgs = {
  input: UpdateTriggerScheduleInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateTriggerScheduleByNodeIdArgs = {
  input: UpdateTriggerScheduleByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserApplicationJoinArgs = {
  input: UpdateUserApplicationJoinInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserApplicationJoinByNodeIdArgs = {
  input: UpdateUserApplicationJoinByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationArgs = {
  input: UpdateUserOrganisationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateUserOrganisationByNodeIdArgs = {
  input: UpdateUserOrganisationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationArgs = {
  input: UpdateVerificationInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationByNodeIdArgs = {
  input: UpdateVerificationByNodeIdInput;
};


/** The root mutation type which contains root level fields which mutate data. */
export type MutationUpdateVerificationByUniqueIdArgs = {
  input: UpdateVerificationByUniqueIdInput;
};

/** An object with a globally unique `ID`. */
export type Node = {
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
};

export type Notification = Node & {
  __typename?: 'Notification';
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  attachments?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  emailRecipients?: Maybe<Scalars['String']['output']>;
  emailSent?: Maybe<Scalars['Boolean']['output']>;
  emailServerLog?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isRead?: Maybe<Scalars['Boolean']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
  reviewId?: Maybe<Scalars['Int']['output']>;
  subject?: Maybe<Scalars['String']['output']>;
  timestamp: Scalars['Datetime']['output'];
  userId?: Maybe<Scalars['Int']['output']>;
};

/** The `application` to be created by this mutation. */
export type NotificationApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `NotificationInput` mutation. */
export type NotificationApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<NotificationApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `notification` in the `ApplicationInput` mutation. */
export type NotificationApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: InputMaybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<NotificationNodeIdConnect>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<NotificationApplicationIdFkeyNotificationCreateInput>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<NotificationNodeIdDelete>>;
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: InputMaybe<Array<NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationApplicationIdFkeyNotificationCreateInput = {
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/**
 * A condition to be used against `Notification` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type NotificationCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `attachments` field. */
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `emailRecipients` field. */
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `emailSent` field. */
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `emailServerLog` field. */
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isRead` field. */
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `subject` field. */
  subject?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `Notification` object types. All fields are combined with a logical ‘and.’ */
export type NotificationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<NotificationFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `attachments` field. */
  attachments?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `emailRecipients` field. */
  emailRecipients?: InputMaybe<StringFilter>;
  /** Filter by the object’s `emailSent` field. */
  emailSent?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `emailServerLog` field. */
  emailServerLog?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isRead` field. */
  isRead?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<NotificationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<NotificationFilter>>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** A related `review` exists. */
  reviewExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `subject` field. */
  subject?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `Notification` */
export type NotificationInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type NotificationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type NotificationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `notification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The fields on `notification` to look up the row to connect. */
export type NotificationNotificationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `notification` to look up the row to delete. */
export type NotificationNotificationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `notification` to look up the row to update. */
export type NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch;
};

/** Represents an update to a `Notification`. Fields that are set will be updated. */
export type NotificationPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** Input for the nested mutation of `review` in the `NotificationInput` mutation. */
export type NotificationReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<NotificationReviewIdFkeyReviewCreateInput>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** Input for the nested mutation of `notification` in the `ReviewInput` mutation. */
export type NotificationReviewIdFkeyInverseInput = {
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectById?: InputMaybe<Array<NotificationNotificationPkeyConnect>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<NotificationNodeIdConnect>>;
  /** A `NotificationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<NotificationReviewIdFkeyNotificationCreateInput>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<NotificationNotificationPkeyDelete>>;
  /** The primary key(s) for `notification` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<NotificationNodeIdDelete>>;
  /** Flag indicating whether all other `notification` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateById?: InputMaybe<Array<NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `notification` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate>>;
};

/** The `notification` to be created by this mutation. */
export type NotificationReviewIdFkeyNotificationCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The `review` to be created by this mutation. */
export type NotificationReviewIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** A connection to a list of `Notification` values. */
export type NotificationsConnection = {
  __typename?: 'NotificationsConnection';
  /** A list of edges which contains the `Notification` and cursor to aid in pagination. */
  edges: Array<NotificationsEdge>;
  /** A list of `Notification` objects. */
  nodes: Array<Maybe<Notification>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Notification` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Notification` edge in the connection. */
export type NotificationsEdge = {
  __typename?: 'NotificationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Notification` at the end of the edge. */
  node?: Maybe<Notification>;
};

/** Methods to use when ordering `Notification`. */
export enum NotificationsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  AttachmentsAsc = 'ATTACHMENTS_ASC',
  AttachmentsDesc = 'ATTACHMENTS_DESC',
  EmailRecipientsAsc = 'EMAIL_RECIPIENTS_ASC',
  EmailRecipientsDesc = 'EMAIL_RECIPIENTS_DESC',
  EmailSentAsc = 'EMAIL_SENT_ASC',
  EmailSentDesc = 'EMAIL_SENT_DESC',
  EmailServerLogAsc = 'EMAIL_SERVER_LOG_ASC',
  EmailServerLogDesc = 'EMAIL_SERVER_LOG_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsReadAsc = 'IS_READ_ASC',
  IsReadDesc = 'IS_READ_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  SubjectAsc = 'SUBJECT_ASC',
  SubjectDesc = 'SUBJECT_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type Organisation = Node & {
  __typename?: 'Organisation';
  address?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ApplicationNote`. */
  applicationNotesByOrgId: ApplicationNotesConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applicationsByOrgId: ApplicationsConnection;
  businessCertificate?: Maybe<Scalars['JSON']['output']>;
  contactEmail?: Maybe<Scalars['String']['output']>;
  contactPhone?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `DataChangelog`. */
  dataChangelogsByOrgId: DataChangelogsConnection;
  id: Scalars['Int']['output'];
  isChemicalImporter?: Maybe<Scalars['Boolean']['output']>;
  isSponsorCompany?: Maybe<Scalars['Boolean']['output']>;
  isSystemOrg?: Maybe<Scalars['Boolean']['output']>;
  license?: Maybe<Scalars['JSON']['output']>;
  localAgentBusinessAddress?: Maybe<Scalars['String']['output']>;
  localAgentEmail?: Maybe<Scalars['String']['output']>;
  localAgentName?: Maybe<Scalars['String']['output']>;
  localAgentPhoneNumber?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `OrganisationApplicationJoin`. */
  organisationApplicationJoins: OrganisationApplicationJoinsConnection;
  otherDocuments?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins: PermissionJoinsConnection;
  postalAddress?: Maybe<Scalars['String']['output']>;
  province?: Maybe<Scalars['String']['output']>;
  registration?: Maybe<Scalars['String']['output']>;
  registrationDocumentation?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignerJoin`. */
  reviewAssignmentAssignerJoins: ReviewAssignmentAssignerJoinsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments: ReviewAssignmentsConnection;
  subType?: Maybe<Scalars['String']['output']>;
  tinLetter?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations: UserOrganisationsConnection;
};


export type OrganisationApplicationNotesByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationNoteCondition>;
  filter?: InputMaybe<ApplicationNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};


export type OrganisationApplicationsByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


export type OrganisationDataChangelogsByOrgIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataChangelogCondition>;
  filter?: InputMaybe<DataChangelogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataChangelogsOrderBy>>;
};


export type OrganisationOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganisationApplicationJoinCondition>;
  filter?: InputMaybe<OrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};


export type OrganisationPermissionJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionJoinCondition>;
  filter?: InputMaybe<PermissionJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};


export type OrganisationReviewAssignmentAssignerJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignerJoinCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};


export type OrganisationReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type OrganisationUserOrganisationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationCondition>;
  filter?: InputMaybe<UserOrganisationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

export type OrganisationApplicationJoin = Node & {
  __typename?: 'OrganisationApplicationJoin';
  /** Reads a single `Application` that is related to this `OrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `OrganisationApplicationJoin`. */
  organisation?: Maybe<Organisation>;
  organisationId: Scalars['Int']['output'];
};

/** The `application` to be created by this mutation. */
export type OrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `OrganisationApplicationJoinInput` mutation. */
export type OrganisationApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `organisationApplicationJoin` in the `ApplicationInput` mutation. */
export type OrganisationApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<OrganisationApplicationJoinNodeIdConnect>>;
  /** A `OrganisationApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<OrganisationApplicationJoinApplicationIdFkeyOrganisationApplicationJoinCreateInput>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<OrganisationApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `organisationApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `organisationApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `organisationApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/** The `organisationApplicationJoin` to be created by this mutation. */
export type OrganisationApplicationJoinApplicationIdFkeyOrganisationApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/**
 * A condition to be used against `OrganisationApplicationJoin` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type OrganisationApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `OrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganisationApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganisationApplicationJoinFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `OrganisationApplicationJoin` */
export type OrganisationApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OrganisationApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `organisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OrganisationApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `organisationApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `organisationApplicationJoin` to look up the row to update. */
export type OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
  patch: UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `organisationApplicationJoin` to look up the row to update. */
export type OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
  patch: UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisationApplicationJoin` to look up the row to connect. */
export type OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `organisationApplicationJoin` to look up the row to delete. */
export type OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `organisation` in the `OrganisationApplicationJoinInput` mutation. */
export type OrganisationApplicationJoinOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `organisationApplicationJoin` in the `OrganisationInput` mutation. */
export type OrganisationApplicationJoinOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<OrganisationApplicationJoinNodeIdConnect>>;
  /** A `OrganisationApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<OrganisationApplicationJoinOrganisationIdFkeyOrganisationApplicationJoinCreateInput>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `organisationApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<OrganisationApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `organisationApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `organisationApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `organisationApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisationApplicationJoin` to be created by this mutation. */
export type OrganisationApplicationJoinOrganisationIdFkeyOrganisationApplicationJoinCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** The `organisation` to be created by this mutation. */
export type OrganisationApplicationJoinOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** Represents an update to a `OrganisationApplicationJoin`. Fields that are set will be updated. */
export type OrganisationApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** A connection to a list of `OrganisationApplicationJoin` values. */
export type OrganisationApplicationJoinsConnection = {
  __typename?: 'OrganisationApplicationJoinsConnection';
  /** A list of edges which contains the `OrganisationApplicationJoin` and cursor to aid in pagination. */
  edges: Array<OrganisationApplicationJoinsEdge>;
  /** A list of `OrganisationApplicationJoin` objects. */
  nodes: Array<Maybe<OrganisationApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `OrganisationApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `OrganisationApplicationJoin` edge in the connection. */
export type OrganisationApplicationJoinsEdge = {
  __typename?: 'OrganisationApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `OrganisationApplicationJoin` at the end of the edge. */
  node?: Maybe<OrganisationApplicationJoin>;
};

/** Methods to use when ordering `OrganisationApplicationJoin`. */
export enum OrganisationApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/**
 * A condition to be used against `Organisation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type OrganisationCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `businessCertificate` field. */
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `contactPhone` field. */
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isChemicalImporter` field. */
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSponsorCompany` field. */
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSystemOrg` field. */
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `license` field. */
  license?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `localAgentBusinessAddress` field. */
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `localAgentEmail` field. */
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `localAgentName` field. */
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `localAgentPhoneNumber` field. */
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `logoUrl` field. */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `otherDocuments` field. */
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `postalAddress` field. */
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `province` field. */
  province?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registration` field. */
  registration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registrationDocumentation` field. */
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `subType` field. */
  subType?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tinLetter` field. */
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `Organisation` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<OrganisationFilter>>;
  /** Filter by the object’s `applicationNotesByOrgId` relation. */
  applicationNotesByOrgId?: InputMaybe<OrganisationToManyApplicationNoteFilter>;
  /** Some related `applicationNotesByOrgId` exist. */
  applicationNotesByOrgIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationsByOrgId` relation. */
  applicationsByOrgId?: InputMaybe<OrganisationToManyApplicationFilter>;
  /** Some related `applicationsByOrgId` exist. */
  applicationsByOrgIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `businessCertificate` field. */
  businessCertificate?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `contactEmail` field. */
  contactEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `contactPhone` field. */
  contactPhone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dataChangelogsByOrgId` relation. */
  dataChangelogsByOrgId?: InputMaybe<OrganisationToManyDataChangelogFilter>;
  /** Some related `dataChangelogsByOrgId` exist. */
  dataChangelogsByOrgIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isChemicalImporter` field. */
  isChemicalImporter?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSponsorCompany` field. */
  isSponsorCompany?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSystemOrg` field. */
  isSystemOrg?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `license` field. */
  license?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `localAgentBusinessAddress` field. */
  localAgentBusinessAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `localAgentEmail` field. */
  localAgentEmail?: InputMaybe<StringFilter>;
  /** Filter by the object’s `localAgentName` field. */
  localAgentName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `localAgentPhoneNumber` field. */
  localAgentPhoneNumber?: InputMaybe<StringFilter>;
  /** Filter by the object’s `logoUrl` field. */
  logoUrl?: InputMaybe<StringFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<OrganisationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<OrganisationFilter>>;
  /** Filter by the object’s `organisationApplicationJoins` relation. */
  organisationApplicationJoins?: InputMaybe<OrganisationToManyOrganisationApplicationJoinFilter>;
  /** Some related `organisationApplicationJoins` exist. */
  organisationApplicationJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `otherDocuments` field. */
  otherDocuments?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `permissionJoins` relation. */
  permissionJoins?: InputMaybe<OrganisationToManyPermissionJoinFilter>;
  /** Some related `permissionJoins` exist. */
  permissionJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `postalAddress` field. */
  postalAddress?: InputMaybe<StringFilter>;
  /** Filter by the object’s `province` field. */
  province?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registration` field. */
  registration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registrationDocumentation` field. */
  registrationDocumentation?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `reviewAssignmentAssignerJoins` relation. */
  reviewAssignmentAssignerJoins?: InputMaybe<OrganisationToManyReviewAssignmentAssignerJoinFilter>;
  /** Some related `reviewAssignmentAssignerJoins` exist. */
  reviewAssignmentAssignerJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewAssignments` relation. */
  reviewAssignments?: InputMaybe<OrganisationToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignments` exist. */
  reviewAssignmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `subType` field. */
  subType?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tinLetter` field. */
  tinLetter?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `userOrganisations` relation. */
  userOrganisations?: InputMaybe<OrganisationToManyUserOrganisationFilter>;
  /** Some related `userOrganisations` exist. */
  userOrganisationsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `Organisation` */
export type OrganisationInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type OrganisationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type OrganisationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `organisation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `dataChangelog` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `dataChangelog` being updated. */
  patch: DataChangelogPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnDataChangelogForDataChangelogOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnDataChangelogForDataChangelogOrgIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnDataChangelogForDataChangelogOrgIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisationApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
  patch: OrganisationApplicationJoinPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
};

/** The fields on `organisation` to look up the row to update. */
export type OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate = {
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  registration: Scalars['String']['input'];
};

/** The fields on `organisation` to look up the row to connect. */
export type OrganisationOrganisationNameKeyConnect = {
  name: Scalars['String']['input'];
};

/** The fields on `organisation` to look up the row to delete. */
export type OrganisationOrganisationNameKeyDelete = {
  name: Scalars['String']['input'];
};

/** The fields on `organisation` to look up the row to connect. */
export type OrganisationOrganisationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `organisation` to look up the row to delete. */
export type OrganisationOrganisationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `organisation` to look up the row to connect. */
export type OrganisationOrganisationRegistrationKeyConnect = {
  registration: Scalars['String']['input'];
};

/** The fields on `organisation` to look up the row to delete. */
export type OrganisationOrganisationRegistrationKeyDelete = {
  registration: Scalars['String']['input'];
};

/** Represents an update to a `Organisation`. Fields that are set will be updated. */
export type OrganisationPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationFilter>;
};

/** A filter to be used against many `ApplicationNote` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyApplicationNoteFilter = {
  /** Every related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationNoteFilter>;
  /** No related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationNoteFilter>;
  /** Some related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationNoteFilter>;
};

/** A filter to be used against many `DataChangelog` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyDataChangelogFilter = {
  /** Every related `DataChangelog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<DataChangelogFilter>;
  /** No related `DataChangelog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<DataChangelogFilter>;
  /** Some related `DataChangelog` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<DataChangelogFilter>;
};

/** A filter to be used against many `OrganisationApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyOrganisationApplicationJoinFilter = {
  /** Every related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** No related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<OrganisationApplicationJoinFilter>;
  /** Some related `OrganisationApplicationJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<OrganisationApplicationJoinFilter>;
};

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PermissionJoinFilter>;
};

/** A filter to be used against many `ReviewAssignmentAssignerJoin` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyReviewAssignmentAssignerJoinFilter = {
  /** Every related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** No related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** Some related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type OrganisationToManyUserOrganisationFilter = {
  /** Every related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserOrganisationFilter>;
  /** No related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserOrganisationFilter>;
  /** Some related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserOrganisationFilter>;
};

/** A connection to a list of `Organisation` values. */
export type OrganisationsConnection = {
  __typename?: 'OrganisationsConnection';
  /** A list of edges which contains the `Organisation` and cursor to aid in pagination. */
  edges: Array<OrganisationsEdge>;
  /** A list of `Organisation` objects. */
  nodes: Array<Maybe<Organisation>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Organisation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Organisation` edge in the connection. */
export type OrganisationsEdge = {
  __typename?: 'OrganisationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Organisation` at the end of the edge. */
  node?: Maybe<Organisation>;
};

/** Methods to use when ordering `Organisation`. */
export enum OrganisationsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  BusinessCertificateAsc = 'BUSINESS_CERTIFICATE_ASC',
  BusinessCertificateDesc = 'BUSINESS_CERTIFICATE_DESC',
  ContactEmailAsc = 'CONTACT_EMAIL_ASC',
  ContactEmailDesc = 'CONTACT_EMAIL_DESC',
  ContactPhoneAsc = 'CONTACT_PHONE_ASC',
  ContactPhoneDesc = 'CONTACT_PHONE_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsChemicalImporterAsc = 'IS_CHEMICAL_IMPORTER_ASC',
  IsChemicalImporterDesc = 'IS_CHEMICAL_IMPORTER_DESC',
  IsSponsorCompanyAsc = 'IS_SPONSOR_COMPANY_ASC',
  IsSponsorCompanyDesc = 'IS_SPONSOR_COMPANY_DESC',
  IsSystemOrgAsc = 'IS_SYSTEM_ORG_ASC',
  IsSystemOrgDesc = 'IS_SYSTEM_ORG_DESC',
  LicenseAsc = 'LICENSE_ASC',
  LicenseDesc = 'LICENSE_DESC',
  LocalAgentBusinessAddressAsc = 'LOCAL_AGENT_BUSINESS_ADDRESS_ASC',
  LocalAgentBusinessAddressDesc = 'LOCAL_AGENT_BUSINESS_ADDRESS_DESC',
  LocalAgentEmailAsc = 'LOCAL_AGENT_EMAIL_ASC',
  LocalAgentEmailDesc = 'LOCAL_AGENT_EMAIL_DESC',
  LocalAgentNameAsc = 'LOCAL_AGENT_NAME_ASC',
  LocalAgentNameDesc = 'LOCAL_AGENT_NAME_DESC',
  LocalAgentPhoneNumberAsc = 'LOCAL_AGENT_PHONE_NUMBER_ASC',
  LocalAgentPhoneNumberDesc = 'LOCAL_AGENT_PHONE_NUMBER_DESC',
  LogoUrlAsc = 'LOGO_URL_ASC',
  LogoUrlDesc = 'LOGO_URL_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  OtherDocumentsAsc = 'OTHER_DOCUMENTS_ASC',
  OtherDocumentsDesc = 'OTHER_DOCUMENTS_DESC',
  PostalAddressAsc = 'POSTAL_ADDRESS_ASC',
  PostalAddressDesc = 'POSTAL_ADDRESS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ProvinceAsc = 'PROVINCE_ASC',
  ProvinceDesc = 'PROVINCE_DESC',
  RegistrationAsc = 'REGISTRATION_ASC',
  RegistrationDesc = 'REGISTRATION_DESC',
  RegistrationDocumentationAsc = 'REGISTRATION_DOCUMENTATION_ASC',
  RegistrationDocumentationDesc = 'REGISTRATION_DOCUMENTATION_DESC',
  SubTypeAsc = 'SUB_TYPE_ASC',
  SubTypeDesc = 'SUB_TYPE_DESC',
  TinLetterAsc = 'TIN_LETTER_ASC',
  TinLetterDesc = 'TIN_LETTER_DESC'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']['output']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']['output']>;
};

export type PermissionFlattened = {
  __typename?: 'PermissionFlattened';
  organisationId?: Maybe<Scalars['Int']['output']>;
  permissionPolicyId?: Maybe<Scalars['Int']['output']>;
  templateId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `PermissionFlattened` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type PermissionFlattenedCondition = {
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `PermissionFlattened` object types. All fields are combined with a logical ‘and.’ */
export type PermissionFlattenedFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionFlattenedFilter>>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionFlattenedFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionFlattenedFilter>>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** A connection to a list of `PermissionFlattened` values. */
export type PermissionFlattenedsConnection = {
  __typename?: 'PermissionFlattenedsConnection';
  /** A list of edges which contains the `PermissionFlattened` and cursor to aid in pagination. */
  edges: Array<PermissionFlattenedsEdge>;
  /** A list of `PermissionFlattened` objects. */
  nodes: Array<Maybe<PermissionFlattened>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionFlattened` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionFlattened` edge in the connection. */
export type PermissionFlattenedsEdge = {
  __typename?: 'PermissionFlattenedsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionFlattened` at the end of the edge. */
  node?: Maybe<PermissionFlattened>;
};

/** Methods to use when ordering `PermissionFlattened`. */
export enum PermissionFlattenedsOrderBy {
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PermissionPolicyIdAsc = 'PERMISSION_POLICY_ID_ASC',
  PermissionPolicyIdDesc = 'PERMISSION_POLICY_ID_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type PermissionJoin = Node & {
  __typename?: 'PermissionJoin';
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  organisationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  permissionNameId: Scalars['Int']['output'];
  /** Reads a single `UserList` that is related to this `PermissionJoin`. */
  user?: Maybe<UserList>;
  userId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `PermissionJoin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PermissionJoinCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type PermissionJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionJoinFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionJoinFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionName` relation. */
  permissionName?: InputMaybe<PermissionNameFilter>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserListFilter>;
  /** A related `user` exists. */
  userExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `PermissionJoin` */
export type PermissionJoinInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicPermissionJoinForeignKey0Input>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0UsingPermissionJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0Patch;
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `permissionJoin` to look up the row to update. */
export type PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
};

/** Input for the nested mutation of `organisation` in the `PermissionJoinInput` mutation. */
export type PermissionJoinOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<PermissionJoinOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `permissionJoin` in the `OrganisationInput` mutation. */
export type PermissionJoinOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PermissionJoinNodeIdConnect>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PermissionJoinNodeIdDelete>>;
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type PermissionJoinOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The `permissionJoin` to be created by this mutation. */
export type PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicPermissionJoinForeignKey0Input>;
};

/** Represents an update to a `PermissionJoin`. Fields that are set will be updated. */
export type PermissionJoinPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicPermissionJoinForeignKey0Input>;
};

/** The fields on `permissionJoin` to look up the row to connect. */
export type PermissionJoinPermissionJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `permissionJoin` to look up the row to delete. */
export type PermissionJoinPermissionJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `permissionName` in the `PermissionJoinInput` mutation. */
export type PermissionJoinPermissionNameIdFkeyInput = {
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: InputMaybe<PermissionNamePermissionNamePkeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: InputMaybe<PermissionNamePermissionNameNameKeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PermissionNameNodeIdConnect>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: InputMaybe<PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: InputMaybe<PermissionNamePermissionNamePkeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: InputMaybe<PermissionNamePermissionNameNameKeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PermissionNameNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: InputMaybe<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: InputMaybe<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `permissionJoin` in the `PermissionNameInput` mutation. */
export type PermissionJoinPermissionNameIdFkeyInverseInput = {
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyConnect>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PermissionJoinNodeIdConnect>>;
  /** A `PermissionJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PermissionJoinPermissionJoinPkeyDelete>>;
  /** The primary key(s) for `permissionJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PermissionJoinNodeIdDelete>>;
  /** Flag indicating whether all other `permissionJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate>>;
};

/** The `permissionJoin` to be created by this mutation. */
export type PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicPermissionJoinForeignKey0Input>;
};

/** The `permissionName` to be created by this mutation. */
export type PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** A connection to a list of `PermissionJoin` values. */
export type PermissionJoinsConnection = {
  __typename?: 'PermissionJoinsConnection';
  /** A list of edges which contains the `PermissionJoin` and cursor to aid in pagination. */
  edges: Array<PermissionJoinsEdge>;
  /** A list of `PermissionJoin` objects. */
  nodes: Array<Maybe<PermissionJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionJoin` edge in the connection. */
export type PermissionJoinsEdge = {
  __typename?: 'PermissionJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionJoin` at the end of the edge. */
  node?: Maybe<PermissionJoin>;
};

/** Methods to use when ordering `PermissionJoin`. */
export enum PermissionJoinsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type PermissionName = Node & {
  __typename?: 'PermissionName';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isSystemOrgPermission?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins: PermissionJoinsConnection;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  permissionPolicyId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions: TemplatePermissionsConnection;
};


export type PermissionNamePermissionJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionJoinCondition>;
  filter?: InputMaybe<PermissionJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};


export type PermissionNameTemplatePermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplatePermissionCondition>;
  filter?: InputMaybe<TemplatePermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};

/**
 * A condition to be used against `PermissionName` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PermissionNameCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isSystemOrgPermission` field. */
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `PermissionName` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionNameFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isSystemOrgPermission` field. */
  isSystemOrgPermission?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionNameFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionNameFilter>>;
  /** Filter by the object’s `permissionJoins` relation. */
  permissionJoins?: InputMaybe<PermissionNameToManyPermissionJoinFilter>;
  /** Some related `permissionJoins` exist. */
  permissionJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `permissionPolicy` relation. */
  permissionPolicy?: InputMaybe<PermissionPolicyFilter>;
  /** A related `permissionPolicy` exists. */
  permissionPolicyExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templatePermissions` relation. */
  templatePermissions?: InputMaybe<PermissionNameToManyTemplatePermissionFilter>;
  /** Some related `templatePermissions` exist. */
  templatePermissionsExist?: InputMaybe<Scalars['Boolean']['input']>;
};

/** An input for mutations affecting `PermissionName` */
export type PermissionNameInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionNameNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionNameNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionName` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
};

/** The fields on `permissionName` to look up the row to update. */
export type PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
};

/** Represents an update to a `PermissionName`. Fields that are set will be updated. */
export type PermissionNamePatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The fields on `permissionName` to look up the row to connect. */
export type PermissionNamePermissionNameNameKeyConnect = {
  name: Scalars['String']['input'];
};

/** The fields on `permissionName` to look up the row to delete. */
export type PermissionNamePermissionNameNameKeyDelete = {
  name: Scalars['String']['input'];
};

/** The fields on `permissionName` to look up the row to connect. */
export type PermissionNamePermissionNamePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `permissionName` to look up the row to delete. */
export type PermissionNamePermissionNamePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `permissionPolicy` in the `PermissionNameInput` mutation. */
export type PermissionNamePermissionPolicyIdFkeyInput = {
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  connectById?: InputMaybe<PermissionPolicyPermissionPolicyPkeyConnect>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  connectByName?: InputMaybe<PermissionPolicyPermissionPolicyNameKeyConnect>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PermissionPolicyNodeIdConnect>;
  /** A `PermissionPolicyInput` object that will be created and connected to this object. */
  create?: InputMaybe<PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  deleteById?: InputMaybe<PermissionPolicyPermissionPolicyPkeyDelete>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  deleteByName?: InputMaybe<PermissionPolicyPermissionPolicyNameKeyDelete>;
  /** The primary key(s) for `permissionPolicy` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PermissionPolicyNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionPolicy` for the far side of the relationship. */
  updateById?: InputMaybe<PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate>;
  /** The primary key(s) and patch data for `permissionPolicy` for the far side of the relationship. */
  updateByName?: InputMaybe<PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyNameKeyUpdate>;
  /** The primary key(s) and patch data for `permissionPolicy` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `permissionName` in the `PermissionPolicyInput` mutation. */
export type PermissionNamePermissionPolicyIdFkeyInverseInput = {
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: InputMaybe<Array<PermissionNamePermissionNamePkeyConnect>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: InputMaybe<Array<PermissionNamePermissionNameNameKeyConnect>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<PermissionNameNodeIdConnect>>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<PermissionNamePermissionNamePkeyDelete>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: InputMaybe<Array<PermissionNamePermissionNameNameKeyDelete>>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<PermissionNameNodeIdDelete>>;
  /** Flag indicating whether all other `permissionName` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: InputMaybe<Array<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate>>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: InputMaybe<Array<PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate>>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate>>;
};

/** The `permissionName` to be created by this mutation. */
export type PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The `permissionPolicy` to be created by this mutation. */
export type PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput = {
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionNamesUsingId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
  rules?: InputMaybe<Scalars['JSON']['input']>;
  type?: InputMaybe<PermissionPolicyType>;
};

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PermissionJoinFilter>;
};

/** A filter to be used against many `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type PermissionNameToManyTemplatePermissionFilter = {
  /** Every related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplatePermissionFilter>;
  /** No related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplatePermissionFilter>;
  /** Some related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplatePermissionFilter>;
};

/** A connection to a list of `PermissionName` values. */
export type PermissionNamesConnection = {
  __typename?: 'PermissionNamesConnection';
  /** A list of edges which contains the `PermissionName` and cursor to aid in pagination. */
  edges: Array<PermissionNamesEdge>;
  /** A list of `PermissionName` objects. */
  nodes: Array<Maybe<PermissionName>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionName` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionName` edge in the connection. */
export type PermissionNamesEdge = {
  __typename?: 'PermissionNamesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionName` at the end of the edge. */
  node?: Maybe<PermissionName>;
};

/** Methods to use when ordering `PermissionName`. */
export enum PermissionNamesOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsSystemOrgPermissionAsc = 'IS_SYSTEM_ORG_PERMISSION_ASC',
  IsSystemOrgPermissionDesc = 'IS_SYSTEM_ORG_PERMISSION_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PermissionPolicyIdAsc = 'PERMISSION_POLICY_ID_ASC',
  PermissionPolicyIdDesc = 'PERMISSION_POLICY_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC'
}

/** A connection to a list of `PermissionPolicy` values. */
export type PermissionPoliciesConnection = {
  __typename?: 'PermissionPoliciesConnection';
  /** A list of edges which contains the `PermissionPolicy` and cursor to aid in pagination. */
  edges: Array<PermissionPoliciesEdge>;
  /** A list of `PermissionPolicy` objects. */
  nodes: Array<Maybe<PermissionPolicy>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionPolicy` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionPolicy` edge in the connection. */
export type PermissionPoliciesEdge = {
  __typename?: 'PermissionPoliciesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionPolicy` at the end of the edge. */
  node?: Maybe<PermissionPolicy>;
};

/** Methods to use when ordering `PermissionPolicy`. */
export enum PermissionPoliciesOrderBy {
  DefaultRestrictionsAsc = 'DEFAULT_RESTRICTIONS_ASC',
  DefaultRestrictionsDesc = 'DEFAULT_RESTRICTIONS_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsAdminAsc = 'IS_ADMIN_ASC',
  IsAdminDesc = 'IS_ADMIN_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RulesAsc = 'RULES_ASC',
  RulesDesc = 'RULES_DESC',
  TypeAsc = 'TYPE_ASC',
  TypeDesc = 'TYPE_DESC'
}

export type PermissionPolicy = Node & {
  __typename?: 'PermissionPolicy';
  defaultRestrictions?: Maybe<Scalars['JSON']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isAdmin?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `PermissionName`. */
  permissionNames: PermissionNamesConnection;
  rules?: Maybe<Scalars['JSON']['output']>;
  type?: Maybe<PermissionPolicyType>;
};


export type PermissionPolicyPermissionNamesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionNameCondition>;
  filter?: InputMaybe<PermissionNameFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};

/**
 * A condition to be used against `PermissionPolicy` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PermissionPolicyCondition = {
  /** Checks for equality with the object’s `defaultRestrictions` field. */
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `rules` field. */
  rules?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `type` field. */
  type?: InputMaybe<PermissionPolicyType>;
};

/** A filter to be used against `PermissionPolicy` object types. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionPolicyFilter>>;
  /** Filter by the object’s `defaultRestrictions` field. */
  defaultRestrictions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionPolicyFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionPolicyFilter>>;
  /** Filter by the object’s `permissionNames` relation. */
  permissionNames?: InputMaybe<PermissionPolicyToManyPermissionNameFilter>;
  /** Some related `permissionNames` exist. */
  permissionNamesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `rules` field. */
  rules?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `type` field. */
  type?: InputMaybe<PermissionPolicyTypeFilter>;
};

/** An input for mutations affecting `PermissionPolicy` */
export type PermissionPolicyInput = {
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionNamesUsingId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
  rules?: InputMaybe<Scalars['JSON']['input']>;
  type?: InputMaybe<PermissionPolicyType>;
};

/** The globally unique `ID` look up for the row to connect. */
export type PermissionPolicyNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type PermissionPolicyNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `permissionPolicy` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `permissionPolicy` to look up the row to update. */
export type PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyNameKeyUpdate = {
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `permissionPolicy` being updated. */
  patch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
};

/** The fields on `permissionPolicy` to look up the row to update. */
export type PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `permissionPolicy` being updated. */
  patch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
};

/** Represents an update to a `PermissionPolicy`. Fields that are set will be updated. */
export type PermissionPolicyPatch = {
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionNamesUsingId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
  rules?: InputMaybe<Scalars['JSON']['input']>;
  type?: InputMaybe<PermissionPolicyType>;
};

/** The fields on `permissionPolicy` to look up the row to connect. */
export type PermissionPolicyPermissionPolicyNameKeyConnect = {
  name: Scalars['String']['input'];
};

/** The fields on `permissionPolicy` to look up the row to delete. */
export type PermissionPolicyPermissionPolicyNameKeyDelete = {
  name: Scalars['String']['input'];
};

/** The fields on `permissionPolicy` to look up the row to connect. */
export type PermissionPolicyPermissionPolicyPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `permissionPolicy` to look up the row to delete. */
export type PermissionPolicyPermissionPolicyPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `PermissionName` object types. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyToManyPermissionNameFilter = {
  /** Every related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PermissionNameFilter>;
  /** No related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PermissionNameFilter>;
  /** Some related `PermissionName` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PermissionNameFilter>;
};

export enum PermissionPolicyType {
  Apply = 'APPLY',
  Assign = 'ASSIGN',
  Review = 'REVIEW',
  View = 'VIEW'
}

/** A filter to be used against PermissionPolicyType fields. All fields are combined with a logical ‘and.’ */
export type PermissionPolicyTypeFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<PermissionPolicyType>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<PermissionPolicyType>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<PermissionPolicyType>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<PermissionPolicyType>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<PermissionPolicyType>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<PermissionPolicyType>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<PermissionPolicyType>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<PermissionPolicyType>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<PermissionPolicyType>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<PermissionPolicyType>>;
};

export type PermissionsAll = {
  __typename?: 'PermissionsAll';
  allowedSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  canMakeFinalDecision?: Maybe<Scalars['Boolean']['output']>;
  canSelfAssign?: Maybe<Scalars['Boolean']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  isActive?: Maybe<Scalars['Boolean']['output']>;
  isAdmin?: Maybe<Scalars['Boolean']['output']>;
  isSystemOrgPermission?: Maybe<Scalars['Boolean']['output']>;
  isUserCategory?: Maybe<Scalars['Boolean']['output']>;
  orgId?: Maybe<Scalars['Int']['output']>;
  orgName?: Maybe<Scalars['String']['output']>;
  permissionJoinId?: Maybe<Scalars['Int']['output']>;
  permissionName?: Maybe<Scalars['String']['output']>;
  permissionNameId?: Maybe<Scalars['Int']['output']>;
  permissionPolicyId?: Maybe<Scalars['Int']['output']>;
  permissionPolicyRules?: Maybe<Scalars['JSON']['output']>;
  permissionType?: Maybe<PermissionPolicyType>;
  policyName?: Maybe<Scalars['String']['output']>;
  restrictions?: Maybe<Scalars['JSON']['output']>;
  reviewLevel?: Maybe<Scalars['Int']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  templateCode?: Maybe<Scalars['String']['output']>;
  templateId?: Maybe<Scalars['Int']['output']>;
  templatePermissionId?: Maybe<Scalars['Int']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  username?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `PermissionsAll` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PermissionsAllCondition = {
  /** Checks for equality with the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `canMakeFinalDecision` field. */
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `canSelfAssign` field. */
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSystemOrgPermission` field. */
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isUserCategory` field. */
  isUserCategory?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissionJoinId` field. */
  permissionJoinId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionName` field. */
  permissionName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionPolicyRules` field. */
  permissionPolicyRules?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `permissionType` field. */
  permissionType?: InputMaybe<PermissionPolicyType>;
  /** Checks for equality with the object’s `policyName` field. */
  policyName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `restrictions` field. */
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `reviewLevel` field. */
  reviewLevel?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templatePermissionId` field. */
  templatePermissionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PermissionsAll` object types. All fields are combined with a logical ‘and.’ */
export type PermissionsAllFilter = {
  /** Filter by the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PermissionsAllFilter>>;
  /** Filter by the object’s `canMakeFinalDecision` field. */
  canMakeFinalDecision?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `canSelfAssign` field. */
  canSelfAssign?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isAdmin` field. */
  isAdmin?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSystemOrgPermission` field. */
  isSystemOrgPermission?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isUserCategory` field. */
  isUserCategory?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PermissionsAllFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PermissionsAllFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `orgName` field. */
  orgName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `permissionJoinId` field. */
  permissionJoinId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionName` field. */
  permissionName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionPolicyId` field. */
  permissionPolicyId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `permissionPolicyRules` field. */
  permissionPolicyRules?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `permissionType` field. */
  permissionType?: InputMaybe<PermissionPolicyTypeFilter>;
  /** Filter by the object’s `policyName` field. */
  policyName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `restrictions` field. */
  restrictions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `reviewLevel` field. */
  reviewLevel?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templatePermissionId` field. */
  templatePermissionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** A connection to a list of `PermissionsAll` values. */
export type PermissionsAllsConnection = {
  __typename?: 'PermissionsAllsConnection';
  /** A list of edges which contains the `PermissionsAll` and cursor to aid in pagination. */
  edges: Array<PermissionsAllsEdge>;
  /** A list of `PermissionsAll` objects. */
  nodes: Array<Maybe<PermissionsAll>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PermissionsAll` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PermissionsAll` edge in the connection. */
export type PermissionsAllsEdge = {
  __typename?: 'PermissionsAllsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PermissionsAll` at the end of the edge. */
  node?: Maybe<PermissionsAll>;
};

/** Methods to use when ordering `PermissionsAll`. */
export enum PermissionsAllsOrderBy {
  AllowedSectionsAsc = 'ALLOWED_SECTIONS_ASC',
  AllowedSectionsDesc = 'ALLOWED_SECTIONS_DESC',
  CanMakeFinalDecisionAsc = 'CAN_MAKE_FINAL_DECISION_ASC',
  CanMakeFinalDecisionDesc = 'CAN_MAKE_FINAL_DECISION_DESC',
  CanSelfAssignAsc = 'CAN_SELF_ASSIGN_ASC',
  CanSelfAssignDesc = 'CAN_SELF_ASSIGN_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  IsAdminAsc = 'IS_ADMIN_ASC',
  IsAdminDesc = 'IS_ADMIN_DESC',
  IsSystemOrgPermissionAsc = 'IS_SYSTEM_ORG_PERMISSION_ASC',
  IsSystemOrgPermissionDesc = 'IS_SYSTEM_ORG_PERMISSION_DESC',
  IsUserCategoryAsc = 'IS_USER_CATEGORY_ASC',
  IsUserCategoryDesc = 'IS_USER_CATEGORY_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OrgNameAsc = 'ORG_NAME_ASC',
  OrgNameDesc = 'ORG_NAME_DESC',
  PermissionJoinIdAsc = 'PERMISSION_JOIN_ID_ASC',
  PermissionJoinIdDesc = 'PERMISSION_JOIN_ID_DESC',
  PermissionNameAsc = 'PERMISSION_NAME_ASC',
  PermissionNameDesc = 'PERMISSION_NAME_DESC',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  PermissionPolicyIdAsc = 'PERMISSION_POLICY_ID_ASC',
  PermissionPolicyIdDesc = 'PERMISSION_POLICY_ID_DESC',
  PermissionPolicyRulesAsc = 'PERMISSION_POLICY_RULES_ASC',
  PermissionPolicyRulesDesc = 'PERMISSION_POLICY_RULES_DESC',
  PermissionTypeAsc = 'PERMISSION_TYPE_ASC',
  PermissionTypeDesc = 'PERMISSION_TYPE_DESC',
  PolicyNameAsc = 'POLICY_NAME_ASC',
  PolicyNameDesc = 'POLICY_NAME_DESC',
  RestrictionsAsc = 'RESTRICTIONS_ASC',
  RestrictionsDesc = 'RESTRICTIONS_DESC',
  ReviewLevelAsc = 'REVIEW_LEVEL_ASC',
  ReviewLevelDesc = 'REVIEW_LEVEL_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TemplatePermissionIdAsc = 'TEMPLATE_PERMISSION_ID_ASC',
  TemplatePermissionIdDesc = 'TEMPLATE_PERMISSION_ID_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

export type PostgresRowLevel = {
  __typename?: 'PostgresRowLevel';
  cmd?: Maybe<Scalars['String']['output']>;
  permissive?: Maybe<Scalars['String']['output']>;
  policyname?: Maybe<Scalars['String']['output']>;
  qual?: Maybe<Scalars['String']['output']>;
  roles?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  schemaname?: Maybe<Scalars['String']['output']>;
  tablename?: Maybe<Scalars['String']['output']>;
  withCheck?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `PostgresRowLevel` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type PostgresRowLevelCondition = {
  /** Checks for equality with the object’s `cmd` field. */
  cmd?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `permissive` field. */
  permissive?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `policyname` field. */
  policyname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `qual` field. */
  qual?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `roles` field. */
  roles?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `schemaname` field. */
  schemaname?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `tablename` field. */
  tablename?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `withCheck` field. */
  withCheck?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `PostgresRowLevel` object types. All fields are combined with a logical ‘and.’ */
export type PostgresRowLevelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<PostgresRowLevelFilter>>;
  /** Filter by the object’s `cmd` field. */
  cmd?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<PostgresRowLevelFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<PostgresRowLevelFilter>>;
  /** Filter by the object’s `permissive` field. */
  permissive?: InputMaybe<StringFilter>;
  /** Filter by the object’s `policyname` field. */
  policyname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `qual` field. */
  qual?: InputMaybe<StringFilter>;
  /** Filter by the object’s `roles` field. */
  roles?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `schemaname` field. */
  schemaname?: InputMaybe<StringFilter>;
  /** Filter by the object’s `tablename` field. */
  tablename?: InputMaybe<StringFilter>;
  /** Filter by the object’s `withCheck` field. */
  withCheck?: InputMaybe<StringFilter>;
};

/** A connection to a list of `PostgresRowLevel` values. */
export type PostgresRowLevelsConnection = {
  __typename?: 'PostgresRowLevelsConnection';
  /** A list of edges which contains the `PostgresRowLevel` and cursor to aid in pagination. */
  edges: Array<PostgresRowLevelsEdge>;
  /** A list of `PostgresRowLevel` objects. */
  nodes: Array<Maybe<PostgresRowLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `PostgresRowLevel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `PostgresRowLevel` edge in the connection. */
export type PostgresRowLevelsEdge = {
  __typename?: 'PostgresRowLevelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `PostgresRowLevel` at the end of the edge. */
  node?: Maybe<PostgresRowLevel>;
};

/** Methods to use when ordering `PostgresRowLevel`. */
export enum PostgresRowLevelsOrderBy {
  CmdAsc = 'CMD_ASC',
  CmdDesc = 'CMD_DESC',
  Natural = 'NATURAL',
  PermissiveAsc = 'PERMISSIVE_ASC',
  PermissiveDesc = 'PERMISSIVE_DESC',
  PolicynameAsc = 'POLICYNAME_ASC',
  PolicynameDesc = 'POLICYNAME_DESC',
  QualAsc = 'QUAL_ASC',
  QualDesc = 'QUAL_DESC',
  RolesAsc = 'ROLES_ASC',
  RolesDesc = 'ROLES_DESC',
  SchemanameAsc = 'SCHEMANAME_ASC',
  SchemanameDesc = 'SCHEMANAME_DESC',
  TablenameAsc = 'TABLENAME_ASC',
  TablenameDesc = 'TABLENAME_DESC',
  WithCheckAsc = 'WITH_CHECK_ASC',
  WithCheckDesc = 'WITH_CHECK_DESC'
}

/** The root query type which gives access points into the data universe. */
export type Query = Node & {
  __typename?: 'Query';
  actionPlugin?: Maybe<ActionPlugin>;
  actionPluginByCode?: Maybe<ActionPlugin>;
  /** Reads a single `ActionPlugin` using its globally unique `ID`. */
  actionPluginByNodeId?: Maybe<ActionPlugin>;
  /** Reads and enables pagination through a set of `ActionPlugin`. */
  actionPlugins?: Maybe<ActionPluginsConnection>;
  actionQueue?: Maybe<ActionQueue>;
  /** Reads a single `ActionQueue` using its globally unique `ID`. */
  actionQueueByNodeId?: Maybe<ActionQueue>;
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueues?: Maybe<ActionQueuesConnection>;
  activityLog?: Maybe<ActivityLog>;
  /** Reads a single `ActivityLog` using its globally unique `ID`. */
  activityLogByNodeId?: Maybe<ActivityLog>;
  /** Reads and enables pagination through a set of `ActivityLog`. */
  activityLogs?: Maybe<ActivityLogsConnection>;
  /** Reads and enables pagination through a set of `AllowedSelfAssignableSectionsShape`. */
  allowedSelfAssignableSections?: Maybe<AllowedSelfAssignableSectionsShapesConnection>;
  /** Reads and enables pagination through a set of `AllowedSelfAssignableSectionsShape`. */
  allowedSelfAssignableSectionsShapes?: Maybe<AllowedSelfAssignableSectionsShapesConnection>;
  application?: Maybe<Application>;
  /** Reads a single `Application` using its globally unique `ID`. */
  applicationByNodeId?: Maybe<Application>;
  applicationByOutcomeRegistration?: Maybe<Application>;
  applicationBySerial?: Maybe<Application>;
  /** Reads and enables pagination through a set of `ApplicationListShape`. */
  applicationList?: Maybe<ApplicationListShapesConnection>;
  applicationListFilterApplicant?: Maybe<ApplicationListFilterApplicantConnection>;
  applicationListFilterAssigner?: Maybe<ApplicationListFilterAssignerConnection>;
  applicationListFilterOrganisation?: Maybe<ApplicationListFilterOrganisationConnection>;
  applicationListFilterReviewer?: Maybe<ApplicationListFilterReviewerConnection>;
  applicationListFilterStage?: Maybe<ApplicationListFilterStageConnection>;
  /** Reads and enables pagination through a set of `ApplicationListShape`. */
  applicationListShapes?: Maybe<ApplicationListShapesConnection>;
  applicationNote?: Maybe<ApplicationNote>;
  /** Reads a single `ApplicationNote` using its globally unique `ID`. */
  applicationNoteByNodeId?: Maybe<ApplicationNote>;
  /** Reads and enables pagination through a set of `ApplicationNote`. */
  applicationNotes?: Maybe<ApplicationNotesConnection>;
  applicationResponse?: Maybe<ApplicationResponse>;
  /** Reads a single `ApplicationResponse` using its globally unique `ID`. */
  applicationResponseByNodeId?: Maybe<ApplicationResponse>;
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses?: Maybe<ApplicationResponsesConnection>;
  applicationReviewerAction?: Maybe<ApplicationReviewerAction>;
  /** Reads a single `ApplicationReviewerAction` using its globally unique `ID`. */
  applicationReviewerActionByNodeId?: Maybe<ApplicationReviewerAction>;
  applicationReviewerActionByUserIdAndApplicationId?: Maybe<ApplicationReviewerAction>;
  /** Reads and enables pagination through a set of `ApplicationReviewerAction`. */
  applicationReviewerActions?: Maybe<ApplicationReviewerActionsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistories?: Maybe<ApplicationStageHistoriesConnection>;
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** Reads a single `ApplicationStageHistory` using its globally unique `ID`. */
  applicationStageHistoryByNodeId?: Maybe<ApplicationStageHistory>;
  /** Reads and enables pagination through a set of `ApplicationStageStatusAll`. */
  applicationStageStatusAlls?: Maybe<ApplicationStageStatusAllsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStageStatusLatest`. */
  applicationStageStatusLatests?: Maybe<ApplicationStageStatusLatestsConnection>;
  /** Reads and enables pagination through a set of `ApplicationStatusHistory`. */
  applicationStatusHistories?: Maybe<ApplicationStatusHistoriesConnection>;
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** Reads a single `ApplicationStatusHistory` using its globally unique `ID`. */
  applicationStatusHistoryByNodeId?: Maybe<ApplicationStatusHistory>;
  /** Reads and enables pagination through a set of `Application`. */
  applications?: Maybe<ApplicationsConnection>;
  assignableQuestionsCount?: Maybe<Scalars['BigInt']['output']>;
  assignedQuestions?: Maybe<AssignedQuestionsConnection>;
  assignedQuestionsCount?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `AssignedSectionsByStageAndLevel`. */
  assignedSectionsByStageAndLevels?: Maybe<AssignedSectionsByStageAndLevelsConnection>;
  assignerList?: Maybe<AssignerListConnection>;
  assignmentList?: Maybe<AssignmentListConnection>;
  /** Reads and enables pagination through a set of `ConstraintsInfo`. */
  constraintsInfos?: Maybe<ConstraintsInfosConnection>;
  counter?: Maybe<Counter>;
  counterByName?: Maybe<Counter>;
  /** Reads a single `Counter` using its globally unique `ID`. */
  counterByNodeId?: Maybe<Counter>;
  /** Reads and enables pagination through a set of `Counter`. */
  counters?: Maybe<CountersConnection>;
  dataChangelog?: Maybe<DataChangelog>;
  /** Reads a single `DataChangelog` using its globally unique `ID`. */
  dataChangelogByNodeId?: Maybe<DataChangelog>;
  /** Reads and enables pagination through a set of `DataChangelog`. */
  dataChangelogs?: Maybe<DataChangelogsConnection>;
  dataTable?: Maybe<DataTable>;
  dataTableActiveIngredient?: Maybe<DataTableActiveIngredient>;
  /** Reads a single `DataTableActiveIngredient` using its globally unique `ID`. */
  dataTableActiveIngredientByNodeId?: Maybe<DataTableActiveIngredient>;
  /** Reads and enables pagination through a set of `DataTableActiveIngredient`. */
  dataTableActiveIngredients?: Maybe<DataTableActiveIngredientsConnection>;
  dataTableAdministrationRoute?: Maybe<DataTableAdministrationRoute>;
  /** Reads a single `DataTableAdministrationRoute` using its globally unique `ID`. */
  dataTableAdministrationRouteByNodeId?: Maybe<DataTableAdministrationRoute>;
  /** Reads and enables pagination through a set of `DataTableAdministrationRoute`. */
  dataTableAdministrationRoutes?: Maybe<DataTableAdministrationRoutesConnection>;
  dataTableAtcCode?: Maybe<DataTableAtcCode>;
  /** Reads a single `DataTableAtcCode` using its globally unique `ID`. */
  dataTableAtcCodeByNodeId?: Maybe<DataTableAtcCode>;
  /** Reads and enables pagination through a set of `DataTableAtcCode`. */
  dataTableAtcCodes?: Maybe<DataTableAtcCodesConnection>;
  /** Reads a single `DataTable` using its globally unique `ID`. */
  dataTableByNodeId?: Maybe<DataTable>;
  dataTableByTableName?: Maybe<DataTable>;
  dataTableContainer?: Maybe<DataTableContainer>;
  /** Reads a single `DataTableContainer` using its globally unique `ID`. */
  dataTableContainerByNodeId?: Maybe<DataTableContainer>;
  /** Reads and enables pagination through a set of `DataTableContainer`. */
  dataTableContainers?: Maybe<DataTableContainersConnection>;
  /** Reads and enables pagination through a set of `DataTableCountry`. */
  dataTableCountries?: Maybe<DataTableCountriesConnection>;
  dataTableCountry?: Maybe<DataTableCountry>;
  /** Reads a single `DataTableCountry` using its globally unique `ID`. */
  dataTableCountryByNodeId?: Maybe<DataTableCountry>;
  dataTableDosageForm?: Maybe<DataTableDosageForm>;
  /** Reads a single `DataTableDosageForm` using its globally unique `ID`. */
  dataTableDosageFormByNodeId?: Maybe<DataTableDosageForm>;
  dataTableDosageFormGroup?: Maybe<DataTableDosageFormGroup>;
  /** Reads a single `DataTableDosageFormGroup` using its globally unique `ID`. */
  dataTableDosageFormGroupByNodeId?: Maybe<DataTableDosageFormGroup>;
  /** Reads and enables pagination through a set of `DataTableDosageFormGroup`. */
  dataTableDosageFormGroups?: Maybe<DataTableDosageFormGroupsConnection>;
  /** Reads and enables pagination through a set of `DataTableDosageForm`. */
  dataTableDosageForms?: Maybe<DataTableDosageFormsConnection>;
  dataTableGenericIngredient?: Maybe<DataTableGenericIngredient>;
  /** Reads a single `DataTableGenericIngredient` using its globally unique `ID`. */
  dataTableGenericIngredientByNodeId?: Maybe<DataTableGenericIngredient>;
  /** Reads and enables pagination through a set of `DataTableGenericIngredient`. */
  dataTableGenericIngredients?: Maybe<DataTableGenericIngredientsConnection>;
  dataTableManufacturer?: Maybe<DataTableManufacturer>;
  dataTableManufacturerApplicationJoin?: Maybe<DataTableManufacturerApplicationJoin>;
  /** Reads a single `DataTableManufacturerApplicationJoin` using its globally unique `ID`. */
  dataTableManufacturerApplicationJoinByNodeId?: Maybe<DataTableManufacturerApplicationJoin>;
  /** Reads and enables pagination through a set of `DataTableManufacturerApplicationJoin`. */
  dataTableManufacturerApplicationJoins?: Maybe<DataTableManufacturerApplicationJoinsConnection>;
  /** Reads a single `DataTableManufacturer` using its globally unique `ID`. */
  dataTableManufacturerByNodeId?: Maybe<DataTableManufacturer>;
  dataTableManufacturerRepresentative?: Maybe<DataTableManufacturerRepresentative>;
  dataTableManufacturerRepresentativeApplicationJoin?: Maybe<DataTableManufacturerRepresentativeApplicationJoin>;
  /** Reads a single `DataTableManufacturerRepresentativeApplicationJoin` using its globally unique `ID`. */
  dataTableManufacturerRepresentativeApplicationJoinByNodeId?: Maybe<DataTableManufacturerRepresentativeApplicationJoin>;
  /** Reads and enables pagination through a set of `DataTableManufacturerRepresentativeApplicationJoin`. */
  dataTableManufacturerRepresentativeApplicationJoins?: Maybe<DataTableManufacturerRepresentativeApplicationJoinsConnection>;
  /** Reads a single `DataTableManufacturerRepresentative` using its globally unique `ID`. */
  dataTableManufacturerRepresentativeByNodeId?: Maybe<DataTableManufacturerRepresentative>;
  /** Reads and enables pagination through a set of `DataTableManufacturerRepresentative`. */
  dataTableManufacturerRepresentatives?: Maybe<DataTableManufacturerRepresentativesConnection>;
  /** Reads and enables pagination through a set of `DataTableManufacturer`. */
  dataTableManufacturers?: Maybe<DataTableManufacturersConnection>;
  dataTablePermitChemical?: Maybe<DataTablePermitChemical>;
  dataTablePermitChemicalApplicationJoin?: Maybe<DataTablePermitChemicalApplicationJoin>;
  /** Reads a single `DataTablePermitChemicalApplicationJoin` using its globally unique `ID`. */
  dataTablePermitChemicalApplicationJoinByNodeId?: Maybe<DataTablePermitChemicalApplicationJoin>;
  /** Reads and enables pagination through a set of `DataTablePermitChemicalApplicationJoin`. */
  dataTablePermitChemicalApplicationJoins?: Maybe<DataTablePermitChemicalApplicationJoinsConnection>;
  /** Reads a single `DataTablePermitChemical` using its globally unique `ID`. */
  dataTablePermitChemicalByNodeId?: Maybe<DataTablePermitChemical>;
  /** Reads and enables pagination through a set of `DataTablePermitChemical`. */
  dataTablePermitChemicals?: Maybe<DataTablePermitChemicalsConnection>;
  dataTablePreRegisteredProductsProvisional?: Maybe<DataTablePreRegisteredProductsProvisional>;
  /** Reads a single `DataTablePreRegisteredProductsProvisional` using its globally unique `ID`. */
  dataTablePreRegisteredProductsProvisionalByNodeId?: Maybe<DataTablePreRegisteredProductsProvisional>;
  /** Reads and enables pagination through a set of `DataTablePreRegisteredProductsProvisional`. */
  dataTablePreRegisteredProductsProvisionals?: Maybe<DataTablePreRegisteredProductsProvisionalsConnection>;
  dataTablePrequalManufacturer?: Maybe<DataTablePrequalManufacturer>;
  dataTablePrequalManufacturerApplicationJoin?: Maybe<DataTablePrequalManufacturerApplicationJoin>;
  /** Reads a single `DataTablePrequalManufacturerApplicationJoin` using its globally unique `ID`. */
  dataTablePrequalManufacturerApplicationJoinByNodeId?: Maybe<DataTablePrequalManufacturerApplicationJoin>;
  /** Reads and enables pagination through a set of `DataTablePrequalManufacturerApplicationJoin`. */
  dataTablePrequalManufacturerApplicationJoins?: Maybe<DataTablePrequalManufacturerApplicationJoinsConnection>;
  /** Reads a single `DataTablePrequalManufacturer` using its globally unique `ID`. */
  dataTablePrequalManufacturerByNodeId?: Maybe<DataTablePrequalManufacturer>;
  /** Reads and enables pagination through a set of `DataTablePrequalManufacturer`. */
  dataTablePrequalManufacturers?: Maybe<DataTablePrequalManufacturersConnection>;
  dataTableProcessingStep?: Maybe<DataTableProcessingStep>;
  /** Reads a single `DataTableProcessingStep` using its globally unique `ID`. */
  dataTableProcessingStepByNodeId?: Maybe<DataTableProcessingStep>;
  /** Reads and enables pagination through a set of `DataTableProcessingStep`. */
  dataTableProcessingSteps?: Maybe<DataTableProcessingStepsConnection>;
  dataTableProduct?: Maybe<DataTableProduct>;
  dataTableProductApplicationJoin?: Maybe<DataTableProductApplicationJoin>;
  /** Reads a single `DataTableProductApplicationJoin` using its globally unique `ID`. */
  dataTableProductApplicationJoinByNodeId?: Maybe<DataTableProductApplicationJoin>;
  /** Reads and enables pagination through a set of `DataTableProductApplicationJoin`. */
  dataTableProductApplicationJoins?: Maybe<DataTableProductApplicationJoinsConnection>;
  /** Reads a single `DataTableProduct` using its globally unique `ID`. */
  dataTableProductByNodeId?: Maybe<DataTableProduct>;
  /** Reads and enables pagination through a set of `DataTableProduct`. */
  dataTableProducts?: Maybe<DataTableProductsConnection>;
  dataTableProvisionalProduct?: Maybe<DataTableProvisionalProduct>;
  dataTableProvisionalProductApplicationJoin?: Maybe<DataTableProvisionalProductApplicationJoin>;
  /** Reads a single `DataTableProvisionalProductApplicationJoin` using its globally unique `ID`. */
  dataTableProvisionalProductApplicationJoinByNodeId?: Maybe<DataTableProvisionalProductApplicationJoin>;
  /** Reads and enables pagination through a set of `DataTableProvisionalProductApplicationJoin`. */
  dataTableProvisionalProductApplicationJoins?: Maybe<DataTableProvisionalProductApplicationJoinsConnection>;
  /** Reads a single `DataTableProvisionalProduct` using its globally unique `ID`. */
  dataTableProvisionalProductByNodeId?: Maybe<DataTableProvisionalProduct>;
  /** Reads and enables pagination through a set of `DataTableProvisionalProduct`. */
  dataTableProvisionalProducts?: Maybe<DataTableProvisionalProductsConnection>;
  dataTableScheduledChemical?: Maybe<DataTableScheduledChemical>;
  /** Reads a single `DataTableScheduledChemical` using its globally unique `ID`. */
  dataTableScheduledChemicalByNodeId?: Maybe<DataTableScheduledChemical>;
  /** Reads and enables pagination through a set of `DataTableScheduledChemical`. */
  dataTableScheduledChemicals?: Maybe<DataTableScheduledChemicalsConnection>;
  dataTableStorageCondition?: Maybe<DataTableStorageCondition>;
  /** Reads a single `DataTableStorageCondition` using its globally unique `ID`. */
  dataTableStorageConditionByNodeId?: Maybe<DataTableStorageCondition>;
  /** Reads and enables pagination through a set of `DataTableStorageCondition`. */
  dataTableStorageConditions?: Maybe<DataTableStorageConditionsConnection>;
  dataTableStorageConditionsSimplified?: Maybe<DataTableStorageConditionsSimplified>;
  /** Reads a single `DataTableStorageConditionsSimplified` using its globally unique `ID`. */
  dataTableStorageConditionsSimplifiedByNodeId?: Maybe<DataTableStorageConditionsSimplified>;
  /** Reads and enables pagination through a set of `DataTableStorageConditionsSimplified`. */
  dataTableStorageConditionsSimplifieds?: Maybe<DataTableStorageConditionsSimplifiedsConnection>;
  dataTableUnitsOfProportion?: Maybe<DataTableUnitsOfProportion>;
  /** Reads a single `DataTableUnitsOfProportion` using its globally unique `ID`. */
  dataTableUnitsOfProportionByNodeId?: Maybe<DataTableUnitsOfProportion>;
  /** Reads and enables pagination through a set of `DataTableUnitsOfProportion`. */
  dataTableUnitsOfProportions?: Maybe<DataTableUnitsOfProportionsConnection>;
  dataTableWorldHealthOrganisationPqListOfFpp?: Maybe<DataTableWorldHealthOrganisationPqListOfFpp>;
  /** Reads a single `DataTableWorldHealthOrganisationPqListOfFpp` using its globally unique `ID`. */
  dataTableWorldHealthOrganisationPqListOfFppByNodeId?: Maybe<DataTableWorldHealthOrganisationPqListOfFpp>;
  /** Reads and enables pagination through a set of `DataTableWorldHealthOrganisationPqListOfFpp`. */
  dataTableWorldHealthOrganisationPqListOfFpps?: Maybe<DataTableWorldHealthOrganisationPqListOfFppsConnection>;
  /** Reads and enables pagination through a set of `DataTable`. */
  dataTables?: Maybe<DataTablesConnection>;
  dataView?: Maybe<DataView>;
  dataViewByIdentifier?: Maybe<DataView>;
  /** Reads a single `DataView` using its globally unique `ID`. */
  dataViewByNodeId?: Maybe<DataView>;
  dataViewColumnDefinition?: Maybe<DataViewColumnDefinition>;
  /** Reads a single `DataViewColumnDefinition` using its globally unique `ID`. */
  dataViewColumnDefinitionByNodeId?: Maybe<DataViewColumnDefinition>;
  dataViewColumnDefinitionByTableNameAndColumnName?: Maybe<DataViewColumnDefinition>;
  /** Reads and enables pagination through a set of `DataViewColumnDefinition`. */
  dataViewColumnDefinitions?: Maybe<DataViewColumnDefinitionsConnection>;
  /** Reads and enables pagination through a set of `DataView`. */
  dataViews?: Maybe<DataViewsConnection>;
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** Reads a single `ElementTypePlugin` using its globally unique `ID`. */
  elementTypePluginByNodeId?: Maybe<ElementTypePlugin>;
  /** Reads and enables pagination through a set of `ElementTypePlugin`. */
  elementTypePlugins?: Maybe<ElementTypePluginsConnection>;
  file?: Maybe<File>;
  /** Reads a single `File` using its globally unique `ID`. */
  fileByNodeId?: Maybe<File>;
  fileByUniqueId?: Maybe<File>;
  /** Reads and enables pagination through a set of `File`. */
  files?: Maybe<FilesConnection>;
  filter?: Maybe<Filter>;
  filterByCode?: Maybe<Filter>;
  /** Reads a single `Filter` using its globally unique `ID`. */
  filterByNodeId?: Maybe<Filter>;
  /** Reads and enables pagination through a set of `Filter`. */
  filters?: Maybe<FiltersConnection>;
  grafanaDashboardImage?: Maybe<GrafanaDashboardImage>;
  /** Reads a single `GrafanaDashboardImage` using its globally unique `ID`. */
  grafanaDashboardImageByNodeId?: Maybe<GrafanaDashboardImage>;
  /** Reads and enables pagination through a set of `GrafanaDashboardImage`. */
  grafanaDashboardImages?: Maybe<GrafanaDashboardImagesConnection>;
  jwtGetBigint?: Maybe<Scalars['BigInt']['output']>;
  jwtGetBoolean?: Maybe<Scalars['Boolean']['output']>;
  jwtGetText?: Maybe<Scalars['String']['output']>;
  /** Fetches an object given its globally unique `ID`. */
  node?: Maybe<Node>;
  /** The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`. */
  nodeId: Scalars['ID']['output'];
  notification?: Maybe<Notification>;
  /** Reads a single `Notification` using its globally unique `ID`. */
  notificationByNodeId?: Maybe<Notification>;
  /** Reads and enables pagination through a set of `Notification`. */
  notifications?: Maybe<NotificationsConnection>;
  organisation?: Maybe<Organisation>;
  organisationApplicationJoin?: Maybe<OrganisationApplicationJoin>;
  /** Reads a single `OrganisationApplicationJoin` using its globally unique `ID`. */
  organisationApplicationJoinByNodeId?: Maybe<OrganisationApplicationJoin>;
  /** Reads and enables pagination through a set of `OrganisationApplicationJoin`. */
  organisationApplicationJoins?: Maybe<OrganisationApplicationJoinsConnection>;
  organisationByName?: Maybe<Organisation>;
  /** Reads a single `Organisation` using its globally unique `ID`. */
  organisationByNodeId?: Maybe<Organisation>;
  organisationByRegistration?: Maybe<Organisation>;
  /** Reads and enables pagination through a set of `Organisation`. */
  organisations?: Maybe<OrganisationsConnection>;
  /** Reads and enables pagination through a set of `PermissionFlattened`. */
  permissionFlatteneds?: Maybe<PermissionFlattenedsConnection>;
  permissionJoin?: Maybe<PermissionJoin>;
  /** Reads a single `PermissionJoin` using its globally unique `ID`. */
  permissionJoinByNodeId?: Maybe<PermissionJoin>;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoins?: Maybe<PermissionJoinsConnection>;
  permissionName?: Maybe<PermissionName>;
  permissionNameByName?: Maybe<PermissionName>;
  /** Reads a single `PermissionName` using its globally unique `ID`. */
  permissionNameByNodeId?: Maybe<PermissionName>;
  /** Reads and enables pagination through a set of `PermissionName`. */
  permissionNames?: Maybe<PermissionNamesConnection>;
  /** Reads and enables pagination through a set of `PermissionPolicy`. */
  permissionPolicies?: Maybe<PermissionPoliciesConnection>;
  permissionPolicy?: Maybe<PermissionPolicy>;
  permissionPolicyByName?: Maybe<PermissionPolicy>;
  /** Reads a single `PermissionPolicy` using its globally unique `ID`. */
  permissionPolicyByNodeId?: Maybe<PermissionPolicy>;
  /** Reads and enables pagination through a set of `PermissionsAll`. */
  permissionsAlls?: Maybe<PermissionsAllsConnection>;
  /** Reads and enables pagination through a set of `PostgresRowLevel`. */
  postgresRowLevels?: Maybe<PostgresRowLevelsConnection>;
  /**
   * Exposes the root query type nested one level down. This is helpful for Relay 1
   * which can only query top level fields if they are in a particular form.
   */
  query: Query;
  review?: Maybe<Review>;
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignedSectionsShape`. */
  reviewAssignmentAssignedSections?: Maybe<ReviewAssignmentAssignedSectionsShapesConnection>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignedSectionsShape`. */
  reviewAssignmentAssignedSectionsShapes?: Maybe<ReviewAssignmentAssignedSectionsShapesConnection>;
  reviewAssignmentAssignerJoin?: Maybe<ReviewAssignmentAssignerJoin>;
  /** Reads a single `ReviewAssignmentAssignerJoin` using its globally unique `ID`. */
  reviewAssignmentAssignerJoinByNodeId?: Maybe<ReviewAssignmentAssignerJoin>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignerJoin`. */
  reviewAssignmentAssignerJoins?: Maybe<ReviewAssignmentAssignerJoinsConnection>;
  /** Reads a single `ReviewAssignment` using its globally unique `ID`. */
  reviewAssignmentByNodeId?: Maybe<ReviewAssignment>;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments?: Maybe<ReviewAssignmentsConnection>;
  /** Reads a single `Review` using its globally unique `ID`. */
  reviewByNodeId?: Maybe<Review>;
  reviewByReviewAssignmentId?: Maybe<Review>;
  reviewDecision?: Maybe<ReviewDecision>;
  /** Reads a single `ReviewDecision` using its globally unique `ID`. */
  reviewDecisionByNodeId?: Maybe<ReviewDecision>;
  /** Reads and enables pagination through a set of `ReviewDecision`. */
  reviewDecisions?: Maybe<ReviewDecisionsConnection>;
  reviewList?: Maybe<ReviewListConnection>;
  reviewResponse?: Maybe<ReviewResponse>;
  /** Reads a single `ReviewResponse` using its globally unique `ID`. */
  reviewResponseByNodeId?: Maybe<ReviewResponse>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses?: Maybe<ReviewResponsesConnection>;
  /** Reads and enables pagination through a set of `ReviewStatusHistory`. */
  reviewStatusHistories?: Maybe<ReviewStatusHistoriesConnection>;
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** Reads a single `ReviewStatusHistory` using its globally unique `ID`. */
  reviewStatusHistoryByNodeId?: Maybe<ReviewStatusHistory>;
  reviewableQuestions?: Maybe<ReviewableQuestionsConnection>;
  reviewableQuestionsCount?: Maybe<Scalars['BigInt']['output']>;
  /** Reads and enables pagination through a set of `Review`. */
  reviews?: Maybe<ReviewsConnection>;
  /** Reads and enables pagination through a set of `SchemaColumn`. */
  schemaColumns?: Maybe<SchemaColumnsConnection>;
  singleApplicationDetail?: Maybe<SingleApplicationDetailConnection>;
  submittedAssignedQuestionsCount?: Maybe<Scalars['BigInt']['output']>;
  systemInfo?: Maybe<SystemInfo>;
  /** Reads a single `SystemInfo` using its globally unique `ID`. */
  systemInfoByNodeId?: Maybe<SystemInfo>;
  /** Reads and enables pagination through a set of `SystemInfo`. */
  systemInfos?: Maybe<SystemInfosConnection>;
  template?: Maybe<Template>;
  templateAction?: Maybe<TemplateAction>;
  /** Reads a single `TemplateAction` using its globally unique `ID`. */
  templateActionByNodeId?: Maybe<TemplateAction>;
  /** Reads and enables pagination through a set of `TemplateAction`. */
  templateActions?: Maybe<TemplateActionsConnection>;
  templateByCodeAndVersionId?: Maybe<Template>;
  /** Reads a single `Template` using its globally unique `ID`. */
  templateByNodeId?: Maybe<Template>;
  /** Reads and enables pagination through a set of `TemplateCategory`. */
  templateCategories?: Maybe<TemplateCategoriesConnection>;
  templateCategory?: Maybe<TemplateCategory>;
  templateCategoryByCode?: Maybe<TemplateCategory>;
  /** Reads a single `TemplateCategory` using its globally unique `ID`. */
  templateCategoryByNodeId?: Maybe<TemplateCategory>;
  templateElement?: Maybe<TemplateElement>;
  /** Reads a single `TemplateElement` using its globally unique `ID`. */
  templateElementByNodeId?: Maybe<TemplateElement>;
  templateElementByTemplateCodeAndCodeAndTemplateVersion?: Maybe<TemplateElement>;
  /** Reads and enables pagination through a set of `TemplateElement`. */
  templateElements?: Maybe<TemplateElementsConnection>;
  templateFilterJoin?: Maybe<TemplateFilterJoin>;
  /** Reads a single `TemplateFilterJoin` using its globally unique `ID`. */
  templateFilterJoinByNodeId?: Maybe<TemplateFilterJoin>;
  /** Reads and enables pagination through a set of `TemplateFilterJoin`. */
  templateFilterJoins?: Maybe<TemplateFilterJoinsConnection>;
  templatePermission?: Maybe<TemplatePermission>;
  /** Reads a single `TemplatePermission` using its globally unique `ID`. */
  templatePermissionByNodeId?: Maybe<TemplatePermission>;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions?: Maybe<TemplatePermissionsConnection>;
  templateSection?: Maybe<TemplateSection>;
  /** Reads a single `TemplateSection` using its globally unique `ID`. */
  templateSectionByNodeId?: Maybe<TemplateSection>;
  templateSectionByTemplateIdAndCode?: Maybe<TemplateSection>;
  /** Reads and enables pagination through a set of `TemplateSection`. */
  templateSections?: Maybe<TemplateSectionsConnection>;
  templateStage?: Maybe<TemplateStage>;
  /** Reads a single `TemplateStage` using its globally unique `ID`. */
  templateStageByNodeId?: Maybe<TemplateStage>;
  templateStageReviewLevel?: Maybe<TemplateStageReviewLevel>;
  /** Reads a single `TemplateStageReviewLevel` using its globally unique `ID`. */
  templateStageReviewLevelByNodeId?: Maybe<TemplateStageReviewLevel>;
  /** Reads and enables pagination through a set of `TemplateStageReviewLevel`. */
  templateStageReviewLevels?: Maybe<TemplateStageReviewLevelsConnection>;
  /** Reads and enables pagination through a set of `TemplateStage`. */
  templateStages?: Maybe<TemplateStagesConnection>;
  /** Reads and enables pagination through a set of `Template`. */
  templates?: Maybe<TemplatesConnection>;
  triggerQueue?: Maybe<TriggerQueue>;
  /** Reads a single `TriggerQueue` using its globally unique `ID`. */
  triggerQueueByNodeId?: Maybe<TriggerQueue>;
  /** Reads and enables pagination through a set of `TriggerQueue`. */
  triggerQueues?: Maybe<TriggerQueuesConnection>;
  triggerSchedule?: Maybe<TriggerSchedule>;
  /** Reads a single `TriggerSchedule` using its globally unique `ID`. */
  triggerScheduleByNodeId?: Maybe<TriggerSchedule>;
  /** Reads and enables pagination through a set of `TriggerSchedule`. */
  triggerSchedules?: Maybe<TriggerSchedulesConnection>;
  /** Reads and enables pagination through a set of `UnnestedSection`. */
  unnestedSections?: Maybe<UnnestedSectionsConnection>;
  userApplicationJoin?: Maybe<UserApplicationJoin>;
  /** Reads a single `UserApplicationJoin` using its globally unique `ID`. */
  userApplicationJoinByNodeId?: Maybe<UserApplicationJoin>;
  /** Reads and enables pagination through a set of `UserApplicationJoin`. */
  userApplicationJoins?: Maybe<UserApplicationJoinsConnection>;
  /** Reads and enables pagination through a set of `UserList`. */
  userLists?: Maybe<UserListsConnection>;
  /** Reads and enables pagination through a set of `UserOrgJoin`. */
  userOrgJoins?: Maybe<UserOrgJoinsConnection>;
  userOrganisation?: Maybe<UserOrganisation>;
  /** Reads a single `UserOrganisation` using its globally unique `ID`. */
  userOrganisationByNodeId?: Maybe<UserOrganisation>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations?: Maybe<UserOrganisationsConnection>;
  /** Reads and enables pagination through a set of `User`. */
  users?: Maybe<UsersConnection>;
  verification?: Maybe<Verification>;
  /** Reads a single `Verification` using its globally unique `ID`. */
  verificationByNodeId?: Maybe<Verification>;
  verificationByUniqueId?: Maybe<Verification>;
  /** Reads and enables pagination through a set of `Verification`. */
  verifications?: Maybe<VerificationsConnection>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginByCodeArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionPluginsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionPluginCondition>;
  filter?: InputMaybe<ActionPluginFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionPluginsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueueArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueueByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActionQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionQueueCondition>;
  filter?: InputMaybe<ActionQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryActivityLogArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActivityLogByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryActivityLogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActivityLogCondition>;
  filter?: InputMaybe<ActivityLogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllowedSelfAssignableSectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AllowedSelfAssignableSectionsShapeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  userid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAllowedSelfAssignableSectionsShapesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AllowedSelfAssignableSectionsShapeCondition>;
  filter?: InputMaybe<AllowedSelfAssignableSectionsShapeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AllowedSelfAssignableSectionsShapesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationByOutcomeRegistrationArgs = {
  outcomeRegistration: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationBySerialArgs = {
  serial: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ApplicationListShapeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationListShapesOrderBy>>;
  userid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterApplicantArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  applicant?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterAssignerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  assigner?: InputMaybe<Scalars['String']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterOrganisationArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  organisation?: InputMaybe<Scalars['String']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterReviewerArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  reviewer?: InputMaybe<Scalars['String']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListFilterStageArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<StringFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationListShapesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationListShapeCondition>;
  filter?: InputMaybe<ApplicationListShapeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationListShapesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationNoteArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationNoteByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationNotesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationNoteCondition>;
  filter?: InputMaybe<ApplicationNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponseArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponseByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationResponseCondition>;
  filter?: InputMaybe<ApplicationResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationReviewerActionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationReviewerActionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationReviewerActionByUserIdAndApplicationIdArgs = {
  applicationId: Scalars['Int']['input'];
  userId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationReviewerActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationReviewerActionCondition>;
  filter?: InputMaybe<ApplicationReviewerActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationReviewerActionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageHistoryCondition>;
  filter?: InputMaybe<ApplicationStageHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageHistoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageStatusAllsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageStatusAllCondition>;
  filter?: InputMaybe<ApplicationStageStatusAllFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageStatusAllsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStageStatusLatestsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageStatusLatestCondition>;
  filter?: InputMaybe<ApplicationStageStatusLatestFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageStatusLatestsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStatusHistoryCondition>;
  filter?: InputMaybe<ApplicationStatusHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationStatusHistoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignableQuestionsCountArgs = {
  appId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignedQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  appId?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssignedQuestionsRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignedQuestionsCountArgs = {
  appId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignedSectionsByStageAndLevelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<AssignedSectionsByStageAndLevelCondition>;
  filter?: InputMaybe<AssignedSectionsByStageAndLevelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<AssignedSectionsByStageAndLevelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignerListArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssignerListRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryAssignmentListArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<AssignmentListRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  stageid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryConstraintsInfosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ConstraintsInfoCondition>;
  filter?: InputMaybe<ConstraintsInfoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ConstraintsInfosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryCounterArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCounterByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCounterByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryCountersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<CounterCondition>;
  filter?: InputMaybe<CounterFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<CountersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataChangelogArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataChangelogByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataChangelogsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataChangelogCondition>;
  filter?: InputMaybe<DataChangelogFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataChangelogsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableActiveIngredientArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableActiveIngredientByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableActiveIngredientsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableActiveIngredientCondition>;
  filter?: InputMaybe<DataTableActiveIngredientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableActiveIngredientsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAdministrationRouteArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAdministrationRouteByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAdministrationRoutesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableAdministrationRouteCondition>;
  filter?: InputMaybe<DataTableAdministrationRouteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableAdministrationRoutesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcCodeArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcCodeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableAtcCodesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableAtcCodeCondition>;
  filter?: InputMaybe<DataTableAtcCodeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableAtcCodesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableByTableNameArgs = {
  tableName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableContainerArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableContainerByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableContainersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableContainerCondition>;
  filter?: InputMaybe<DataTableContainerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableContainersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableCountriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableCountryCondition>;
  filter?: InputMaybe<DataTableCountryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableCountriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableCountryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableCountryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormGroupArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormGroupByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableDosageFormGroupCondition>;
  filter?: InputMaybe<DataTableDosageFormGroupFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableDosageFormGroupsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableDosageFormsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableDosageFormCondition>;
  filter?: InputMaybe<DataTableDosageFormFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableDosageFormsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableGenericIngredientArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableGenericIngredientByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableGenericIngredientsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableGenericIngredientCondition>;
  filter?: InputMaybe<DataTableGenericIngredientFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableGenericIngredientsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturerApplicationJoinCondition>;
  filter?: InputMaybe<DataTableManufacturerApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturerApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerRepresentativeArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerRepresentativeApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerRepresentativeApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerRepresentativeApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinCondition>;
  filter?: InputMaybe<DataTableManufacturerRepresentativeApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerRepresentativeByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturerRepresentativesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturerRepresentativeCondition>;
  filter?: InputMaybe<DataTableManufacturerRepresentativeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableManufacturersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableManufacturerCondition>;
  filter?: InputMaybe<DataTableManufacturerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableManufacturersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePermitChemicalArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePermitChemicalApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePermitChemicalApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePermitChemicalApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePermitChemicalApplicationJoinCondition>;
  filter?: InputMaybe<DataTablePermitChemicalApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePermitChemicalByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePermitChemicalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePermitChemicalCondition>;
  filter?: InputMaybe<DataTablePermitChemicalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePermitChemicalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePreRegisteredProductsProvisionalArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePreRegisteredProductsProvisionalByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePreRegisteredProductsProvisionalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePreRegisteredProductsProvisionalCondition>;
  filter?: InputMaybe<DataTablePreRegisteredProductsProvisionalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePreRegisteredProductsProvisionalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePrequalManufacturerArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePrequalManufacturerApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePrequalManufacturerApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePrequalManufacturerApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePrequalManufacturerApplicationJoinCondition>;
  filter?: InputMaybe<DataTablePrequalManufacturerApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePrequalManufacturerByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablePrequalManufacturersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTablePrequalManufacturerCondition>;
  filter?: InputMaybe<DataTablePrequalManufacturerFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProcessingStepArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProcessingStepByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProcessingStepsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProcessingStepCondition>;
  filter?: InputMaybe<DataTableProcessingStepFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProcessingStepsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProductApplicationJoinCondition>;
  filter?: InputMaybe<DataTableProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProductsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProductCondition>;
  filter?: InputMaybe<DataTableProductFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProductsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvisionalProductArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvisionalProductApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvisionalProductApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvisionalProductApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProvisionalProductApplicationJoinCondition>;
  filter?: InputMaybe<DataTableProvisionalProductApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvisionalProductByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableProvisionalProductsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableProvisionalProductCondition>;
  filter?: InputMaybe<DataTableProvisionalProductFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableProvisionalProductsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableScheduledChemicalArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableScheduledChemicalByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableScheduledChemicalsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableScheduledChemicalCondition>;
  filter?: InputMaybe<DataTableScheduledChemicalFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableScheduledChemicalsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableStorageConditionCondition>;
  filter?: InputMaybe<DataTableStorageConditionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableStorageConditionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionsSimplifiedArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionsSimplifiedByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableStorageConditionsSimplifiedsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableStorageConditionsSimplifiedCondition>;
  filter?: InputMaybe<DataTableStorageConditionsSimplifiedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableStorageConditionsSimplifiedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableUnitsOfProportionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableUnitsOfProportionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableUnitsOfProportionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableUnitsOfProportionCondition>;
  filter?: InputMaybe<DataTableUnitsOfProportionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableUnitsOfProportionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableWorldHealthOrganisationPqListOfFppArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableWorldHealthOrganisationPqListOfFppByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTableWorldHealthOrganisationPqListOfFppsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableWorldHealthOrganisationPqListOfFppCondition>;
  filter?: InputMaybe<DataTableWorldHealthOrganisationPqListOfFppFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTableWorldHealthOrganisationPqListOfFppsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataTablesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataTableCondition>;
  filter?: InputMaybe<DataTableFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataTablesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewByIdentifierArgs = {
  identifier: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewColumnDefinitionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewColumnDefinitionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewColumnDefinitionByTableNameAndColumnNameArgs = {
  columnName: Scalars['String']['input'];
  tableName: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewColumnDefinitionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataViewColumnDefinitionCondition>;
  filter?: InputMaybe<DataViewColumnDefinitionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataViewColumnDefinitionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryDataViewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<DataViewCondition>;
  filter?: InputMaybe<DataViewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<DataViewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryElementTypePluginsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ElementTypePluginCondition>;
  filter?: InputMaybe<ElementTypePluginFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ElementTypePluginsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFileArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFileByUniqueIdArgs = {
  uniqueId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterByCodeArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFilterByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryFiltersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FilterCondition>;
  filter?: InputMaybe<FilterFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryGrafanaDashboardImageArgs = {
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGrafanaDashboardImageByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryGrafanaDashboardImagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<GrafanaDashboardImageCondition>;
  filter?: InputMaybe<GrafanaDashboardImageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<GrafanaDashboardImagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetBigintArgs = {
  jwtKey?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetBooleanArgs = {
  jwtKey?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryJwtGetTextArgs = {
  jwtKey?: InputMaybe<Scalars['String']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryNodeArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotificationCondition>;
  filter?: InputMaybe<NotificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganisationApplicationJoinCondition>;
  filter?: InputMaybe<OrganisationApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationByRegistrationArgs = {
  registration: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryOrganisationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<OrganisationCondition>;
  filter?: InputMaybe<OrganisationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<OrganisationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionFlattenedsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionFlattenedCondition>;
  filter?: InputMaybe<PermissionFlattenedFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionFlattenedsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionJoinCondition>;
  filter?: InputMaybe<PermissionJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNameByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionNamesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionNameCondition>;
  filter?: InputMaybe<PermissionNameFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPoliciesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionPolicyCondition>;
  filter?: InputMaybe<PermissionPolicyFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionPoliciesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPolicyArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPolicyByNameArgs = {
  name: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionPolicyByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryPermissionsAllsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionsAllCondition>;
  filter?: InputMaybe<PermissionsAllFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionsAllsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryPostgresRowLevelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PostgresRowLevelCondition>;
  filter?: InputMaybe<PostgresRowLevelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PostgresRowLevelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentAssignedSectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ReviewAssignmentAssignedSectionsShapeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  userid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentAssignedSectionsShapesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignedSectionsShapeCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignedSectionsShapeFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignedSectionsShapesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentAssignerJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentAssignerJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentAssignerJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignerJoinCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewByReviewAssignmentIdArgs = {
  reviewAssignmentId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewDecisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewDecisionCondition>;
  filter?: InputMaybe<ReviewDecisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewListArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  appstatus?: InputMaybe<ApplicationStatus>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ReviewListRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  reviewerid?: InputMaybe<Scalars['Int']['input']>;
  stageid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponseArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponseByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewStatusHistoryCondition>;
  filter?: InputMaybe<ReviewStatusHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewStatusHistoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewableQuestionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  appId?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<ReviewableQuestionsRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewableQuestionsCountArgs = {
  appId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QueryReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewCondition>;
  filter?: InputMaybe<ReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySchemaColumnsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SchemaColumnCondition>;
  filter?: InputMaybe<SchemaColumnFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SchemaColumnsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySingleApplicationDetailArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  applicationid?: InputMaybe<Scalars['Int']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  filter?: InputMaybe<SingleApplicationDetailRecordFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  userid?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySubmittedAssignedQuestionsCountArgs = {
  appId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemInfoArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemInfoByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QuerySystemInfosArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<SystemInfoCondition>;
  filter?: InputMaybe<SystemInfoFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<SystemInfosOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateActionCondition>;
  filter?: InputMaybe<TemplateActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateByCodeAndVersionIdArgs = {
  code: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateCategoryCondition>;
  filter?: InputMaybe<TemplateCategoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateCategoriesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateCategoryArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateCategoryByCodeArgs = {
  code: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateCategoryByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs = {
  code: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateElementsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateElementCondition>;
  filter?: InputMaybe<TemplateElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateFilterJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateFilterJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateFilterJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateFilterJoinCondition>;
  filter?: InputMaybe<TemplateFilterJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatePermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplatePermissionCondition>;
  filter?: InputMaybe<TemplatePermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionByTemplateIdAndCodeArgs = {
  code: Scalars['String']['input'];
  templateId: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateSectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateSectionCondition>;
  filter?: InputMaybe<TemplateSectionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageReviewLevelArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageReviewLevelByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStageReviewLevelsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateStageReviewLevelCondition>;
  filter?: InputMaybe<TemplateStageReviewLevelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplateStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateStageCondition>;
  filter?: InputMaybe<TemplateStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTemplatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateCondition>;
  filter?: InputMaybe<TemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueueArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueueByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerQueueCondition>;
  filter?: InputMaybe<TriggerQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerScheduleArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerScheduleByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryTriggerSchedulesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerScheduleCondition>;
  filter?: InputMaybe<TriggerScheduleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUnnestedSectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UnnestedSectionCondition>;
  filter?: InputMaybe<UnnestedSectionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UnnestedSectionsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserApplicationJoinArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserApplicationJoinByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserApplicationJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserApplicationJoinCondition>;
  filter?: InputMaybe<UserApplicationJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserListsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserListCondition>;
  filter?: InputMaybe<UserListFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserListsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrgJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrgJoinCondition>;
  filter?: InputMaybe<UserOrgJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrgJoinsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryUserOrganisationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationCondition>;
  filter?: InputMaybe<UserOrganisationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserCondition>;
  filter?: InputMaybe<UserFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UsersOrderBy>>;
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationArgs = {
  id: Scalars['Int']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationByNodeIdArgs = {
  nodeId: Scalars['ID']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationByUniqueIdArgs = {
  uniqueId: Scalars['String']['input'];
};


/** The root query type which gives access points into the data universe. */
export type QueryVerificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<VerificationCondition>;
  filter?: InputMaybe<VerificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

export type Review = Node & {
  __typename?: 'Review';
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  isFinalDecision?: Maybe<Scalars['Boolean']['output']>;
  isLastLevel?: Maybe<Scalars['Boolean']['output']>;
  isLastStage?: Maybe<Scalars['Boolean']['output']>;
  isLocked?: Maybe<Scalars['Boolean']['output']>;
  latestDecision?: Maybe<ReviewDecision>;
  levelNumber?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads and enables pagination through a set of `Notification`. */
  notifications: NotificationsConnection;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  reviewAssignmentId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewDecision`. */
  reviewDecisions: ReviewDecisionsConnection;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
  /** Reads and enables pagination through a set of `ReviewStatusHistory`. */
  reviewStatusHistories: ReviewStatusHistoriesConnection;
  /** Reads a single `UserList` that is related to this `Review`. */
  reviewer?: Maybe<UserList>;
  reviewerId?: Maybe<Scalars['Int']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ReviewStatus>;
  timeStageCreated?: Maybe<Scalars['Datetime']['output']>;
  timeStatusCreated?: Maybe<Scalars['Datetime']['output']>;
  trigger?: Maybe<Trigger>;
};


export type ReviewNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<NotificationCondition>;
  filter?: InputMaybe<NotificationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};


export type ReviewReviewDecisionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewDecisionCondition>;
  filter?: InputMaybe<ReviewDecisionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};


export type ReviewReviewResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};


export type ReviewReviewStatusHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewStatusHistoryCondition>;
  filter?: InputMaybe<ReviewStatusHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ReviewApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ReviewInput` mutation. */
export type ReviewApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `review` in the `ApplicationInput` mutation. */
export type ReviewApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewReviewPkeyConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewNodeIdConnect>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<Array<ReviewReviewReviewAssignmentIdKeyConnect>>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewApplicationIdFkeyReviewCreateInput>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewReviewPkeyDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewNodeIdDelete>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<Array<ReviewReviewReviewAssignmentIdKeyDelete>>;
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<Array<ReviewOnReviewForReviewApplicationIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewApplicationIdFkeyReviewCreateInput = {
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

export type ReviewAssignment = Node & {
  __typename?: 'ReviewAssignment';
  allowedSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  assignedSections: Array<Maybe<Scalars['String']['output']>>;
  /** Reads a single `UserList` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<UserList>;
  assignerId?: Maybe<Scalars['Int']['output']>;
  availableSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  id: Scalars['Int']['output'];
  isFinalDecision?: Maybe<Scalars['Boolean']['output']>;
  isLastLevel?: Maybe<Scalars['Boolean']['output']>;
  isLastStage?: Maybe<Scalars['Boolean']['output']>;
  isSelfAssignable?: Maybe<Scalars['Boolean']['output']>;
  /** Reads a single `TemplateStageReviewLevel` that is related to this `ReviewAssignment`. */
  level?: Maybe<TemplateStageReviewLevel>;
  levelId?: Maybe<Scalars['Int']['output']>;
  levelNumber?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  organisationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Review` that is related to this `ReviewAssignment`. */
  review?: Maybe<Review>;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignerJoin`. */
  reviewAssignmentAssignerJoins: ReviewAssignmentAssignerJoinsConnection;
  /** Reads a single `UserList` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<UserList>;
  reviewerId: Scalars['Int']['output'];
  /**
   * Reads and enables pagination through a set of `Review`.
   * @deprecated Please use review instead
   */
  reviews: ReviewsConnection;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  stageId: Scalars['Int']['output'];
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status: ReviewAssignmentStatus;
  /** Reads a single `Template` that is related to this `ReviewAssignment`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
  timeStageCreated?: Maybe<Scalars['Datetime']['output']>;
  timeUpdated?: Maybe<Scalars['Datetime']['output']>;
  trigger?: Maybe<Trigger>;
};


export type ReviewAssignmentReviewAssignmentAssignerJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignerJoinCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};


export type ReviewAssignmentReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewCondition>;
  filter?: InputMaybe<ReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type ReviewAssignmentApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `ApplicationInput` mutation. */
export type ReviewAssignmentApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

export type ReviewAssignmentAssignedSectionsShape = {
  __typename?: 'ReviewAssignmentAssignedSectionsShape';
  assignedSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  reviewAssignmentId?: Maybe<Scalars['Int']['output']>;
};

/**
 * A condition to be used against `ReviewAssignmentAssignedSectionsShape` object
 * types. All fields are tested for equality and combined with a logical ‘and.’
 */
export type ReviewAssignmentAssignedSectionsShapeCondition = {
  /** Checks for equality with the object’s `assignedSections` field. */
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ReviewAssignmentAssignedSectionsShape` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentAssignedSectionsShapeFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewAssignmentAssignedSectionsShapeFilter>>;
  /** Filter by the object’s `assignedSections` field. */
  assignedSections?: InputMaybe<StringListFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewAssignmentAssignedSectionsShapeFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewAssignmentAssignedSectionsShapeFilter>>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ReviewAssignmentAssignedSectionsShape` */
export type ReviewAssignmentAssignedSectionsShapeInput = {
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};

/** A connection to a list of `ReviewAssignmentAssignedSectionsShape` values. */
export type ReviewAssignmentAssignedSectionsShapesConnection = {
  __typename?: 'ReviewAssignmentAssignedSectionsShapesConnection';
  /** A list of edges which contains the `ReviewAssignmentAssignedSectionsShape` and cursor to aid in pagination. */
  edges: Array<ReviewAssignmentAssignedSectionsShapesEdge>;
  /** A list of `ReviewAssignmentAssignedSectionsShape` objects. */
  nodes: Array<Maybe<ReviewAssignmentAssignedSectionsShape>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewAssignmentAssignedSectionsShape` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewAssignmentAssignedSectionsShape` edge in the connection. */
export type ReviewAssignmentAssignedSectionsShapesEdge = {
  __typename?: 'ReviewAssignmentAssignedSectionsShapesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewAssignmentAssignedSectionsShape` at the end of the edge. */
  node?: Maybe<ReviewAssignmentAssignedSectionsShape>;
};

/** Methods to use when ordering `ReviewAssignmentAssignedSectionsShape`. */
export enum ReviewAssignmentAssignedSectionsShapesOrderBy {
  AssignedSectionsAsc = 'ASSIGNED_SECTIONS_ASC',
  AssignedSectionsDesc = 'ASSIGNED_SECTIONS_DESC',
  Natural = 'NATURAL',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC'
}

export type ReviewAssignmentAssignerJoin = Node & {
  __typename?: 'ReviewAssignmentAssignerJoin';
  /** Reads a single `UserList` that is related to this `ReviewAssignmentAssignerJoin`. */
  assigner?: Maybe<UserList>;
  assignerId?: Maybe<Scalars['Int']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `ReviewAssignmentAssignerJoin`. */
  organisation?: Maybe<Organisation>;
  organisationId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewAssignmentAssignerJoin`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  reviewAssignmentId: Scalars['Int']['output'];
};

/**
 * A condition to be used against `ReviewAssignmentAssignerJoin` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type ReviewAssignmentAssignerJoinCondition = {
  /** Checks for equality with the object’s `assignerId` field. */
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `ReviewAssignmentAssignerJoin` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentAssignerJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewAssignmentAssignerJoinFilter>>;
  /** Filter by the object’s `assigner` relation. */
  assigner?: InputMaybe<UserListFilter>;
  /** A related `assigner` exists. */
  assignerExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assignerId` field. */
  assignerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewAssignmentAssignerJoinFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewAssignment` relation. */
  reviewAssignment?: InputMaybe<ReviewAssignmentFilter>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `ReviewAssignmentAssignerJoin` */
export type ReviewAssignmentAssignerJoinInput = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0Input>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewAssignmentAssignerJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewAssignmentAssignerJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0UsingReviewAssignmentAssignerJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0Patch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to update. */
export type ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch;
};

/** Input for the nested mutation of `organisation` in the `ReviewAssignmentAssignerJoinInput` mutation. */
export type ReviewAssignmentAssignerJoinOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignmentAssignerJoin` in the `OrganisationInput` mutation. */
export type ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdConnect>>;
  /** A `ReviewAssignmentAssignerJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentAssignerJoinOrganisationIdFkeyReviewAssignmentAssignerJoinCreateInput>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignmentAssignerJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The `reviewAssignmentAssignerJoin` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinOrganisationIdFkeyReviewAssignmentAssignerJoinCreateInput = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0Input>;
};

/** Represents an update to a `ReviewAssignmentAssignerJoin`. Fields that are set will be updated. */
export type ReviewAssignmentAssignerJoinPatch = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0Input>;
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to connect. */
export type ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewAssignmentAssignerJoin` to look up the row to delete. */
export type ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `reviewAssignment` in the `ReviewAssignmentAssignerJoinInput` mutation. */
export type ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewAssignmentReviewAssignmentPkeyConnect>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewAssignmentNodeIdConnect>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentCreateInput>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewAssignmentReviewAssignmentPkeyDelete>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewAssignmentNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewAssignmentAssignerJoin` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdConnect>>;
  /** A `ReviewAssignmentAssignerJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentAssignerJoinCreateInput>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete>>;
  /** The primary key(s) for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentAssignerJoinNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignmentAssignerJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignmentAssignerJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignmentAssignerJoin` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentAssignerJoinCreateInput = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0Input>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** A connection to a list of `ReviewAssignmentAssignerJoin` values. */
export type ReviewAssignmentAssignerJoinsConnection = {
  __typename?: 'ReviewAssignmentAssignerJoinsConnection';
  /** A list of edges which contains the `ReviewAssignmentAssignerJoin` and cursor to aid in pagination. */
  edges: Array<ReviewAssignmentAssignerJoinsEdge>;
  /** A list of `ReviewAssignmentAssignerJoin` objects. */
  nodes: Array<Maybe<ReviewAssignmentAssignerJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewAssignmentAssignerJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewAssignmentAssignerJoin` edge in the connection. */
export type ReviewAssignmentAssignerJoinsEdge = {
  __typename?: 'ReviewAssignmentAssignerJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewAssignmentAssignerJoin` at the end of the edge. */
  node?: Maybe<ReviewAssignmentAssignerJoin>;
};

/** Methods to use when ordering `ReviewAssignmentAssignerJoin`. */
export enum ReviewAssignmentAssignerJoinsOrderBy {
  AssignerIdAsc = 'ASSIGNER_ID_ASC',
  AssignerIdDesc = 'ASSIGNER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC'
}

/**
 * A condition to be used against `ReviewAssignment` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ReviewAssignmentCondition = {
  /** Checks for equality with the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `assignedSections` field. */
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `assignerId` field. */
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isFinalDecision` field. */
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLastLevel` field. */
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLastStage` field. */
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isSelfAssignable` field. */
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `levelId` field. */
  levelId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ReviewAssignmentStatus>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeStageCreated` field. */
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
};

/** A filter to be used against `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentFilter = {
  /** Filter by the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewAssignmentFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `assignedSections` field. */
  assignedSections?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `assigner` relation. */
  assigner?: InputMaybe<UserListFilter>;
  /** A related `assigner` exists. */
  assignerExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `assignerId` field. */
  assignerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `availableSections` field. */
  availableSections?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isFinalDecision` field. */
  isFinalDecision?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLastLevel` field. */
  isLastLevel?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLastStage` field. */
  isLastStage?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isSelfAssignable` field. */
  isSelfAssignable?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `level` relation. */
  level?: InputMaybe<TemplateStageReviewLevelFilter>;
  /** A related `level` exists. */
  levelExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `levelId` field. */
  levelId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewAssignmentFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewAssignmentFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** A related `organisation` exists. */
  organisationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** Filter by the object’s `reviewAssignmentAssignerJoins` relation. */
  reviewAssignmentAssignerJoins?: InputMaybe<ReviewAssignmentToManyReviewAssignmentAssignerJoinFilter>;
  /** Some related `reviewAssignmentAssignerJoins` exist. */
  reviewAssignmentAssignerJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** A related `review` exists. */
  reviewExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewer` relation. */
  reviewer?: InputMaybe<UserListFilter>;
  /** Filter by the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stage` relation. */
  stage?: InputMaybe<TemplateStageFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ReviewAssignmentStatusFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeStageCreated` field. */
  timeStageCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `ReviewAssignment` */
export type ReviewAssignmentInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** Input for the nested mutation of `templateStageReviewLevel` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentLevelIdFkeyInput = {
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateStageReviewLevelNodeIdConnect>;
  /** A `TemplateStageReviewLevelInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentLevelIdFkeyTemplateStageReviewLevelCreateInput>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateStageReviewLevelNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStageReviewLevel` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingTemplateStageReviewLevelPkeyUpdate>;
  /** The primary key(s) and patch data for `templateStageReviewLevel` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `TemplateStageReviewLevelInput` mutation. */
export type ReviewAssignmentLevelIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentLevelIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentLevelIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** The `templateStageReviewLevel` to be created by this mutation. */
export type ReviewAssignmentLevelIdFkeyTemplateStageReviewLevelCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  number: Scalars['Int']['input'];
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  singleReviewerAllSections?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewAssignmentNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewAssignmentNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0UsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0Patch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1UsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1Patch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStageReviewLevel` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
  patch: TemplateStageReviewLevelPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewAssignment` to look up the row to update. */
export type ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch;
};

/** Input for the nested mutation of `organisation` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `OrganisationInput` mutation. */
export type ReviewAssignmentOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** Represents an update to a `ReviewAssignment`. Fields that are set will be updated. */
export type ReviewAssignmentPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** The fields on `reviewAssignment` to look up the row to connect. */
export type ReviewAssignmentReviewAssignmentPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewAssignment` to look up the row to delete. */
export type ReviewAssignmentReviewAssignmentPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `templateStage` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentStageIdFkeyInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateStageTemplateStagePkeyConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateStageNodeIdConnect>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentStageIdFkeyTemplateStageCreateInput>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateStageTemplateStagePkeyDelete>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateStageNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `TemplateStageInput` mutation. */
export type ReviewAssignmentStageIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** The `templateStage` to be created by this mutation. */
export type ReviewAssignmentStageIdFkeyTemplateStageCreateInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export enum ReviewAssignmentStatus {
  Assigned = 'ASSIGNED',
  Available = 'AVAILABLE'
}

/** A filter to be used against ReviewAssignmentStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewAssignmentStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewAssignmentStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewAssignmentStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewAssignmentStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewAssignmentStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewAssignmentStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewAssignmentStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewAssignmentStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewAssignmentStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewAssignmentStatus>>;
};

/** Input for the nested mutation of `template` in the `ReviewAssignmentInput` mutation. */
export type ReviewAssignmentTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewAssignmentTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewAssignment` in the `TemplateInput` mutation. */
export type ReviewAssignmentTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyConnect>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdConnect>>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewAssignmentTemplateIdFkeyReviewAssignmentCreateInput>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewAssignmentReviewAssignmentPkeyDelete>>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewAssignmentNodeIdDelete>>;
  /** Flag indicating whether all other `reviewAssignment` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingReviewAssignmentPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate>>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewAssignmentTemplateIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** The `template` to be created by this mutation. */
export type ReviewAssignmentTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against many `ReviewAssignmentAssignerJoin` object types. All fields are combined with a logical ‘and.’ */
export type ReviewAssignmentToManyReviewAssignmentAssignerJoinFilter = {
  /** Every related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** No related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** Some related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
};

/** A connection to a list of `ReviewAssignment` values. */
export type ReviewAssignmentsConnection = {
  __typename?: 'ReviewAssignmentsConnection';
  /** A list of edges which contains the `ReviewAssignment` and cursor to aid in pagination. */
  edges: Array<ReviewAssignmentsEdge>;
  /** A list of `ReviewAssignment` objects. */
  nodes: Array<Maybe<ReviewAssignment>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewAssignment` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewAssignment` edge in the connection. */
export type ReviewAssignmentsEdge = {
  __typename?: 'ReviewAssignmentsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewAssignment` at the end of the edge. */
  node?: Maybe<ReviewAssignment>;
};

/** Methods to use when ordering `ReviewAssignment`. */
export enum ReviewAssignmentsOrderBy {
  AllowedSectionsAsc = 'ALLOWED_SECTIONS_ASC',
  AllowedSectionsDesc = 'ALLOWED_SECTIONS_DESC',
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  AssignedSectionsAsc = 'ASSIGNED_SECTIONS_ASC',
  AssignedSectionsDesc = 'ASSIGNED_SECTIONS_DESC',
  AssignerIdAsc = 'ASSIGNER_ID_ASC',
  AssignerIdDesc = 'ASSIGNER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsFinalDecisionAsc = 'IS_FINAL_DECISION_ASC',
  IsFinalDecisionDesc = 'IS_FINAL_DECISION_DESC',
  IsLastLevelAsc = 'IS_LAST_LEVEL_ASC',
  IsLastLevelDesc = 'IS_LAST_LEVEL_DESC',
  IsLastStageAsc = 'IS_LAST_STAGE_ASC',
  IsLastStageDesc = 'IS_LAST_STAGE_DESC',
  IsSelfAssignableAsc = 'IS_SELF_ASSIGNABLE_ASC',
  IsSelfAssignableDesc = 'IS_SELF_ASSIGNABLE_DESC',
  LevelIdAsc = 'LEVEL_ID_ASC',
  LevelIdDesc = 'LEVEL_ID_DESC',
  LevelNumberAsc = 'LEVEL_NUMBER_ASC',
  LevelNumberDesc = 'LEVEL_NUMBER_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewerIdAsc = 'REVIEWER_ID_ASC',
  ReviewerIdDesc = 'REVIEWER_ID_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TimeStageCreatedAsc = 'TIME_STAGE_CREATED_ASC',
  TimeStageCreatedDesc = 'TIME_STAGE_CREATED_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC'
}

/** A condition to be used against `Review` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type ReviewCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isFinalDecision` field. */
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLastLevel` field. */
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLastStage` field. */
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeStageCreated` field. */
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
};

export type ReviewDecision = Node & {
  __typename?: 'ReviewDecision';
  comment?: Maybe<Scalars['String']['output']>;
  decision?: Maybe<Decision>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  reviewId: Scalars['Int']['output'];
  timeUpdated?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `ReviewDecision` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ReviewDecisionCondition = {
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `decision` field. */
  decision?: InputMaybe<Decision>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ReviewDecision` object types. All fields are combined with a logical ‘and.’ */
export type ReviewDecisionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewDecisionFilter>>;
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `decision` field. */
  decision?: InputMaybe<DecisionFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewDecisionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewDecisionFilter>>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ReviewDecision` */
export type ReviewDecisionInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<Decision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewDecisionReviewIdFkeyInput>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewDecisionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewDecisionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewDecision` to look up the row to update. */
export type ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewDecision` being updated. */
  patch: UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
};

/** Represents an update to a `ReviewDecision`. Fields that are set will be updated. */
export type ReviewDecisionPatch = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<Decision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewDecisionReviewIdFkeyInput>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `reviewDecision` to look up the row to connect. */
export type ReviewDecisionReviewDecisionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewDecision` to look up the row to delete. */
export type ReviewDecisionReviewDecisionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `review` in the `ReviewDecisionInput` mutation. */
export type ReviewDecisionReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewDecisionReviewIdFkeyReviewCreateInput>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** Input for the nested mutation of `reviewDecision` in the `ReviewInput` mutation. */
export type ReviewDecisionReviewIdFkeyInverseInput = {
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewDecisionReviewDecisionPkeyConnect>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewDecisionNodeIdConnect>>;
  /** A `ReviewDecisionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewDecisionReviewIdFkeyReviewDecisionCreateInput>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewDecisionReviewDecisionPkeyDelete>>;
  /** The primary key(s) for `reviewDecision` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewDecisionNodeIdDelete>>;
  /** Flag indicating whether all other `reviewDecision` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewDecision` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewDecision` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewDecisionReviewIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** The `reviewDecision` to be created by this mutation. */
export type ReviewDecisionReviewIdFkeyReviewDecisionCreateInput = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<Decision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewDecisionReviewIdFkeyInput>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `ReviewDecision` values. */
export type ReviewDecisionsConnection = {
  __typename?: 'ReviewDecisionsConnection';
  /** A list of edges which contains the `ReviewDecision` and cursor to aid in pagination. */
  edges: Array<ReviewDecisionsEdge>;
  /** A list of `ReviewDecision` objects. */
  nodes: Array<Maybe<ReviewDecision>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewDecision` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewDecision` edge in the connection. */
export type ReviewDecisionsEdge = {
  __typename?: 'ReviewDecisionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewDecision` at the end of the edge. */
  node?: Maybe<ReviewDecision>;
};

/** Methods to use when ordering `ReviewDecision`. */
export enum ReviewDecisionsOrderBy {
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  DecisionAsc = 'DECISION_ASC',
  DecisionDesc = 'DECISION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC'
}

/** A filter to be used against `Review` object types. All fields are combined with a logical ‘and.’ */
export type ReviewFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isFinalDecision` field. */
  isFinalDecision?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLastLevel` field. */
  isLastLevel?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLastStage` field. */
  isLastStage?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLocked` field. */
  isLocked?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewFilter>;
  /** Filter by the object’s `notifications` relation. */
  notifications?: InputMaybe<ReviewToManyNotificationFilter>;
  /** Some related `notifications` exist. */
  notificationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewFilter>>;
  /** Filter by the object’s `reviewAssignment` relation. */
  reviewAssignment?: InputMaybe<ReviewAssignmentFilter>;
  /** A related `reviewAssignment` exists. */
  reviewAssignmentExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewAssignmentId` field. */
  reviewAssignmentId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewDecisions` relation. */
  reviewDecisions?: InputMaybe<ReviewToManyReviewDecisionFilter>;
  /** Some related `reviewDecisions` exist. */
  reviewDecisionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: InputMaybe<ReviewToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewStatusHistories` relation. */
  reviewStatusHistories?: InputMaybe<ReviewToManyReviewStatusHistoryFilter>;
  /** Some related `reviewStatusHistories` exist. */
  reviewStatusHistoriesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewer` relation. */
  reviewer?: InputMaybe<UserListFilter>;
  /** A related `reviewer` exists. */
  reviewerExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewerId` field. */
  reviewerId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ReviewStatusFilter>;
  /** Filter by the object’s `timeStageCreated` field. */
  timeStageCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeStatusCreated` field. */
  timeStatusCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `Review` */
export type ReviewInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** A connection to a list of `ReviewListRecord` values. */
export type ReviewListConnection = {
  __typename?: 'ReviewListConnection';
  /** A list of edges which contains the `ReviewListRecord` and cursor to aid in pagination. */
  edges: Array<ReviewListEdge>;
  /** A list of `ReviewListRecord` objects. */
  nodes: Array<Maybe<ReviewListRecord>>;
  /** The count of *all* `ReviewListRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewListRecord` edge in the connection. */
export type ReviewListEdge = {
  __typename?: 'ReviewListEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewListRecord` at the end of the edge. */
  node?: Maybe<ReviewListRecord>;
};

/** The return type of our `reviewList` query. */
export type ReviewListRecord = {
  __typename?: 'ReviewListRecord';
  applicationId?: Maybe<Scalars['Int']['output']>;
  reviewerAction?: Maybe<ReviewerAction>;
};

/** A filter to be used against `ReviewListRecord` object types. All fields are combined with a logical ‘and.’ */
export type ReviewListRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewListRecordFilter>>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewListRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewListRecordFilter>>;
  /** Filter by the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerActionFilter>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `review` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `notification` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `notification` being updated. */
  patch: NotificationPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewDecision` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewDecision` being updated. */
  patch: ReviewDecisionPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForFakePublicReviewForeignKey0Patch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForFakePublicReviewForeignKey0Patch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewApplicationIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
};

/** The fields on `review` to look up the row to update. */
export type ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate = {
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** Represents an update to a `Review`. Fields that are set will be updated. */
export type ReviewPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

export type ReviewResponse = Node & {
  __typename?: 'ReviewResponse';
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  applicationResponseId?: Maybe<Scalars['Int']['output']>;
  comment?: Maybe<Scalars['String']['output']>;
  decision?: Maybe<ReviewResponseDecision>;
  id: Scalars['Int']['output'];
  isLatestReview?: Maybe<Scalars['Boolean']['output']>;
  isLatestReviewSubmission?: Maybe<Scalars['Boolean']['output']>;
  isVisibleToApplicant?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  originalReviewResponseId?: Maybe<Scalars['Int']['output']>;
  recommendedApplicantVisibility?: Maybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  reviewId?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  reviewResponseLinkId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponsesByOriginalReviewResponseId: ReviewResponsesConnection;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponsesByReviewResponseLinkId: ReviewResponsesConnection;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<ReviewResponseStatus>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
  templateElementId?: Maybe<Scalars['Int']['output']>;
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
  timeSubmitted?: Maybe<Scalars['Datetime']['output']>;
  timeUpdated?: Maybe<Scalars['Datetime']['output']>;
};


export type ReviewResponseReviewResponsesByOriginalReviewResponseIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};


export type ReviewResponseReviewResponsesByReviewResponseLinkIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** The `applicationResponse` to be created by this mutation. */
export type ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** Input for the nested mutation of `applicationResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseApplicationResponseIdFkeyInput = {
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationResponseApplicationResponsePkeyConnect>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationResponseNodeIdConnect>;
  /** A `ApplicationResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationResponseApplicationResponsePkeyDelete>;
  /** The primary key(s) for `applicationResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `applicationResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `reviewResponse` in the `ApplicationResponseInput` mutation. */
export type ReviewResponseApplicationResponseIdFkeyInverseInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewResponseNodeIdConnect>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewResponseNodeIdDelete>>;
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate>>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput = {
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/**
 * A condition to be used against `ReviewResponse` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type ReviewResponseCondition = {
  /** Checks for equality with the object’s `applicationResponseId` field. */
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `comment` field. */
  comment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `decision` field. */
  decision?: InputMaybe<ReviewResponseDecision>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isLatestReview` field. */
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isLatestReviewSubmission` field. */
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `isVisibleToApplicant` field. */
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `originalReviewResponseId` field. */
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `recommendedApplicantVisibility` field. */
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `reviewResponseLinkId` field. */
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ReviewResponseStatus>;
  /** Checks for equality with the object’s `templateElementId` field. */
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeSubmitted` field. */
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

export enum ReviewResponseDecision {
  Agree = 'AGREE',
  Approve = 'APPROVE',
  Decline = 'DECLINE',
  Disagree = 'DISAGREE'
}

/** A filter to be used against ReviewResponseDecision fields. All fields are combined with a logical ‘and.’ */
export type ReviewResponseDecisionFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewResponseDecision>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewResponseDecision>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewResponseDecision>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewResponseDecision>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewResponseDecision>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewResponseDecision>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewResponseDecision>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewResponseDecision>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewResponseDecision>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewResponseDecision>>;
};

/** A filter to be used against `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewResponseFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewResponseFilter>>;
  /** Filter by the object’s `applicationResponse` relation. */
  applicationResponse?: InputMaybe<ApplicationResponseFilter>;
  /** A related `applicationResponse` exists. */
  applicationResponseExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationResponseId` field. */
  applicationResponseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `comment` field. */
  comment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `decision` field. */
  decision?: InputMaybe<ReviewResponseDecisionFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isLatestReview` field. */
  isLatestReview?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isLatestReviewSubmission` field. */
  isLatestReviewSubmission?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `isVisibleToApplicant` field. */
  isVisibleToApplicant?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewResponseFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewResponseFilter>>;
  /** Filter by the object’s `originalReviewResponse` relation. */
  originalReviewResponse?: InputMaybe<ReviewResponseFilter>;
  /** A related `originalReviewResponse` exists. */
  originalReviewResponseExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `originalReviewResponseId` field. */
  originalReviewResponseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `recommendedApplicantVisibility` field. */
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibilityFilter>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** A related `review` exists. */
  reviewExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewResponseLink` relation. */
  reviewResponseLink?: InputMaybe<ReviewResponseFilter>;
  /** A related `reviewResponseLink` exists. */
  reviewResponseLinkExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewResponseLinkId` field. */
  reviewResponseLinkId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewResponsesByOriginalReviewResponseId` relation. */
  reviewResponsesByOriginalReviewResponseId?: InputMaybe<ReviewResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponsesByOriginalReviewResponseId` exist. */
  reviewResponsesByOriginalReviewResponseIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewResponsesByReviewResponseLinkId` relation. */
  reviewResponsesByReviewResponseLinkId?: InputMaybe<ReviewResponseToManyReviewResponseFilter>;
  /** Some related `reviewResponsesByReviewResponseLinkId` exist. */
  reviewResponsesByReviewResponseLinkIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ReviewResponseStatusFilter>;
  /** Filter by the object’s `templateElement` relation. */
  templateElement?: InputMaybe<TemplateElementFilter>;
  /** A related `templateElement` exists. */
  templateElementExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateElementId` field. */
  templateElementId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeSubmitted` field. */
  timeSubmitted?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeUpdated` field. */
  timeUpdated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ReviewResponse` */
export type ReviewResponseInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewResponseNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewResponseNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `reviewResponse` to look up the row to update. */
export type ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseOriginalReviewResponseIdFkeyInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewResponseReviewResponsePkeyConnect>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewResponseNodeIdConnect>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewResponseReviewResponsePkeyDelete>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Represents an update to a `ReviewResponse`. Fields that are set will be updated. */
export type ReviewResponsePatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

export enum ReviewResponseRecommendedApplicantVisibility {
  OriginalResponseNotVisibleToApplicant = 'ORIGINAL_RESPONSE_NOT_VISIBLE_TO_APPLICANT',
  OriginalResponseVisibleToApplicant = 'ORIGINAL_RESPONSE_VISIBLE_TO_APPLICANT'
}

/** A filter to be used against ReviewResponseRecommendedApplicantVisibility fields. All fields are combined with a logical ‘and.’ */
export type ReviewResponseRecommendedApplicantVisibilityFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewResponseRecommendedApplicantVisibility>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewResponseRecommendedApplicantVisibility>>;
};

/** Input for the nested mutation of `review` in the `ReviewResponseInput` mutation. */
export type ReviewResponseReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseReviewIdFkeyReviewCreateInput>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewInput` mutation. */
export type ReviewResponseReviewIdFkeyInverseInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewResponseNodeIdConnect>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewResponseReviewIdFkeyReviewResponseCreateInput>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewResponseNodeIdDelete>>;
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewResponseReviewIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseReviewIdFkeyReviewResponseCreateInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `reviewResponse` in the `ReviewResponseInput` mutation. */
export type ReviewResponseReviewResponseLinkIdFkeyInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewResponseReviewResponsePkeyConnect>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewResponseNodeIdConnect>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewResponseReviewResponsePkeyDelete>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewResponseNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `reviewResponse` to look up the row to connect. */
export type ReviewResponseReviewResponsePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewResponse` to look up the row to delete. */
export type ReviewResponseReviewResponsePkeyDelete = {
  id: Scalars['Int']['input'];
};

export enum ReviewResponseStatus {
  Draft = 'DRAFT',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ReviewResponseStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewResponseStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewResponseStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewResponseStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewResponseStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewResponseStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewResponseStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewResponseStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewResponseStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewResponseStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewResponseStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewResponseStatus>>;
};

/** Input for the nested mutation of `templateElement` in the `ReviewResponseInput` mutation. */
export type ReviewResponseTemplateElementIdFkeyInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateElementTemplateElementPkeyConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateElementNodeIdConnect>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateElementTemplateElementPkeyDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateElementNodeIdDelete>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate>;
};

/** Input for the nested mutation of `reviewResponse` in the `TemplateElementInput` mutation. */
export type ReviewResponseTemplateElementIdFkeyInverseInput = {
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyConnect>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewResponseNodeIdConnect>>;
  /** A `ReviewResponseInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewResponseReviewResponsePkeyDelete>>;
  /** The primary key(s) for `reviewResponse` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewResponseNodeIdDelete>>;
  /** Flag indicating whether all other `reviewResponse` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewResponse` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate>>;
};

/** The `reviewResponse` to be created by this mutation. */
export type ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templateElement` to be created by this mutation. */
export type ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  reviewability?: InputMaybe<Reviewability>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode: Scalars['String']['input'];
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion: Scalars['String']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewResponseToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewResponseFilter>;
};

/** A connection to a list of `ReviewResponse` values. */
export type ReviewResponsesConnection = {
  __typename?: 'ReviewResponsesConnection';
  /** A list of edges which contains the `ReviewResponse` and cursor to aid in pagination. */
  edges: Array<ReviewResponsesEdge>;
  /** A list of `ReviewResponse` objects. */
  nodes: Array<Maybe<ReviewResponse>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewResponse` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewResponse` edge in the connection. */
export type ReviewResponsesEdge = {
  __typename?: 'ReviewResponsesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewResponse` at the end of the edge. */
  node?: Maybe<ReviewResponse>;
};

/** Methods to use when ordering `ReviewResponse`. */
export enum ReviewResponsesOrderBy {
  ApplicationResponseIdAsc = 'APPLICATION_RESPONSE_ID_ASC',
  ApplicationResponseIdDesc = 'APPLICATION_RESPONSE_ID_DESC',
  CommentAsc = 'COMMENT_ASC',
  CommentDesc = 'COMMENT_DESC',
  DecisionAsc = 'DECISION_ASC',
  DecisionDesc = 'DECISION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsLatestReviewAsc = 'IS_LATEST_REVIEW_ASC',
  IsLatestReviewDesc = 'IS_LATEST_REVIEW_DESC',
  IsLatestReviewSubmissionAsc = 'IS_LATEST_REVIEW_SUBMISSION_ASC',
  IsLatestReviewSubmissionDesc = 'IS_LATEST_REVIEW_SUBMISSION_DESC',
  IsVisibleToApplicantAsc = 'IS_VISIBLE_TO_APPLICANT_ASC',
  IsVisibleToApplicantDesc = 'IS_VISIBLE_TO_APPLICANT_DESC',
  Natural = 'NATURAL',
  OriginalReviewResponseIdAsc = 'ORIGINAL_REVIEW_RESPONSE_ID_ASC',
  OriginalReviewResponseIdDesc = 'ORIGINAL_REVIEW_RESPONSE_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecommendedApplicantVisibilityAsc = 'RECOMMENDED_APPLICANT_VISIBILITY_ASC',
  RecommendedApplicantVisibilityDesc = 'RECOMMENDED_APPLICANT_VISIBILITY_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  ReviewResponseLinkIdAsc = 'REVIEW_RESPONSE_LINK_ID_ASC',
  ReviewResponseLinkIdDesc = 'REVIEW_RESPONSE_LINK_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TemplateElementIdAsc = 'TEMPLATE_ELEMENT_ID_ASC',
  TemplateElementIdDesc = 'TEMPLATE_ELEMENT_ID_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  TimeSubmittedAsc = 'TIME_SUBMITTED_ASC',
  TimeSubmittedDesc = 'TIME_SUBMITTED_DESC',
  TimeUpdatedAsc = 'TIME_UPDATED_ASC',
  TimeUpdatedDesc = 'TIME_UPDATED_DESC'
}

/** Input for the nested mutation of `reviewAssignment` in the `ReviewInput` mutation. */
export type ReviewReviewAssignmentIdFkeyInput = {
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewAssignmentReviewAssignmentPkeyConnect>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewAssignmentNodeIdConnect>;
  /** A `ReviewAssignmentInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewAssignmentReviewAssignmentPkeyDelete>;
  /** The primary key(s) for `reviewAssignment` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewAssignmentNodeIdDelete>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate>;
  /** The primary key(s) and patch data for `reviewAssignment` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `review` in the `ReviewAssignmentInput` mutation. */
export type ReviewReviewAssignmentIdFkeyInverseInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewReviewAssignmentIdFkeyReviewCreateInput>>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** Flag indicating whether all other `review` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** The `reviewAssignment` to be created by this mutation. */
export type ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status: ReviewAssignmentStatus;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** The `review` to be created by this mutation. */
export type ReviewReviewAssignmentIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** The fields on `review` to look up the row to connect. */
export type ReviewReviewPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `review` to look up the row to delete. */
export type ReviewReviewPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `review` to look up the row to connect. */
export type ReviewReviewReviewAssignmentIdKeyConnect = {
  reviewAssignmentId: Scalars['Int']['input'];
};

/** The fields on `review` to look up the row to delete. */
export type ReviewReviewReviewAssignmentIdKeyDelete = {
  reviewAssignmentId: Scalars['Int']['input'];
};

export enum ReviewStatus {
  ChangesRequested = 'CHANGES_REQUESTED',
  Discontinued = 'DISCONTINUED',
  Draft = 'DRAFT',
  Pending = 'PENDING',
  Submitted = 'SUBMITTED'
}

/** A filter to be used against ReviewStatus fields. All fields are combined with a logical ‘and.’ */
export type ReviewStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewStatus>>;
};

/** A connection to a list of `ReviewStatusHistory` values. */
export type ReviewStatusHistoriesConnection = {
  __typename?: 'ReviewStatusHistoriesConnection';
  /** A list of edges which contains the `ReviewStatusHistory` and cursor to aid in pagination. */
  edges: Array<ReviewStatusHistoriesEdge>;
  /** A list of `ReviewStatusHistory` objects. */
  nodes: Array<Maybe<ReviewStatusHistory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `ReviewStatusHistory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `ReviewStatusHistory` edge in the connection. */
export type ReviewStatusHistoriesEdge = {
  __typename?: 'ReviewStatusHistoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewStatusHistory` at the end of the edge. */
  node?: Maybe<ReviewStatusHistory>;
};

/** Methods to use when ordering `ReviewStatusHistory`. */
export enum ReviewStatusHistoriesOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsCurrentAsc = 'IS_CURRENT_ASC',
  IsCurrentDesc = 'IS_CURRENT_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewIdAsc = 'REVIEW_ID_ASC',
  ReviewIdDesc = 'REVIEW_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC'
}

export type ReviewStatusHistory = Node & {
  __typename?: 'ReviewStatusHistory';
  id: Scalars['Int']['output'];
  isCurrent?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  reviewId: Scalars['Int']['output'];
  status?: Maybe<ReviewStatus>;
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
};

/**
 * A condition to be used against `ReviewStatusHistory` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type ReviewStatusHistoryCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `reviewId` field. */
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<ReviewStatus>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A filter to be used against `ReviewStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ReviewStatusHistoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewStatusHistoryFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isCurrent` field. */
  isCurrent?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewStatusHistoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewStatusHistoryFilter>>;
  /** Filter by the object’s `review` relation. */
  review?: InputMaybe<ReviewFilter>;
  /** Filter by the object’s `reviewId` field. */
  reviewId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<ReviewStatusFilter>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
};

/** An input for mutations affecting `ReviewStatusHistory` */
export type ReviewStatusHistoryInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInput>;
  status?: InputMaybe<ReviewStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type ReviewStatusHistoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type ReviewStatusHistoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `reviewStatusHistory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** The fields on `reviewStatusHistory` to look up the row to update. */
export type ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
  patch: UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
};

/** Represents an update to a `ReviewStatusHistory`. Fields that are set will be updated. */
export type ReviewStatusHistoryPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInput>;
  status?: InputMaybe<ReviewStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** Input for the nested mutation of `review` in the `ReviewStatusHistoryInput` mutation. */
export type ReviewStatusHistoryReviewIdFkeyInput = {
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectById?: InputMaybe<ReviewReviewPkeyConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ReviewNodeIdConnect>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  connectByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyConnect>;
  /** A `ReviewInput` object that will be created and connected to this object. */
  create?: InputMaybe<ReviewStatusHistoryReviewIdFkeyReviewCreateInput>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteById?: InputMaybe<ReviewReviewPkeyDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ReviewNodeIdDelete>;
  /** The primary key(s) for `review` for the far side of the relationship. */
  deleteByReviewAssignmentId?: InputMaybe<ReviewReviewReviewAssignmentIdKeyDelete>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateById?: InputMaybe<ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `review` for the far side of the relationship. */
  updateByReviewAssignmentId?: InputMaybe<ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate>;
};

/** Input for the nested mutation of `reviewStatusHistory` in the `ReviewInput` mutation. */
export type ReviewStatusHistoryReviewIdFkeyInverseInput = {
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  connectById?: InputMaybe<Array<ReviewStatusHistoryReviewStatusHistoryPkeyConnect>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<ReviewStatusHistoryNodeIdConnect>>;
  /** A `ReviewStatusHistoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<ReviewStatusHistoryReviewStatusHistoryPkeyDelete>>;
  /** The primary key(s) for `reviewStatusHistory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<ReviewStatusHistoryNodeIdDelete>>;
  /** Flag indicating whether all other `reviewStatusHistory` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `reviewStatusHistory` for the far side of the relationship. */
  updateById?: InputMaybe<Array<ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate>>;
  /** The primary key(s) and patch data for `reviewStatusHistory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate>>;
};

/** The `review` to be created by this mutation. */
export type ReviewStatusHistoryReviewIdFkeyReviewCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** The `reviewStatusHistory` to be created by this mutation. */
export type ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  reviewToReviewId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInput>;
  status?: InputMaybe<ReviewStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `reviewStatusHistory` to look up the row to connect. */
export type ReviewStatusHistoryReviewStatusHistoryPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `reviewStatusHistory` to look up the row to delete. */
export type ReviewStatusHistoryReviewStatusHistoryPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `Notification` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyNotificationFilter = {
  /** Every related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<NotificationFilter>;
  /** No related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<NotificationFilter>;
  /** Some related `Notification` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<NotificationFilter>;
};

/** A filter to be used against many `ReviewDecision` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewDecisionFilter = {
  /** Every related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewDecisionFilter>;
  /** No related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewDecisionFilter>;
  /** Some related `ReviewDecision` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewDecisionFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewResponseFilter>;
};

/** A filter to be used against many `ReviewStatusHistory` object types. All fields are combined with a logical ‘and.’ */
export type ReviewToManyReviewStatusHistoryFilter = {
  /** Every related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewStatusHistoryFilter>;
  /** No related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewStatusHistoryFilter>;
  /** Some related `ReviewStatusHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewStatusHistoryFilter>;
};

export enum Reviewability {
  Always = 'ALWAYS',
  Never = 'NEVER',
  OnlyIfApplicantAnswer = 'ONLY_IF_APPLICANT_ANSWER',
  OptionalIfNoResponse = 'OPTIONAL_IF_NO_RESPONSE'
}

/** A filter to be used against Reviewability fields. All fields are combined with a logical ‘and.’ */
export type ReviewabilityFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Reviewability>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Reviewability>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Reviewability>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Reviewability>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Reviewability>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Reviewability>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Reviewability>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Reviewability>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Reviewability>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Reviewability>>;
};

/** A `ReviewableQuestionsRecord` edge in the connection. */
export type ReviewableQuestionEdge = {
  __typename?: 'ReviewableQuestionEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `ReviewableQuestionsRecord` at the end of the edge. */
  node?: Maybe<ReviewableQuestionsRecord>;
};

/** A connection to a list of `ReviewableQuestionsRecord` values. */
export type ReviewableQuestionsConnection = {
  __typename?: 'ReviewableQuestionsConnection';
  /** A list of edges which contains the `ReviewableQuestionsRecord` and cursor to aid in pagination. */
  edges: Array<ReviewableQuestionEdge>;
  /** A list of `ReviewableQuestionsRecord` objects. */
  nodes: Array<Maybe<ReviewableQuestionsRecord>>;
  /** The count of *all* `ReviewableQuestionsRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** The return type of our `reviewableQuestions` query. */
export type ReviewableQuestionsRecord = {
  __typename?: 'ReviewableQuestionsRecord';
  code?: Maybe<Scalars['String']['output']>;
  isOptional?: Maybe<Scalars['Boolean']['output']>;
  responseId?: Maybe<Scalars['Int']['output']>;
  responseValue?: Maybe<Scalars['JSON']['output']>;
  reviewability?: Maybe<Reviewability>;
};

/** A filter to be used against `ReviewableQuestionsRecord` object types. All fields are combined with a logical ‘and.’ */
export type ReviewableQuestionsRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<ReviewableQuestionsRecordFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isOptional` field. */
  isOptional?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<ReviewableQuestionsRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<ReviewableQuestionsRecordFilter>>;
  /** Filter by the object’s `responseId` field. */
  responseId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `responseValue` field. */
  responseValue?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `reviewability` field. */
  reviewability?: InputMaybe<ReviewabilityFilter>;
};

export enum ReviewerAction {
  AwaitingResponse = 'AWAITING_RESPONSE',
  ContinueReview = 'CONTINUE_REVIEW',
  MakeDecision = 'MAKE_DECISION',
  RestartReview = 'RESTART_REVIEW',
  SelfAssign = 'SELF_ASSIGN',
  StartReview = 'START_REVIEW',
  UpdateReview = 'UPDATE_REVIEW',
  ViewReview = 'VIEW_REVIEW'
}

/** A filter to be used against ReviewerAction fields. All fields are combined with a logical ‘and.’ */
export type ReviewerActionFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<ReviewerAction>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<ReviewerAction>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<ReviewerAction>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<ReviewerAction>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<ReviewerAction>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<ReviewerAction>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<ReviewerAction>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<ReviewerAction>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<ReviewerAction>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<ReviewerAction>>;
};

/** A connection to a list of `Review` values. */
export type ReviewsConnection = {
  __typename?: 'ReviewsConnection';
  /** A list of edges which contains the `Review` and cursor to aid in pagination. */
  edges: Array<ReviewsEdge>;
  /** A list of `Review` objects. */
  nodes: Array<Maybe<Review>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Review` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Review` edge in the connection. */
export type ReviewsEdge = {
  __typename?: 'ReviewsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Review` at the end of the edge. */
  node?: Maybe<Review>;
};

/** Methods to use when ordering `Review`. */
export enum ReviewsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsFinalDecisionAsc = 'IS_FINAL_DECISION_ASC',
  IsFinalDecisionDesc = 'IS_FINAL_DECISION_DESC',
  IsLastLevelAsc = 'IS_LAST_LEVEL_ASC',
  IsLastLevelDesc = 'IS_LAST_LEVEL_DESC',
  IsLastStageAsc = 'IS_LAST_STAGE_ASC',
  IsLastStageDesc = 'IS_LAST_STAGE_DESC',
  LevelNumberAsc = 'LEVEL_NUMBER_ASC',
  LevelNumberDesc = 'LEVEL_NUMBER_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewerIdAsc = 'REVIEWER_ID_ASC',
  ReviewerIdDesc = 'REVIEWER_ID_DESC',
  ReviewAssignmentIdAsc = 'REVIEW_ASSIGNMENT_ID_ASC',
  ReviewAssignmentIdDesc = 'REVIEW_ASSIGNMENT_ID_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  TimeStageCreatedAsc = 'TIME_STAGE_CREATED_ASC',
  TimeStageCreatedDesc = 'TIME_STAGE_CREATED_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC'
}

export type SchemaColumn = {
  __typename?: 'SchemaColumn';
  columnName?: Maybe<Scalars['SqlIdentifier']['output']>;
  constraintType?: Maybe<Scalars['CharacterData']['output']>;
  dataType?: Maybe<Scalars['CharacterData']['output']>;
  fkToColumnName?: Maybe<Scalars['SqlIdentifier']['output']>;
  fkToTableName?: Maybe<Scalars['SqlIdentifier']['output']>;
  isGenerated?: Maybe<Scalars['CharacterData']['output']>;
  isNullable?: Maybe<Scalars['YesOrNo']['output']>;
  subDataType?: Maybe<Scalars['CharacterData']['output']>;
  tableName?: Maybe<Scalars['SqlIdentifier']['output']>;
  tableType?: Maybe<Scalars['CharacterData']['output']>;
};

/**
 * A condition to be used against `SchemaColumn` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type SchemaColumnCondition = {
  /** Checks for equality with the object’s `columnName` field. */
  columnName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `constraintType` field. */
  constraintType?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `dataType` field. */
  dataType?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `fkToColumnName` field. */
  fkToColumnName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `fkToTableName` field. */
  fkToTableName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `isGenerated` field. */
  isGenerated?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `isNullable` field. */
  isNullable?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Checks for equality with the object’s `subDataType` field. */
  subDataType?: InputMaybe<Scalars['CharacterData']['input']>;
  /** Checks for equality with the object’s `tableName` field. */
  tableName?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Checks for equality with the object’s `tableType` field. */
  tableType?: InputMaybe<Scalars['CharacterData']['input']>;
};

/** A filter to be used against `SchemaColumn` object types. All fields are combined with a logical ‘and.’ */
export type SchemaColumnFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SchemaColumnFilter>>;
  /** Filter by the object’s `columnName` field. */
  columnName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `constraintType` field. */
  constraintType?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `dataType` field. */
  dataType?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `fkToColumnName` field. */
  fkToColumnName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `fkToTableName` field. */
  fkToTableName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `isGenerated` field. */
  isGenerated?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `isNullable` field. */
  isNullable?: InputMaybe<YesOrNoFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SchemaColumnFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SchemaColumnFilter>>;
  /** Filter by the object’s `subDataType` field. */
  subDataType?: InputMaybe<CharacterDataFilter>;
  /** Filter by the object’s `tableName` field. */
  tableName?: InputMaybe<SqlIdentifierFilter>;
  /** Filter by the object’s `tableType` field. */
  tableType?: InputMaybe<CharacterDataFilter>;
};

/** A connection to a list of `SchemaColumn` values. */
export type SchemaColumnsConnection = {
  __typename?: 'SchemaColumnsConnection';
  /** A list of edges which contains the `SchemaColumn` and cursor to aid in pagination. */
  edges: Array<SchemaColumnsEdge>;
  /** A list of `SchemaColumn` objects. */
  nodes: Array<Maybe<SchemaColumn>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SchemaColumn` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SchemaColumn` edge in the connection. */
export type SchemaColumnsEdge = {
  __typename?: 'SchemaColumnsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SchemaColumn` at the end of the edge. */
  node?: Maybe<SchemaColumn>;
};

/** Methods to use when ordering `SchemaColumn`. */
export enum SchemaColumnsOrderBy {
  ColumnNameAsc = 'COLUMN_NAME_ASC',
  ColumnNameDesc = 'COLUMN_NAME_DESC',
  ConstraintTypeAsc = 'CONSTRAINT_TYPE_ASC',
  ConstraintTypeDesc = 'CONSTRAINT_TYPE_DESC',
  DataTypeAsc = 'DATA_TYPE_ASC',
  DataTypeDesc = 'DATA_TYPE_DESC',
  FkToColumnNameAsc = 'FK_TO_COLUMN_NAME_ASC',
  FkToColumnNameDesc = 'FK_TO_COLUMN_NAME_DESC',
  FkToTableNameAsc = 'FK_TO_TABLE_NAME_ASC',
  FkToTableNameDesc = 'FK_TO_TABLE_NAME_DESC',
  IsGeneratedAsc = 'IS_GENERATED_ASC',
  IsGeneratedDesc = 'IS_GENERATED_DESC',
  IsNullableAsc = 'IS_NULLABLE_ASC',
  IsNullableDesc = 'IS_NULLABLE_DESC',
  Natural = 'NATURAL',
  SubDataTypeAsc = 'SUB_DATA_TYPE_ASC',
  SubDataTypeDesc = 'SUB_DATA_TYPE_DESC',
  TableNameAsc = 'TABLE_NAME_ASC',
  TableNameDesc = 'TABLE_NAME_DESC',
  TableTypeAsc = 'TABLE_TYPE_ASC',
  TableTypeDesc = 'TABLE_TYPE_DESC'
}

/** A connection to a list of `SingleApplicationDetailRecord` values. */
export type SingleApplicationDetailConnection = {
  __typename?: 'SingleApplicationDetailConnection';
  /** A list of edges which contains the `SingleApplicationDetailRecord` and cursor to aid in pagination. */
  edges: Array<SingleApplicationDetailEdge>;
  /** A list of `SingleApplicationDetailRecord` objects. */
  nodes: Array<Maybe<SingleApplicationDetailRecord>>;
  /** The count of *all* `SingleApplicationDetailRecord` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SingleApplicationDetailRecord` edge in the connection. */
export type SingleApplicationDetailEdge = {
  __typename?: 'SingleApplicationDetailEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SingleApplicationDetailRecord` at the end of the edge. */
  node?: Maybe<SingleApplicationDetailRecord>;
};

/** The return type of our `singleApplicationDetail` query. */
export type SingleApplicationDetailRecord = {
  __typename?: 'SingleApplicationDetailRecord';
  assignerAction?: Maybe<AssignerAction>;
  assigners?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  reviewerAction?: Maybe<ReviewerAction>;
  reviewers?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
};

/** A filter to be used against `SingleApplicationDetailRecord` object types. All fields are combined with a logical ‘and.’ */
export type SingleApplicationDetailRecordFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SingleApplicationDetailRecordFilter>>;
  /** Filter by the object’s `assignerAction` field. */
  assignerAction?: InputMaybe<AssignerActionFilter>;
  /** Filter by the object’s `assigners` field. */
  assigners?: InputMaybe<StringListFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SingleApplicationDetailRecordFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SingleApplicationDetailRecordFilter>>;
  /** Filter by the object’s `reviewerAction` field. */
  reviewerAction?: InputMaybe<ReviewerActionFilter>;
  /** Filter by the object’s `reviewers` field. */
  reviewers?: InputMaybe<StringListFilter>;
};

/** A filter to be used against SqlIdentifier fields. All fields are combined with a logical ‘and.’ */
export type SqlIdentifierFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['SqlIdentifier']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['SqlIdentifier']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['SqlIdentifier']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['SqlIdentifier']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['SqlIdentifier']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['SqlIdentifier']['input']>;
};

/** A filter to be used against String fields. All fields are combined with a logical ‘and.’ */
export type StringFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['String']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['String']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['String']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['String']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['String']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['String']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['String']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['String']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['String']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['String']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against String List fields. All fields are combined with a logical ‘and.’ */
export type StringListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<Scalars['String']['input']>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
};

export type SystemInfo = Node & {
  __typename?: 'SystemInfo';
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  timestamp?: Maybe<Scalars['Datetime']['output']>;
  value?: Maybe<Scalars['JSON']['output']>;
};

/**
 * A condition to be used against `SystemInfo` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type SystemInfoCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `value` field. */
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `SystemInfo` object types. All fields are combined with a logical ‘and.’ */
export type SystemInfoFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<SystemInfoFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<SystemInfoFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<SystemInfoFilter>>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `value` field. */
  value?: InputMaybe<JsonFilter>;
};

/** An input for mutations affecting `SystemInfo` */
export type SystemInfoInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** Represents an update to a `SystemInfo`. Fields that are set will be updated. */
export type SystemInfoPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** A connection to a list of `SystemInfo` values. */
export type SystemInfosConnection = {
  __typename?: 'SystemInfosConnection';
  /** A list of edges which contains the `SystemInfo` and cursor to aid in pagination. */
  edges: Array<SystemInfosEdge>;
  /** A list of `SystemInfo` objects. */
  nodes: Array<Maybe<SystemInfo>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `SystemInfo` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `SystemInfo` edge in the connection. */
export type SystemInfosEdge = {
  __typename?: 'SystemInfosEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `SystemInfo` at the end of the edge. */
  node?: Maybe<SystemInfo>;
};

/** Methods to use when ordering `SystemInfo`. */
export enum SystemInfosOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  ValueAsc = 'VALUE_ASC',
  ValueDesc = 'VALUE_DESC'
}

export type Template = Node & {
  __typename?: 'Template';
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueues: ActionQueuesConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applications: ApplicationsConnection;
  canApplicantMakeChanges?: Maybe<Scalars['Boolean']['output']>;
  code: Scalars['String']['output'];
  dashboardRestrictions?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  /** Reads and enables pagination through a set of `File`. */
  files: FilesConnection;
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isLinear?: Maybe<Scalars['Boolean']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  namePlural?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parentVersionId?: Maybe<Scalars['String']['output']>;
  priority?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignments: ReviewAssignmentsConnection;
  serialPattern?: Maybe<Scalars['String']['output']>;
  startMessage?: Maybe<Scalars['JSON']['output']>;
  status?: Maybe<TemplateStatus>;
  submissionMessage?: Maybe<Scalars['JSON']['output']>;
  /** Reads and enables pagination through a set of `TemplateAction`. */
  templateActions: TemplateActionsConnection;
  /** Reads a single `TemplateCategory` that is related to this `Template`. */
  templateCategory?: Maybe<TemplateCategory>;
  templateCategoryId?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `TemplateFilterJoin`. */
  templateFilterJoins: TemplateFilterJoinsConnection;
  /** Reads and enables pagination through a set of `TemplatePermission`. */
  templatePermissions: TemplatePermissionsConnection;
  /** Reads and enables pagination through a set of `TemplateSection`. */
  templateSections: TemplateSectionsConnection;
  /** Reads and enables pagination through a set of `TemplateStage`. */
  templateStages: TemplateStagesConnection;
  /** Reads and enables pagination through a set of `TriggerSchedule`. */
  triggerSchedules: TriggerSchedulesConnection;
  versionComment?: Maybe<Scalars['String']['output']>;
  versionHistory?: Maybe<Scalars['JSON']['output']>;
  versionId: Scalars['String']['output'];
  versionTimestamp?: Maybe<Scalars['Datetime']['output']>;
};


export type TemplateActionQueuesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionQueueCondition>;
  filter?: InputMaybe<ActionQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};


export type TemplateApplicationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


export type TemplateFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<FileCondition>;
  filter?: InputMaybe<FileFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};


export type TemplateReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type TemplateTemplateActionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateActionCondition>;
  filter?: InputMaybe<TemplateActionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};


export type TemplateTemplateFilterJoinsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateFilterJoinCondition>;
  filter?: InputMaybe<TemplateFilterJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};


export type TemplateTemplatePermissionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplatePermissionCondition>;
  filter?: InputMaybe<TemplatePermissionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};


export type TemplateTemplateSectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateSectionCondition>;
  filter?: InputMaybe<TemplateSectionFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};


export type TemplateTemplateStagesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateStageCondition>;
  filter?: InputMaybe<TemplateStageFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};


export type TemplateTriggerSchedulesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TriggerScheduleCondition>;
  filter?: InputMaybe<TriggerScheduleFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};

export type TemplateAction = Node & {
  __typename?: 'TemplateAction';
  actionCode?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  condition?: Maybe<Scalars['JSON']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  eventCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parameterQueries?: Maybe<Scalars['JSON']['output']>;
  parametersQueriesString?: Maybe<Scalars['String']['output']>;
  sequence?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
  trigger?: Maybe<Trigger>;
};

/**
 * A condition to be used against `TemplateAction` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateActionCondition = {
  /** Checks for equality with the object’s `actionCode` field. */
  actionCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `condition` field. */
  condition?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `eventCode` field. */
  eventCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `parameterQueries` field. */
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `sequence` field. */
  sequence?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
};

/** A filter to be used against `TemplateAction` object types. All fields are combined with a logical ‘and.’ */
export type TemplateActionFilter = {
  /** Filter by the object’s `actionCode` field. */
  actionCode?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateActionFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `condition` field. */
  condition?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `eventCode` field. */
  eventCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateActionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateActionFilter>>;
  /** Filter by the object’s `parameterQueries` field. */
  parameterQueries?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parametersQueriesString` field. */
  parametersQueriesString?: InputMaybe<StringFilter>;
  /** Filter by the object’s `sequence` field. */
  sequence?: InputMaybe<IntFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `TemplateAction` */
export type TemplateActionInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateActionTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateActionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateAction` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateActionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateAction` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateAction` to look up the row to update. */
export type TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateAction` being updated. */
  patch: UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
};

/** Represents an update to a `TemplateAction`. Fields that are set will be updated. */
export type TemplateActionPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateActionTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
};

/** The fields on `templateAction` to look up the row to connect. */
export type TemplateActionTemplateActionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateAction` to look up the row to delete. */
export type TemplateActionTemplateActionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `template` in the `TemplateActionInput` mutation. */
export type TemplateActionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateActionTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateAction` in the `TemplateInput` mutation. */
export type TemplateActionTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateActionTemplateActionPkeyConnect>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateActionNodeIdConnect>>;
  /** A `TemplateActionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateActionTemplateIdFkeyTemplateActionCreateInput>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateActionTemplateActionPkeyDelete>>;
  /** The primary key(s) for `templateAction` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateActionNodeIdDelete>>;
  /** Flag indicating whether all other `templateAction` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateAction` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateAction` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate>>;
};

/** The `templateAction` to be created by this mutation. */
export type TemplateActionTemplateIdFkeyTemplateActionCreateInput = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateActionTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
};

/** The `template` to be created by this mutation. */
export type TemplateActionTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** A connection to a list of `TemplateAction` values. */
export type TemplateActionsConnection = {
  __typename?: 'TemplateActionsConnection';
  /** A list of edges which contains the `TemplateAction` and cursor to aid in pagination. */
  edges: Array<TemplateActionsEdge>;
  /** A list of `TemplateAction` objects. */
  nodes: Array<Maybe<TemplateAction>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateAction` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateAction` edge in the connection. */
export type TemplateActionsEdge = {
  __typename?: 'TemplateActionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateAction` at the end of the edge. */
  node?: Maybe<TemplateAction>;
};

/** Methods to use when ordering `TemplateAction`. */
export enum TemplateActionsOrderBy {
  ActionCodeAsc = 'ACTION_CODE_ASC',
  ActionCodeDesc = 'ACTION_CODE_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  ConditionAsc = 'CONDITION_ASC',
  ConditionDesc = 'CONDITION_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  EventCodeAsc = 'EVENT_CODE_ASC',
  EventCodeDesc = 'EVENT_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  ParameterQueriesAsc = 'PARAMETER_QUERIES_ASC',
  ParameterQueriesDesc = 'PARAMETER_QUERIES_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SequenceAsc = 'SEQUENCE_ASC',
  SequenceDesc = 'SEQUENCE_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC'
}

/** A connection to a list of `TemplateCategory` values. */
export type TemplateCategoriesConnection = {
  __typename?: 'TemplateCategoriesConnection';
  /** A list of edges which contains the `TemplateCategory` and cursor to aid in pagination. */
  edges: Array<TemplateCategoriesEdge>;
  /** A list of `TemplateCategory` objects. */
  nodes: Array<Maybe<TemplateCategory>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateCategory` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateCategory` edge in the connection. */
export type TemplateCategoriesEdge = {
  __typename?: 'TemplateCategoriesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateCategory` at the end of the edge. */
  node?: Maybe<TemplateCategory>;
};

/** Methods to use when ordering `TemplateCategory`. */
export enum TemplateCategoriesOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IconAsc = 'ICON_ASC',
  IconDesc = 'ICON_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsSubmenuAsc = 'IS_SUBMENU_ASC',
  IsSubmenuDesc = 'IS_SUBMENU_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PriorityAsc = 'PRIORITY_ASC',
  PriorityDesc = 'PRIORITY_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  UiLocationAsc = 'UI_LOCATION_ASC',
  UiLocationDesc = 'UI_LOCATION_DESC'
}

export type TemplateCategory = Node & {
  __typename?: 'TemplateCategory';
  code: Scalars['String']['output'];
  icon?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isSubmenu?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  priority?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `Template`. */
  templates: TemplatesConnection;
  title?: Maybe<Scalars['String']['output']>;
  uiLocation?: Maybe<Array<Maybe<UiLocation>>>;
};


export type TemplateCategoryTemplatesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateCondition>;
  filter?: InputMaybe<TemplateFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/**
 * A condition to be used against `TemplateCategory` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateCategoryCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `icon` field. */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isSubmenu` field. */
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `uiLocation` field. */
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** A filter to be used against `TemplateCategory` object types. All fields are combined with a logical ‘and.’ */
export type TemplateCategoryFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateCategoryFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `icon` field. */
  icon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isSubmenu` field. */
  isSubmenu?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateCategoryFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateCategoryFilter>>;
  /** Filter by the object’s `priority` field. */
  priority?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templates` relation. */
  templates?: InputMaybe<TemplateCategoryToManyTemplateFilter>;
  /** Some related `templates` exist. */
  templatesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `uiLocation` field. */
  uiLocation?: InputMaybe<UiLocationListFilter>;
};

/** An input for mutations affecting `TemplateCategory` */
export type TemplateCategoryInput = {
  code: Scalars['String']['input'];
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  templatesUsingId?: InputMaybe<TemplateTemplateCategoryIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateCategoryNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateCategory` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateCategoryNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateCategory` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateCategory` to look up the row to update. */
export type TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryCodeKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateCategory` being updated. */
  patch: UpdateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
};

/** The fields on `templateCategory` to look up the row to update. */
export type TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateCategory` being updated. */
  patch: UpdateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
};

/** Represents an update to a `TemplateCategory`. Fields that are set will be updated. */
export type TemplateCategoryPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  templatesUsingId?: InputMaybe<TemplateTemplateCategoryIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** The fields on `templateCategory` to look up the row to connect. */
export type TemplateCategoryTemplateCategoryCodeKeyConnect = {
  code: Scalars['String']['input'];
};

/** The fields on `templateCategory` to look up the row to delete. */
export type TemplateCategoryTemplateCategoryCodeKeyDelete = {
  code: Scalars['String']['input'];
};

/** The fields on `templateCategory` to look up the row to connect. */
export type TemplateCategoryTemplateCategoryPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateCategory` to look up the row to delete. */
export type TemplateCategoryTemplateCategoryPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `Template` object types. All fields are combined with a logical ‘and.’ */
export type TemplateCategoryToManyTemplateFilter = {
  /** Every related `Template` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateFilter>;
  /** No related `Template` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateFilter>;
  /** Some related `Template` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateFilter>;
};

/**
 * A condition to be used against `Template` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type TemplateCondition = {
  /** Checks for equality with the object’s `canApplicantMakeChanges` field. */
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dashboardRestrictions` field. */
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `icon` field. */
  icon?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isLinear` field. */
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `namePlural` field. */
  namePlural?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `parentVersionId` field. */
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `priority` field. */
  priority?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `serialPattern` field. */
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `startMessage` field. */
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<TemplateStatus>;
  /** Checks for equality with the object’s `submissionMessage` field. */
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `templateCategoryId` field. */
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `versionComment` field. */
  versionComment?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `versionHistory` field. */
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `versionId` field. */
  versionId?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `versionTimestamp` field. */
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

export type TemplateElement = Node & {
  __typename?: 'TemplateElement';
  /** Reads and enables pagination through a set of `ApplicationResponse`. */
  applicationResponses: ApplicationResponsesConnection;
  category?: Maybe<TemplateElementCategory>;
  code: Scalars['String']['output'];
  elementTypePluginCode?: Maybe<Scalars['String']['output']>;
  helpText?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  index?: Maybe<Scalars['Int']['output']>;
  initialValue?: Maybe<Scalars['JSON']['output']>;
  isEditable?: Maybe<Scalars['JSON']['output']>;
  isRequired?: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  parameters?: Maybe<Scalars['JSON']['output']>;
  parametersString?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `ReviewResponse`. */
  reviewResponses: ReviewResponsesConnection;
  reviewability: Reviewability;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  sectionId: Scalars['Int']['output'];
  templateCode: Scalars['String']['output'];
  templateVersion: Scalars['String']['output'];
  title?: Maybe<Scalars['String']['output']>;
  validation?: Maybe<Scalars['JSON']['output']>;
  validationMessage?: Maybe<Scalars['String']['output']>;
  visibilityCondition?: Maybe<Scalars['JSON']['output']>;
};


export type TemplateElementApplicationResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationResponseCondition>;
  filter?: InputMaybe<ApplicationResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};


export type TemplateElementReviewResponsesArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewResponseCondition>;
  filter?: InputMaybe<ReviewResponseFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

export enum TemplateElementCategory {
  Information = 'INFORMATION',
  Question = 'QUESTION'
}

/** A filter to be used against TemplateElementCategory fields. All fields are combined with a logical ‘and.’ */
export type TemplateElementCategoryFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TemplateElementCategory>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TemplateElementCategory>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TemplateElementCategory>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TemplateElementCategory>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TemplateElementCategory>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TemplateElementCategory>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TemplateElementCategory>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TemplateElementCategory>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TemplateElementCategory>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TemplateElementCategory>>;
};

/**
 * A condition to be used against `TemplateElement` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateElementCondition = {
  /** Checks for equality with the object’s `category` field. */
  category?: InputMaybe<TemplateElementCategory>;
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `helpText` field. */
  helpText?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `index` field. */
  index?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `initialValue` field. */
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `isEditable` field. */
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `isRequired` field. */
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `parameters` field. */
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `reviewability` field. */
  reviewability?: InputMaybe<Reviewability>;
  /** Checks for equality with the object’s `sectionId` field. */
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateCode` field. */
  templateCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `templateVersion` field. */
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `validation` field. */
  validation?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `validationMessage` field. */
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `visibilityCondition` field. */
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** A filter to be used against `TemplateElement` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateElementFilter>>;
  /** Filter by the object’s `applicationResponses` relation. */
  applicationResponses?: InputMaybe<TemplateElementToManyApplicationResponseFilter>;
  /** Some related `applicationResponses` exist. */
  applicationResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `category` field. */
  category?: InputMaybe<TemplateElementCategoryFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `elementTypePluginCode` field. */
  elementTypePluginCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `helpText` field. */
  helpText?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `index` field. */
  index?: InputMaybe<IntFilter>;
  /** Filter by the object’s `initialValue` field. */
  initialValue?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `isEditable` field. */
  isEditable?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `isRequired` field. */
  isRequired?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateElementFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateElementFilter>>;
  /** Filter by the object’s `parameters` field. */
  parameters?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `parametersString` field. */
  parametersString?: InputMaybe<StringFilter>;
  /** Filter by the object’s `reviewResponses` relation. */
  reviewResponses?: InputMaybe<TemplateElementToManyReviewResponseFilter>;
  /** Some related `reviewResponses` exist. */
  reviewResponsesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewability` field. */
  reviewability?: InputMaybe<ReviewabilityFilter>;
  /** Filter by the object’s `section` relation. */
  section?: InputMaybe<TemplateSectionFilter>;
  /** Filter by the object’s `sectionId` field. */
  sectionId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateCode` field. */
  templateCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `templateVersion` field. */
  templateVersion?: InputMaybe<StringFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
  /** Filter by the object’s `validation` field. */
  validation?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `validationMessage` field. */
  validationMessage?: InputMaybe<StringFilter>;
  /** Filter by the object’s `visibilityCondition` field. */
  visibilityCondition?: InputMaybe<JsonFilter>;
};

/** An input for mutations affecting `TemplateElement` */
export type TemplateElementInput = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  reviewability?: InputMaybe<Reviewability>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode: Scalars['String']['input'];
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion: Scalars['String']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateElementNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateElementNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateElement` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewResponse` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
};

/** The fields on `templateElement` to look up the row to update. */
export type TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** Represents an update to a `TemplateElement`. Fields that are set will be updated. */
export type TemplateElementPatch = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  reviewability?: InputMaybe<Reviewability>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** Input for the nested mutation of `templateSection` in the `TemplateElementInput` mutation. */
export type TemplateElementSectionIdFkeyInput = {
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateSectionTemplateSectionPkeyConnect>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateSectionNodeIdConnect>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByTemplateIdAndCode?: InputMaybe<TemplateSectionTemplateSectionTemplateIdCodeKeyConnect>;
  /** A `TemplateSectionInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateElementSectionIdFkeyTemplateSectionCreateInput>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateSectionTemplateSectionPkeyDelete>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateSectionNodeIdDelete>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByTemplateIdAndCode?: InputMaybe<TemplateSectionTemplateSectionTemplateIdCodeKeyDelete>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByTemplateIdAndCode?: InputMaybe<TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate>;
};

/** Input for the nested mutation of `templateElement` in the `TemplateSectionInput` mutation. */
export type TemplateElementSectionIdFkeyInverseInput = {
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateElementTemplateElementPkeyConnect>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateElementNodeIdConnect>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  connectByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<Array<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect>>;
  /** A `TemplateElementInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateElementSectionIdFkeyTemplateElementCreateInput>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateElementTemplateElementPkeyDelete>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateElementNodeIdDelete>>;
  /** The primary key(s) for `templateElement` for the far side of the relationship. */
  deleteByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<Array<TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete>>;
  /** Flag indicating whether all other `templateElement` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `templateElement` for the far side of the relationship. */
  updateByTemplateCodeAndCodeAndTemplateVersion?: InputMaybe<Array<TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate>>;
};

/** The `templateElement` to be created by this mutation. */
export type TemplateElementSectionIdFkeyTemplateElementCreateInput = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code: Scalars['String']['input'];
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  reviewability?: InputMaybe<Reviewability>;
  templateCode: Scalars['String']['input'];
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion: Scalars['String']['input'];
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** The `templateSection` to be created by this mutation. */
export type TemplateElementSectionIdFkeyTemplateSectionCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `templateElement` to look up the row to connect. */
export type TemplateElementTemplateElementPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateElement` to look up the row to delete. */
export type TemplateElementTemplateElementPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateElement` to look up the row to connect. */
export type TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect = {
  code: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** The fields on `templateElement` to look up the row to delete. */
export type TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete = {
  code: Scalars['String']['input'];
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** A filter to be used against many `ApplicationResponse` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementToManyApplicationResponseFilter = {
  /** Every related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationResponseFilter>;
  /** No related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationResponseFilter>;
  /** Some related `ApplicationResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationResponseFilter>;
};

/** A filter to be used against many `ReviewResponse` object types. All fields are combined with a logical ‘and.’ */
export type TemplateElementToManyReviewResponseFilter = {
  /** Every related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewResponseFilter>;
  /** No related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewResponseFilter>;
  /** Some related `ReviewResponse` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewResponseFilter>;
};

/** A connection to a list of `TemplateElement` values. */
export type TemplateElementsConnection = {
  __typename?: 'TemplateElementsConnection';
  /** A list of edges which contains the `TemplateElement` and cursor to aid in pagination. */
  edges: Array<TemplateElementsEdge>;
  /** A list of `TemplateElement` objects. */
  nodes: Array<Maybe<TemplateElement>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateElement` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateElement` edge in the connection. */
export type TemplateElementsEdge = {
  __typename?: 'TemplateElementsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateElement` at the end of the edge. */
  node?: Maybe<TemplateElement>;
};

/** Methods to use when ordering `TemplateElement`. */
export enum TemplateElementsOrderBy {
  CategoryAsc = 'CATEGORY_ASC',
  CategoryDesc = 'CATEGORY_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  ElementTypePluginCodeAsc = 'ELEMENT_TYPE_PLUGIN_CODE_ASC',
  ElementTypePluginCodeDesc = 'ELEMENT_TYPE_PLUGIN_CODE_DESC',
  HelpTextAsc = 'HELP_TEXT_ASC',
  HelpTextDesc = 'HELP_TEXT_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IndexAsc = 'INDEX_ASC',
  IndexDesc = 'INDEX_DESC',
  InitialValueAsc = 'INITIAL_VALUE_ASC',
  InitialValueDesc = 'INITIAL_VALUE_DESC',
  IsEditableAsc = 'IS_EDITABLE_ASC',
  IsEditableDesc = 'IS_EDITABLE_DESC',
  IsRequiredAsc = 'IS_REQUIRED_ASC',
  IsRequiredDesc = 'IS_REQUIRED_DESC',
  Natural = 'NATURAL',
  ParametersAsc = 'PARAMETERS_ASC',
  ParametersDesc = 'PARAMETERS_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  ReviewabilityAsc = 'REVIEWABILITY_ASC',
  ReviewabilityDesc = 'REVIEWABILITY_DESC',
  SectionIdAsc = 'SECTION_ID_ASC',
  SectionIdDesc = 'SECTION_ID_DESC',
  TemplateCodeAsc = 'TEMPLATE_CODE_ASC',
  TemplateCodeDesc = 'TEMPLATE_CODE_DESC',
  TemplateVersionAsc = 'TEMPLATE_VERSION_ASC',
  TemplateVersionDesc = 'TEMPLATE_VERSION_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC',
  ValidationAsc = 'VALIDATION_ASC',
  ValidationDesc = 'VALIDATION_DESC',
  ValidationMessageAsc = 'VALIDATION_MESSAGE_ASC',
  ValidationMessageDesc = 'VALIDATION_MESSAGE_DESC',
  VisibilityConditionAsc = 'VISIBILITY_CONDITION_ASC',
  VisibilityConditionDesc = 'VISIBILITY_CONDITION_DESC'
}

/** A filter to be used against `Template` object types. All fields are combined with a logical ‘and.’ */
export type TemplateFilter = {
  /** Filter by the object’s `actionQueues` relation. */
  actionQueues?: InputMaybe<TemplateToManyActionQueueFilter>;
  /** Some related `actionQueues` exist. */
  actionQueuesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateFilter>>;
  /** Filter by the object’s `applications` relation. */
  applications?: InputMaybe<TemplateToManyApplicationFilter>;
  /** Some related `applications` exist. */
  applicationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `canApplicantMakeChanges` field. */
  canApplicantMakeChanges?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dashboardRestrictions` field. */
  dashboardRestrictions?: InputMaybe<StringListFilter>;
  /** Filter by the object’s `files` relation. */
  files?: InputMaybe<TemplateToManyFileFilter>;
  /** Some related `files` exist. */
  filesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `icon` field. */
  icon?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isLinear` field. */
  isLinear?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Filter by the object’s `namePlural` field. */
  namePlural?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateFilter>>;
  /** Filter by the object’s `parentVersionId` field. */
  parentVersionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `priority` field. */
  priority?: InputMaybe<IntFilter>;
  /** Filter by the object’s `reviewAssignments` relation. */
  reviewAssignments?: InputMaybe<TemplateToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignments` exist. */
  reviewAssignmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `serialPattern` field. */
  serialPattern?: InputMaybe<StringFilter>;
  /** Filter by the object’s `startMessage` field. */
  startMessage?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<TemplateStatusFilter>;
  /** Filter by the object’s `submissionMessage` field. */
  submissionMessage?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `templateActions` relation. */
  templateActions?: InputMaybe<TemplateToManyTemplateActionFilter>;
  /** Some related `templateActions` exist. */
  templateActionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateCategory` relation. */
  templateCategory?: InputMaybe<TemplateCategoryFilter>;
  /** A related `templateCategory` exists. */
  templateCategoryExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateCategoryId` field. */
  templateCategoryId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateFilterJoins` relation. */
  templateFilterJoins?: InputMaybe<TemplateToManyTemplateFilterJoinFilter>;
  /** Some related `templateFilterJoins` exist. */
  templateFilterJoinsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templatePermissions` relation. */
  templatePermissions?: InputMaybe<TemplateToManyTemplatePermissionFilter>;
  /** Some related `templatePermissions` exist. */
  templatePermissionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateSections` relation. */
  templateSections?: InputMaybe<TemplateToManyTemplateSectionFilter>;
  /** Some related `templateSections` exist. */
  templateSectionsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateStages` relation. */
  templateStages?: InputMaybe<TemplateToManyTemplateStageFilter>;
  /** Some related `templateStages` exist. */
  templateStagesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `triggerSchedules` relation. */
  triggerSchedules?: InputMaybe<TemplateToManyTriggerScheduleFilter>;
  /** Some related `triggerSchedules` exist. */
  triggerSchedulesExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `versionComment` field. */
  versionComment?: InputMaybe<StringFilter>;
  /** Filter by the object’s `versionHistory` field. */
  versionHistory?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `versionId` field. */
  versionId?: InputMaybe<StringFilter>;
  /** Filter by the object’s `versionTimestamp` field. */
  versionTimestamp?: InputMaybe<DatetimeFilter>;
};

export type TemplateFilterJoin = Node & {
  __typename?: 'TemplateFilterJoin';
  /** Reads a single `Filter` that is related to this `TemplateFilterJoin`. */
  filter?: Maybe<Filter>;
  filterId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Template` that is related to this `TemplateFilterJoin`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
};

/**
 * A condition to be used against `TemplateFilterJoin` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateFilterJoinCondition = {
  /** Checks for equality with the object’s `filterId` field. */
  filterId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `TemplateFilterJoin` object types. All fields are combined with a logical ‘and.’ */
export type TemplateFilterJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateFilterJoinFilter>>;
  /** Filter by the object’s `filter` relation. */
  filter?: InputMaybe<FilterFilter>;
  /** Filter by the object’s `filterId` field. */
  filterId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateFilterJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateFilterJoinFilter>>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
};

/** The `filter` to be created by this mutation. */
export type TemplateFilterJoinFilterIdFkeyFilterCreateInput = {
  code: Scalars['String']['input'];
  id?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['JSON']['input']>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** Input for the nested mutation of `filter` in the `TemplateFilterJoinInput` mutation. */
export type TemplateFilterJoinFilterIdFkeyInput = {
  /** The primary key(s) for `filter` for the far side of the relationship. */
  connectByCode?: InputMaybe<FilterFilterCodeKeyConnect>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  connectById?: InputMaybe<FilterFilterPkeyConnect>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<FilterNodeIdConnect>;
  /** A `FilterInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateFilterJoinFilterIdFkeyFilterCreateInput>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  deleteByCode?: InputMaybe<FilterFilterCodeKeyDelete>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  deleteById?: InputMaybe<FilterFilterPkeyDelete>;
  /** The primary key(s) for `filter` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<FilterNodeIdDelete>;
  /** The primary key(s) and patch data for `filter` for the far side of the relationship. */
  updateByCode?: InputMaybe<FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterCodeKeyUpdate>;
  /** The primary key(s) and patch data for `filter` for the far side of the relationship. */
  updateById?: InputMaybe<FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterPkeyUpdate>;
  /** The primary key(s) and patch data for `filter` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateFilterJoin` in the `FilterInput` mutation. */
export type TemplateFilterJoinFilterIdFkeyInverseInput = {
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateFilterJoinTemplateFilterJoinPkeyConnect>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateFilterJoinNodeIdConnect>>;
  /** A `TemplateFilterJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateFilterJoinFilterIdFkeyTemplateFilterJoinCreateInput>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateFilterJoinTemplateFilterJoinPkeyDelete>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateFilterJoinNodeIdDelete>>;
  /** Flag indicating whether all other `templateFilterJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateFilterJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingTemplateFilterJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateFilterJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate>>;
};

/** The `templateFilterJoin` to be created by this mutation. */
export type TemplateFilterJoinFilterIdFkeyTemplateFilterJoinCreateInput = {
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** An input for mutations affecting `TemplateFilterJoin` */
export type TemplateFilterJoinInput = {
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateFilterJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateFilterJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateFilterJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateFilterJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `filter` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `filter` being updated. */
  patch: FilterPatch;
};

/** The fields on `templateFilterJoin` to look up the row to update. */
export type TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingTemplateFilterJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
  patch: UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateFilterJoin` to look up the row to update. */
export type TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateFilterJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
  patch: UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
};

/** Represents an update to a `TemplateFilterJoin`. Fields that are set will be updated. */
export type TemplateFilterJoinPatch = {
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** The fields on `templateFilterJoin` to look up the row to connect. */
export type TemplateFilterJoinTemplateFilterJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateFilterJoin` to look up the row to delete. */
export type TemplateFilterJoinTemplateFilterJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** Input for the nested mutation of `template` in the `TemplateFilterJoinInput` mutation. */
export type TemplateFilterJoinTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateFilterJoinTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateFilterJoin` in the `TemplateInput` mutation. */
export type TemplateFilterJoinTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateFilterJoinTemplateFilterJoinPkeyConnect>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateFilterJoinNodeIdConnect>>;
  /** A `TemplateFilterJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateFilterJoinTemplateIdFkeyTemplateFilterJoinCreateInput>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateFilterJoinTemplateFilterJoinPkeyDelete>>;
  /** The primary key(s) for `templateFilterJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateFilterJoinNodeIdDelete>>;
  /** Flag indicating whether all other `templateFilterJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateFilterJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateFilterJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateFilterJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TemplateFilterJoinTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templateFilterJoin` to be created by this mutation. */
export type TemplateFilterJoinTemplateIdFkeyTemplateFilterJoinCreateInput = {
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** A connection to a list of `TemplateFilterJoin` values. */
export type TemplateFilterJoinsConnection = {
  __typename?: 'TemplateFilterJoinsConnection';
  /** A list of edges which contains the `TemplateFilterJoin` and cursor to aid in pagination. */
  edges: Array<TemplateFilterJoinsEdge>;
  /** A list of `TemplateFilterJoin` objects. */
  nodes: Array<Maybe<TemplateFilterJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateFilterJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateFilterJoin` edge in the connection. */
export type TemplateFilterJoinsEdge = {
  __typename?: 'TemplateFilterJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateFilterJoin` at the end of the edge. */
  node?: Maybe<TemplateFilterJoin>;
};

/** Methods to use when ordering `TemplateFilterJoin`. */
export enum TemplateFilterJoinsOrderBy {
  FilterIdAsc = 'FILTER_ID_ASC',
  FilterIdDesc = 'FILTER_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC'
}

/** An input for mutations affecting `Template` */
export type TemplateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `template` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnFileForFileTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `file` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `file` being updated. */
  patch: FilePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnFileForFileTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnFileForFileTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnFileForFileTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnFileForFileTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateAction` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateAction` being updated. */
  patch: TemplateActionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateFilterJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
  patch: TemplateFilterJoinPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateCategory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateCategory` being updated. */
  patch: TemplateCategoryPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to update. */
export type TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplatePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: UpdateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
};

/** Represents an update to a `Template`. Fields that are set will be updated. */
export type TemplatePatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

export type TemplatePermission = Node & {
  __typename?: 'TemplatePermission';
  allowedSections?: Maybe<Array<Maybe<Scalars['String']['output']>>>;
  canMakeFinalDecision: Scalars['Boolean']['output'];
  canSelfAssign: Scalars['Boolean']['output'];
  id: Scalars['Int']['output'];
  levelNumber?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  permissionNameId?: Maybe<Scalars['Int']['output']>;
  restrictions?: Maybe<Scalars['JSON']['output']>;
  stageNumber?: Maybe<Scalars['Int']['output']>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
};

/**
 * A condition to be used against `TemplatePermission` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplatePermissionCondition = {
  /** Checks for equality with the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  /** Checks for equality with the object’s `canMakeFinalDecision` field. */
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `canSelfAssign` field. */
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `restrictions` field. */
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type TemplatePermissionFilter = {
  /** Filter by the object’s `allowedSections` field. */
  allowedSections?: InputMaybe<StringListFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplatePermissionFilter>>;
  /** Filter by the object’s `canMakeFinalDecision` field. */
  canMakeFinalDecision?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `canSelfAssign` field. */
  canSelfAssign?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `levelNumber` field. */
  levelNumber?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplatePermissionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplatePermissionFilter>>;
  /** Filter by the object’s `permissionName` relation. */
  permissionName?: InputMaybe<PermissionNameFilter>;
  /** A related `permissionName` exists. */
  permissionNameExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `permissionNameId` field. */
  permissionNameId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `restrictions` field. */
  restrictions?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `stageNumber` field. */
  stageNumber?: InputMaybe<IntFilter>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `TemplatePermission` */
export type TemplatePermissionInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplatePermissionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplatePermissionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templatePermission` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionName` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The fields on `templatePermission` to look up the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templatePermission` to look up the row to update. */
export type TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templatePermission` being updated. */
  patch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
};

/** Represents an update to a `TemplatePermission`. Fields that are set will be updated. */
export type TemplatePermissionPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** Input for the nested mutation of `permissionName` in the `TemplatePermissionInput` mutation. */
export type TemplatePermissionPermissionNameIdFkeyInput = {
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectById?: InputMaybe<PermissionNamePermissionNamePkeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByName?: InputMaybe<PermissionNamePermissionNameNameKeyConnect>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<PermissionNameNodeIdConnect>;
  /** A `PermissionNameInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteById?: InputMaybe<PermissionNamePermissionNamePkeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByName?: InputMaybe<PermissionNamePermissionNameNameKeyDelete>;
  /** The primary key(s) for `permissionName` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<PermissionNameNodeIdDelete>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateById?: InputMaybe<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByName?: InputMaybe<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate>;
  /** The primary key(s) and patch data for `permissionName` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templatePermission` in the `PermissionNameInput` mutation. */
export type TemplatePermissionPermissionNameIdFkeyInverseInput = {
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplatePermissionTemplatePermissionPkeyConnect>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplatePermissionNodeIdConnect>>;
  /** A `TemplatePermissionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplatePermissionTemplatePermissionPkeyDelete>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplatePermissionNodeIdDelete>>;
  /** Flag indicating whether all other `templatePermission` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate>>;
};

/** The `permissionName` to be created by this mutation. */
export type TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** The `templatePermission` to be created by this mutation. */
export type TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** Input for the nested mutation of `template` in the `TemplatePermissionInput` mutation. */
export type TemplatePermissionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplatePermissionTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templatePermission` in the `TemplateInput` mutation. */
export type TemplatePermissionTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplatePermissionTemplatePermissionPkeyConnect>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplatePermissionNodeIdConnect>>;
  /** A `TemplatePermissionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplatePermissionTemplatePermissionPkeyDelete>>;
  /** The primary key(s) for `templatePermission` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplatePermissionNodeIdDelete>>;
  /** Flag indicating whether all other `templatePermission` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templatePermission` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TemplatePermissionTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templatePermission` to be created by this mutation. */
export type TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** The fields on `templatePermission` to look up the row to connect. */
export type TemplatePermissionTemplatePermissionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templatePermission` to look up the row to delete. */
export type TemplatePermissionTemplatePermissionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `TemplatePermission` values. */
export type TemplatePermissionsConnection = {
  __typename?: 'TemplatePermissionsConnection';
  /** A list of edges which contains the `TemplatePermission` and cursor to aid in pagination. */
  edges: Array<TemplatePermissionsEdge>;
  /** A list of `TemplatePermission` objects. */
  nodes: Array<Maybe<TemplatePermission>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplatePermission` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplatePermission` edge in the connection. */
export type TemplatePermissionsEdge = {
  __typename?: 'TemplatePermissionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplatePermission` at the end of the edge. */
  node?: Maybe<TemplatePermission>;
};

/** Methods to use when ordering `TemplatePermission`. */
export enum TemplatePermissionsOrderBy {
  AllowedSectionsAsc = 'ALLOWED_SECTIONS_ASC',
  AllowedSectionsDesc = 'ALLOWED_SECTIONS_DESC',
  CanMakeFinalDecisionAsc = 'CAN_MAKE_FINAL_DECISION_ASC',
  CanMakeFinalDecisionDesc = 'CAN_MAKE_FINAL_DECISION_DESC',
  CanSelfAssignAsc = 'CAN_SELF_ASSIGN_ASC',
  CanSelfAssignDesc = 'CAN_SELF_ASSIGN_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LevelNumberAsc = 'LEVEL_NUMBER_ASC',
  LevelNumberDesc = 'LEVEL_NUMBER_DESC',
  Natural = 'NATURAL',
  PermissionNameIdAsc = 'PERMISSION_NAME_ID_ASC',
  PermissionNameIdDesc = 'PERMISSION_NAME_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RestrictionsAsc = 'RESTRICTIONS_ASC',
  RestrictionsDesc = 'RESTRICTIONS_DESC',
  StageNumberAsc = 'STAGE_NUMBER_ASC',
  StageNumberDesc = 'STAGE_NUMBER_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC'
}

export type TemplateSection = Node & {
  __typename?: 'TemplateSection';
  code?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  index?: Maybe<Scalars['Int']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** Reads and enables pagination through a set of `TemplateElement`. */
  templateElementsBySectionId: TemplateElementsConnection;
  templateId: Scalars['Int']['output'];
  title?: Maybe<Scalars['String']['output']>;
};


export type TemplateSectionTemplateElementsBySectionIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateElementCondition>;
  filter?: InputMaybe<TemplateElementFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};

/**
 * A condition to be used against `TemplateSection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateSectionCondition = {
  /** Checks for equality with the object’s `code` field. */
  code?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `index` field. */
  index?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TemplateSection` object types. All fields are combined with a logical ‘and.’ */
export type TemplateSectionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateSectionFilter>>;
  /** Filter by the object’s `code` field. */
  code?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `index` field. */
  index?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateSectionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateSectionFilter>>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateElementsBySectionId` relation. */
  templateElementsBySectionId?: InputMaybe<TemplateSectionToManyTemplateElementFilter>;
  /** Some related `templateElementsBySectionId` exist. */
  templateElementsBySectionIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `TemplateSection` */
export type TemplateSectionInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateSectionNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateSection` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateSectionNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateSection` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateElement` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  templateId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
};

/** The fields on `templateSection` to look up the row to update. */
export type TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate = {
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `templateSection` being updated. */
  patch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  templateId: Scalars['Int']['input'];
};

/** Represents an update to a `TemplateSection`. Fields that are set will be updated. */
export type TemplateSectionPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** Input for the nested mutation of `template` in the `TemplateSectionInput` mutation. */
export type TemplateSectionTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateSectionTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateSection` in the `TemplateInput` mutation. */
export type TemplateSectionTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateSectionTemplateSectionPkeyConnect>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateSectionNodeIdConnect>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  connectByTemplateIdAndCode?: InputMaybe<Array<TemplateSectionTemplateSectionTemplateIdCodeKeyConnect>>;
  /** A `TemplateSectionInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateSectionTemplateIdFkeyTemplateSectionCreateInput>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateSectionTemplateSectionPkeyDelete>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateSectionNodeIdDelete>>;
  /** The primary key(s) for `templateSection` for the far side of the relationship. */
  deleteByTemplateIdAndCode?: InputMaybe<Array<TemplateSectionTemplateSectionTemplateIdCodeKeyDelete>>;
  /** Flag indicating whether all other `templateSection` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `templateSection` for the far side of the relationship. */
  updateByTemplateIdAndCode?: InputMaybe<Array<TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TemplateSectionTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templateSection` to be created by this mutation. */
export type TemplateSectionTemplateIdFkeyTemplateSectionCreateInput = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `templateSection` to look up the row to connect. */
export type TemplateSectionTemplateSectionPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateSection` to look up the row to delete. */
export type TemplateSectionTemplateSectionPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateSection` to look up the row to connect. */
export type TemplateSectionTemplateSectionTemplateIdCodeKeyConnect = {
  code: Scalars['String']['input'];
  templateId: Scalars['Int']['input'];
};

/** The fields on `templateSection` to look up the row to delete. */
export type TemplateSectionTemplateSectionTemplateIdCodeKeyDelete = {
  code: Scalars['String']['input'];
  templateId: Scalars['Int']['input'];
};

/** A filter to be used against many `TemplateElement` object types. All fields are combined with a logical ‘and.’ */
export type TemplateSectionToManyTemplateElementFilter = {
  /** Every related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateElementFilter>;
  /** No related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateElementFilter>;
  /** Some related `TemplateElement` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateElementFilter>;
};

/** A connection to a list of `TemplateSection` values. */
export type TemplateSectionsConnection = {
  __typename?: 'TemplateSectionsConnection';
  /** A list of edges which contains the `TemplateSection` and cursor to aid in pagination. */
  edges: Array<TemplateSectionsEdge>;
  /** A list of `TemplateSection` objects. */
  nodes: Array<Maybe<TemplateSection>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateSection` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateSection` edge in the connection. */
export type TemplateSectionsEdge = {
  __typename?: 'TemplateSectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateSection` at the end of the edge. */
  node?: Maybe<TemplateSection>;
};

/** Methods to use when ordering `TemplateSection`. */
export enum TemplateSectionsOrderBy {
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IndexAsc = 'INDEX_ASC',
  IndexDesc = 'INDEX_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

export type TemplateStage = Node & {
  __typename?: 'TemplateStage';
  /** Reads and enables pagination through a set of `ApplicationStageHistory`. */
  applicationStageHistoriesByStageId: ApplicationStageHistoriesConnection;
  colour?: Maybe<Scalars['String']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  number?: Maybe<Scalars['Int']['output']>;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignmentsByStageId: ReviewAssignmentsConnection;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  templateId: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `TemplateStageReviewLevel`. */
  templateStageReviewLevelsByStageId: TemplateStageReviewLevelsConnection;
  title?: Maybe<Scalars['String']['output']>;
};


export type TemplateStageApplicationStageHistoriesByStageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationStageHistoryCondition>;
  filter?: InputMaybe<ApplicationStageHistoryFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};


export type TemplateStageReviewAssignmentsByStageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type TemplateStageTemplateStageReviewLevelsByStageIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<TemplateStageReviewLevelCondition>;
  filter?: InputMaybe<TemplateStageReviewLevelFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};

/**
 * A condition to be used against `TemplateStage` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TemplateStageCondition = {
  /** Checks for equality with the object’s `colour` field. */
  colour?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `title` field. */
  title?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `TemplateStage` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateStageFilter>>;
  /** Filter by the object’s `applicationStageHistoriesByStageId` relation. */
  applicationStageHistoriesByStageId?: InputMaybe<TemplateStageToManyApplicationStageHistoryFilter>;
  /** Some related `applicationStageHistoriesByStageId` exist. */
  applicationStageHistoriesByStageIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `colour` field. */
  colour?: InputMaybe<StringFilter>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateStageFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateStageFilter>>;
  /** Filter by the object’s `reviewAssignmentsByStageId` relation. */
  reviewAssignmentsByStageId?: InputMaybe<TemplateStageToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignmentsByStageId` exist. */
  reviewAssignmentsByStageIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `templateStageReviewLevelsByStageId` relation. */
  templateStageReviewLevelsByStageId?: InputMaybe<TemplateStageToManyTemplateStageReviewLevelFilter>;
  /** Some related `templateStageReviewLevelsByStageId` exist. */
  templateStageReviewLevelsByStageIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `title` field. */
  title?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `TemplateStage` */
export type TemplateStageInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateStageNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateStageNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateStage` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationStageHistory` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStageReviewLevel` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
  patch: TemplateStageReviewLevelPatch;
};

/** The fields on `templateStage` to look up the row to update. */
export type TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStagePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: UpdateTemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch;
};

/** Represents an update to a `TemplateStage`. Fields that are set will be updated. */
export type TemplateStagePatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

export type TemplateStageReviewLevel = Node & {
  __typename?: 'TemplateStageReviewLevel';
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  name: Scalars['String']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  number: Scalars['Int']['output'];
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignmentsByLevelId: ReviewAssignmentsConnection;
  singleReviewerAllSections: Scalars['Boolean']['output'];
  /** Reads a single `TemplateStage` that is related to this `TemplateStageReviewLevel`. */
  stage?: Maybe<TemplateStage>;
  stageId: Scalars['Int']['output'];
};


export type TemplateStageReviewLevelReviewAssignmentsByLevelIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};

/**
 * A condition to be used against `TemplateStageReviewLevel` object types. All
 * fields are tested for equality and combined with a logical ‘and.’
 */
export type TemplateStageReviewLevelCondition = {
  /** Checks for equality with the object’s `description` field. */
  description?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `name` field. */
  name?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `number` field. */
  number?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `singleReviewerAllSections` field. */
  singleReviewerAllSections?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `stageId` field. */
  stageId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `TemplateStageReviewLevel` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageReviewLevelFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TemplateStageReviewLevelFilter>>;
  /** Filter by the object’s `description` field. */
  description?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `name` field. */
  name?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TemplateStageReviewLevelFilter>;
  /** Filter by the object’s `number` field. */
  number?: InputMaybe<IntFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TemplateStageReviewLevelFilter>>;
  /** Filter by the object’s `reviewAssignmentsByLevelId` relation. */
  reviewAssignmentsByLevelId?: InputMaybe<TemplateStageReviewLevelToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignmentsByLevelId` exist. */
  reviewAssignmentsByLevelIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `singleReviewerAllSections` field. */
  singleReviewerAllSections?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `stage` relation. */
  stage?: InputMaybe<TemplateStageFilter>;
  /** Filter by the object’s `stageId` field. */
  stageId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `TemplateStageReviewLevel` */
export type TemplateStageReviewLevelInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  number: Scalars['Int']['input'];
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  singleReviewerAllSections?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TemplateStageReviewLevelNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `templateStageReviewLevel` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TemplateStageReviewLevelNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `templateStageReviewLevel` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The fields on `templateStageReviewLevel` to look up the row to update. */
export type TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingTemplateStageReviewLevelPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
  patch: UpdateTemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `templateStage` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `templateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The fields on `templateStageReviewLevel` to look up the row to update. */
export type TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStageReviewLevelPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
  patch: UpdateTemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch;
};

/** Represents an update to a `TemplateStageReviewLevel`. Fields that are set will be updated. */
export type TemplateStageReviewLevelPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  singleReviewerAllSections?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** Input for the nested mutation of `templateStage` in the `TemplateStageReviewLevelInput` mutation. */
export type TemplateStageReviewLevelStageIdFkeyInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateStageTemplateStagePkeyConnect>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateStageNodeIdConnect>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateStageReviewLevelStageIdFkeyTemplateStageCreateInput>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateStageTemplateStagePkeyDelete>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateStageNodeIdDelete>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStagePkeyUpdate>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateStageReviewLevel` in the `TemplateStageInput` mutation. */
export type TemplateStageReviewLevelStageIdFkeyInverseInput = {
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect>>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateStageReviewLevelNodeIdConnect>>;
  /** A `TemplateStageReviewLevelInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateStageReviewLevelStageIdFkeyTemplateStageReviewLevelCreateInput>>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete>>;
  /** The primary key(s) for `templateStageReviewLevel` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateStageReviewLevelNodeIdDelete>>;
  /** Flag indicating whether all other `templateStageReviewLevel` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateStageReviewLevel` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStageReviewLevelPkeyUpdate>>;
  /** The primary key(s) and patch data for `templateStageReviewLevel` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate>>;
};

/** The `templateStage` to be created by this mutation. */
export type TemplateStageReviewLevelStageIdFkeyTemplateStageCreateInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The `templateStageReviewLevel` to be created by this mutation. */
export type TemplateStageReviewLevelStageIdFkeyTemplateStageReviewLevelCreateInput = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name: Scalars['String']['input'];
  number: Scalars['Int']['input'];
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  singleReviewerAllSections?: InputMaybe<Scalars['Boolean']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** The fields on `templateStageReviewLevel` to look up the row to connect. */
export type TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateStageReviewLevel` to look up the row to delete. */
export type TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageReviewLevelToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A connection to a list of `TemplateStageReviewLevel` values. */
export type TemplateStageReviewLevelsConnection = {
  __typename?: 'TemplateStageReviewLevelsConnection';
  /** A list of edges which contains the `TemplateStageReviewLevel` and cursor to aid in pagination. */
  edges: Array<TemplateStageReviewLevelsEdge>;
  /** A list of `TemplateStageReviewLevel` objects. */
  nodes: Array<Maybe<TemplateStageReviewLevel>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateStageReviewLevel` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateStageReviewLevel` edge in the connection. */
export type TemplateStageReviewLevelsEdge = {
  __typename?: 'TemplateStageReviewLevelsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateStageReviewLevel` at the end of the edge. */
  node?: Maybe<TemplateStageReviewLevel>;
};

/** Methods to use when ordering `TemplateStageReviewLevel`. */
export enum TemplateStageReviewLevelsOrderBy {
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  SingleReviewerAllSectionsAsc = 'SINGLE_REVIEWER_ALL_SECTIONS_ASC',
  SingleReviewerAllSectionsDesc = 'SINGLE_REVIEWER_ALL_SECTIONS_DESC',
  StageIdAsc = 'STAGE_ID_ASC',
  StageIdDesc = 'STAGE_ID_DESC'
}

/** Input for the nested mutation of `template` in the `TemplateStageInput` mutation. */
export type TemplateStageTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateStageTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `templateStage` in the `TemplateInput` mutation. */
export type TemplateStageTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateStageTemplateStagePkeyConnect>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateStageNodeIdConnect>>;
  /** A `TemplateStageInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateStageTemplateIdFkeyTemplateStageCreateInput>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateStageTemplateStagePkeyDelete>>;
  /** The primary key(s) for `templateStage` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateStageNodeIdDelete>>;
  /** Flag indicating whether all other `templateStage` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate>>;
  /** The primary key(s) and patch data for `templateStage` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TemplateStageTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `templateStage` to be created by this mutation. */
export type TemplateStageTemplateIdFkeyTemplateStageCreateInput = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `templateStage` to look up the row to connect. */
export type TemplateStageTemplateStagePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `templateStage` to look up the row to delete. */
export type TemplateStageTemplateStagePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `ApplicationStageHistory` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageToManyApplicationStageHistoryFilter = {
  /** Every related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationStageHistoryFilter>;
  /** No related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationStageHistoryFilter>;
  /** Some related `ApplicationStageHistory` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationStageHistoryFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `TemplateStageReviewLevel` object types. All fields are combined with a logical ‘and.’ */
export type TemplateStageToManyTemplateStageReviewLevelFilter = {
  /** Every related `TemplateStageReviewLevel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateStageReviewLevelFilter>;
  /** No related `TemplateStageReviewLevel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateStageReviewLevelFilter>;
  /** Some related `TemplateStageReviewLevel` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateStageReviewLevelFilter>;
};

/** A connection to a list of `TemplateStage` values. */
export type TemplateStagesConnection = {
  __typename?: 'TemplateStagesConnection';
  /** A list of edges which contains the `TemplateStage` and cursor to aid in pagination. */
  edges: Array<TemplateStagesEdge>;
  /** A list of `TemplateStage` objects. */
  nodes: Array<Maybe<TemplateStage>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TemplateStage` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TemplateStage` edge in the connection. */
export type TemplateStagesEdge = {
  __typename?: 'TemplateStagesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TemplateStage` at the end of the edge. */
  node?: Maybe<TemplateStage>;
};

/** Methods to use when ordering `TemplateStage`. */
export enum TemplateStagesOrderBy {
  ColourAsc = 'COLOUR_ASC',
  ColourDesc = 'COLOUR_DESC',
  DescriptionAsc = 'DESCRIPTION_ASC',
  DescriptionDesc = 'DESCRIPTION_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  NumberAsc = 'NUMBER_ASC',
  NumberDesc = 'NUMBER_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TitleAsc = 'TITLE_ASC',
  TitleDesc = 'TITLE_DESC'
}

export enum TemplateStatus {
  Available = 'AVAILABLE',
  Disabled = 'DISABLED',
  Draft = 'DRAFT'
}

/** A filter to be used against TemplateStatus fields. All fields are combined with a logical ‘and.’ */
export type TemplateStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TemplateStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TemplateStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TemplateStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TemplateStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TemplateStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TemplateStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TemplateStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TemplateStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TemplateStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TemplateStatus>>;
};

/** Input for the nested mutation of `templateCategory` in the `TemplateInput` mutation. */
export type TemplateTemplateCategoryIdFkeyInput = {
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  connectByCode?: InputMaybe<TemplateCategoryTemplateCategoryCodeKeyConnect>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateCategoryTemplateCategoryPkeyConnect>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateCategoryNodeIdConnect>;
  /** A `TemplateCategoryInput` object that will be created and connected to this object. */
  create?: InputMaybe<TemplateTemplateCategoryIdFkeyTemplateCategoryCreateInput>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  deleteByCode?: InputMaybe<TemplateCategoryTemplateCategoryCodeKeyDelete>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateCategoryTemplateCategoryPkeyDelete>;
  /** The primary key(s) for `templateCategory` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateCategoryNodeIdDelete>;
  /** The primary key(s) and patch data for `templateCategory` for the far side of the relationship. */
  updateByCode?: InputMaybe<TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryCodeKeyUpdate>;
  /** The primary key(s) and patch data for `templateCategory` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryPkeyUpdate>;
  /** The primary key(s) and patch data for `templateCategory` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TemplateOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `template` in the `TemplateCategoryInput` mutation. */
export type TemplateTemplateCategoryIdFkeyInverseInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<Array<TemplateTemplateCodeVersionIdKeyConnect>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TemplateTemplatePkeyConnect>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TemplateNodeIdConnect>>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TemplateTemplateCategoryIdFkeyTemplateCreateInput>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<Array<TemplateTemplateCodeVersionIdKeyDelete>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TemplateTemplatePkeyDelete>>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TemplateNodeIdDelete>>;
  /** Flag indicating whether all other `template` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<Array<TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCodeVersionIdKeyUpdate>>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplatePkeyUpdate>>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate>>;
};

/** The `templateCategory` to be created by this mutation. */
export type TemplateTemplateCategoryIdFkeyTemplateCategoryCreateInput = {
  code: Scalars['String']['input'];
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  templatesUsingId?: InputMaybe<TemplateTemplateCategoryIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** The `template` to be created by this mutation. */
export type TemplateTemplateCategoryIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The fields on `template` to look up the row to connect. */
export type TemplateTemplateCodeVersionIdKeyConnect = {
  code: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to delete. */
export type TemplateTemplateCodeVersionIdKeyDelete = {
  code: Scalars['String']['input'];
  versionId: Scalars['String']['input'];
};

/** The fields on `template` to look up the row to connect. */
export type TemplateTemplatePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `template` to look up the row to delete. */
export type TemplateTemplatePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A filter to be used against many `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyActionQueueFilter = {
  /** Every related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionQueueFilter>;
  /** No related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionQueueFilter>;
  /** Some related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionQueueFilter>;
};

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationFilter>;
};

/** A filter to be used against many `File` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyFileFilter = {
  /** Every related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<FileFilter>;
  /** No related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<FileFilter>;
  /** Some related `File` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<FileFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `TemplateAction` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateActionFilter = {
  /** Every related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateActionFilter>;
  /** No related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateActionFilter>;
  /** Some related `TemplateAction` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateActionFilter>;
};

/** A filter to be used against many `TemplateFilterJoin` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateFilterJoinFilter = {
  /** Every related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateFilterJoinFilter>;
  /** No related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateFilterJoinFilter>;
  /** Some related `TemplateFilterJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateFilterJoinFilter>;
};

/** A filter to be used against many `TemplatePermission` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplatePermissionFilter = {
  /** Every related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplatePermissionFilter>;
  /** No related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplatePermissionFilter>;
  /** Some related `TemplatePermission` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplatePermissionFilter>;
};

/** A filter to be used against many `TemplateSection` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateSectionFilter = {
  /** Every related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateSectionFilter>;
  /** No related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateSectionFilter>;
  /** Some related `TemplateSection` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateSectionFilter>;
};

/** A filter to be used against many `TemplateStage` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTemplateStageFilter = {
  /** Every related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TemplateStageFilter>;
  /** No related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TemplateStageFilter>;
  /** Some related `TemplateStage` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TemplateStageFilter>;
};

/** A filter to be used against many `TriggerSchedule` object types. All fields are combined with a logical ‘and.’ */
export type TemplateToManyTriggerScheduleFilter = {
  /** Every related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<TriggerScheduleFilter>;
  /** No related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<TriggerScheduleFilter>;
  /** Some related `TriggerSchedule` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<TriggerScheduleFilter>;
};

/** A connection to a list of `Template` values. */
export type TemplatesConnection = {
  __typename?: 'TemplatesConnection';
  /** A list of edges which contains the `Template` and cursor to aid in pagination. */
  edges: Array<TemplatesEdge>;
  /** A list of `Template` objects. */
  nodes: Array<Maybe<Template>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Template` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Template` edge in the connection. */
export type TemplatesEdge = {
  __typename?: 'TemplatesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Template` at the end of the edge. */
  node?: Maybe<Template>;
};

/** Methods to use when ordering `Template`. */
export enum TemplatesOrderBy {
  CanApplicantMakeChangesAsc = 'CAN_APPLICANT_MAKE_CHANGES_ASC',
  CanApplicantMakeChangesDesc = 'CAN_APPLICANT_MAKE_CHANGES_DESC',
  CodeAsc = 'CODE_ASC',
  CodeDesc = 'CODE_DESC',
  DashboardRestrictionsAsc = 'DASHBOARD_RESTRICTIONS_ASC',
  DashboardRestrictionsDesc = 'DASHBOARD_RESTRICTIONS_DESC',
  IconAsc = 'ICON_ASC',
  IconDesc = 'ICON_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsLinearAsc = 'IS_LINEAR_ASC',
  IsLinearDesc = 'IS_LINEAR_DESC',
  NameAsc = 'NAME_ASC',
  NameDesc = 'NAME_DESC',
  NamePluralAsc = 'NAME_PLURAL_ASC',
  NamePluralDesc = 'NAME_PLURAL_DESC',
  Natural = 'NATURAL',
  ParentVersionIdAsc = 'PARENT_VERSION_ID_ASC',
  ParentVersionIdDesc = 'PARENT_VERSION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  PriorityAsc = 'PRIORITY_ASC',
  PriorityDesc = 'PRIORITY_DESC',
  SerialPatternAsc = 'SERIAL_PATTERN_ASC',
  SerialPatternDesc = 'SERIAL_PATTERN_DESC',
  StartMessageAsc = 'START_MESSAGE_ASC',
  StartMessageDesc = 'START_MESSAGE_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  SubmissionMessageAsc = 'SUBMISSION_MESSAGE_ASC',
  SubmissionMessageDesc = 'SUBMISSION_MESSAGE_DESC',
  TemplateCategoryIdAsc = 'TEMPLATE_CATEGORY_ID_ASC',
  TemplateCategoryIdDesc = 'TEMPLATE_CATEGORY_ID_DESC',
  VersionCommentAsc = 'VERSION_COMMENT_ASC',
  VersionCommentDesc = 'VERSION_COMMENT_DESC',
  VersionHistoryAsc = 'VERSION_HISTORY_ASC',
  VersionHistoryDesc = 'VERSION_HISTORY_DESC',
  VersionIdAsc = 'VERSION_ID_ASC',
  VersionIdDesc = 'VERSION_ID_DESC',
  VersionTimestampAsc = 'VERSION_TIMESTAMP_ASC',
  VersionTimestampDesc = 'VERSION_TIMESTAMP_DESC'
}

export enum Trigger {
  DevTest = 'DEV_TEST',
  Error = 'ERROR',
  OnApplicationCreate = 'ON_APPLICATION_CREATE',
  OnApplicationRestart = 'ON_APPLICATION_RESTART',
  OnApplicationSave = 'ON_APPLICATION_SAVE',
  OnApplicationSubmit = 'ON_APPLICATION_SUBMIT',
  OnApplicationWithdraw = 'ON_APPLICATION_WITHDRAW',
  OnApprovalSubmit = 'ON_APPROVAL_SUBMIT',
  OnExtend = 'ON_EXTEND',
  OnPreview = 'ON_PREVIEW',
  OnReviewAssign = 'ON_REVIEW_ASSIGN',
  OnReviewCreate = 'ON_REVIEW_CREATE',
  OnReviewRestart = 'ON_REVIEW_RESTART',
  OnReviewSubmit = 'ON_REVIEW_SUBMIT',
  OnReviewUnassign = 'ON_REVIEW_UNASSIGN',
  OnSchedule = 'ON_SCHEDULE',
  OnVerification = 'ON_VERIFICATION',
  Processing = 'PROCESSING'
}

/** A filter to be used against Trigger fields. All fields are combined with a logical ‘and.’ */
export type TriggerFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Trigger>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Trigger>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Trigger>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Trigger>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Trigger>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Trigger>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Trigger>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Trigger>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Trigger>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Trigger>>;
};

export type TriggerQueue = Node & {
  __typename?: 'TriggerQueue';
  /** Reads and enables pagination through a set of `ActionQueue`. */
  actionQueuesByTriggerEvent: ActionQueuesConnection;
  /** Reads a single `Application` that is related to this `TriggerQueue`. */
  application?: Maybe<Application>;
  applicationId?: Maybe<Scalars['Int']['output']>;
  data?: Maybe<Scalars['JSON']['output']>;
  eventCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  log?: Maybe<Scalars['JSON']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  recordId?: Maybe<Scalars['Int']['output']>;
  status?: Maybe<TriggerQueueStatus>;
  table?: Maybe<Scalars['String']['output']>;
  timestamp?: Maybe<Scalars['Datetime']['output']>;
  triggerType?: Maybe<Trigger>;
};


export type TriggerQueueActionQueuesByTriggerEventArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ActionQueueCondition>;
  filter?: InputMaybe<ActionQueueFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};

/** The `application` to be created by this mutation. */
export type TriggerQueueApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `TriggerQueueInput` mutation. */
export type TriggerQueueApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<TriggerQueueApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `triggerQueue` in the `ApplicationInput` mutation. */
export type TriggerQueueApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TriggerQueueTriggerQueuePkeyConnect>>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TriggerQueueNodeIdConnect>>;
  /** A `TriggerQueueInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TriggerQueueApplicationIdFkeyTriggerQueueCreateInput>>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TriggerQueueTriggerQueuePkeyDelete>>;
  /** The primary key(s) for `triggerQueue` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TriggerQueueNodeIdDelete>>;
  /** Flag indicating whether all other `triggerQueue` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingTriggerQueuePkeyUpdate>>;
  /** The primary key(s) and patch data for `triggerQueue` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate>>;
};

/** The `triggerQueue` to be created by this mutation. */
export type TriggerQueueApplicationIdFkeyTriggerQueueCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/**
 * A condition to be used against `TriggerQueue` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TriggerQueueCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `eventCode` field. */
  eventCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `log` field. */
  log?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `recordId` field. */
  recordId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `status` field. */
  status?: InputMaybe<TriggerQueueStatus>;
  /** Checks for equality with the object’s `table` field. */
  table?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timestamp` field. */
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `triggerType` field. */
  triggerType?: InputMaybe<Trigger>;
};

/** A filter to be used against `TriggerQueue` object types. All fields are combined with a logical ‘and.’ */
export type TriggerQueueFilter = {
  /** Filter by the object’s `actionQueuesByTriggerEvent` relation. */
  actionQueuesByTriggerEvent?: InputMaybe<TriggerQueueToManyActionQueueFilter>;
  /** Some related `actionQueuesByTriggerEvent` exist. */
  actionQueuesByTriggerEventExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TriggerQueueFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** A related `application` exists. */
  applicationExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `eventCode` field. */
  eventCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `log` field. */
  log?: InputMaybe<JsonFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TriggerQueueFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TriggerQueueFilter>>;
  /** Filter by the object’s `recordId` field. */
  recordId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `status` field. */
  status?: InputMaybe<TriggerQueueStatusFilter>;
  /** Filter by the object’s `table` field. */
  table?: InputMaybe<StringFilter>;
  /** Filter by the object’s `timestamp` field. */
  timestamp?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `triggerType` field. */
  triggerType?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `TriggerQueue` */
export type TriggerQueueInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TriggerQueueNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TriggerQueueNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `triggerQueue` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `actionQueue` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `actionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The fields on `triggerQueue` to look up the row to update. */
export type TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `triggerQueue` to look up the row to update. */
export type TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingTriggerQueuePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerQueue` being updated. */
  patch: UpdateTriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
};

/** Represents an update to a `TriggerQueue`. Fields that are set will be updated. */
export type TriggerQueuePatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

export enum TriggerQueueStatus {
  ActionsDispatched = 'ACTIONS_DISPATCHED',
  Completed = 'COMPLETED',
  Error = 'ERROR',
  Triggered = 'TRIGGERED'
}

/** A filter to be used against TriggerQueueStatus fields. All fields are combined with a logical ‘and.’ */
export type TriggerQueueStatusFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<TriggerQueueStatus>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<TriggerQueueStatus>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<TriggerQueueStatus>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<TriggerQueueStatus>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<TriggerQueueStatus>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<TriggerQueueStatus>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<TriggerQueueStatus>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<TriggerQueueStatus>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<TriggerQueueStatus>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<TriggerQueueStatus>>;
};

/** A filter to be used against many `ActionQueue` object types. All fields are combined with a logical ‘and.’ */
export type TriggerQueueToManyActionQueueFilter = {
  /** Every related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ActionQueueFilter>;
  /** No related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ActionQueueFilter>;
  /** Some related `ActionQueue` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ActionQueueFilter>;
};

/** The fields on `triggerQueue` to look up the row to connect. */
export type TriggerQueueTriggerQueuePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `triggerQueue` to look up the row to delete. */
export type TriggerQueueTriggerQueuePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `TriggerQueue` values. */
export type TriggerQueuesConnection = {
  __typename?: 'TriggerQueuesConnection';
  /** A list of edges which contains the `TriggerQueue` and cursor to aid in pagination. */
  edges: Array<TriggerQueuesEdge>;
  /** A list of `TriggerQueue` objects. */
  nodes: Array<Maybe<TriggerQueue>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TriggerQueue` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TriggerQueue` edge in the connection. */
export type TriggerQueuesEdge = {
  __typename?: 'TriggerQueuesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TriggerQueue` at the end of the edge. */
  node?: Maybe<TriggerQueue>;
};

/** Methods to use when ordering `TriggerQueue`. */
export enum TriggerQueuesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  EventCodeAsc = 'EVENT_CODE_ASC',
  EventCodeDesc = 'EVENT_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LogAsc = 'LOG_ASC',
  LogDesc = 'LOG_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  RecordIdAsc = 'RECORD_ID_ASC',
  RecordIdDesc = 'RECORD_ID_DESC',
  StatusAsc = 'STATUS_ASC',
  StatusDesc = 'STATUS_DESC',
  TableAsc = 'TABLE_ASC',
  TableDesc = 'TABLE_DESC',
  TimestampAsc = 'TIMESTAMP_ASC',
  TimestampDesc = 'TIMESTAMP_DESC',
  TriggerTypeAsc = 'TRIGGER_TYPE_ASC',
  TriggerTypeDesc = 'TRIGGER_TYPE_DESC'
}

export type TriggerSchedule = Node & {
  __typename?: 'TriggerSchedule';
  /** Reads a single `Application` that is related to this `TriggerSchedule`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  data?: Maybe<Scalars['JSON']['output']>;
  editorUserId?: Maybe<Scalars['Int']['output']>;
  eventCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isActive?: Maybe<Scalars['Boolean']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Template` that is related to this `TriggerSchedule`. */
  template?: Maybe<Template>;
  templateId?: Maybe<Scalars['Int']['output']>;
  timeScheduled: Scalars['Datetime']['output'];
  trigger?: Maybe<Trigger>;
};

/** The `application` to be created by this mutation. */
export type TriggerScheduleApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `TriggerScheduleInput` mutation. */
export type TriggerScheduleApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<TriggerScheduleApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `triggerSchedule` in the `ApplicationInput` mutation. */
export type TriggerScheduleApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyConnect>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdConnect>>;
  /** A `TriggerScheduleInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TriggerScheduleApplicationIdFkeyTriggerScheduleCreateInput>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyDelete>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdDelete>>;
  /** Flag indicating whether all other `triggerSchedule` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingTriggerSchedulePkeyUpdate>>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate>>;
};

/** The `triggerSchedule` to be created by this mutation. */
export type TriggerScheduleApplicationIdFkeyTriggerScheduleCreateInput = {
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled: Scalars['Datetime']['input'];
  trigger?: InputMaybe<Trigger>;
};

/**
 * A condition to be used against `TriggerSchedule` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type TriggerScheduleCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `editorUserId` field. */
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `eventCode` field. */
  eventCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isActive` field. */
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `templateId` field. */
  templateId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `timeScheduled` field. */
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
};

/** A filter to be used against `TriggerSchedule` object types. All fields are combined with a logical ‘and.’ */
export type TriggerScheduleFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<TriggerScheduleFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `editorUserId` field. */
  editorUserId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `eventCode` field. */
  eventCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isActive` field. */
  isActive?: InputMaybe<BooleanFilter>;
  /** Negates the expression. */
  not?: InputMaybe<TriggerScheduleFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<TriggerScheduleFilter>>;
  /** Filter by the object’s `template` relation. */
  template?: InputMaybe<TemplateFilter>;
  /** A related `template` exists. */
  templateExists?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `templateId` field. */
  templateId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `timeScheduled` field. */
  timeScheduled?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
};

/** An input for mutations affecting `TriggerSchedule` */
export type TriggerScheduleInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled: Scalars['Datetime']['input'];
  trigger?: InputMaybe<Trigger>;
};

/** The globally unique `ID` look up for the row to connect. */
export type TriggerScheduleNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type TriggerScheduleNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `triggerSchedule` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `triggerSchedule` to look up the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingTriggerSchedulePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `template` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `template` being updated. */
  patch: TemplatePatch;
};

/** The fields on `triggerSchedule` to look up the row to update. */
export type TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTriggerSchedulePkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `triggerSchedule` being updated. */
  patch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
};

/** Represents an update to a `TriggerSchedule`. Fields that are set will be updated. */
export type TriggerSchedulePatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
};

/** Input for the nested mutation of `template` in the `TriggerScheduleInput` mutation. */
export type TriggerScheduleTemplateIdFkeyInput = {
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectById?: InputMaybe<TemplateTemplatePkeyConnect>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<TemplateNodeIdConnect>;
  /** A `TemplateInput` object that will be created and connected to this object. */
  create?: InputMaybe<TriggerScheduleTemplateIdFkeyTemplateCreateInput>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByCodeAndVersionId?: InputMaybe<TemplateTemplateCodeVersionIdKeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteById?: InputMaybe<TemplateTemplatePkeyDelete>;
  /** The primary key(s) for `template` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<TemplateNodeIdDelete>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByCodeAndVersionId?: InputMaybe<TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateById?: InputMaybe<TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplatePkeyUpdate>;
  /** The primary key(s) and patch data for `template` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate>;
};

/** Input for the nested mutation of `triggerSchedule` in the `TemplateInput` mutation. */
export type TriggerScheduleTemplateIdFkeyInverseInput = {
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyConnect>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdConnect>>;
  /** A `TriggerScheduleInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<TriggerScheduleTemplateIdFkeyTriggerScheduleCreateInput>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<TriggerScheduleTriggerSchedulePkeyDelete>>;
  /** The primary key(s) for `triggerSchedule` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<TriggerScheduleNodeIdDelete>>;
  /** Flag indicating whether all other `triggerSchedule` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateById?: InputMaybe<Array<TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTriggerSchedulePkeyUpdate>>;
  /** The primary key(s) and patch data for `triggerSchedule` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate>>;
};

/** The `template` to be created by this mutation. */
export type TriggerScheduleTemplateIdFkeyTemplateCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code: Scalars['String']['input'];
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId: Scalars['String']['input'];
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** The `triggerSchedule` to be created by this mutation. */
export type TriggerScheduleTemplateIdFkeyTriggerScheduleCreateInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled: Scalars['Datetime']['input'];
  trigger?: InputMaybe<Trigger>;
};

/** The fields on `triggerSchedule` to look up the row to connect. */
export type TriggerScheduleTriggerSchedulePkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `triggerSchedule` to look up the row to delete. */
export type TriggerScheduleTriggerSchedulePkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `TriggerSchedule` values. */
export type TriggerSchedulesConnection = {
  __typename?: 'TriggerSchedulesConnection';
  /** A list of edges which contains the `TriggerSchedule` and cursor to aid in pagination. */
  edges: Array<TriggerSchedulesEdge>;
  /** A list of `TriggerSchedule` objects. */
  nodes: Array<Maybe<TriggerSchedule>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `TriggerSchedule` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `TriggerSchedule` edge in the connection. */
export type TriggerSchedulesEdge = {
  __typename?: 'TriggerSchedulesEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `TriggerSchedule` at the end of the edge. */
  node?: Maybe<TriggerSchedule>;
};

/** Methods to use when ordering `TriggerSchedule`. */
export enum TriggerSchedulesOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  EditorUserIdAsc = 'EDITOR_USER_ID_ASC',
  EditorUserIdDesc = 'EDITOR_USER_ID_DESC',
  EventCodeAsc = 'EVENT_CODE_ASC',
  EventCodeDesc = 'EVENT_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsActiveAsc = 'IS_ACTIVE_ASC',
  IsActiveDesc = 'IS_ACTIVE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TemplateIdAsc = 'TEMPLATE_ID_ASC',
  TemplateIdDesc = 'TEMPLATE_ID_DESC',
  TimeScheduledAsc = 'TIME_SCHEDULED_ASC',
  TimeScheduledDesc = 'TIME_SCHEDULED_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC'
}

export enum UiLocation {
  Admin = 'ADMIN',
  Dashboard = 'DASHBOARD',
  List = 'LIST',
  Management = 'MANAGEMENT',
  User = 'USER'
}

/** A filter to be used against UiLocation List fields. All fields are combined with a logical ‘and.’ */
export type UiLocationListFilter = {
  /** Any array item is equal to the specified value. */
  anyEqualTo?: InputMaybe<UiLocation>;
  /** Any array item is greater than the specified value. */
  anyGreaterThan?: InputMaybe<UiLocation>;
  /** Any array item is greater than or equal to the specified value. */
  anyGreaterThanOrEqualTo?: InputMaybe<UiLocation>;
  /** Any array item is less than the specified value. */
  anyLessThan?: InputMaybe<UiLocation>;
  /** Any array item is less than or equal to the specified value. */
  anyLessThanOrEqualTo?: InputMaybe<UiLocation>;
  /** Any array item is not equal to the specified value. */
  anyNotEqualTo?: InputMaybe<UiLocation>;
  /** Contained by the specified list of values. */
  containedBy?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Contains the specified list of values. */
  contains?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Array<InputMaybe<UiLocation>>>;
  /** Overlaps the specified list of values. */
  overlaps?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

export type UnnestedSection = {
  __typename?: 'UnnestedSection';
  id?: Maybe<Scalars['Int']['output']>;
  section?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `UnnestedSection` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UnnestedSectionCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `section` field. */
  section?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `UnnestedSection` object types. All fields are combined with a logical ‘and.’ */
export type UnnestedSectionFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UnnestedSectionFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UnnestedSectionFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UnnestedSectionFilter>>;
  /** Filter by the object’s `section` field. */
  section?: InputMaybe<StringFilter>;
};

/** A connection to a list of `UnnestedSection` values. */
export type UnnestedSectionsConnection = {
  __typename?: 'UnnestedSectionsConnection';
  /** A list of edges which contains the `UnnestedSection` and cursor to aid in pagination. */
  edges: Array<UnnestedSectionsEdge>;
  /** A list of `UnnestedSection` objects. */
  nodes: Array<Maybe<UnnestedSection>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UnnestedSection` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UnnestedSection` edge in the connection. */
export type UnnestedSectionsEdge = {
  __typename?: 'UnnestedSectionsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UnnestedSection` at the end of the edge. */
  node?: Maybe<UnnestedSection>;
};

/** Methods to use when ordering `UnnestedSection`. */
export enum UnnestedSectionsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  SectionAsc = 'SECTION_ASC',
  SectionDesc = 'SECTION_DESC'
}

/** All input for the `updateActionPluginByCode` mutation. */
export type UpdateActionPluginByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `ActionPlugin` being updated. */
  patch: ActionPluginPatch;
};

/** All input for the `updateActionPluginByNodeId` mutation. */
export type UpdateActionPluginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActionPlugin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ActionPlugin` being updated. */
  patch: ActionPluginPatch;
};

/** All input for the `updateActionPlugin` mutation. */
export type UpdateActionPluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ActionPlugin` being updated. */
  patch: ActionPluginPatch;
};

/** The output of our update `ActionPlugin` mutation. */
export type UpdateActionPluginPayload = {
  __typename?: 'UpdateActionPluginPayload';
  /** The `ActionPlugin` that was updated by this mutation. */
  actionPlugin?: Maybe<ActionPlugin>;
  /** An edge for our `ActionPlugin`. May be used by Relay 1. */
  actionPluginEdge?: Maybe<ActionPluginsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ActionPlugin` mutation. */
export type UpdateActionPluginPayloadActionPluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionPluginsOrderBy>>;
};

/** All input for the `updateActionQueueByNodeId` mutation. */
export type UpdateActionQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActionQueue` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ActionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** All input for the `updateActionQueue` mutation. */
export type UpdateActionQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ActionQueue` being updated. */
  patch: ActionQueuePatch;
};

/** The output of our update `ActionQueue` mutation. */
export type UpdateActionQueuePayload = {
  __typename?: 'UpdateActionQueuePayload';
  /** The `ActionQueue` that was updated by this mutation. */
  actionQueue?: Maybe<ActionQueue>;
  /** An edge for our `ActionQueue`. May be used by Relay 1. */
  actionQueueEdge?: Maybe<ActionQueuesEdge>;
  /** Reads a single `Application` that is related to this `ActionQueue`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `ActionQueue`. */
  template?: Maybe<Template>;
  /** Reads a single `TriggerQueue` that is related to this `ActionQueue`. */
  triggerQueueByTriggerEvent?: Maybe<TriggerQueue>;
};


/** The output of our update `ActionQueue` mutation. */
export type UpdateActionQueuePayloadActionQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<ActionQueuesOrderBy>>;
};

/** All input for the `updateActivityLogByNodeId` mutation. */
export type UpdateActivityLogByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ActivityLog` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ActivityLog` being updated. */
  patch: ActivityLogPatch;
};

/** All input for the `updateActivityLog` mutation. */
export type UpdateActivityLogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ActivityLog` being updated. */
  patch: ActivityLogPatch;
};

/** The output of our update `ActivityLog` mutation. */
export type UpdateActivityLogPayload = {
  __typename?: 'UpdateActivityLogPayload';
  /** The `ActivityLog` that was updated by this mutation. */
  activityLog?: Maybe<ActivityLog>;
  /** An edge for our `ActivityLog`. May be used by Relay 1. */
  activityLogEdge?: Maybe<ActivityLogsEdge>;
  /** Reads a single `Application` that is related to this `ActivityLog`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ActivityLog` mutation. */
export type UpdateActivityLogPayloadActivityLogEdgeArgs = {
  orderBy?: InputMaybe<Array<ActivityLogsOrderBy>>;
};

/** All input for the `updateApplicationByNodeId` mutation. */
export type UpdateApplicationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Application` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
};

/** All input for the `updateApplicationByOutcomeRegistration` mutation. */
export type UpdateApplicationByOutcomeRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  outcomeRegistration: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
};

/** All input for the `updateApplicationBySerial` mutation. */
export type UpdateApplicationBySerialInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
  serial: Scalars['String']['input'];
};

/** All input for the `updateApplication` mutation. */
export type UpdateApplicationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Application` being updated. */
  patch: ApplicationPatch;
};

/** All input for the `updateApplicationNoteByNodeId` mutation. */
export type UpdateApplicationNoteByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationNote` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** All input for the `updateApplicationNote` mutation. */
export type UpdateApplicationNoteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The output of our update `ApplicationNote` mutation. */
export type UpdateApplicationNotePayload = {
  __typename?: 'UpdateApplicationNotePayload';
  /** Reads a single `Application` that is related to this `ApplicationNote`. */
  application?: Maybe<Application>;
  /** The `ApplicationNote` that was updated by this mutation. */
  applicationNote?: Maybe<ApplicationNote>;
  /** An edge for our `ApplicationNote`. May be used by Relay 1. */
  applicationNoteEdge?: Maybe<ApplicationNotesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `ApplicationNote`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserList` that is related to this `ApplicationNote`. */
  user?: Maybe<UserList>;
};


/** The output of our update `ApplicationNote` mutation. */
export type UpdateApplicationNotePayloadApplicationNoteEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};

/** The output of our update `Application` mutation. */
export type UpdateApplicationPayload = {
  __typename?: 'UpdateApplicationPayload';
  /** The `Application` that was updated by this mutation. */
  application?: Maybe<Application>;
  /** An edge for our `Application`. May be used by Relay 1. */
  applicationEdge?: Maybe<ApplicationsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `Application`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `Application`. */
  template?: Maybe<Template>;
  /** Reads a single `UserList` that is related to this `Application`. */
  user?: Maybe<UserList>;
};


/** The output of our update `Application` mutation. */
export type UpdateApplicationPayloadApplicationEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};

/** All input for the `updateApplicationResponseByNodeId` mutation. */
export type UpdateApplicationResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationResponse` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** All input for the `updateApplicationResponse` mutation. */
export type UpdateApplicationResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationResponse` being updated. */
  patch: ApplicationResponsePatch;
};

/** The output of our update `ApplicationResponse` mutation. */
export type UpdateApplicationResponsePayload = {
  __typename?: 'UpdateApplicationResponsePayload';
  /** Reads a single `Application` that is related to this `ApplicationResponse`. */
  application?: Maybe<Application>;
  /** The `ApplicationResponse` that was updated by this mutation. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /** An edge for our `ApplicationResponse`. May be used by Relay 1. */
  applicationResponseEdge?: Maybe<ApplicationResponsesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateElement` that is related to this `ApplicationResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our update `ApplicationResponse` mutation. */
export type UpdateApplicationResponsePayloadApplicationResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationResponsesOrderBy>>;
};

/** All input for the `updateApplicationReviewerActionByNodeId` mutation. */
export type UpdateApplicationReviewerActionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationReviewerAction` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationReviewerAction` being updated. */
  patch: ApplicationReviewerActionPatch;
};

/** All input for the `updateApplicationReviewerActionByUserIdAndApplicationId` mutation. */
export type UpdateApplicationReviewerActionByUserIdAndApplicationIdInput = {
  applicationId: Scalars['Int']['input'];
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `ApplicationReviewerAction` being updated. */
  patch: ApplicationReviewerActionPatch;
  userId: Scalars['Int']['input'];
};

/** All input for the `updateApplicationReviewerAction` mutation. */
export type UpdateApplicationReviewerActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationReviewerAction` being updated. */
  patch: ApplicationReviewerActionPatch;
};

/** The output of our update `ApplicationReviewerAction` mutation. */
export type UpdateApplicationReviewerActionPayload = {
  __typename?: 'UpdateApplicationReviewerActionPayload';
  /** Reads a single `Application` that is related to this `ApplicationReviewerAction`. */
  application?: Maybe<Application>;
  /** The `ApplicationReviewerAction` that was updated by this mutation. */
  applicationReviewerAction?: Maybe<ApplicationReviewerAction>;
  /** An edge for our `ApplicationReviewerAction`. May be used by Relay 1. */
  applicationReviewerActionEdge?: Maybe<ApplicationReviewerActionsEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ApplicationReviewerAction` mutation. */
export type UpdateApplicationReviewerActionPayloadApplicationReviewerActionEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationReviewerActionsOrderBy>>;
};

/** All input for the `updateApplicationStageHistoryByNodeId` mutation. */
export type UpdateApplicationStageHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationStageHistory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** All input for the `updateApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationStageHistory` being updated. */
  patch: ApplicationStageHistoryPatch;
};

/** The output of our update `ApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryPayload = {
  __typename?: 'UpdateApplicationStageHistoryPayload';
  /** Reads a single `Application` that is related to this `ApplicationStageHistory`. */
  application?: Maybe<Application>;
  /** The `ApplicationStageHistory` that was updated by this mutation. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** An edge for our `ApplicationStageHistory`. May be used by Relay 1. */
  applicationStageHistoryEdge?: Maybe<ApplicationStageHistoriesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `ApplicationStageHistory`. */
  stage?: Maybe<TemplateStage>;
};


/** The output of our update `ApplicationStageHistory` mutation. */
export type UpdateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStageHistoriesOrderBy>>;
};

/** All input for the `updateApplicationStatusHistoryByNodeId` mutation. */
export type UpdateApplicationStatusHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ApplicationStatusHistory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ApplicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
};

/** All input for the `updateApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ApplicationStatusHistory` being updated. */
  patch: ApplicationStatusHistoryPatch;
};

/** The output of our update `ApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryPayload = {
  __typename?: 'UpdateApplicationStatusHistoryPayload';
  /** Reads a single `ApplicationStageHistory` that is related to this `ApplicationStatusHistory`. */
  applicationStageHistory?: Maybe<ApplicationStageHistory>;
  /** The `ApplicationStatusHistory` that was updated by this mutation. */
  applicationStatusHistory?: Maybe<ApplicationStatusHistory>;
  /** An edge for our `ApplicationStatusHistory`. May be used by Relay 1. */
  applicationStatusHistoryEdge?: Maybe<ApplicationStatusHistoriesEdge>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ApplicationStatusHistory` mutation. */
export type UpdateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ApplicationStatusHistoriesOrderBy>>;
};

/** All input for the `updateCounterByName` mutation. */
export type UpdateCounterByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Counter` being updated. */
  patch: CounterPatch;
};

/** All input for the `updateCounterByNodeId` mutation. */
export type UpdateCounterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Counter` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Counter` being updated. */
  patch: CounterPatch;
};

/** All input for the `updateCounter` mutation. */
export type UpdateCounterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Counter` being updated. */
  patch: CounterPatch;
};

/** The output of our update `Counter` mutation. */
export type UpdateCounterPayload = {
  __typename?: 'UpdateCounterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Counter` that was updated by this mutation. */
  counter?: Maybe<Counter>;
  /** An edge for our `Counter`. May be used by Relay 1. */
  counterEdge?: Maybe<CountersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Counter` mutation. */
export type UpdateCounterPayloadCounterEdgeArgs = {
  orderBy?: InputMaybe<Array<CountersOrderBy>>;
};

/** All input for the `updateDataChangelogByNodeId` mutation. */
export type UpdateDataChangelogByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataChangelog` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataChangelog` being updated. */
  patch: DataChangelogPatch;
};

/** All input for the `updateDataChangelog` mutation. */
export type UpdateDataChangelogInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataChangelog` being updated. */
  patch: DataChangelogPatch;
};

/** The output of our update `DataChangelog` mutation. */
export type UpdateDataChangelogPayload = {
  __typename?: 'UpdateDataChangelogPayload';
  /** Reads a single `Application` that is related to this `DataChangelog`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataChangelog` that was updated by this mutation. */
  dataChangelog?: Maybe<DataChangelog>;
  /** An edge for our `DataChangelog`. May be used by Relay 1. */
  dataChangelogEdge?: Maybe<DataChangelogsEdge>;
  /** Reads a single `Organisation` that is related to this `DataChangelog`. */
  org?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataChangelog` mutation. */
export type UpdateDataChangelogPayloadDataChangelogEdgeArgs = {
  orderBy?: InputMaybe<Array<DataChangelogsOrderBy>>;
};

/** All input for the `updateDataTableActiveIngredientByNodeId` mutation. */
export type UpdateDataTableActiveIngredientByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableActiveIngredient` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableActiveIngredient` being updated. */
  patch: DataTableActiveIngredientPatch;
};

/** All input for the `updateDataTableActiveIngredient` mutation. */
export type UpdateDataTableActiveIngredientInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableActiveIngredient` being updated. */
  patch: DataTableActiveIngredientPatch;
};

/** The output of our update `DataTableActiveIngredient` mutation. */
export type UpdateDataTableActiveIngredientPayload = {
  __typename?: 'UpdateDataTableActiveIngredientPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableActiveIngredient` that was updated by this mutation. */
  dataTableActiveIngredient?: Maybe<DataTableActiveIngredient>;
  /** An edge for our `DataTableActiveIngredient`. May be used by Relay 1. */
  dataTableActiveIngredientEdge?: Maybe<DataTableActiveIngredientsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableActiveIngredient` mutation. */
export type UpdateDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableActiveIngredientsOrderBy>>;
};

/** All input for the `updateDataTableAdministrationRouteByNodeId` mutation. */
export type UpdateDataTableAdministrationRouteByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAdministrationRoute` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableAdministrationRoute` being updated. */
  patch: DataTableAdministrationRoutePatch;
};

/** All input for the `updateDataTableAdministrationRoute` mutation. */
export type UpdateDataTableAdministrationRouteInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableAdministrationRoute` being updated. */
  patch: DataTableAdministrationRoutePatch;
};

/** The output of our update `DataTableAdministrationRoute` mutation. */
export type UpdateDataTableAdministrationRoutePayload = {
  __typename?: 'UpdateDataTableAdministrationRoutePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAdministrationRoute` that was updated by this mutation. */
  dataTableAdministrationRoute?: Maybe<DataTableAdministrationRoute>;
  /** An edge for our `DataTableAdministrationRoute`. May be used by Relay 1. */
  dataTableAdministrationRouteEdge?: Maybe<DataTableAdministrationRoutesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableAdministrationRoute` mutation. */
export type UpdateDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAdministrationRoutesOrderBy>>;
};

/** All input for the `updateDataTableAtcCodeByNodeId` mutation. */
export type UpdateDataTableAtcCodeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableAtcCode` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableAtcCode` being updated. */
  patch: DataTableAtcCodePatch;
};

/** All input for the `updateDataTableAtcCode` mutation. */
export type UpdateDataTableAtcCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableAtcCode` being updated. */
  patch: DataTableAtcCodePatch;
};

/** The output of our update `DataTableAtcCode` mutation. */
export type UpdateDataTableAtcCodePayload = {
  __typename?: 'UpdateDataTableAtcCodePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableAtcCode` that was updated by this mutation. */
  dataTableAtcCode?: Maybe<DataTableAtcCode>;
  /** An edge for our `DataTableAtcCode`. May be used by Relay 1. */
  dataTableAtcCodeEdge?: Maybe<DataTableAtcCodesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableAtcCode` mutation. */
export type UpdateDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableAtcCodesOrderBy>>;
};

/** All input for the `updateDataTableByNodeId` mutation. */
export type UpdateDataTableByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTable` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTable` being updated. */
  patch: DataTablePatch;
};

/** All input for the `updateDataTableByTableName` mutation. */
export type UpdateDataTableByTableNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `DataTable` being updated. */
  patch: DataTablePatch;
  tableName: Scalars['String']['input'];
};

/** All input for the `updateDataTableContainerByNodeId` mutation. */
export type UpdateDataTableContainerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableContainer` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableContainer` being updated. */
  patch: DataTableContainerPatch;
};

/** All input for the `updateDataTableContainer` mutation. */
export type UpdateDataTableContainerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableContainer` being updated. */
  patch: DataTableContainerPatch;
};

/** The output of our update `DataTableContainer` mutation. */
export type UpdateDataTableContainerPayload = {
  __typename?: 'UpdateDataTableContainerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableContainer` that was updated by this mutation. */
  dataTableContainer?: Maybe<DataTableContainer>;
  /** An edge for our `DataTableContainer`. May be used by Relay 1. */
  dataTableContainerEdge?: Maybe<DataTableContainersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableContainer` mutation. */
export type UpdateDataTableContainerPayloadDataTableContainerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableContainersOrderBy>>;
};

/** All input for the `updateDataTableCountryByNodeId` mutation. */
export type UpdateDataTableCountryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableCountry` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableCountry` being updated. */
  patch: DataTableCountryPatch;
};

/** All input for the `updateDataTableCountry` mutation. */
export type UpdateDataTableCountryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableCountry` being updated. */
  patch: DataTableCountryPatch;
};

/** The output of our update `DataTableCountry` mutation. */
export type UpdateDataTableCountryPayload = {
  __typename?: 'UpdateDataTableCountryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableCountry` that was updated by this mutation. */
  dataTableCountry?: Maybe<DataTableCountry>;
  /** An edge for our `DataTableCountry`. May be used by Relay 1. */
  dataTableCountryEdge?: Maybe<DataTableCountriesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableCountry` mutation. */
export type UpdateDataTableCountryPayloadDataTableCountryEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableCountriesOrderBy>>;
};

/** All input for the `updateDataTableDosageFormByNodeId` mutation. */
export type UpdateDataTableDosageFormByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableDosageForm` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableDosageForm` being updated. */
  patch: DataTableDosageFormPatch;
};

/** All input for the `updateDataTableDosageFormGroupByNodeId` mutation. */
export type UpdateDataTableDosageFormGroupByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableDosageFormGroup` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableDosageFormGroup` being updated. */
  patch: DataTableDosageFormGroupPatch;
};

/** All input for the `updateDataTableDosageFormGroup` mutation. */
export type UpdateDataTableDosageFormGroupInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableDosageFormGroup` being updated. */
  patch: DataTableDosageFormGroupPatch;
};

/** The output of our update `DataTableDosageFormGroup` mutation. */
export type UpdateDataTableDosageFormGroupPayload = {
  __typename?: 'UpdateDataTableDosageFormGroupPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageFormGroup` that was updated by this mutation. */
  dataTableDosageFormGroup?: Maybe<DataTableDosageFormGroup>;
  /** An edge for our `DataTableDosageFormGroup`. May be used by Relay 1. */
  dataTableDosageFormGroupEdge?: Maybe<DataTableDosageFormGroupsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableDosageFormGroup` mutation. */
export type UpdateDataTableDosageFormGroupPayloadDataTableDosageFormGroupEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormGroupsOrderBy>>;
};

/** All input for the `updateDataTableDosageForm` mutation. */
export type UpdateDataTableDosageFormInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableDosageForm` being updated. */
  patch: DataTableDosageFormPatch;
};

/** The output of our update `DataTableDosageForm` mutation. */
export type UpdateDataTableDosageFormPayload = {
  __typename?: 'UpdateDataTableDosageFormPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableDosageForm` that was updated by this mutation. */
  dataTableDosageForm?: Maybe<DataTableDosageForm>;
  /** An edge for our `DataTableDosageForm`. May be used by Relay 1. */
  dataTableDosageFormEdge?: Maybe<DataTableDosageFormsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableDosageForm` mutation. */
export type UpdateDataTableDosageFormPayloadDataTableDosageFormEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableDosageFormsOrderBy>>;
};

/** All input for the `updateDataTableGenericIngredientByNodeId` mutation. */
export type UpdateDataTableGenericIngredientByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableGenericIngredient` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableGenericIngredient` being updated. */
  patch: DataTableGenericIngredientPatch;
};

/** All input for the `updateDataTableGenericIngredient` mutation. */
export type UpdateDataTableGenericIngredientInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableGenericIngredient` being updated. */
  patch: DataTableGenericIngredientPatch;
};

/** The output of our update `DataTableGenericIngredient` mutation. */
export type UpdateDataTableGenericIngredientPayload = {
  __typename?: 'UpdateDataTableGenericIngredientPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableGenericIngredient` that was updated by this mutation. */
  dataTableGenericIngredient?: Maybe<DataTableGenericIngredient>;
  /** An edge for our `DataTableGenericIngredient`. May be used by Relay 1. */
  dataTableGenericIngredientEdge?: Maybe<DataTableGenericIngredientsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableGenericIngredient` mutation. */
export type UpdateDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableGenericIngredientsOrderBy>>;
};

/** All input for the `updateDataTable` mutation. */
export type UpdateDataTableInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTable` being updated. */
  patch: DataTablePatch;
};

/** All input for the `updateDataTableManufacturerApplicationJoinByNodeId` mutation. */
export type UpdateDataTableManufacturerApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturerApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturerApplicationJoin` being updated. */
  patch: DataTableManufacturerApplicationJoinPatch;
};

/** All input for the `updateDataTableManufacturerApplicationJoin` mutation. */
export type UpdateDataTableManufacturerApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturerApplicationJoin` being updated. */
  patch: DataTableManufacturerApplicationJoinPatch;
};

/** The output of our update `DataTableManufacturerApplicationJoin` mutation. */
export type UpdateDataTableManufacturerApplicationJoinPayload = {
  __typename?: 'UpdateDataTableManufacturerApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableManufacturerApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableManufacturer` that is related to this `DataTableManufacturerApplicationJoin`. */
  dataTableManufacturer?: Maybe<DataTableManufacturer>;
  /** The `DataTableManufacturerApplicationJoin` that was updated by this mutation. */
  dataTableManufacturerApplicationJoin?: Maybe<DataTableManufacturerApplicationJoin>;
  /** An edge for our `DataTableManufacturerApplicationJoin`. May be used by Relay 1. */
  dataTableManufacturerApplicationJoinEdge?: Maybe<DataTableManufacturerApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableManufacturerApplicationJoin` mutation. */
export type UpdateDataTableManufacturerApplicationJoinPayloadDataTableManufacturerApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerApplicationJoinsOrderBy>>;
};

/** All input for the `updateDataTableManufacturerByNodeId` mutation. */
export type UpdateDataTableManufacturerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturer` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturer` being updated. */
  patch: DataTableManufacturerPatch;
};

/** All input for the `updateDataTableManufacturer` mutation. */
export type UpdateDataTableManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturer` being updated. */
  patch: DataTableManufacturerPatch;
};

/** The output of our update `DataTableManufacturer` mutation. */
export type UpdateDataTableManufacturerPayload = {
  __typename?: 'UpdateDataTableManufacturerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturer` that was updated by this mutation. */
  dataTableManufacturer?: Maybe<DataTableManufacturer>;
  /** An edge for our `DataTableManufacturer`. May be used by Relay 1. */
  dataTableManufacturerEdge?: Maybe<DataTableManufacturersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableManufacturer` mutation. */
export type UpdateDataTableManufacturerPayloadDataTableManufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturersOrderBy>>;
};

/** All input for the `updateDataTableManufacturerRepresentativeApplicationJoinByNodeId` mutation. */
export type UpdateDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturerRepresentativeApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturerRepresentativeApplicationJoin` being updated. */
  patch: DataTableManufacturerRepresentativeApplicationJoinPatch;
};

/** All input for the `updateDataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type UpdateDataTableManufacturerRepresentativeApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturerRepresentativeApplicationJoin` being updated. */
  patch: DataTableManufacturerRepresentativeApplicationJoinPatch;
};

/** The output of our update `DataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type UpdateDataTableManufacturerRepresentativeApplicationJoinPayload = {
  __typename?: 'UpdateDataTableManufacturerRepresentativeApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableManufacturerRepresentativeApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /**
   * Reads a single `DataTableManufacturerRepresentative` that is related to this
   * `DataTableManufacturerRepresentativeApplicationJoin`.
   */
  dataTableManufacturerRepresentative?: Maybe<DataTableManufacturerRepresentative>;
  /** The `DataTableManufacturerRepresentativeApplicationJoin` that was updated by this mutation. */
  dataTableManufacturerRepresentativeApplicationJoin?: Maybe<DataTableManufacturerRepresentativeApplicationJoin>;
  /** An edge for our `DataTableManufacturerRepresentativeApplicationJoin`. May be used by Relay 1. */
  dataTableManufacturerRepresentativeApplicationJoinEdge?: Maybe<DataTableManufacturerRepresentativeApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableManufacturerRepresentativeApplicationJoin` mutation. */
export type UpdateDataTableManufacturerRepresentativeApplicationJoinPayloadDataTableManufacturerRepresentativeApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativeApplicationJoinsOrderBy>>;
};

/** All input for the `updateDataTableManufacturerRepresentativeByNodeId` mutation. */
export type UpdateDataTableManufacturerRepresentativeByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableManufacturerRepresentative` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturerRepresentative` being updated. */
  patch: DataTableManufacturerRepresentativePatch;
};

/** All input for the `updateDataTableManufacturerRepresentative` mutation. */
export type UpdateDataTableManufacturerRepresentativeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableManufacturerRepresentative` being updated. */
  patch: DataTableManufacturerRepresentativePatch;
};

/** The output of our update `DataTableManufacturerRepresentative` mutation. */
export type UpdateDataTableManufacturerRepresentativePayload = {
  __typename?: 'UpdateDataTableManufacturerRepresentativePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableManufacturerRepresentative` that was updated by this mutation. */
  dataTableManufacturerRepresentative?: Maybe<DataTableManufacturerRepresentative>;
  /** An edge for our `DataTableManufacturerRepresentative`. May be used by Relay 1. */
  dataTableManufacturerRepresentativeEdge?: Maybe<DataTableManufacturerRepresentativesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableManufacturerRepresentative` mutation. */
export type UpdateDataTableManufacturerRepresentativePayloadDataTableManufacturerRepresentativeEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableManufacturerRepresentativesOrderBy>>;
};

/** The output of our update `DataTable` mutation. */
export type UpdateDataTablePayload = {
  __typename?: 'UpdateDataTablePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTable` that was updated by this mutation. */
  dataTable?: Maybe<DataTable>;
  /** An edge for our `DataTable`. May be used by Relay 1. */
  dataTableEdge?: Maybe<DataTablesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTable` mutation. */
export type UpdateDataTablePayloadDataTableEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablesOrderBy>>;
};

/** All input for the `updateDataTablePermitChemicalApplicationJoinByNodeId` mutation. */
export type UpdateDataTablePermitChemicalApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePermitChemicalApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTablePermitChemicalApplicationJoin` being updated. */
  patch: DataTablePermitChemicalApplicationJoinPatch;
};

/** All input for the `updateDataTablePermitChemicalApplicationJoin` mutation. */
export type UpdateDataTablePermitChemicalApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTablePermitChemicalApplicationJoin` being updated. */
  patch: DataTablePermitChemicalApplicationJoinPatch;
};

/** The output of our update `DataTablePermitChemicalApplicationJoin` mutation. */
export type UpdateDataTablePermitChemicalApplicationJoinPayload = {
  __typename?: 'UpdateDataTablePermitChemicalApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTablePermitChemicalApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTablePermitChemical` that is related to this `DataTablePermitChemicalApplicationJoin`. */
  dataTablePermitChemical?: Maybe<DataTablePermitChemical>;
  /** The `DataTablePermitChemicalApplicationJoin` that was updated by this mutation. */
  dataTablePermitChemicalApplicationJoin?: Maybe<DataTablePermitChemicalApplicationJoin>;
  /** An edge for our `DataTablePermitChemicalApplicationJoin`. May be used by Relay 1. */
  dataTablePermitChemicalApplicationJoinEdge?: Maybe<DataTablePermitChemicalApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTablePermitChemicalApplicationJoin` mutation. */
export type UpdateDataTablePermitChemicalApplicationJoinPayloadDataTablePermitChemicalApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePermitChemicalApplicationJoinsOrderBy>>;
};

/** All input for the `updateDataTablePermitChemicalByNodeId` mutation. */
export type UpdateDataTablePermitChemicalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePermitChemical` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTablePermitChemical` being updated. */
  patch: DataTablePermitChemicalPatch;
};

/** All input for the `updateDataTablePermitChemical` mutation. */
export type UpdateDataTablePermitChemicalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTablePermitChemical` being updated. */
  patch: DataTablePermitChemicalPatch;
};

/** The output of our update `DataTablePermitChemical` mutation. */
export type UpdateDataTablePermitChemicalPayload = {
  __typename?: 'UpdateDataTablePermitChemicalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePermitChemical` that was updated by this mutation. */
  dataTablePermitChemical?: Maybe<DataTablePermitChemical>;
  /** An edge for our `DataTablePermitChemical`. May be used by Relay 1. */
  dataTablePermitChemicalEdge?: Maybe<DataTablePermitChemicalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTablePermitChemical` mutation. */
export type UpdateDataTablePermitChemicalPayloadDataTablePermitChemicalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePermitChemicalsOrderBy>>;
};

/** All input for the `updateDataTablePreRegisteredProductsProvisionalByNodeId` mutation. */
export type UpdateDataTablePreRegisteredProductsProvisionalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePreRegisteredProductsProvisional` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTablePreRegisteredProductsProvisional` being updated. */
  patch: DataTablePreRegisteredProductsProvisionalPatch;
};

/** All input for the `updateDataTablePreRegisteredProductsProvisional` mutation. */
export type UpdateDataTablePreRegisteredProductsProvisionalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTablePreRegisteredProductsProvisional` being updated. */
  patch: DataTablePreRegisteredProductsProvisionalPatch;
};

/** The output of our update `DataTablePreRegisteredProductsProvisional` mutation. */
export type UpdateDataTablePreRegisteredProductsProvisionalPayload = {
  __typename?: 'UpdateDataTablePreRegisteredProductsProvisionalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePreRegisteredProductsProvisional` that was updated by this mutation. */
  dataTablePreRegisteredProductsProvisional?: Maybe<DataTablePreRegisteredProductsProvisional>;
  /** An edge for our `DataTablePreRegisteredProductsProvisional`. May be used by Relay 1. */
  dataTablePreRegisteredProductsProvisionalEdge?: Maybe<DataTablePreRegisteredProductsProvisionalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTablePreRegisteredProductsProvisional` mutation. */
export type UpdateDataTablePreRegisteredProductsProvisionalPayloadDataTablePreRegisteredProductsProvisionalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePreRegisteredProductsProvisionalsOrderBy>>;
};

/** All input for the `updateDataTablePrequalManufacturerApplicationJoinByNodeId` mutation. */
export type UpdateDataTablePrequalManufacturerApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePrequalManufacturerApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTablePrequalManufacturerApplicationJoin` being updated. */
  patch: DataTablePrequalManufacturerApplicationJoinPatch;
};

/** All input for the `updateDataTablePrequalManufacturerApplicationJoin` mutation. */
export type UpdateDataTablePrequalManufacturerApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTablePrequalManufacturerApplicationJoin` being updated. */
  patch: DataTablePrequalManufacturerApplicationJoinPatch;
};

/** The output of our update `DataTablePrequalManufacturerApplicationJoin` mutation. */
export type UpdateDataTablePrequalManufacturerApplicationJoinPayload = {
  __typename?: 'UpdateDataTablePrequalManufacturerApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTablePrequalManufacturerApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTablePrequalManufacturer` that is related to this `DataTablePrequalManufacturerApplicationJoin`. */
  dataTablePrequalManufacturer?: Maybe<DataTablePrequalManufacturer>;
  /** The `DataTablePrequalManufacturerApplicationJoin` that was updated by this mutation. */
  dataTablePrequalManufacturerApplicationJoin?: Maybe<DataTablePrequalManufacturerApplicationJoin>;
  /** An edge for our `DataTablePrequalManufacturerApplicationJoin`. May be used by Relay 1. */
  dataTablePrequalManufacturerApplicationJoinEdge?: Maybe<DataTablePrequalManufacturerApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTablePrequalManufacturerApplicationJoin` mutation. */
export type UpdateDataTablePrequalManufacturerApplicationJoinPayloadDataTablePrequalManufacturerApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturerApplicationJoinsOrderBy>>;
};

/** All input for the `updateDataTablePrequalManufacturerByNodeId` mutation. */
export type UpdateDataTablePrequalManufacturerByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTablePrequalManufacturer` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTablePrequalManufacturer` being updated. */
  patch: DataTablePrequalManufacturerPatch;
};

/** All input for the `updateDataTablePrequalManufacturer` mutation. */
export type UpdateDataTablePrequalManufacturerInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTablePrequalManufacturer` being updated. */
  patch: DataTablePrequalManufacturerPatch;
};

/** The output of our update `DataTablePrequalManufacturer` mutation. */
export type UpdateDataTablePrequalManufacturerPayload = {
  __typename?: 'UpdateDataTablePrequalManufacturerPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTablePrequalManufacturer` that was updated by this mutation. */
  dataTablePrequalManufacturer?: Maybe<DataTablePrequalManufacturer>;
  /** An edge for our `DataTablePrequalManufacturer`. May be used by Relay 1. */
  dataTablePrequalManufacturerEdge?: Maybe<DataTablePrequalManufacturersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTablePrequalManufacturer` mutation. */
export type UpdateDataTablePrequalManufacturerPayloadDataTablePrequalManufacturerEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTablePrequalManufacturersOrderBy>>;
};

/** All input for the `updateDataTableProcessingStepByNodeId` mutation. */
export type UpdateDataTableProcessingStepByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProcessingStep` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProcessingStep` being updated. */
  patch: DataTableProcessingStepPatch;
};

/** All input for the `updateDataTableProcessingStep` mutation. */
export type UpdateDataTableProcessingStepInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProcessingStep` being updated. */
  patch: DataTableProcessingStepPatch;
};

/** The output of our update `DataTableProcessingStep` mutation. */
export type UpdateDataTableProcessingStepPayload = {
  __typename?: 'UpdateDataTableProcessingStepPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProcessingStep` that was updated by this mutation. */
  dataTableProcessingStep?: Maybe<DataTableProcessingStep>;
  /** An edge for our `DataTableProcessingStep`. May be used by Relay 1. */
  dataTableProcessingStepEdge?: Maybe<DataTableProcessingStepsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProcessingStep` mutation. */
export type UpdateDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProcessingStepsOrderBy>>;
};

/** All input for the `updateDataTableProductApplicationJoinByNodeId` mutation. */
export type UpdateDataTableProductApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProductApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProductApplicationJoin` being updated. */
  patch: DataTableProductApplicationJoinPatch;
};

/** All input for the `updateDataTableProductApplicationJoin` mutation. */
export type UpdateDataTableProductApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProductApplicationJoin` being updated. */
  patch: DataTableProductApplicationJoinPatch;
};

/** The output of our update `DataTableProductApplicationJoin` mutation. */
export type UpdateDataTableProductApplicationJoinPayload = {
  __typename?: 'UpdateDataTableProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProductApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProductApplicationJoin` that was updated by this mutation. */
  dataTableProductApplicationJoin?: Maybe<DataTableProductApplicationJoin>;
  /** An edge for our `DataTableProductApplicationJoin`. May be used by Relay 1. */
  dataTableProductApplicationJoinEdge?: Maybe<DataTableProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProductApplicationJoin` mutation. */
export type UpdateDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductApplicationJoinsOrderBy>>;
};

/** All input for the `updateDataTableProductByNodeId` mutation. */
export type UpdateDataTableProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProduct` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProduct` being updated. */
  patch: DataTableProductPatch;
};

/** All input for the `updateDataTableProduct` mutation. */
export type UpdateDataTableProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProduct` being updated. */
  patch: DataTableProductPatch;
};

/** The output of our update `DataTableProduct` mutation. */
export type UpdateDataTableProductPayload = {
  __typename?: 'UpdateDataTableProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProduct` that was updated by this mutation. */
  dataTableProduct?: Maybe<DataTableProduct>;
  /** An edge for our `DataTableProduct`. May be used by Relay 1. */
  dataTableProductEdge?: Maybe<DataTableProductsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProduct` mutation. */
export type UpdateDataTableProductPayloadDataTableProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProductsOrderBy>>;
};

/** All input for the `updateDataTableProvisionalProductApplicationJoinByNodeId` mutation. */
export type UpdateDataTableProvisionalProductApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProvisionalProductApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProvisionalProductApplicationJoin` being updated. */
  patch: DataTableProvisionalProductApplicationJoinPatch;
};

/** All input for the `updateDataTableProvisionalProductApplicationJoin` mutation. */
export type UpdateDataTableProvisionalProductApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProvisionalProductApplicationJoin` being updated. */
  patch: DataTableProvisionalProductApplicationJoinPatch;
};

/** The output of our update `DataTableProvisionalProductApplicationJoin` mutation. */
export type UpdateDataTableProvisionalProductApplicationJoinPayload = {
  __typename?: 'UpdateDataTableProvisionalProductApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `DataTableProvisionalProductApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `DataTableProvisionalProduct` that is related to this `DataTableProvisionalProductApplicationJoin`. */
  dataTableProvisionalProduct?: Maybe<DataTableProvisionalProduct>;
  /** The `DataTableProvisionalProductApplicationJoin` that was updated by this mutation. */
  dataTableProvisionalProductApplicationJoin?: Maybe<DataTableProvisionalProductApplicationJoin>;
  /** An edge for our `DataTableProvisionalProductApplicationJoin`. May be used by Relay 1. */
  dataTableProvisionalProductApplicationJoinEdge?: Maybe<DataTableProvisionalProductApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProvisionalProductApplicationJoin` mutation. */
export type UpdateDataTableProvisionalProductApplicationJoinPayloadDataTableProvisionalProductApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvisionalProductApplicationJoinsOrderBy>>;
};

/** All input for the `updateDataTableProvisionalProductByNodeId` mutation. */
export type UpdateDataTableProvisionalProductByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableProvisionalProduct` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableProvisionalProduct` being updated. */
  patch: DataTableProvisionalProductPatch;
};

/** All input for the `updateDataTableProvisionalProduct` mutation. */
export type UpdateDataTableProvisionalProductInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableProvisionalProduct` being updated. */
  patch: DataTableProvisionalProductPatch;
};

/** The output of our update `DataTableProvisionalProduct` mutation. */
export type UpdateDataTableProvisionalProductPayload = {
  __typename?: 'UpdateDataTableProvisionalProductPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableProvisionalProduct` that was updated by this mutation. */
  dataTableProvisionalProduct?: Maybe<DataTableProvisionalProduct>;
  /** An edge for our `DataTableProvisionalProduct`. May be used by Relay 1. */
  dataTableProvisionalProductEdge?: Maybe<DataTableProvisionalProductsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableProvisionalProduct` mutation. */
export type UpdateDataTableProvisionalProductPayloadDataTableProvisionalProductEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableProvisionalProductsOrderBy>>;
};

/** All input for the `updateDataTableScheduledChemicalByNodeId` mutation. */
export type UpdateDataTableScheduledChemicalByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableScheduledChemical` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableScheduledChemical` being updated. */
  patch: DataTableScheduledChemicalPatch;
};

/** All input for the `updateDataTableScheduledChemical` mutation. */
export type UpdateDataTableScheduledChemicalInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableScheduledChemical` being updated. */
  patch: DataTableScheduledChemicalPatch;
};

/** The output of our update `DataTableScheduledChemical` mutation. */
export type UpdateDataTableScheduledChemicalPayload = {
  __typename?: 'UpdateDataTableScheduledChemicalPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableScheduledChemical` that was updated by this mutation. */
  dataTableScheduledChemical?: Maybe<DataTableScheduledChemical>;
  /** An edge for our `DataTableScheduledChemical`. May be used by Relay 1. */
  dataTableScheduledChemicalEdge?: Maybe<DataTableScheduledChemicalsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableScheduledChemical` mutation. */
export type UpdateDataTableScheduledChemicalPayloadDataTableScheduledChemicalEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableScheduledChemicalsOrderBy>>;
};

/** All input for the `updateDataTableStorageConditionByNodeId` mutation. */
export type UpdateDataTableStorageConditionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableStorageCondition` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableStorageCondition` being updated. */
  patch: DataTableStorageConditionPatch;
};

/** All input for the `updateDataTableStorageCondition` mutation. */
export type UpdateDataTableStorageConditionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableStorageCondition` being updated. */
  patch: DataTableStorageConditionPatch;
};

/** The output of our update `DataTableStorageCondition` mutation. */
export type UpdateDataTableStorageConditionPayload = {
  __typename?: 'UpdateDataTableStorageConditionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageCondition` that was updated by this mutation. */
  dataTableStorageCondition?: Maybe<DataTableStorageCondition>;
  /** An edge for our `DataTableStorageCondition`. May be used by Relay 1. */
  dataTableStorageConditionEdge?: Maybe<DataTableStorageConditionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableStorageCondition` mutation. */
export type UpdateDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsOrderBy>>;
};

/** All input for the `updateDataTableStorageConditionsSimplifiedByNodeId` mutation. */
export type UpdateDataTableStorageConditionsSimplifiedByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableStorageConditionsSimplified` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableStorageConditionsSimplified` being updated. */
  patch: DataTableStorageConditionsSimplifiedPatch;
};

/** All input for the `updateDataTableStorageConditionsSimplified` mutation. */
export type UpdateDataTableStorageConditionsSimplifiedInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableStorageConditionsSimplified` being updated. */
  patch: DataTableStorageConditionsSimplifiedPatch;
};

/** The output of our update `DataTableStorageConditionsSimplified` mutation. */
export type UpdateDataTableStorageConditionsSimplifiedPayload = {
  __typename?: 'UpdateDataTableStorageConditionsSimplifiedPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableStorageConditionsSimplified` that was updated by this mutation. */
  dataTableStorageConditionsSimplified?: Maybe<DataTableStorageConditionsSimplified>;
  /** An edge for our `DataTableStorageConditionsSimplified`. May be used by Relay 1. */
  dataTableStorageConditionsSimplifiedEdge?: Maybe<DataTableStorageConditionsSimplifiedsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableStorageConditionsSimplified` mutation. */
export type UpdateDataTableStorageConditionsSimplifiedPayloadDataTableStorageConditionsSimplifiedEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableStorageConditionsSimplifiedsOrderBy>>;
};

/** All input for the `updateDataTableUnitsOfProportionByNodeId` mutation. */
export type UpdateDataTableUnitsOfProportionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableUnitsOfProportion` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableUnitsOfProportion` being updated. */
  patch: DataTableUnitsOfProportionPatch;
};

/** All input for the `updateDataTableUnitsOfProportion` mutation. */
export type UpdateDataTableUnitsOfProportionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableUnitsOfProportion` being updated. */
  patch: DataTableUnitsOfProportionPatch;
};

/** The output of our update `DataTableUnitsOfProportion` mutation. */
export type UpdateDataTableUnitsOfProportionPayload = {
  __typename?: 'UpdateDataTableUnitsOfProportionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableUnitsOfProportion` that was updated by this mutation. */
  dataTableUnitsOfProportion?: Maybe<DataTableUnitsOfProportion>;
  /** An edge for our `DataTableUnitsOfProportion`. May be used by Relay 1. */
  dataTableUnitsOfProportionEdge?: Maybe<DataTableUnitsOfProportionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableUnitsOfProportion` mutation. */
export type UpdateDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableUnitsOfProportionsOrderBy>>;
};

/** All input for the `updateDataTableWorldHealthOrganisationPqListOfFppByNodeId` mutation. */
export type UpdateDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataTableWorldHealthOrganisationPqListOfFpp` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataTableWorldHealthOrganisationPqListOfFpp` being updated. */
  patch: DataTableWorldHealthOrganisationPqListOfFppPatch;
};

/** All input for the `updateDataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type UpdateDataTableWorldHealthOrganisationPqListOfFppInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataTableWorldHealthOrganisationPqListOfFpp` being updated. */
  patch: DataTableWorldHealthOrganisationPqListOfFppPatch;
};

/** The output of our update `DataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type UpdateDataTableWorldHealthOrganisationPqListOfFppPayload = {
  __typename?: 'UpdateDataTableWorldHealthOrganisationPqListOfFppPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataTableWorldHealthOrganisationPqListOfFpp` that was updated by this mutation. */
  dataTableWorldHealthOrganisationPqListOfFpp?: Maybe<DataTableWorldHealthOrganisationPqListOfFpp>;
  /** An edge for our `DataTableWorldHealthOrganisationPqListOfFpp`. May be used by Relay 1. */
  dataTableWorldHealthOrganisationPqListOfFppEdge?: Maybe<DataTableWorldHealthOrganisationPqListOfFppsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataTableWorldHealthOrganisationPqListOfFpp` mutation. */
export type UpdateDataTableWorldHealthOrganisationPqListOfFppPayloadDataTableWorldHealthOrganisationPqListOfFppEdgeArgs = {
  orderBy?: InputMaybe<Array<DataTableWorldHealthOrganisationPqListOfFppsOrderBy>>;
};

/** All input for the `updateDataViewByIdentifier` mutation. */
export type UpdateDataViewByIdentifierInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  identifier: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `DataView` being updated. */
  patch: DataViewPatch;
};

/** All input for the `updateDataViewByNodeId` mutation. */
export type UpdateDataViewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataView` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataView` being updated. */
  patch: DataViewPatch;
};

/** All input for the `updateDataViewColumnDefinitionByNodeId` mutation. */
export type UpdateDataViewColumnDefinitionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `DataViewColumnDefinition` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `DataViewColumnDefinition` being updated. */
  patch: DataViewColumnDefinitionPatch;
};

/** All input for the `updateDataViewColumnDefinitionByTableNameAndColumnName` mutation. */
export type UpdateDataViewColumnDefinitionByTableNameAndColumnNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  columnName: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `DataViewColumnDefinition` being updated. */
  patch: DataViewColumnDefinitionPatch;
  tableName: Scalars['String']['input'];
};

/** All input for the `updateDataViewColumnDefinition` mutation. */
export type UpdateDataViewColumnDefinitionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataViewColumnDefinition` being updated. */
  patch: DataViewColumnDefinitionPatch;
};

/** The output of our update `DataViewColumnDefinition` mutation. */
export type UpdateDataViewColumnDefinitionPayload = {
  __typename?: 'UpdateDataViewColumnDefinitionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataViewColumnDefinition` that was updated by this mutation. */
  dataViewColumnDefinition?: Maybe<DataViewColumnDefinition>;
  /** An edge for our `DataViewColumnDefinition`. May be used by Relay 1. */
  dataViewColumnDefinitionEdge?: Maybe<DataViewColumnDefinitionsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataViewColumnDefinition` mutation. */
export type UpdateDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewColumnDefinitionsOrderBy>>;
};

/** All input for the `updateDataView` mutation. */
export type UpdateDataViewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `DataView` being updated. */
  patch: DataViewPatch;
};

/** The output of our update `DataView` mutation. */
export type UpdateDataViewPayload = {
  __typename?: 'UpdateDataViewPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `DataView` that was updated by this mutation. */
  dataView?: Maybe<DataView>;
  /** An edge for our `DataView`. May be used by Relay 1. */
  dataViewEdge?: Maybe<DataViewsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `DataView` mutation. */
export type UpdateDataViewPayloadDataViewEdgeArgs = {
  orderBy?: InputMaybe<Array<DataViewsOrderBy>>;
};

/** All input for the `updateElementTypePluginByNodeId` mutation. */
export type UpdateElementTypePluginByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ElementTypePlugin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ElementTypePlugin` being updated. */
  patch: ElementTypePluginPatch;
};

/** All input for the `updateElementTypePlugin` mutation. */
export type UpdateElementTypePluginInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `ElementTypePlugin` being updated. */
  patch: ElementTypePluginPatch;
};

/** The output of our update `ElementTypePlugin` mutation. */
export type UpdateElementTypePluginPayload = {
  __typename?: 'UpdateElementTypePluginPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `ElementTypePlugin` that was updated by this mutation. */
  elementTypePlugin?: Maybe<ElementTypePlugin>;
  /** An edge for our `ElementTypePlugin`. May be used by Relay 1. */
  elementTypePluginEdge?: Maybe<ElementTypePluginsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `ElementTypePlugin` mutation. */
export type UpdateElementTypePluginPayloadElementTypePluginEdgeArgs = {
  orderBy?: InputMaybe<Array<ElementTypePluginsOrderBy>>;
};

/** All input for the `updateFileByNodeId` mutation. */
export type UpdateFileByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `File` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
};

/** All input for the `updateFileByUniqueId` mutation. */
export type UpdateFileByUniqueIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
  uniqueId: Scalars['String']['input'];
};

/** All input for the `updateFile` mutation. */
export type UpdateFileInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `File` being updated. */
  patch: FilePatch;
};

/** The output of our update `File` mutation. */
export type UpdateFilePayload = {
  __typename?: 'UpdateFilePayload';
  /** Reads a single `Application` that is related to this `File`. */
  applicationByApplicationSerial?: Maybe<Application>;
  /** Reads a single `ApplicationNote` that is related to this `File`. */
  applicationNote?: Maybe<ApplicationNote>;
  /** Reads a single `ApplicationResponse` that is related to this `File`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `File` that was updated by this mutation. */
  file?: Maybe<File>;
  /** An edge for our `File`. May be used by Relay 1. */
  fileEdge?: Maybe<FilesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `File`. */
  template?: Maybe<Template>;
};


/** The output of our update `File` mutation. */
export type UpdateFilePayloadFileEdgeArgs = {
  orderBy?: InputMaybe<Array<FilesOrderBy>>;
};

/** All input for the `updateFilterByCode` mutation. */
export type UpdateFilterByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Filter` being updated. */
  patch: FilterPatch;
};

/** All input for the `updateFilterByNodeId` mutation. */
export type UpdateFilterByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Filter` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Filter` being updated. */
  patch: FilterPatch;
};

/** All input for the `updateFilter` mutation. */
export type UpdateFilterInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Filter` being updated. */
  patch: FilterPatch;
};

/** The output of our update `Filter` mutation. */
export type UpdateFilterPayload = {
  __typename?: 'UpdateFilterPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Filter` that was updated by this mutation. */
  filter?: Maybe<Filter>;
  /** An edge for our `Filter`. May be used by Relay 1. */
  filterEdge?: Maybe<FiltersEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Filter` mutation. */
export type UpdateFilterPayloadFilterEdgeArgs = {
  orderBy?: InputMaybe<Array<FiltersOrderBy>>;
};

/** All input for the `updateGrafanaDashboardImageByNodeId` mutation. */
export type UpdateGrafanaDashboardImageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `GrafanaDashboardImage` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `GrafanaDashboardImage` being updated. */
  patch: GrafanaDashboardImagePatch;
};

/** All input for the `updateGrafanaDashboardImage` mutation. */
export type UpdateGrafanaDashboardImageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `GrafanaDashboardImage` being updated. */
  patch: GrafanaDashboardImagePatch;
};

/** The output of our update `GrafanaDashboardImage` mutation. */
export type UpdateGrafanaDashboardImagePayload = {
  __typename?: 'UpdateGrafanaDashboardImagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `GrafanaDashboardImage` that was updated by this mutation. */
  grafanaDashboardImage?: Maybe<GrafanaDashboardImage>;
  /** An edge for our `GrafanaDashboardImage`. May be used by Relay 1. */
  grafanaDashboardImageEdge?: Maybe<GrafanaDashboardImagesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `GrafanaDashboardImage` mutation. */
export type UpdateGrafanaDashboardImagePayloadGrafanaDashboardImageEdgeArgs = {
  orderBy?: InputMaybe<Array<GrafanaDashboardImagesOrderBy>>;
};

/** All input for the `updateNotificationByNodeId` mutation. */
export type UpdateNotificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Notification` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
};

/** All input for the `updateNotification` mutation. */
export type UpdateNotificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Notification` being updated. */
  patch: NotificationPatch;
};

/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayload = {
  __typename?: 'UpdateNotificationPayload';
  /** Reads a single `Application` that is related to this `Notification`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Notification` that was updated by this mutation. */
  notification?: Maybe<Notification>;
  /** An edge for our `Notification`. May be used by Relay 1. */
  notificationEdge?: Maybe<NotificationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `Notification`. */
  review?: Maybe<Review>;
};


/** The output of our update `Notification` mutation. */
export type UpdateNotificationPayloadNotificationEdgeArgs = {
  orderBy?: InputMaybe<Array<NotificationsOrderBy>>;
};

/** All input for the `updateOrganisationApplicationJoinByNodeId` mutation. */
export type UpdateOrganisationApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `OrganisationApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `OrganisationApplicationJoin` being updated. */
  patch: OrganisationApplicationJoinPatch;
};

/** All input for the `updateOrganisationApplicationJoin` mutation. */
export type UpdateOrganisationApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `OrganisationApplicationJoin` being updated. */
  patch: OrganisationApplicationJoinPatch;
};

/** The output of our update `OrganisationApplicationJoin` mutation. */
export type UpdateOrganisationApplicationJoinPayload = {
  __typename?: 'UpdateOrganisationApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `OrganisationApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `OrganisationApplicationJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `OrganisationApplicationJoin` that was updated by this mutation. */
  organisationApplicationJoin?: Maybe<OrganisationApplicationJoin>;
  /** An edge for our `OrganisationApplicationJoin`. May be used by Relay 1. */
  organisationApplicationJoinEdge?: Maybe<OrganisationApplicationJoinsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `OrganisationApplicationJoin` mutation. */
export type UpdateOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationApplicationJoinsOrderBy>>;
};

/** All input for the `updateOrganisationByName` mutation. */
export type UpdateOrganisationByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
};

/** All input for the `updateOrganisationByNodeId` mutation. */
export type UpdateOrganisationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Organisation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
};

/** All input for the `updateOrganisationByRegistration` mutation. */
export type UpdateOrganisationByRegistrationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
  registration: Scalars['String']['input'];
};

/** All input for the `updateOrganisation` mutation. */
export type UpdateOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Organisation` being updated. */
  patch: OrganisationPatch;
};

/** The output of our update `Organisation` mutation. */
export type UpdateOrganisationPayload = {
  __typename?: 'UpdateOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `Organisation` that was updated by this mutation. */
  organisation?: Maybe<Organisation>;
  /** An edge for our `Organisation`. May be used by Relay 1. */
  organisationEdge?: Maybe<OrganisationsEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `Organisation` mutation. */
export type UpdateOrganisationPayloadOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<OrganisationsOrderBy>>;
};

/** All input for the `updatePermissionJoinByNodeId` mutation. */
export type UpdatePermissionJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PermissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** All input for the `updatePermissionJoin` mutation. */
export type UpdatePermissionJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `PermissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The output of our update `PermissionJoin` mutation. */
export type UpdatePermissionJoinPayload = {
  __typename?: 'UpdatePermissionJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `PermissionJoin`. */
  organisation?: Maybe<Organisation>;
  /** The `PermissionJoin` that was updated by this mutation. */
  permissionJoin?: Maybe<PermissionJoin>;
  /** An edge for our `PermissionJoin`. May be used by Relay 1. */
  permissionJoinEdge?: Maybe<PermissionJoinsEdge>;
  /** Reads a single `PermissionName` that is related to this `PermissionJoin`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `UserList` that is related to this `PermissionJoin`. */
  user?: Maybe<UserList>;
};


/** The output of our update `PermissionJoin` mutation. */
export type UpdatePermissionJoinPayloadPermissionJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};

/** All input for the `updatePermissionNameByName` mutation. */
export type UpdatePermissionNameByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
};

/** All input for the `updatePermissionNameByNodeId` mutation. */
export type UpdatePermissionNameByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionName` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
};

/** All input for the `updatePermissionName` mutation. */
export type UpdatePermissionNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `PermissionName` being updated. */
  patch: PermissionNamePatch;
};

/** The output of our update `PermissionName` mutation. */
export type UpdatePermissionNamePayload = {
  __typename?: 'UpdatePermissionNamePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PermissionName` that was updated by this mutation. */
  permissionName?: Maybe<PermissionName>;
  /** An edge for our `PermissionName`. May be used by Relay 1. */
  permissionNameEdge?: Maybe<PermissionNamesEdge>;
  /** Reads a single `PermissionPolicy` that is related to this `PermissionName`. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PermissionName` mutation. */
export type UpdatePermissionNamePayloadPermissionNameEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionNamesOrderBy>>;
};

/** All input for the `updatePermissionPolicyByName` mutation. */
export type UpdatePermissionPolicyByNameInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `PermissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** All input for the `updatePermissionPolicyByNodeId` mutation. */
export type UpdatePermissionPolicyByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `PermissionPolicy` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `PermissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** All input for the `updatePermissionPolicy` mutation. */
export type UpdatePermissionPolicyInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `PermissionPolicy` being updated. */
  patch: PermissionPolicyPatch;
};

/** The output of our update `PermissionPolicy` mutation. */
export type UpdatePermissionPolicyPayload = {
  __typename?: 'UpdatePermissionPolicyPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** The `PermissionPolicy` that was updated by this mutation. */
  permissionPolicy?: Maybe<PermissionPolicy>;
  /** An edge for our `PermissionPolicy`. May be used by Relay 1. */
  permissionPolicyEdge?: Maybe<PermissionPoliciesEdge>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
};


/** The output of our update `PermissionPolicy` mutation. */
export type UpdatePermissionPolicyPayloadPermissionPolicyEdgeArgs = {
  orderBy?: InputMaybe<Array<PermissionPoliciesOrderBy>>;
};

/** All input for the `updateReviewAssignmentAssignerJoinByNodeId` mutation. */
export type UpdateReviewAssignmentAssignerJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignmentAssignerJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** All input for the `updateReviewAssignmentAssignerJoin` mutation. */
export type UpdateReviewAssignmentAssignerJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** The output of our update `ReviewAssignmentAssignerJoin` mutation. */
export type UpdateReviewAssignmentAssignerJoinPayload = {
  __typename?: 'UpdateReviewAssignmentAssignerJoinPayload';
  /** Reads a single `UserList` that is related to this `ReviewAssignmentAssignerJoin`. */
  assigner?: Maybe<UserList>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignmentAssignerJoin`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `ReviewAssignment` that is related to this `ReviewAssignmentAssignerJoin`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** The `ReviewAssignmentAssignerJoin` that was updated by this mutation. */
  reviewAssignmentAssignerJoin?: Maybe<ReviewAssignmentAssignerJoin>;
  /** An edge for our `ReviewAssignmentAssignerJoin`. May be used by Relay 1. */
  reviewAssignmentAssignerJoinEdge?: Maybe<ReviewAssignmentAssignerJoinsEdge>;
};


/** The output of our update `ReviewAssignmentAssignerJoin` mutation. */
export type UpdateReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};

/** All input for the `updateReviewAssignmentByNodeId` mutation. */
export type UpdateReviewAssignmentByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewAssignment` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** All input for the `updateReviewAssignment` mutation. */
export type UpdateReviewAssignmentInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The output of our update `ReviewAssignment` mutation. */
export type UpdateReviewAssignmentPayload = {
  __typename?: 'UpdateReviewAssignmentPayload';
  /** Reads a single `Application` that is related to this `ReviewAssignment`. */
  application?: Maybe<Application>;
  /** Reads a single `UserList` that is related to this `ReviewAssignment`. */
  assigner?: Maybe<UserList>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `TemplateStageReviewLevel` that is related to this `ReviewAssignment`. */
  level?: Maybe<TemplateStageReviewLevel>;
  /** Reads a single `Organisation` that is related to this `ReviewAssignment`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `ReviewAssignment` that was updated by this mutation. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `ReviewAssignment`. May be used by Relay 1. */
  reviewAssignmentEdge?: Maybe<ReviewAssignmentsEdge>;
  /** Reads a single `UserList` that is related to this `ReviewAssignment`. */
  reviewer?: Maybe<UserList>;
  /** Reads a single `TemplateStage` that is related to this `ReviewAssignment`. */
  stage?: Maybe<TemplateStage>;
  /** Reads a single `Template` that is related to this `ReviewAssignment`. */
  template?: Maybe<Template>;
};


/** The output of our update `ReviewAssignment` mutation. */
export type UpdateReviewAssignmentPayloadReviewAssignmentEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};

/** All input for the `updateReviewByNodeId` mutation. */
export type UpdateReviewByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Review` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Review` being updated. */
  patch: ReviewPatch;
};

/** All input for the `updateReviewByReviewAssignmentId` mutation. */
export type UpdateReviewByReviewAssignmentIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Review` being updated. */
  patch: ReviewPatch;
  reviewAssignmentId: Scalars['Int']['input'];
};

/** All input for the `updateReviewDecisionByNodeId` mutation. */
export type UpdateReviewDecisionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewDecision` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewDecision` being updated. */
  patch: ReviewDecisionPatch;
};

/** All input for the `updateReviewDecision` mutation. */
export type UpdateReviewDecisionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewDecision` being updated. */
  patch: ReviewDecisionPatch;
};

/** The output of our update `ReviewDecision` mutation. */
export type UpdateReviewDecisionPayload = {
  __typename?: 'UpdateReviewDecisionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewDecision`. */
  review?: Maybe<Review>;
  /** The `ReviewDecision` that was updated by this mutation. */
  reviewDecision?: Maybe<ReviewDecision>;
  /** An edge for our `ReviewDecision`. May be used by Relay 1. */
  reviewDecisionEdge?: Maybe<ReviewDecisionsEdge>;
};


/** The output of our update `ReviewDecision` mutation. */
export type UpdateReviewDecisionPayloadReviewDecisionEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewDecisionsOrderBy>>;
};

/** All input for the `updateReview` mutation. */
export type UpdateReviewInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Review` being updated. */
  patch: ReviewPatch;
};

/** The output of our update `Review` mutation. */
export type UpdateReviewPayload = {
  __typename?: 'UpdateReviewPayload';
  /** Reads a single `Application` that is related to this `Review`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Review` that was updated by this mutation. */
  review?: Maybe<Review>;
  /** Reads a single `ReviewAssignment` that is related to this `Review`. */
  reviewAssignment?: Maybe<ReviewAssignment>;
  /** An edge for our `Review`. May be used by Relay 1. */
  reviewEdge?: Maybe<ReviewsEdge>;
  /** Reads a single `UserList` that is related to this `Review`. */
  reviewer?: Maybe<UserList>;
};


/** The output of our update `Review` mutation. */
export type UpdateReviewPayloadReviewEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/** All input for the `updateReviewResponseByNodeId` mutation. */
export type UpdateReviewResponseByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewResponse` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** All input for the `updateReviewResponse` mutation. */
export type UpdateReviewResponseInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewResponse` being updated. */
  patch: ReviewResponsePatch;
};

/** The output of our update `ReviewResponse` mutation. */
export type UpdateReviewResponsePayload = {
  __typename?: 'UpdateReviewResponsePayload';
  /** Reads a single `ApplicationResponse` that is related to this `ReviewResponse`. */
  applicationResponse?: Maybe<ApplicationResponse>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  originalReviewResponse?: Maybe<ReviewResponse>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewResponse`. */
  review?: Maybe<Review>;
  /** The `ReviewResponse` that was updated by this mutation. */
  reviewResponse?: Maybe<ReviewResponse>;
  /** An edge for our `ReviewResponse`. May be used by Relay 1. */
  reviewResponseEdge?: Maybe<ReviewResponsesEdge>;
  /** Reads a single `ReviewResponse` that is related to this `ReviewResponse`. */
  reviewResponseLink?: Maybe<ReviewResponse>;
  /** Reads a single `TemplateElement` that is related to this `ReviewResponse`. */
  templateElement?: Maybe<TemplateElement>;
};


/** The output of our update `ReviewResponse` mutation. */
export type UpdateReviewResponsePayloadReviewResponseEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewResponsesOrderBy>>;
};

/** All input for the `updateReviewStatusHistoryByNodeId` mutation. */
export type UpdateReviewStatusHistoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `ReviewStatusHistory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `ReviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
};

/** All input for the `updateReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `ReviewStatusHistory` being updated. */
  patch: ReviewStatusHistoryPatch;
};

/** The output of our update `ReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryPayload = {
  __typename?: 'UpdateReviewStatusHistoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Review` that is related to this `ReviewStatusHistory`. */
  review?: Maybe<Review>;
  /** The `ReviewStatusHistory` that was updated by this mutation. */
  reviewStatusHistory?: Maybe<ReviewStatusHistory>;
  /** An edge for our `ReviewStatusHistory`. May be used by Relay 1. */
  reviewStatusHistoryEdge?: Maybe<ReviewStatusHistoriesEdge>;
};


/** The output of our update `ReviewStatusHistory` mutation. */
export type UpdateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs = {
  orderBy?: InputMaybe<Array<ReviewStatusHistoriesOrderBy>>;
};

/** All input for the `updateSystemInfoByNodeId` mutation. */
export type UpdateSystemInfoByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `SystemInfo` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `SystemInfo` being updated. */
  patch: SystemInfoPatch;
};

/** All input for the `updateSystemInfo` mutation. */
export type UpdateSystemInfoInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `SystemInfo` being updated. */
  patch: SystemInfoPatch;
};

/** The output of our update `SystemInfo` mutation. */
export type UpdateSystemInfoPayload = {
  __typename?: 'UpdateSystemInfoPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `SystemInfo` that was updated by this mutation. */
  systemInfo?: Maybe<SystemInfo>;
  /** An edge for our `SystemInfo`. May be used by Relay 1. */
  systemInfoEdge?: Maybe<SystemInfosEdge>;
};


/** The output of our update `SystemInfo` mutation. */
export type UpdateSystemInfoPayloadSystemInfoEdgeArgs = {
  orderBy?: InputMaybe<Array<SystemInfosOrderBy>>;
};

/** All input for the `updateTemplateActionByNodeId` mutation. */
export type UpdateTemplateActionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateAction` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateAction` being updated. */
  patch: TemplateActionPatch;
};

/** All input for the `updateTemplateAction` mutation. */
export type UpdateTemplateActionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateAction` being updated. */
  patch: TemplateActionPatch;
};

/** The output of our update `TemplateAction` mutation. */
export type UpdateTemplateActionPayload = {
  __typename?: 'UpdateTemplateActionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateAction`. */
  template?: Maybe<Template>;
  /** The `TemplateAction` that was updated by this mutation. */
  templateAction?: Maybe<TemplateAction>;
  /** An edge for our `TemplateAction`. May be used by Relay 1. */
  templateActionEdge?: Maybe<TemplateActionsEdge>;
};


/** The output of our update `TemplateAction` mutation. */
export type UpdateTemplateActionPayloadTemplateActionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateActionsOrderBy>>;
};

/** All input for the `updateTemplateByCodeAndVersionId` mutation. */
export type UpdateTemplateByCodeAndVersionIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  patch: TemplatePatch;
  versionId: Scalars['String']['input'];
};

/** All input for the `updateTemplateByNodeId` mutation. */
export type UpdateTemplateByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Template` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  patch: TemplatePatch;
};

/** All input for the `updateTemplateCategoryByCode` mutation. */
export type UpdateTemplateCategoryByCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `TemplateCategory` being updated. */
  patch: TemplateCategoryPatch;
};

/** All input for the `updateTemplateCategoryByNodeId` mutation. */
export type UpdateTemplateCategoryByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateCategory` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateCategory` being updated. */
  patch: TemplateCategoryPatch;
};

/** All input for the `updateTemplateCategory` mutation. */
export type UpdateTemplateCategoryInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateCategory` being updated. */
  patch: TemplateCategoryPatch;
};

/** The output of our update `TemplateCategory` mutation. */
export type UpdateTemplateCategoryPayload = {
  __typename?: 'UpdateTemplateCategoryPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TemplateCategory` that was updated by this mutation. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `TemplateCategory`. May be used by Relay 1. */
  templateCategoryEdge?: Maybe<TemplateCategoriesEdge>;
};


/** The output of our update `TemplateCategory` mutation. */
export type UpdateTemplateCategoryPayloadTemplateCategoryEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateCategoriesOrderBy>>;
};

/** All input for the `updateTemplateElementByNodeId` mutation. */
export type UpdateTemplateElementByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateElement` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateElement` being updated. */
  patch: TemplateElementPatch;
};

/** All input for the `updateTemplateElementByTemplateCodeAndCodeAndTemplateVersion` mutation. */
export type UpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `TemplateElement` being updated. */
  patch: TemplateElementPatch;
  templateCode: Scalars['String']['input'];
  templateVersion: Scalars['String']['input'];
};

/** All input for the `updateTemplateElement` mutation. */
export type UpdateTemplateElementInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateElement` being updated. */
  patch: TemplateElementPatch;
};

/** The output of our update `TemplateElement` mutation. */
export type UpdateTemplateElementPayload = {
  __typename?: 'UpdateTemplateElementPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateSection` that is related to this `TemplateElement`. */
  section?: Maybe<TemplateSection>;
  /** The `TemplateElement` that was updated by this mutation. */
  templateElement?: Maybe<TemplateElement>;
  /** An edge for our `TemplateElement`. May be used by Relay 1. */
  templateElementEdge?: Maybe<TemplateElementsEdge>;
};


/** The output of our update `TemplateElement` mutation. */
export type UpdateTemplateElementPayloadTemplateElementEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateElementsOrderBy>>;
};

/** All input for the `updateTemplateFilterJoinByNodeId` mutation. */
export type UpdateTemplateFilterJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateFilterJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateFilterJoin` being updated. */
  patch: TemplateFilterJoinPatch;
};

/** All input for the `updateTemplateFilterJoin` mutation. */
export type UpdateTemplateFilterJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateFilterJoin` being updated. */
  patch: TemplateFilterJoinPatch;
};

/** The output of our update `TemplateFilterJoin` mutation. */
export type UpdateTemplateFilterJoinPayload = {
  __typename?: 'UpdateTemplateFilterJoinPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Filter` that is related to this `TemplateFilterJoin`. */
  filter?: Maybe<Filter>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateFilterJoin`. */
  template?: Maybe<Template>;
  /** The `TemplateFilterJoin` that was updated by this mutation. */
  templateFilterJoin?: Maybe<TemplateFilterJoin>;
  /** An edge for our `TemplateFilterJoin`. May be used by Relay 1. */
  templateFilterJoinEdge?: Maybe<TemplateFilterJoinsEdge>;
};


/** The output of our update `TemplateFilterJoin` mutation. */
export type UpdateTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateFilterJoinsOrderBy>>;
};

/** All input for the `updateTemplate` mutation. */
export type UpdateTemplateInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Template` being updated. */
  patch: TemplatePatch;
};

/** The output of our update `Template` mutation. */
export type UpdateTemplatePayload = {
  __typename?: 'UpdateTemplatePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Template` that was updated by this mutation. */
  template?: Maybe<Template>;
  /** Reads a single `TemplateCategory` that is related to this `Template`. */
  templateCategory?: Maybe<TemplateCategory>;
  /** An edge for our `Template`. May be used by Relay 1. */
  templateEdge?: Maybe<TemplatesEdge>;
};


/** The output of our update `Template` mutation. */
export type UpdateTemplatePayloadTemplateEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatesOrderBy>>;
};

/** All input for the `updateTemplatePermissionByNodeId` mutation. */
export type UpdateTemplatePermissionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplatePermission` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** All input for the `updateTemplatePermission` mutation. */
export type UpdateTemplatePermissionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplatePermission` being updated. */
  patch: TemplatePermissionPatch;
};

/** The output of our update `TemplatePermission` mutation. */
export type UpdateTemplatePermissionPayload = {
  __typename?: 'UpdateTemplatePermissionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `PermissionName` that is related to this `TemplatePermission`. */
  permissionName?: Maybe<PermissionName>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplatePermission`. */
  template?: Maybe<Template>;
  /** The `TemplatePermission` that was updated by this mutation. */
  templatePermission?: Maybe<TemplatePermission>;
  /** An edge for our `TemplatePermission`. May be used by Relay 1. */
  templatePermissionEdge?: Maybe<TemplatePermissionsEdge>;
};


/** The output of our update `TemplatePermission` mutation. */
export type UpdateTemplatePermissionPayloadTemplatePermissionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplatePermissionsOrderBy>>;
};

/** All input for the `updateTemplateSectionByNodeId` mutation. */
export type UpdateTemplateSectionByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateSection` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** All input for the `updateTemplateSectionByTemplateIdAndCode` mutation. */
export type UpdateTemplateSectionByTemplateIdAndCodeInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  code: Scalars['String']['input'];
  /** An object where the defined keys will be set on the `TemplateSection` being updated. */
  patch: TemplateSectionPatch;
  templateId: Scalars['Int']['input'];
};

/** All input for the `updateTemplateSection` mutation. */
export type UpdateTemplateSectionInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateSection` being updated. */
  patch: TemplateSectionPatch;
};

/** The output of our update `TemplateSection` mutation. */
export type UpdateTemplateSectionPayload = {
  __typename?: 'UpdateTemplateSectionPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateSection`. */
  template?: Maybe<Template>;
  /** The `TemplateSection` that was updated by this mutation. */
  templateSection?: Maybe<TemplateSection>;
  /** An edge for our `TemplateSection`. May be used by Relay 1. */
  templateSectionEdge?: Maybe<TemplateSectionsEdge>;
};


/** The output of our update `TemplateSection` mutation. */
export type UpdateTemplateSectionPayloadTemplateSectionEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateSectionsOrderBy>>;
};

/** All input for the `updateTemplateStageByNodeId` mutation. */
export type UpdateTemplateStageByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateStage` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateStage` being updated. */
  patch: TemplateStagePatch;
};

/** All input for the `updateTemplateStage` mutation. */
export type UpdateTemplateStageInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateStage` being updated. */
  patch: TemplateStagePatch;
};

/** The output of our update `TemplateStage` mutation. */
export type UpdateTemplateStagePayload = {
  __typename?: 'UpdateTemplateStagePayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TemplateStage`. */
  template?: Maybe<Template>;
  /** The `TemplateStage` that was updated by this mutation. */
  templateStage?: Maybe<TemplateStage>;
  /** An edge for our `TemplateStage`. May be used by Relay 1. */
  templateStageEdge?: Maybe<TemplateStagesEdge>;
};


/** The output of our update `TemplateStage` mutation. */
export type UpdateTemplateStagePayloadTemplateStageEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStagesOrderBy>>;
};

/** All input for the `updateTemplateStageReviewLevelByNodeId` mutation. */
export type UpdateTemplateStageReviewLevelByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TemplateStageReviewLevel` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TemplateStageReviewLevel` being updated. */
  patch: TemplateStageReviewLevelPatch;
};

/** All input for the `updateTemplateStageReviewLevel` mutation. */
export type UpdateTemplateStageReviewLevelInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TemplateStageReviewLevel` being updated. */
  patch: TemplateStageReviewLevelPatch;
};

/** The output of our update `TemplateStageReviewLevel` mutation. */
export type UpdateTemplateStageReviewLevelPayload = {
  __typename?: 'UpdateTemplateStageReviewLevelPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `TemplateStage` that is related to this `TemplateStageReviewLevel`. */
  stage?: Maybe<TemplateStage>;
  /** The `TemplateStageReviewLevel` that was updated by this mutation. */
  templateStageReviewLevel?: Maybe<TemplateStageReviewLevel>;
  /** An edge for our `TemplateStageReviewLevel`. May be used by Relay 1. */
  templateStageReviewLevelEdge?: Maybe<TemplateStageReviewLevelsEdge>;
};


/** The output of our update `TemplateStageReviewLevel` mutation. */
export type UpdateTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs = {
  orderBy?: InputMaybe<Array<TemplateStageReviewLevelsOrderBy>>;
};

/** All input for the `updateTriggerQueueByNodeId` mutation. */
export type UpdateTriggerQueueByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TriggerQueue` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TriggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** All input for the `updateTriggerQueue` mutation. */
export type UpdateTriggerQueueInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TriggerQueue` being updated. */
  patch: TriggerQueuePatch;
};

/** The output of our update `TriggerQueue` mutation. */
export type UpdateTriggerQueuePayload = {
  __typename?: 'UpdateTriggerQueuePayload';
  /** Reads a single `Application` that is related to this `TriggerQueue`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `TriggerQueue` that was updated by this mutation. */
  triggerQueue?: Maybe<TriggerQueue>;
  /** An edge for our `TriggerQueue`. May be used by Relay 1. */
  triggerQueueEdge?: Maybe<TriggerQueuesEdge>;
};


/** The output of our update `TriggerQueue` mutation. */
export type UpdateTriggerQueuePayloadTriggerQueueEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerQueuesOrderBy>>;
};

/** All input for the `updateTriggerScheduleByNodeId` mutation. */
export type UpdateTriggerScheduleByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `TriggerSchedule` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `TriggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** All input for the `updateTriggerSchedule` mutation. */
export type UpdateTriggerScheduleInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `TriggerSchedule` being updated. */
  patch: TriggerSchedulePatch;
};

/** The output of our update `TriggerSchedule` mutation. */
export type UpdateTriggerSchedulePayload = {
  __typename?: 'UpdateTriggerSchedulePayload';
  /** Reads a single `Application` that is related to this `TriggerSchedule`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `Template` that is related to this `TriggerSchedule`. */
  template?: Maybe<Template>;
  /** The `TriggerSchedule` that was updated by this mutation. */
  triggerSchedule?: Maybe<TriggerSchedule>;
  /** An edge for our `TriggerSchedule`. May be used by Relay 1. */
  triggerScheduleEdge?: Maybe<TriggerSchedulesEdge>;
};


/** The output of our update `TriggerSchedule` mutation. */
export type UpdateTriggerSchedulePayloadTriggerScheduleEdgeArgs = {
  orderBy?: InputMaybe<Array<TriggerSchedulesOrderBy>>;
};

/** All input for the `updateUserApplicationJoinByNodeId` mutation. */
export type UpdateUserApplicationJoinByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserApplicationJoin` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserApplicationJoin` being updated. */
  patch: UserApplicationJoinPatch;
};

/** All input for the `updateUserApplicationJoin` mutation. */
export type UpdateUserApplicationJoinInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserApplicationJoin` being updated. */
  patch: UserApplicationJoinPatch;
};

/** The output of our update `UserApplicationJoin` mutation. */
export type UpdateUserApplicationJoinPayload = {
  __typename?: 'UpdateUserApplicationJoinPayload';
  /** Reads a single `Application` that is related to this `UserApplicationJoin`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `UserApplicationJoin` that was updated by this mutation. */
  userApplicationJoin?: Maybe<UserApplicationJoin>;
  /** An edge for our `UserApplicationJoin`. May be used by Relay 1. */
  userApplicationJoinEdge?: Maybe<UserApplicationJoinsEdge>;
};


/** The output of our update `UserApplicationJoin` mutation. */
export type UpdateUserApplicationJoinPayloadUserApplicationJoinEdgeArgs = {
  orderBy?: InputMaybe<Array<UserApplicationJoinsOrderBy>>;
};

/** All input for the `updateUserOrganisationByNodeId` mutation. */
export type UpdateUserOrganisationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `UserOrganisation` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `UserOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** All input for the `updateUserOrganisation` mutation. */
export type UpdateUserOrganisationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `UserOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

/** The output of our update `UserOrganisation` mutation. */
export type UpdateUserOrganisationPayload = {
  __typename?: 'UpdateUserOrganisationPayload';
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  /** The `UserOrganisation` that was updated by this mutation. */
  userOrganisation?: Maybe<UserOrganisation>;
  /** An edge for our `UserOrganisation`. May be used by Relay 1. */
  userOrganisationEdge?: Maybe<UserOrganisationsEdge>;
};


/** The output of our update `UserOrganisation` mutation. */
export type UpdateUserOrganisationPayloadUserOrganisationEdgeArgs = {
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

/** All input for the `updateVerificationByNodeId` mutation. */
export type UpdateVerificationByNodeIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** The globally unique `ID` which will identify a single `Verification` to be updated. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `Verification` being updated. */
  patch: VerificationPatch;
};

/** All input for the `updateVerificationByUniqueId` mutation. */
export type UpdateVerificationByUniqueIdInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  /** An object where the defined keys will be set on the `Verification` being updated. */
  patch: VerificationPatch;
  uniqueId: Scalars['String']['input'];
};

/** All input for the `updateVerification` mutation. */
export type UpdateVerificationInput = {
  /**
   * An arbitrary string value with no semantic meaning. Will be included in the
   * payload verbatim. May be used to track mutations by the client.
   */
  clientMutationId?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `Verification` being updated. */
  patch: VerificationPatch;
};

/** The output of our update `Verification` mutation. */
export type UpdateVerificationPayload = {
  __typename?: 'UpdateVerificationPayload';
  /** Reads a single `Application` that is related to this `Verification`. */
  application?: Maybe<Application>;
  /**
   * The exact same `clientMutationId` that was provided in the mutation input,
   * unchanged and unused. May be used by a client to track mutations.
   */
  clientMutationId?: Maybe<Scalars['String']['output']>;
  /** Our root query field type. Allows us to run any query from our mutation payload. */
  query?: Maybe<Query>;
  /** The `Verification` that was updated by this mutation. */
  verification?: Maybe<Verification>;
  /** An edge for our `Verification`. May be used by Relay 1. */
  verificationEdge?: Maybe<VerificationsEdge>;
};


/** The output of our update `Verification` mutation. */
export type UpdateVerificationPayloadVerificationEdgeArgs = {
  orderBy?: InputMaybe<Array<VerificationsOrderBy>>;
};

export type User = {
  __typename?: 'User';
  address?: Maybe<Scalars['String']['output']>;
  country?: Maybe<Scalars['String']['output']>;
  dateOfBirth?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  passwordHash?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `UserOrganisation`. */
  userOrganisations: UserOrganisationsConnection;
  username?: Maybe<Scalars['String']['output']>;
};


export type UserUserOrganisationsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<UserOrganisationCondition>;
  filter?: InputMaybe<UserOrganisationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<UserOrganisationsOrderBy>>;
};

export type UserApplicationJoin = Node & {
  __typename?: 'UserApplicationJoin';
  /** Reads a single `Application` that is related to this `UserApplicationJoin`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  userId: Scalars['Int']['output'];
};

/** The `application` to be created by this mutation. */
export type UserApplicationJoinApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `UserApplicationJoinInput` mutation. */
export type UserApplicationJoinApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserApplicationJoinApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `userApplicationJoin` in the `ApplicationInput` mutation. */
export type UserApplicationJoinApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserApplicationJoinUserApplicationJoinPkeyConnect>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserApplicationJoinNodeIdConnect>>;
  /** A `UserApplicationJoinInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserApplicationJoinApplicationIdFkeyUserApplicationJoinCreateInput>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserApplicationJoinUserApplicationJoinPkeyDelete>>;
  /** The primary key(s) for `userApplicationJoin` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserApplicationJoinNodeIdDelete>>;
  /** Flag indicating whether all other `userApplicationJoin` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userApplicationJoin` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingUserApplicationJoinPkeyUpdate>>;
  /** The primary key(s) and patch data for `userApplicationJoin` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate>>;
};

/** The `userApplicationJoin` to be created by this mutation. */
export type UserApplicationJoinApplicationIdFkeyUserApplicationJoinCreateInput = {
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId: Scalars['Int']['input'];
};

/**
 * A condition to be used against `UserApplicationJoin` object types. All fields
 * are tested for equality and combined with a logical ‘and.’
 */
export type UserApplicationJoinCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** A filter to be used against `UserApplicationJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserApplicationJoinFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserApplicationJoinFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserApplicationJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserApplicationJoinFilter>>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
};

/** An input for mutations affecting `UserApplicationJoin` */
export type UserApplicationJoinInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId: Scalars['Int']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type UserApplicationJoinNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userApplicationJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserApplicationJoinNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userApplicationJoin` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `userApplicationJoin` to look up the row to update. */
export type UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingUserApplicationJoinPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
  patch: UpdateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
};

/** Represents an update to a `UserApplicationJoin`. Fields that are set will be updated. */
export type UserApplicationJoinPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** The fields on `userApplicationJoin` to look up the row to connect. */
export type UserApplicationJoinUserApplicationJoinPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `userApplicationJoin` to look up the row to delete. */
export type UserApplicationJoinUserApplicationJoinPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `UserApplicationJoin` values. */
export type UserApplicationJoinsConnection = {
  __typename?: 'UserApplicationJoinsConnection';
  /** A list of edges which contains the `UserApplicationJoin` and cursor to aid in pagination. */
  edges: Array<UserApplicationJoinsEdge>;
  /** A list of `UserApplicationJoin` objects. */
  nodes: Array<Maybe<UserApplicationJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserApplicationJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserApplicationJoin` edge in the connection. */
export type UserApplicationJoinsEdge = {
  __typename?: 'UserApplicationJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserApplicationJoin` at the end of the edge. */
  node?: Maybe<UserApplicationJoin>;
};

/** Methods to use when ordering `UserApplicationJoin`. */
export enum UserApplicationJoinsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC'
}

/** A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’ */
export type UserCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `country` field. */
  country?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fullName` field. */
  fullName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `phone` field. */
  phone?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `User` object types. All fields are combined with a logical ‘and.’ */
export type UserFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `country` field. */
  country?: InputMaybe<StringFilter>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<DateFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fullName` field. */
  fullName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserFilter>>;
  /** Filter by the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `phone` field. */
  phone?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userOrganisations` relation. */
  userOrganisations?: InputMaybe<UserToManyUserOrganisationFilter>;
  /** Some related `userOrganisations` exist. */
  userOrganisationsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `User` */
export type UserInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  userOrganisations?: InputMaybe<FakePublicUserOrganisationForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

export type UserList = {
  __typename?: 'UserList';
  /** Reads and enables pagination through a set of `ApplicationNote`. */
  applicationNotesByUserId: ApplicationNotesConnection;
  /** Reads and enables pagination through a set of `Application`. */
  applicationsByUserId: ApplicationsConnection;
  firstName?: Maybe<Scalars['String']['output']>;
  fullName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['Int']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  /** Reads and enables pagination through a set of `PermissionJoin`. */
  permissionJoinsByUserId: PermissionJoinsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignmentAssignerJoin`. */
  reviewAssignmentAssignerJoinsByAssignerId: ReviewAssignmentAssignerJoinsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewAssignmentsByAssignerId: ReviewAssignmentsConnection;
  /** Reads and enables pagination through a set of `ReviewAssignment`. */
  reviewedReviewAssignments: ReviewAssignmentsConnection;
  /** Reads and enables pagination through a set of `Review`. */
  reviewedReviews: ReviewsConnection;
  username?: Maybe<Scalars['String']['output']>;
};


export type UserListApplicationNotesByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationNoteCondition>;
  filter?: InputMaybe<ApplicationNoteFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationNotesOrderBy>>;
};


export type UserListApplicationsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ApplicationCondition>;
  filter?: InputMaybe<ApplicationFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ApplicationsOrderBy>>;
};


export type UserListPermissionJoinsByUserIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<PermissionJoinCondition>;
  filter?: InputMaybe<PermissionJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<PermissionJoinsOrderBy>>;
};


export type UserListReviewAssignmentAssignerJoinsByAssignerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentAssignerJoinCondition>;
  filter?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentAssignerJoinsOrderBy>>;
};


export type UserListReviewAssignmentsByAssignerIdArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type UserListReviewedReviewAssignmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewAssignmentCondition>;
  filter?: InputMaybe<ReviewAssignmentFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewAssignmentsOrderBy>>;
};


export type UserListReviewedReviewsArgs = {
  after?: InputMaybe<Scalars['Cursor']['input']>;
  before?: InputMaybe<Scalars['Cursor']['input']>;
  condition?: InputMaybe<ReviewCondition>;
  filter?: InputMaybe<ReviewFilter>;
  first?: InputMaybe<Scalars['Int']['input']>;
  last?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  orderBy?: InputMaybe<Array<ReviewsOrderBy>>;
};

/**
 * A condition to be used against `UserList` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserListCondition = {
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `fullName` field. */
  fullName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `UserList` object types. All fields are combined with a logical ‘and.’ */
export type UserListFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserListFilter>>;
  /** Filter by the object’s `applicationNotesByUserId` relation. */
  applicationNotesByUserId?: InputMaybe<UserListToManyApplicationNoteFilter>;
  /** Some related `applicationNotesByUserId` exist. */
  applicationNotesByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `applicationsByUserId` relation. */
  applicationsByUserId?: InputMaybe<UserListToManyApplicationFilter>;
  /** Some related `applicationsByUserId` exist. */
  applicationsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `fullName` field. */
  fullName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserListFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserListFilter>>;
  /** Filter by the object’s `permissionJoinsByUserId` relation. */
  permissionJoinsByUserId?: InputMaybe<UserListToManyPermissionJoinFilter>;
  /** Some related `permissionJoinsByUserId` exist. */
  permissionJoinsByUserIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewAssignmentAssignerJoinsByAssignerId` relation. */
  reviewAssignmentAssignerJoinsByAssignerId?: InputMaybe<UserListToManyReviewAssignmentAssignerJoinFilter>;
  /** Some related `reviewAssignmentAssignerJoinsByAssignerId` exist. */
  reviewAssignmentAssignerJoinsByAssignerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewAssignmentsByAssignerId` relation. */
  reviewAssignmentsByAssignerId?: InputMaybe<UserListToManyReviewAssignmentFilter>;
  /** Some related `reviewAssignmentsByAssignerId` exist. */
  reviewAssignmentsByAssignerIdExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewedReviewAssignments` relation. */
  reviewedReviewAssignments?: InputMaybe<UserListToManyReviewAssignmentFilter>;
  /** Some related `reviewedReviewAssignments` exist. */
  reviewedReviewAssignmentsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `reviewedReviews` relation. */
  reviewedReviews?: InputMaybe<UserListToManyReviewFilter>;
  /** Some related `reviewedReviews` exist. */
  reviewedReviewsExist?: InputMaybe<Scalars['Boolean']['input']>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `UserList` */
export type UserListInput = {
  applicationNotesUsingId?: InputMaybe<FakePublicApplicationNoteForeignKey0InverseInput>;
  applicationsUsingId?: InputMaybe<FakePublicApplicationForeignKey0InverseInput>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<FakePublicPermissionJoinForeignKey0InverseInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput>;
  reviewAssignmentsToAssignerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey1InverseInput>;
  reviewAssignmentsToReviewerIdUsingId?: InputMaybe<FakePublicReviewAssignmentForeignKey0InverseInput>;
  reviewsUsingId?: InputMaybe<FakePublicReviewForeignKey0InverseInput>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** The globally unique `ID` look up for the row to update. */
export type UserListOnApplicationForFakePublicApplicationForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserListOnApplicationNoteForFakePublicApplicationNoteForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `applicationNote` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `applicationNote` being updated. */
  patch: ApplicationNotePatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserListOnPermissionJoinForFakePublicPermissionJoinForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `permissionJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `permissionJoin` being updated. */
  patch: PermissionJoinPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserListOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignmentAssignerJoin` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
  patch: ReviewAssignmentAssignerJoinPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `reviewAssignment` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `reviewAssignment` being updated. */
  patch: ReviewAssignmentPatch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserListOnReviewForFakePublicReviewForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `review` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `review` being updated. */
  patch: ReviewPatch;
};

/** A filter to be used against many `Application` object types. All fields are combined with a logical ‘and.’ */
export type UserListToManyApplicationFilter = {
  /** Every related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationFilter>;
  /** No related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationFilter>;
  /** Some related `Application` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationFilter>;
};

/** A filter to be used against many `ApplicationNote` object types. All fields are combined with a logical ‘and.’ */
export type UserListToManyApplicationNoteFilter = {
  /** Every related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ApplicationNoteFilter>;
  /** No related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ApplicationNoteFilter>;
  /** Some related `ApplicationNote` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ApplicationNoteFilter>;
};

/** A filter to be used against many `PermissionJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserListToManyPermissionJoinFilter = {
  /** Every related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<PermissionJoinFilter>;
  /** No related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<PermissionJoinFilter>;
  /** Some related `PermissionJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<PermissionJoinFilter>;
};

/** A filter to be used against many `ReviewAssignmentAssignerJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserListToManyReviewAssignmentAssignerJoinFilter = {
  /** Every related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** No related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
  /** Some related `ReviewAssignmentAssignerJoin` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentAssignerJoinFilter>;
};

/** A filter to be used against many `ReviewAssignment` object types. All fields are combined with a logical ‘and.’ */
export type UserListToManyReviewAssignmentFilter = {
  /** Every related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewAssignmentFilter>;
  /** No related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewAssignmentFilter>;
  /** Some related `ReviewAssignment` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewAssignmentFilter>;
};

/** A filter to be used against many `Review` object types. All fields are combined with a logical ‘and.’ */
export type UserListToManyReviewFilter = {
  /** Every related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<ReviewFilter>;
  /** No related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<ReviewFilter>;
  /** Some related `Review` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<ReviewFilter>;
};

/** A connection to a list of `UserList` values. */
export type UserListsConnection = {
  __typename?: 'UserListsConnection';
  /** A list of edges which contains the `UserList` and cursor to aid in pagination. */
  edges: Array<UserListsEdge>;
  /** A list of `UserList` objects. */
  nodes: Array<Maybe<UserList>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserList` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserList` edge in the connection. */
export type UserListsEdge = {
  __typename?: 'UserListsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserList` at the end of the edge. */
  node?: Maybe<UserList>;
};

/** Methods to use when ordering `UserList`. */
export enum UserListsOrderBy {
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  FullNameAsc = 'FULL_NAME_ASC',
  FullNameDesc = 'FULL_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  Natural = 'NATURAL',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC'
}

/** The globally unique `ID` look up for the row to update. */
export type UserOnUserOrganisationForFakePublicUserOrganisationForeignKey0NodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UserOrganisationPatch;
};

export type UserOrgJoin = {
  __typename?: 'UserOrgJoin';
  address?: Maybe<Scalars['String']['output']>;
  dateOfBirth?: Maybe<Scalars['Date']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  isSystemOrg?: Maybe<Scalars['Boolean']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  logoUrl?: Maybe<Scalars['String']['output']>;
  orgId?: Maybe<Scalars['Int']['output']>;
  orgName?: Maybe<Scalars['String']['output']>;
  passwordHash?: Maybe<Scalars['String']['output']>;
  registration?: Maybe<Scalars['String']['output']>;
  userId?: Maybe<Scalars['Int']['output']>;
  userRole?: Maybe<Scalars['String']['output']>;
  username?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `UserOrgJoin` object types. All fields are tested
 * for equality and combined with a logical ‘and.’
 */
export type UserOrgJoinCondition = {
  /** Checks for equality with the object’s `address` field. */
  address?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<Scalars['Date']['input']>;
  /** Checks for equality with the object’s `email` field. */
  email?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `firstName` field. */
  firstName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `isSystemOrg` field. */
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `lastName` field. */
  lastName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `logoUrl` field. */
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `orgId` field. */
  orgId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `orgName` field. */
  orgName?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `registration` field. */
  registration?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `username` field. */
  username?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `UserOrgJoin` object types. All fields are combined with a logical ‘and.’ */
export type UserOrgJoinFilter = {
  /** Filter by the object’s `address` field. */
  address?: InputMaybe<StringFilter>;
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserOrgJoinFilter>>;
  /** Filter by the object’s `dateOfBirth` field. */
  dateOfBirth?: InputMaybe<DateFilter>;
  /** Filter by the object’s `email` field. */
  email?: InputMaybe<StringFilter>;
  /** Filter by the object’s `firstName` field. */
  firstName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `isSystemOrg` field. */
  isSystemOrg?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `lastName` field. */
  lastName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `logoUrl` field. */
  logoUrl?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserOrgJoinFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserOrgJoinFilter>>;
  /** Filter by the object’s `orgId` field. */
  orgId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `orgName` field. */
  orgName?: InputMaybe<StringFilter>;
  /** Filter by the object’s `passwordHash` field. */
  passwordHash?: InputMaybe<StringFilter>;
  /** Filter by the object’s `registration` field. */
  registration?: InputMaybe<StringFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: InputMaybe<StringFilter>;
  /** Filter by the object’s `username` field. */
  username?: InputMaybe<StringFilter>;
};

/** A connection to a list of `UserOrgJoin` values. */
export type UserOrgJoinsConnection = {
  __typename?: 'UserOrgJoinsConnection';
  /** A list of edges which contains the `UserOrgJoin` and cursor to aid in pagination. */
  edges: Array<UserOrgJoinsEdge>;
  /** A list of `UserOrgJoin` objects. */
  nodes: Array<Maybe<UserOrgJoin>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserOrgJoin` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserOrgJoin` edge in the connection. */
export type UserOrgJoinsEdge = {
  __typename?: 'UserOrgJoinsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserOrgJoin` at the end of the edge. */
  node?: Maybe<UserOrgJoin>;
};

/** Methods to use when ordering `UserOrgJoin`. */
export enum UserOrgJoinsOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  IsSystemOrgAsc = 'IS_SYSTEM_ORG_ASC',
  IsSystemOrgDesc = 'IS_SYSTEM_ORG_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  LogoUrlAsc = 'LOGO_URL_ASC',
  LogoUrlDesc = 'LOGO_URL_DESC',
  Natural = 'NATURAL',
  OrgIdAsc = 'ORG_ID_ASC',
  OrgIdDesc = 'ORG_ID_DESC',
  OrgNameAsc = 'ORG_NAME_ASC',
  OrgNameDesc = 'ORG_NAME_DESC',
  PasswordHashAsc = 'PASSWORD_HASH_ASC',
  PasswordHashDesc = 'PASSWORD_HASH_DESC',
  RegistrationAsc = 'REGISTRATION_ASC',
  RegistrationDesc = 'REGISTRATION_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

export type UserOrganisation = Node & {
  __typename?: 'UserOrganisation';
  id: Scalars['Int']['output'];
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  /** Reads a single `Organisation` that is related to this `UserOrganisation`. */
  organisation?: Maybe<Organisation>;
  organisationId: Scalars['Int']['output'];
  /** Reads a single `User` that is related to this `UserOrganisation`. */
  user?: Maybe<User>;
  userId: Scalars['Int']['output'];
  userRole?: Maybe<Scalars['String']['output']>;
};

/**
 * A condition to be used against `UserOrganisation` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type UserOrganisationCondition = {
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `organisationId` field. */
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userId` field. */
  userId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `userRole` field. */
  userRole?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type UserOrganisationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<UserOrganisationFilter>>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Negates the expression. */
  not?: InputMaybe<UserOrganisationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<UserOrganisationFilter>>;
  /** Filter by the object’s `organisation` relation. */
  organisation?: InputMaybe<OrganisationFilter>;
  /** Filter by the object’s `organisationId` field. */
  organisationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `user` relation. */
  user?: InputMaybe<UserFilter>;
  /** Filter by the object’s `userId` field. */
  userId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `userRole` field. */
  userRole?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `UserOrganisation` */
export type UserOrganisationInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<FakePublicUserOrganisationForeignKey0Input>;
};

/** The globally unique `ID` look up for the row to connect. */
export type UserOrganisationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type UserOrganisationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `userOrganisation` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0UsingUserOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0Patch;
};

/** The globally unique `ID` look up for the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `organisation` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `organisation` being updated. */
  patch: OrganisationPatch;
};

/** The fields on `userOrganisation` to look up the row to update. */
export type UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `userOrganisation` being updated. */
  patch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
};

/** Input for the nested mutation of `organisation` in the `UserOrganisationInput` mutation. */
export type UserOrganisationOrganisationIdFkeyInput = {
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectById?: InputMaybe<OrganisationOrganisationPkeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByName?: InputMaybe<OrganisationOrganisationNameKeyConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<OrganisationNodeIdConnect>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  connectByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyConnect>;
  /** A `OrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<UserOrganisationOrganisationIdFkeyOrganisationCreateInput>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteById?: InputMaybe<OrganisationOrganisationPkeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByName?: InputMaybe<OrganisationOrganisationNameKeyDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<OrganisationNodeIdDelete>;
  /** The primary key(s) for `organisation` for the far side of the relationship. */
  deleteByRegistration?: InputMaybe<OrganisationOrganisationRegistrationKeyDelete>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateById?: InputMaybe<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByName?: InputMaybe<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `organisation` for the far side of the relationship. */
  updateByRegistration?: InputMaybe<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate>;
};

/** Input for the nested mutation of `userOrganisation` in the `OrganisationInput` mutation. */
export type UserOrganisationOrganisationIdFkeyInverseInput = {
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectById?: InputMaybe<Array<UserOrganisationUserOrganisationPkeyConnect>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<UserOrganisationNodeIdConnect>>;
  /** A `UserOrganisationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<UserOrganisationUserOrganisationPkeyDelete>>;
  /** The primary key(s) for `userOrganisation` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<UserOrganisationNodeIdDelete>>;
  /** Flag indicating whether all other `userOrganisation` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateById?: InputMaybe<Array<UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate>>;
  /** The primary key(s) and patch data for `userOrganisation` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate>>;
};

/** The `organisation` to be created by this mutation. */
export type UserOrganisationOrganisationIdFkeyOrganisationCreateInput = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** The `userOrganisation` to be created by this mutation. */
export type UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<FakePublicUserOrganisationForeignKey0Input>;
};

/** Represents an update to a `UserOrganisation`. Fields that are set will be updated. */
export type UserOrganisationPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<FakePublicUserOrganisationForeignKey0Input>;
};

/** The fields on `userOrganisation` to look up the row to connect. */
export type UserOrganisationUserOrganisationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `userOrganisation` to look up the row to delete. */
export type UserOrganisationUserOrganisationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** A connection to a list of `UserOrganisation` values. */
export type UserOrganisationsConnection = {
  __typename?: 'UserOrganisationsConnection';
  /** A list of edges which contains the `UserOrganisation` and cursor to aid in pagination. */
  edges: Array<UserOrganisationsEdge>;
  /** A list of `UserOrganisation` objects. */
  nodes: Array<Maybe<UserOrganisation>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `UserOrganisation` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `UserOrganisation` edge in the connection. */
export type UserOrganisationsEdge = {
  __typename?: 'UserOrganisationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `UserOrganisation` at the end of the edge. */
  node?: Maybe<UserOrganisation>;
};

/** Methods to use when ordering `UserOrganisation`. */
export enum UserOrganisationsOrderBy {
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  Natural = 'NATURAL',
  OrganisationIdAsc = 'ORGANISATION_ID_ASC',
  OrganisationIdDesc = 'ORGANISATION_ID_DESC',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  UserIdAsc = 'USER_ID_ASC',
  UserIdDesc = 'USER_ID_DESC',
  UserRoleAsc = 'USER_ROLE_ASC',
  UserRoleDesc = 'USER_ROLE_DESC'
}

/** A filter to be used against many `UserOrganisation` object types. All fields are combined with a logical ‘and.’ */
export type UserToManyUserOrganisationFilter = {
  /** Every related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  every?: InputMaybe<UserOrganisationFilter>;
  /** No related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  none?: InputMaybe<UserOrganisationFilter>;
  /** Some related `UserOrganisation` matches the filter criteria. All fields are combined with a logical ‘and.’ */
  some?: InputMaybe<UserOrganisationFilter>;
};

/** A connection to a list of `User` values. */
export type UsersConnection = {
  __typename?: 'UsersConnection';
  /** A list of edges which contains the `User` and cursor to aid in pagination. */
  edges: Array<UsersEdge>;
  /** A list of `User` objects. */
  nodes: Array<Maybe<User>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `User` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `User` edge in the connection. */
export type UsersEdge = {
  __typename?: 'UsersEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `User` at the end of the edge. */
  node?: Maybe<User>;
};

/** Methods to use when ordering `User`. */
export enum UsersOrderBy {
  AddressAsc = 'ADDRESS_ASC',
  AddressDesc = 'ADDRESS_DESC',
  CountryAsc = 'COUNTRY_ASC',
  CountryDesc = 'COUNTRY_DESC',
  DateOfBirthAsc = 'DATE_OF_BIRTH_ASC',
  DateOfBirthDesc = 'DATE_OF_BIRTH_DESC',
  EmailAsc = 'EMAIL_ASC',
  EmailDesc = 'EMAIL_DESC',
  FirstNameAsc = 'FIRST_NAME_ASC',
  FirstNameDesc = 'FIRST_NAME_DESC',
  FullNameAsc = 'FULL_NAME_ASC',
  FullNameDesc = 'FULL_NAME_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  LastNameAsc = 'LAST_NAME_ASC',
  LastNameDesc = 'LAST_NAME_DESC',
  Natural = 'NATURAL',
  PasswordHashAsc = 'PASSWORD_HASH_ASC',
  PasswordHashDesc = 'PASSWORD_HASH_DESC',
  PhoneAsc = 'PHONE_ASC',
  PhoneDesc = 'PHONE_DESC',
  UsernameAsc = 'USERNAME_ASC',
  UsernameDesc = 'USERNAME_DESC'
}

export type Verification = Node & {
  __typename?: 'Verification';
  /** Reads a single `Application` that is related to this `Verification`. */
  application?: Maybe<Application>;
  applicationId: Scalars['Int']['output'];
  data?: Maybe<Scalars['JSON']['output']>;
  eventCode?: Maybe<Scalars['String']['output']>;
  id: Scalars['Int']['output'];
  isVerified?: Maybe<Scalars['Boolean']['output']>;
  message?: Maybe<Scalars['String']['output']>;
  /** A globally unique identifier. Can be used in various places throughout the system to identify this single value. */
  nodeId: Scalars['ID']['output'];
  timeCreated?: Maybe<Scalars['Datetime']['output']>;
  timeExpired?: Maybe<Scalars['Datetime']['output']>;
  trigger?: Maybe<Trigger>;
  uniqueId: Scalars['String']['output'];
};

/** The `application` to be created by this mutation. */
export type VerificationApplicationIdFkeyApplicationCreateInput = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** Input for the nested mutation of `application` in the `VerificationInput` mutation. */
export type VerificationApplicationIdFkeyInput = {
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectById?: InputMaybe<ApplicationApplicationPkeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<ApplicationNodeIdConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyConnect>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  connectBySerial?: InputMaybe<ApplicationApplicationSerialKeyConnect>;
  /** A `ApplicationInput` object that will be created and connected to this object. */
  create?: InputMaybe<VerificationApplicationIdFkeyApplicationCreateInput>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteById?: InputMaybe<ApplicationApplicationPkeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<ApplicationNodeIdDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteByOutcomeRegistration?: InputMaybe<ApplicationApplicationOutcomeRegistrationKeyDelete>;
  /** The primary key(s) for `application` for the far side of the relationship. */
  deleteBySerial?: InputMaybe<ApplicationApplicationSerialKeyDelete>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateById?: InputMaybe<ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationPkeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<VerificationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateByOutcomeRegistration?: InputMaybe<ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate>;
  /** The primary key(s) and patch data for `application` for the far side of the relationship. */
  updateBySerial?: InputMaybe<ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationSerialKeyUpdate>;
};

/** Input for the nested mutation of `verification` in the `ApplicationInput` mutation. */
export type VerificationApplicationIdFkeyInverseInput = {
  /** The primary key(s) for `verification` for the far side of the relationship. */
  connectById?: InputMaybe<Array<VerificationVerificationPkeyConnect>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  connectByNodeId?: InputMaybe<Array<VerificationNodeIdConnect>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  connectByUniqueId?: InputMaybe<Array<VerificationVerificationUniqueIdKeyConnect>>;
  /** A `VerificationInput` object that will be created and connected to this object. */
  create?: InputMaybe<Array<VerificationApplicationIdFkeyVerificationCreateInput>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  deleteById?: InputMaybe<Array<VerificationVerificationPkeyDelete>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  deleteByNodeId?: InputMaybe<Array<VerificationNodeIdDelete>>;
  /** The primary key(s) for `verification` for the far side of the relationship. */
  deleteByUniqueId?: InputMaybe<Array<VerificationVerificationUniqueIdKeyDelete>>;
  /** Flag indicating whether all other `verification` records that match this relationship should be removed. */
  deleteOthers?: InputMaybe<Scalars['Boolean']['input']>;
  /** The primary key(s) and patch data for `verification` for the far side of the relationship. */
  updateById?: InputMaybe<Array<VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationPkeyUpdate>>;
  /** The primary key(s) and patch data for `verification` for the far side of the relationship. */
  updateByNodeId?: InputMaybe<Array<ApplicationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate>>;
  /** The primary key(s) and patch data for `verification` for the far side of the relationship. */
  updateByUniqueId?: InputMaybe<Array<VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationUniqueIdKeyUpdate>>;
};

/** The `verification` to be created by this mutation. */
export type VerificationApplicationIdFkeyVerificationCreateInput = {
  applicationToApplicationId?: InputMaybe<VerificationApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  uniqueId: Scalars['String']['input'];
};

/**
 * A condition to be used against `Verification` object types. All fields are
 * tested for equality and combined with a logical ‘and.’
 */
export type VerificationCondition = {
  /** Checks for equality with the object’s `applicationId` field. */
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `data` field. */
  data?: InputMaybe<Scalars['JSON']['input']>;
  /** Checks for equality with the object’s `eventCode` field. */
  eventCode?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `id` field. */
  id?: InputMaybe<Scalars['Int']['input']>;
  /** Checks for equality with the object’s `isVerified` field. */
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  /** Checks for equality with the object’s `message` field. */
  message?: InputMaybe<Scalars['String']['input']>;
  /** Checks for equality with the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `timeExpired` field. */
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  /** Checks for equality with the object’s `trigger` field. */
  trigger?: InputMaybe<Trigger>;
  /** Checks for equality with the object’s `uniqueId` field. */
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

/** A filter to be used against `Verification` object types. All fields are combined with a logical ‘and.’ */
export type VerificationFilter = {
  /** Checks for all expressions in this list. */
  and?: InputMaybe<Array<VerificationFilter>>;
  /** Filter by the object’s `application` relation. */
  application?: InputMaybe<ApplicationFilter>;
  /** Filter by the object’s `applicationId` field. */
  applicationId?: InputMaybe<IntFilter>;
  /** Filter by the object’s `data` field. */
  data?: InputMaybe<JsonFilter>;
  /** Filter by the object’s `eventCode` field. */
  eventCode?: InputMaybe<StringFilter>;
  /** Filter by the object’s `id` field. */
  id?: InputMaybe<IntFilter>;
  /** Filter by the object’s `isVerified` field. */
  isVerified?: InputMaybe<BooleanFilter>;
  /** Filter by the object’s `message` field. */
  message?: InputMaybe<StringFilter>;
  /** Negates the expression. */
  not?: InputMaybe<VerificationFilter>;
  /** Checks for any expressions in this list. */
  or?: InputMaybe<Array<VerificationFilter>>;
  /** Filter by the object’s `timeCreated` field. */
  timeCreated?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `timeExpired` field. */
  timeExpired?: InputMaybe<DatetimeFilter>;
  /** Filter by the object’s `trigger` field. */
  trigger?: InputMaybe<TriggerFilter>;
  /** Filter by the object’s `uniqueId` field. */
  uniqueId?: InputMaybe<StringFilter>;
};

/** An input for mutations affecting `Verification` */
export type VerificationInput = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<VerificationApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  uniqueId: Scalars['String']['input'];
};

/** The globally unique `ID` look up for the row to connect. */
export type VerificationNodeIdConnect = {
  /** The globally unique `ID` which identifies a single `verification` to be connected. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to delete. */
export type VerificationNodeIdDelete = {
  /** The globally unique `ID` which identifies a single `verification` to be deleted. */
  nodeId: Scalars['ID']['input'];
};

/** The globally unique `ID` look up for the row to update. */
export type VerificationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate = {
  /** The globally unique `ID` which identifies a single `application` to be connected. */
  nodeId: Scalars['ID']['input'];
  /** An object where the defined keys will be set on the `application` being updated. */
  patch: ApplicationPatch;
};

/** The fields on `verification` to look up the row to update. */
export type VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationPkeyUpdate = {
  id: Scalars['Int']['input'];
  /** An object where the defined keys will be set on the `verification` being updated. */
  patch: UpdateVerificationOnVerificationForVerificationApplicationIdFkeyPatch;
};

/** The fields on `verification` to look up the row to update. */
export type VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationUniqueIdKeyUpdate = {
  /** An object where the defined keys will be set on the `verification` being updated. */
  patch: UpdateVerificationOnVerificationForVerificationApplicationIdFkeyPatch;
  uniqueId: Scalars['String']['input'];
};

/** Represents an update to a `Verification`. Fields that are set will be updated. */
export type VerificationPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<VerificationApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};

/** The fields on `verification` to look up the row to connect. */
export type VerificationVerificationPkeyConnect = {
  id: Scalars['Int']['input'];
};

/** The fields on `verification` to look up the row to delete. */
export type VerificationVerificationPkeyDelete = {
  id: Scalars['Int']['input'];
};

/** The fields on `verification` to look up the row to connect. */
export type VerificationVerificationUniqueIdKeyConnect = {
  uniqueId: Scalars['String']['input'];
};

/** The fields on `verification` to look up the row to delete. */
export type VerificationVerificationUniqueIdKeyDelete = {
  uniqueId: Scalars['String']['input'];
};

/** A connection to a list of `Verification` values. */
export type VerificationsConnection = {
  __typename?: 'VerificationsConnection';
  /** A list of edges which contains the `Verification` and cursor to aid in pagination. */
  edges: Array<VerificationsEdge>;
  /** A list of `Verification` objects. */
  nodes: Array<Maybe<Verification>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** The count of *all* `Verification` you could get from the connection. */
  totalCount: Scalars['Int']['output'];
};

/** A `Verification` edge in the connection. */
export type VerificationsEdge = {
  __typename?: 'VerificationsEdge';
  /** A cursor for use in pagination. */
  cursor?: Maybe<Scalars['Cursor']['output']>;
  /** The `Verification` at the end of the edge. */
  node?: Maybe<Verification>;
};

/** Methods to use when ordering `Verification`. */
export enum VerificationsOrderBy {
  ApplicationIdAsc = 'APPLICATION_ID_ASC',
  ApplicationIdDesc = 'APPLICATION_ID_DESC',
  DataAsc = 'DATA_ASC',
  DataDesc = 'DATA_DESC',
  EventCodeAsc = 'EVENT_CODE_ASC',
  EventCodeDesc = 'EVENT_CODE_DESC',
  IdAsc = 'ID_ASC',
  IdDesc = 'ID_DESC',
  IsVerifiedAsc = 'IS_VERIFIED_ASC',
  IsVerifiedDesc = 'IS_VERIFIED_DESC',
  MessageAsc = 'MESSAGE_ASC',
  MessageDesc = 'MESSAGE_DESC',
  Natural = 'NATURAL',
  PrimaryKeyAsc = 'PRIMARY_KEY_ASC',
  PrimaryKeyDesc = 'PRIMARY_KEY_DESC',
  TimeCreatedAsc = 'TIME_CREATED_ASC',
  TimeCreatedDesc = 'TIME_CREATED_DESC',
  TimeExpiredAsc = 'TIME_EXPIRED_ASC',
  TimeExpiredDesc = 'TIME_EXPIRED_DESC',
  TriggerAsc = 'TRIGGER_ASC',
  TriggerDesc = 'TRIGGER_DESC',
  UniqueIdAsc = 'UNIQUE_ID_ASC',
  UniqueIdDesc = 'UNIQUE_ID_DESC'
}

/** A filter to be used against YesOrNo fields. All fields are combined with a logical ‘and.’ */
export type YesOrNoFilter = {
  /** Not equal to the specified value, treating null like an ordinary value. */
  distinctFrom?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not equal to the specified value, treating null like an ordinary value (case-insensitive). */
  distinctFromInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Ends with the specified string (case-sensitive). */
  endsWith?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Ends with the specified string (case-insensitive). */
  endsWithInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Equal to the specified value. */
  equalTo?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Equal to the specified value (case-insensitive). */
  equalToInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Greater than the specified value. */
  greaterThan?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Greater than the specified value (case-insensitive). */
  greaterThanInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Greater than or equal to the specified value. */
  greaterThanOrEqualTo?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Greater than or equal to the specified value (case-insensitive). */
  greaterThanOrEqualToInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Included in the specified list. */
  in?: InputMaybe<Array<Scalars['YesOrNo']['input']>>;
  /** Included in the specified list (case-insensitive). */
  inInsensitive?: InputMaybe<Array<Scalars['YesOrNo']['input']>>;
  /** Contains the specified string (case-sensitive). */
  includes?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Contains the specified string (case-insensitive). */
  includesInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Is null (if `true` is specified) or is not null (if `false` is specified). */
  isNull?: InputMaybe<Scalars['Boolean']['input']>;
  /** Less than the specified value. */
  lessThan?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Less than the specified value (case-insensitive). */
  lessThanInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Less than or equal to the specified value. */
  lessThanOrEqualTo?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Less than or equal to the specified value (case-insensitive). */
  lessThanOrEqualToInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Matches the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  like?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Matches the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  likeInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Equal to the specified value, treating null like an ordinary value. */
  notDistinctFrom?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Equal to the specified value, treating null like an ordinary value (case-insensitive). */
  notDistinctFromInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not end with the specified string (case-sensitive). */
  notEndsWith?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not end with the specified string (case-insensitive). */
  notEndsWithInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not equal to the specified value. */
  notEqualTo?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not equal to the specified value (case-insensitive). */
  notEqualToInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Not included in the specified list. */
  notIn?: InputMaybe<Array<Scalars['YesOrNo']['input']>>;
  /** Not included in the specified list (case-insensitive). */
  notInInsensitive?: InputMaybe<Array<Scalars['YesOrNo']['input']>>;
  /** Does not contain the specified string (case-sensitive). */
  notIncludes?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not contain the specified string (case-insensitive). */
  notIncludesInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not match the specified pattern (case-sensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLike?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not match the specified pattern (case-insensitive). An underscore (_) matches any single character; a percent sign (%) matches any sequence of zero or more characters. */
  notLikeInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not start with the specified string (case-sensitive). */
  notStartsWith?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Does not start with the specified string (case-insensitive). */
  notStartsWithInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Starts with the specified string (case-sensitive). */
  startsWith?: InputMaybe<Scalars['YesOrNo']['input']>;
  /** Starts with the specified string (case-insensitive). */
  startsWithInsensitive?: InputMaybe<Scalars['YesOrNo']['input']>;
};

/** An object where the defined keys will be set on the `actionQueue` being updated. */
export type UpdateActionQueueOnActionQueueForActionQueueApplicationIdFkeyPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** An object where the defined keys will be set on the `actionQueue` being updated. */
export type UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerEvent?: InputMaybe<Scalars['Int']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** An object where the defined keys will be set on the `actionQueue` being updated. */
export type UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ActionQueueApplicationIdFkeyInput>;
  conditionExpression?: InputMaybe<Scalars['JSON']['input']>;
  errorLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  output?: InputMaybe<Scalars['JSON']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  parametersEvaluated?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ActionQueueStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ActionQueueTemplateIdFkeyInput>;
  timeCompleted?: InputMaybe<Scalars['Datetime']['input']>;
  timeQueued?: InputMaybe<Scalars['Datetime']['input']>;
  triggerPayload?: InputMaybe<Scalars['JSON']['input']>;
  triggerQueueToTriggerEvent?: InputMaybe<ActionQueueTriggerEventFkeyInput>;
};

/** An object where the defined keys will be set on the `activityLog` being updated. */
export type UpdateActivityLogOnActivityLogForActivityLogApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ActivityLogApplicationIdFkeyInput>;
  details?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  type?: InputMaybe<EventType>;
  value?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `applicationNote` being updated. */
export type UpdateApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** An object where the defined keys will be set on the `applicationNote` being updated. */
export type UpdateApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** An object where the defined keys will be set on the `applicationNote` being updated. */
export type UpdateApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0Patch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** An object where the defined keys will be set on the `applicationNote` being updated. */
export type UpdateApplicationNoteOnFileForFileApplicationNoteIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationNoteApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  filesUsingId?: InputMaybe<FileApplicationNoteIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<ApplicationNoteOrgIdFkeyInput>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationNoteForeignKey0Input>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationForFakePublicApplicationForeignKey0Patch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnDataChangelogForDataChangelogApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnFileForFileApplicationSerialFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `application` being updated. */
export type UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueApplicationIdFkeyInverseInput>;
  activityLogsUsingId?: InputMaybe<ActivityLogApplicationIdFkeyInverseInput>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteApplicationIdFkeyInverseInput>;
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseApplicationIdFkeyInverseInput>;
  applicationReviewerActionsUsingId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInverseInput>;
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInverseInput>;
  assignerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogApplicationIdFkeyInverseInput>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput>;
  dataTableProductApplicationJoinsUsingId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInverseInput>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput>;
  filesUsingSerial?: InputMaybe<FileApplicationSerialFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  isConfig?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  notificationsUsingId?: InputMaybe<NotificationApplicationIdFkeyInverseInput>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInverseInput>;
  organisationToOrgId?: InputMaybe<ApplicationOrgIdFkeyInput>;
  outcome?: InputMaybe<ApplicationOutcome>;
  outcomeRegistration?: InputMaybe<Scalars['String']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInverseInput>;
  reviewerList?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  reviewsUsingId?: InputMaybe<ReviewApplicationIdFkeyInverseInput>;
  serial?: InputMaybe<Scalars['String']['input']>;
  sessionId?: InputMaybe<Scalars['String']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<ApplicationTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
  triggerQueuesUsingId?: InputMaybe<TriggerQueueApplicationIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleApplicationIdFkeyInverseInput>;
  userApplicationJoinsUsingId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInverseInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicApplicationForeignKey0Input>;
  verificationsUsingId?: InputMaybe<VerificationApplicationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `applicationResponse` being updated. */
export type UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ApplicationResponseApplicationIdFkeyInput>;
  evaluatedParameters?: InputMaybe<Scalars['JSON']['input']>;
  filesUsingId?: InputMaybe<FileApplicationResponseIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isValid?: InputMaybe<Scalars['Boolean']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ApplicationResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  value?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `applicationReviewerAction` being updated. */
export type UpdateApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ApplicationReviewerActionApplicationIdFkeyInput>;
  assignerAction?: InputMaybe<AssignerAction>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewerAction?: InputMaybe<ReviewerAction>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch = {
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `applicationStageHistory` being updated. */
export type UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStatusHistoriesUsingId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<ApplicationStageHistoryApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `applicationStatusHistory` being updated. */
export type UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationStageHistoryToApplicationStageHistoryId?: InputMaybe<ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  status?: InputMaybe<ApplicationStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `dataChangelog` being updated. */
export type UpdateDataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<DataChangelogApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  dataTable?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  newData?: InputMaybe<Scalars['JSON']['input']>;
  oldData?: InputMaybe<Scalars['JSON']['input']>;
  orgId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrgId?: InputMaybe<DataChangelogOrgIdFkeyInput>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  updateType?: InputMaybe<ChangelogType>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `dataChangelog` being updated. */
export type UpdateDataChangelogOnDataChangelogForDataChangelogOrgIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataChangelogApplicationIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  dataTable?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  newData?: InputMaybe<Scalars['JSON']['input']>;
  oldData?: InputMaybe<Scalars['JSON']['input']>;
  organisationToOrgId?: InputMaybe<DataChangelogOrgIdFkeyInput>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  updateType?: InputMaybe<ChangelogType>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  username?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `dataTableManufacturerApplicationJoin` being updated. */
export type UpdateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInput>;
  dataTableManufacturerToDataTableManufacturerId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTableManufacturerApplicationJoin` being updated. */
export type UpdateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<DataTableManufacturerApplicationJoinApplicationIdFkeyInput>;
  dataTableManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  dataTableManufacturerToDataTableManufacturerId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTableManufacturer` being updated. */
export type UpdateDataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTableManufacturerApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdditional?: InputMaybe<Scalars['Boolean']['input']>;
  manufacturer?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `dataTableManufacturerRepresentativeApplicationJoin` being updated. */
export type UpdateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInput>;
  dataTableManufacturerRepresentativeToDataTableManufacturerRepresentativeId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTableManufacturerRepresentativeApplicationJoin` being updated. */
export type UpdateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<DataTableManufacturerRepresentativeApplApplicationIdFkeyInput>;
  dataTableManufacturerRepresentativeId?: InputMaybe<Scalars['Int']['input']>;
  dataTableManufacturerRepresentativeToDataTableManufacturerRepresentativeId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTableManufacturerRepresentative` being updated. */
export type UpdateDataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch = {
  additionalCertifications?: InputMaybe<Scalars['JSON']['input']>;
  address?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTableManufacturerRepresentativeApplicationJoinsUsingId?: InputMaybe<DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput>;
  evaluationNotes?: InputMaybe<Scalars['String']['input']>;
  gmpByWhoCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpCountry1?: InputMaybe<Scalars['String']['input']>;
  gmpCountry2?: InputMaybe<Scalars['String']['input']>;
  gmpCountry3?: InputMaybe<Scalars['String']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  gmpExpiry1?: InputMaybe<Scalars['Date']['input']>;
  gmpExpiry2?: InputMaybe<Scalars['Date']['input']>;
  gmpExpiry3?: InputMaybe<Scalars['Date']['input']>;
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  letterOfAuthorization?: InputMaybe<Scalars['JSON']['input']>;
  manufacturerDatabaseId?: InputMaybe<Scalars['Int']['input']>;
  manufacturerRegistrationId?: InputMaybe<Scalars['String']['input']>;
  manufacturingCompanies?: InputMaybe<Scalars['JSON']['input']>;
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `dataTablePermitChemicalApplicationJoin` being updated. */
export type UpdateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput>;
  dataTablePermitChemicalToDataTablePermitChemicalId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTablePermitChemicalApplicationJoin` being updated. */
export type UpdateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput>;
  dataTablePermitChemicalId?: InputMaybe<Scalars['Int']['input']>;
  dataTablePermitChemicalToDataTablePermitChemicalId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTablePermitChemical` being updated. */
export type UpdateDataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch = {
  chemicals?: InputMaybe<Scalars['JSON']['input']>;
  chemicalsFilterData?: InputMaybe<Scalars['String']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTablePermitChemicalApplicationJoinsUsingId?: InputMaybe<DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  permitNo?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `dataTablePrequalManufacturerApplicationJoin` being updated. */
export type UpdateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInput>;
  dataTablePrequalManufacturerToDataTablePrequalManufacturerId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTablePrequalManufacturerApplicationJoin` being updated. */
export type UpdateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<DataTablePrequalManufacturerApplicationApplicationIdFkeyInput>;
  dataTablePrequalManufacturerId?: InputMaybe<Scalars['Int']['input']>;
  dataTablePrequalManufacturerToDataTablePrequalManufacturerId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTablePrequalManufacturer` being updated. */
export type UpdateDataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataTablePrequalManufacturerApplicationJoinsUsingId?: InputMaybe<DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput>;
  dateIssued?: InputMaybe<Scalars['String']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  gmpScope?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  lookupId?: InputMaybe<Scalars['Int']['input']>;
  manufacturerId?: InputMaybe<Scalars['String']['input']>;
  manufacturingLicence?: InputMaybe<Scalars['JSON']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permitNo?: InputMaybe<Scalars['String']['input']>;
  prequalificationDate?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `dataTableProductApplicationJoin` being updated. */
export type UpdateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<DataTableProductApplicationJoinApplicationIdFkeyInput>;
  dataTableProductId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTableProvisionalProductApplicationJoin` being updated. */
export type UpdateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInput>;
  dataTableProvisionalProductToDataTableProvisionalProductId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTableProvisionalProductApplicationJoin` being updated. */
export type UpdateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<DataTableProvisionalProductApplicationApplicationIdFkeyInput>;
  dataTableProvisionalProductId?: InputMaybe<Scalars['Int']['input']>;
  dataTableProvisionalProductToDataTableProvisionalProductId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `dataTableProvisionalProduct` being updated. */
export type UpdateDataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch = {
  activeIngredients?: InputMaybe<Scalars['JSON']['input']>;
  activeIngredientsFilterData?: InputMaybe<Scalars['String']['input']>;
  applicantId?: InputMaybe<Scalars['Int']['input']>;
  approval?: InputMaybe<Scalars['String']['input']>;
  atcCode?: InputMaybe<Scalars['JSON']['input']>;
  companyId?: InputMaybe<Scalars['Int']['input']>;
  companyName?: InputMaybe<Scalars['String']['input']>;
  dataTableProvisionalProductApplicationJoinsUsingId?: InputMaybe<DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput>;
  dosageForm?: InputMaybe<Scalars['String']['input']>;
  evaluationComment?: InputMaybe<Scalars['String']['input']>;
  expiryDate?: InputMaybe<Scalars['Datetime']['input']>;
  fullName?: InputMaybe<Scalars['String']['input']>;
  gmpCertificate?: InputMaybe<Scalars['JSON']['input']>;
  gmpDetails?: InputMaybe<Scalars['JSON']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  letterOfAuthorisation?: InputMaybe<Scalars['JSON']['input']>;
  loaSource?: InputMaybe<Scalars['String']['input']>;
  manufacturerPrequalified?: InputMaybe<Scalars['JSON']['input']>;
  manufacturers?: InputMaybe<Scalars['JSON']['input']>;
  manufacturersFilterData?: InputMaybe<Scalars['String']['input']>;
  medicalProductClassification?: InputMaybe<Scalars['String']['input']>;
  originalId?: InputMaybe<Scalars['String']['input']>;
  packagingSizes?: InputMaybe<Scalars['JSON']['input']>;
  packagingSizesFilterData?: InputMaybe<Scalars['String']['input']>;
  packagingSizesForm?: InputMaybe<Scalars['JSON']['input']>;
  pharmacopeia?: InputMaybe<Scalars['String']['input']>;
  prequalified?: InputMaybe<Scalars['Boolean']['input']>;
  prodRegCertificate?: InputMaybe<Scalars['JSON']['input']>;
  productId?: InputMaybe<Scalars['String']['input']>;
  registeredIn?: InputMaybe<Scalars['String']['input']>;
  registrationDate?: InputMaybe<Scalars['Datetime']['input']>;
  registrationSerial?: InputMaybe<Scalars['String']['input']>;
  routeOfAdministration?: InputMaybe<Scalars['String']['input']>;
  shelfLife?: InputMaybe<Scalars['String']['input']>;
  sponsorName?: InputMaybe<Scalars['String']['input']>;
  storageConditions?: InputMaybe<Scalars['String']['input']>;
  tradeName?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileApplicationNoteIdFkeyPatch = {
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileApplicationResponseIdFkeyPatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileApplicationSerialFkeyPatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `file` being updated. */
export type UpdateFileOnFileForFileTemplateIdFkeyPatch = {
  applicationNoteId?: InputMaybe<Scalars['Int']['input']>;
  applicationNoteToApplicationNoteId?: InputMaybe<FileApplicationNoteIdFkeyInput>;
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<FileApplicationResponseIdFkeyInput>;
  applicationSerial?: InputMaybe<Scalars['String']['input']>;
  applicationToApplicationSerial?: InputMaybe<FileApplicationSerialFkeyInput>;
  archivePath?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  filePath?: InputMaybe<Scalars['String']['input']>;
  fileSize?: InputMaybe<Scalars['BigInt']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isExternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isInternalReferenceDoc?: InputMaybe<Scalars['Boolean']['input']>;
  isOutputDoc?: InputMaybe<Scalars['Boolean']['input']>;
  mimetype?: InputMaybe<Scalars['String']['input']>;
  originalFilename?: InputMaybe<Scalars['String']['input']>;
  submitted?: InputMaybe<Scalars['Boolean']['input']>;
  templateToTemplateId?: InputMaybe<FileTemplateIdFkeyInput>;
  thumbnailPath?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  toBeDeleted?: InputMaybe<Scalars['Boolean']['input']>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `filter` being updated. */
export type UpdateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  query?: InputMaybe<Scalars['JSON']['input']>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  userRole?: InputMaybe<PermissionPolicyType>;
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `notification` being updated. */
export type UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<NotificationApplicationIdFkeyInput>;
  attachments?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  emailRecipients?: InputMaybe<Scalars['String']['input']>;
  emailSent?: InputMaybe<Scalars['Boolean']['input']>;
  emailServerLog?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isRead?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  reviewToReviewId?: InputMaybe<NotificationReviewIdFkeyInput>;
  subject?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
export type UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** An object where the defined keys will be set on the `organisationApplicationJoin` being updated. */
export type UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<OrganisationApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnDataChangelogForDataChangelogOrgIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `organisation` being updated. */
export type UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch = {
  address?: InputMaybe<Scalars['String']['input']>;
  applicationNotesUsingId?: InputMaybe<ApplicationNoteOrgIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationOrgIdFkeyInverseInput>;
  businessCertificate?: InputMaybe<Scalars['JSON']['input']>;
  contactEmail?: InputMaybe<Scalars['String']['input']>;
  contactPhone?: InputMaybe<Scalars['String']['input']>;
  country?: InputMaybe<Scalars['String']['input']>;
  dataChangelogsUsingId?: InputMaybe<DataChangelogOrgIdFkeyInverseInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isChemicalImporter?: InputMaybe<Scalars['Boolean']['input']>;
  isSponsorCompany?: InputMaybe<Scalars['Boolean']['input']>;
  isSystemOrg?: InputMaybe<Scalars['Boolean']['input']>;
  license?: InputMaybe<Scalars['JSON']['input']>;
  localAgentBusinessAddress?: InputMaybe<Scalars['String']['input']>;
  localAgentEmail?: InputMaybe<Scalars['String']['input']>;
  localAgentName?: InputMaybe<Scalars['String']['input']>;
  localAgentPhoneNumber?: InputMaybe<Scalars['String']['input']>;
  logoUrl?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  organisationApplicationJoinsUsingId?: InputMaybe<OrganisationApplicationJoinOrganisationIdFkeyInverseInput>;
  otherDocuments?: InputMaybe<Scalars['JSON']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinOrganisationIdFkeyInverseInput>;
  postalAddress?: InputMaybe<Scalars['String']['input']>;
  province?: InputMaybe<Scalars['String']['input']>;
  registration?: InputMaybe<Scalars['String']['input']>;
  registrationDocumentation?: InputMaybe<Scalars['JSON']['input']>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInverseInput>;
  subType?: InputMaybe<Scalars['String']['input']>;
  tinLetter?: InputMaybe<Scalars['JSON']['input']>;
  userOrganisationsUsingId?: InputMaybe<UserOrganisationOrganisationIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0Patch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userListToUserId?: InputMaybe<FakePublicPermissionJoinForeignKey0Input>;
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicPermissionJoinForeignKey0Input>;
};

/** An object where the defined keys will be set on the `permissionJoin` being updated. */
export type UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<PermissionJoinOrganisationIdFkeyInput>;
  permissionNameToPermissionNameId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userListToUserId?: InputMaybe<FakePublicPermissionJoinForeignKey0Input>;
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `permissionName` being updated. */
export type UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSystemOrgPermission?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionJoinsUsingId?: InputMaybe<PermissionJoinPermissionNameIdFkeyInverseInput>;
  permissionPolicyId?: InputMaybe<Scalars['Int']['input']>;
  permissionPolicyToPermissionPolicyId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInverseInput>;
};

/** An object where the defined keys will be set on the `permissionPolicy` being updated. */
export type UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch = {
  defaultRestrictions?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isAdmin?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  permissionNamesUsingId?: InputMaybe<PermissionNamePermissionPolicyIdFkeyInverseInput>;
  rules?: InputMaybe<Scalars['JSON']['input']>;
  type?: InputMaybe<PermissionPolicyType>;
};

/** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
export type UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0Patch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
export type UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignmentAssignerJoin` being updated. */
export type UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch = {
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentAssignerJoinOrganisationIdFkeyInput>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentAssignerJoinForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0Patch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1Patch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewAssignment` being updated. */
export type UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewAssignmentApplicationIdFkeyInput>;
  assignedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  assignerId?: InputMaybe<Scalars['Int']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  isSelfAssignable?: InputMaybe<Scalars['Boolean']['input']>;
  levelId?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<ReviewAssignmentOrganisationIdFkeyInput>;
  reviewAssignmentAssignerJoinsUsingId?: InputMaybe<ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput>;
  reviewUsingId?: InputMaybe<ReviewReviewAssignmentIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewAssignmentStatus>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelToLevelId?: InputMaybe<ReviewAssignmentLevelIdFkeyInput>;
  templateStageToStageId?: InputMaybe<ReviewAssignmentStageIdFkeyInput>;
  templateToTemplateId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInput>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToAssignerId?: InputMaybe<FakePublicReviewAssignmentForeignKey1Input>;
  userListToReviewerId?: InputMaybe<FakePublicReviewAssignmentForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewDecision` being updated. */
export type UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch = {
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<Decision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  reviewToReviewId?: InputMaybe<ReviewDecisionReviewIdFkeyInput>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForFakePublicReviewForeignKey0Patch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForReviewApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** An object where the defined keys will be set on the `review` being updated. */
export type UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<ReviewApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  isLastLevel?: InputMaybe<Scalars['Boolean']['input']>;
  isLastStage?: InputMaybe<Scalars['Boolean']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  notificationsUsingId?: InputMaybe<NotificationReviewIdFkeyInverseInput>;
  reviewAssignmentId?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentToReviewAssignmentId?: InputMaybe<ReviewReviewAssignmentIdFkeyInput>;
  reviewDecisionsUsingId?: InputMaybe<ReviewDecisionReviewIdFkeyInverseInput>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseReviewIdFkeyInverseInput>;
  reviewStatusHistoriesUsingId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInverseInput>;
  reviewerId?: InputMaybe<Scalars['Int']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  timeStageCreated?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  userListToReviewerId?: InputMaybe<FakePublicReviewForeignKey0Input>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch = {
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementId?: InputMaybe<Scalars['Int']['input']>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewResponse` being updated. */
export type UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch = {
  applicationResponseId?: InputMaybe<Scalars['Int']['input']>;
  applicationResponseToApplicationResponseId?: InputMaybe<ReviewResponseApplicationResponseIdFkeyInput>;
  comment?: InputMaybe<Scalars['String']['input']>;
  decision?: InputMaybe<ReviewResponseDecision>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLatestReview?: InputMaybe<Scalars['Boolean']['input']>;
  isLatestReviewSubmission?: InputMaybe<Scalars['Boolean']['input']>;
  isVisibleToApplicant?: InputMaybe<Scalars['Boolean']['input']>;
  originalReviewResponseId?: InputMaybe<Scalars['Int']['input']>;
  recommendedApplicantVisibility?: InputMaybe<ReviewResponseRecommendedApplicantVisibility>;
  reviewId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseLinkId?: InputMaybe<Scalars['Int']['input']>;
  reviewResponseToOriginalReviewResponseId?: InputMaybe<ReviewResponseOriginalReviewResponseIdFkeyInput>;
  reviewResponseToReviewResponseLinkId?: InputMaybe<ReviewResponseReviewResponseLinkIdFkeyInput>;
  reviewToReviewId?: InputMaybe<ReviewResponseReviewIdFkeyInput>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<ReviewResponseStatus>;
  templateElementToTemplateElementId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInput>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeSubmitted?: InputMaybe<Scalars['Datetime']['input']>;
  timeUpdated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `reviewStatusHistory` being updated. */
export type UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  isCurrent?: InputMaybe<Scalars['Boolean']['input']>;
  reviewToReviewId?: InputMaybe<ReviewStatusHistoryReviewIdFkeyInput>;
  status?: InputMaybe<ReviewStatus>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `templateAction` being updated. */
export type UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch = {
  actionCode?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  condition?: InputMaybe<Scalars['JSON']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  parameterQueries?: InputMaybe<Scalars['JSON']['input']>;
  sequence?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateActionTemplateIdFkeyInput>;
  trigger?: InputMaybe<Trigger>;
};

/** An object where the defined keys will be set on the `templateCategory` being updated. */
export type UpdateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isSubmenu?: InputMaybe<Scalars['Boolean']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  templatesUsingId?: InputMaybe<TemplateTemplateCategoryIdFkeyInverseInput>;
  title?: InputMaybe<Scalars['String']['input']>;
  uiLocation?: InputMaybe<Array<InputMaybe<UiLocation>>>;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  reviewability?: InputMaybe<Reviewability>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  reviewability?: InputMaybe<Reviewability>;
  sectionId?: InputMaybe<Scalars['Int']['input']>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `templateElement` being updated. */
export type UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch = {
  applicationResponsesUsingId?: InputMaybe<ApplicationResponseTemplateElementIdFkeyInverseInput>;
  category?: InputMaybe<TemplateElementCategory>;
  code?: InputMaybe<Scalars['String']['input']>;
  elementTypePluginCode?: InputMaybe<Scalars['String']['input']>;
  helpText?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  initialValue?: InputMaybe<Scalars['JSON']['input']>;
  isEditable?: InputMaybe<Scalars['JSON']['input']>;
  isRequired?: InputMaybe<Scalars['JSON']['input']>;
  parameters?: InputMaybe<Scalars['JSON']['input']>;
  reviewResponsesUsingId?: InputMaybe<ReviewResponseTemplateElementIdFkeyInverseInput>;
  reviewability?: InputMaybe<Reviewability>;
  templateCode?: InputMaybe<Scalars['String']['input']>;
  templateSectionToSectionId?: InputMaybe<TemplateElementSectionIdFkeyInput>;
  templateVersion?: InputMaybe<Scalars['String']['input']>;
  title?: InputMaybe<Scalars['String']['input']>;
  validation?: InputMaybe<Scalars['JSON']['input']>;
  validationMessage?: InputMaybe<Scalars['String']['input']>;
  visibilityCondition?: InputMaybe<Scalars['JSON']['input']>;
};

/** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
export type UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch = {
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** An object where the defined keys will be set on the `templateFilterJoin` being updated. */
export type UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch = {
  filterId?: InputMaybe<Scalars['Int']['input']>;
  filterToFilterId?: InputMaybe<TemplateFilterJoinFilterIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInput>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnFileForFileTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `template` being updated. */
export type UpdateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTemplateIdFkeyInverseInput>;
  applicationsUsingId?: InputMaybe<ApplicationTemplateIdFkeyInverseInput>;
  canApplicantMakeChanges?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  dashboardRestrictions?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  filesUsingId?: InputMaybe<FileTemplateIdFkeyInverseInput>;
  icon?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isLinear?: InputMaybe<Scalars['Boolean']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  namePlural?: InputMaybe<Scalars['String']['input']>;
  parentVersionId?: InputMaybe<Scalars['String']['input']>;
  priority?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentTemplateIdFkeyInverseInput>;
  serialPattern?: InputMaybe<Scalars['String']['input']>;
  startMessage?: InputMaybe<Scalars['JSON']['input']>;
  status?: InputMaybe<TemplateStatus>;
  submissionMessage?: InputMaybe<Scalars['JSON']['input']>;
  templateActionsUsingId?: InputMaybe<TemplateActionTemplateIdFkeyInverseInput>;
  templateCategoryId?: InputMaybe<Scalars['Int']['input']>;
  templateCategoryToTemplateCategoryId?: InputMaybe<TemplateTemplateCategoryIdFkeyInput>;
  templateFilterJoinsUsingId?: InputMaybe<TemplateFilterJoinTemplateIdFkeyInverseInput>;
  templatePermissionsUsingId?: InputMaybe<TemplatePermissionTemplateIdFkeyInverseInput>;
  templateSectionsUsingId?: InputMaybe<TemplateSectionTemplateIdFkeyInverseInput>;
  templateStagesUsingId?: InputMaybe<TemplateStageTemplateIdFkeyInverseInput>;
  triggerSchedulesUsingId?: InputMaybe<TriggerScheduleTemplateIdFkeyInverseInput>;
  versionComment?: InputMaybe<Scalars['String']['input']>;
  versionHistory?: InputMaybe<Scalars['JSON']['input']>;
  versionId?: InputMaybe<Scalars['String']['input']>;
  versionTimestamp?: InputMaybe<Scalars['Datetime']['input']>;
};

/** An object where the defined keys will be set on the `templatePermission` being updated. */
export type UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** An object where the defined keys will be set on the `templatePermission` being updated. */
export type UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch = {
  allowedSections?: InputMaybe<Array<InputMaybe<Scalars['String']['input']>>>;
  canMakeFinalDecision?: InputMaybe<Scalars['Boolean']['input']>;
  canSelfAssign?: InputMaybe<Scalars['Boolean']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  levelNumber?: InputMaybe<Scalars['Int']['input']>;
  permissionNameId?: InputMaybe<Scalars['Int']['input']>;
  permissionNameToPermissionNameId?: InputMaybe<TemplatePermissionPermissionNameIdFkeyInput>;
  restrictions?: InputMaybe<Scalars['JSON']['input']>;
  stageNumber?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplatePermissionTemplateIdFkeyInput>;
};

/** An object where the defined keys will be set on the `templateSection` being updated. */
export type UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateSection` being updated. */
export type UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch = {
  code?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  index?: InputMaybe<Scalars['Int']['input']>;
  templateElementsUsingId?: InputMaybe<TemplateElementSectionIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateSectionTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateStage` being updated. */
export type UpdateTemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch = {
  applicationStageHistoriesUsingId?: InputMaybe<ApplicationStageHistoryStageIdFkeyInverseInput>;
  colour?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentStageIdFkeyInverseInput>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateStageReviewLevelsUsingId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInverseInput>;
  templateToTemplateId?: InputMaybe<TemplateStageTemplateIdFkeyInput>;
  title?: InputMaybe<Scalars['String']['input']>;
};

/** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
export type UpdateTemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  singleReviewerAllSections?: InputMaybe<Scalars['Boolean']['input']>;
  stageId?: InputMaybe<Scalars['Int']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** An object where the defined keys will be set on the `templateStageReviewLevel` being updated. */
export type UpdateTemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch = {
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  number?: InputMaybe<Scalars['Int']['input']>;
  reviewAssignmentsUsingId?: InputMaybe<ReviewAssignmentLevelIdFkeyInverseInput>;
  singleReviewerAllSections?: InputMaybe<Scalars['Boolean']['input']>;
  templateStageToStageId?: InputMaybe<TemplateStageReviewLevelStageIdFkeyInput>;
};

/** An object where the defined keys will be set on the `triggerQueue` being updated. */
export type UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** An object where the defined keys will be set on the `triggerQueue` being updated. */
export type UpdateTriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch = {
  actionQueuesUsingId?: InputMaybe<ActionQueueTriggerEventFkeyInverseInput>;
  applicationToApplicationId?: InputMaybe<TriggerQueueApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  log?: InputMaybe<Scalars['JSON']['input']>;
  recordId?: InputMaybe<Scalars['Int']['input']>;
  status?: InputMaybe<TriggerQueueStatus>;
  table?: InputMaybe<Scalars['String']['input']>;
  timestamp?: InputMaybe<Scalars['Datetime']['input']>;
  triggerType?: InputMaybe<Trigger>;
};

/** An object where the defined keys will be set on the `triggerSchedule` being updated. */
export type UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateId?: InputMaybe<Scalars['Int']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
};

/** An object where the defined keys will be set on the `triggerSchedule` being updated. */
export type UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch = {
  applicationId?: InputMaybe<Scalars['Int']['input']>;
  applicationToApplicationId?: InputMaybe<TriggerScheduleApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  editorUserId?: InputMaybe<Scalars['Int']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isActive?: InputMaybe<Scalars['Boolean']['input']>;
  templateToTemplateId?: InputMaybe<TriggerScheduleTemplateIdFkeyInput>;
  timeScheduled?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
};

/** An object where the defined keys will be set on the `userApplicationJoin` being updated. */
export type UpdateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<UserApplicationJoinApplicationIdFkeyInput>;
  id?: InputMaybe<Scalars['Int']['input']>;
  userId?: InputMaybe<Scalars['Int']['input']>;
};

/** An object where the defined keys will be set on the `userOrganisation` being updated. */
export type UpdateUserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0Patch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationId?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<FakePublicUserOrganisationForeignKey0Input>;
};

/** An object where the defined keys will be set on the `userOrganisation` being updated. */
export type UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch = {
  id?: InputMaybe<Scalars['Int']['input']>;
  organisationToOrganisationId?: InputMaybe<UserOrganisationOrganisationIdFkeyInput>;
  userId?: InputMaybe<Scalars['Int']['input']>;
  userRole?: InputMaybe<Scalars['String']['input']>;
  userToUserId?: InputMaybe<FakePublicUserOrganisationForeignKey0Input>;
};

/** An object where the defined keys will be set on the `verification` being updated. */
export type UpdateVerificationOnVerificationForVerificationApplicationIdFkeyPatch = {
  applicationToApplicationId?: InputMaybe<VerificationApplicationIdFkeyInput>;
  data?: InputMaybe<Scalars['JSON']['input']>;
  eventCode?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['Int']['input']>;
  isVerified?: InputMaybe<Scalars['Boolean']['input']>;
  message?: InputMaybe<Scalars['String']['input']>;
  timeCreated?: InputMaybe<Scalars['Datetime']['input']>;
  timeExpired?: InputMaybe<Scalars['Datetime']['input']>;
  trigger?: InputMaybe<Trigger>;
  uniqueId?: InputMaybe<Scalars['String']['input']>;
};



export type ResolverTypeWrapper<T> = Promise<T> | T;


export type ResolverWithResolve<TResult, TParent, TContext, TArgs> = {
  resolve: ResolverFn<TResult, TParent, TContext, TArgs>;
};
export type Resolver<TResult, TParent = {}, TContext = {}, TArgs = {}> = ResolverFn<TResult, TParent, TContext, TArgs> | ResolverWithResolve<TResult, TParent, TContext, TArgs>;

export type ResolverFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => Promise<TResult> | TResult;

export type SubscriptionSubscribeFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => AsyncIterable<TResult> | Promise<AsyncIterable<TResult>>;

export type SubscriptionResolveFn<TResult, TParent, TContext, TArgs> = (
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;

export interface SubscriptionSubscriberObject<TResult, TKey extends string, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<{ [key in TKey]: TResult }, TParent, TContext, TArgs>;
  resolve?: SubscriptionResolveFn<TResult, { [key in TKey]: TResult }, TContext, TArgs>;
}

export interface SubscriptionResolverObject<TResult, TParent, TContext, TArgs> {
  subscribe: SubscriptionSubscribeFn<any, TParent, TContext, TArgs>;
  resolve: SubscriptionResolveFn<TResult, any, TContext, TArgs>;
}

export type SubscriptionObject<TResult, TKey extends string, TParent, TContext, TArgs> =
  | SubscriptionSubscriberObject<TResult, TKey, TParent, TContext, TArgs>
  | SubscriptionResolverObject<TResult, TParent, TContext, TArgs>;

export type SubscriptionResolver<TResult, TKey extends string, TParent = {}, TContext = {}, TArgs = {}> =
  | ((...args: any[]) => SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>)
  | SubscriptionObject<TResult, TKey, TParent, TContext, TArgs>;

export type TypeResolveFn<TTypes, TParent = {}, TContext = {}> = (
  parent: TParent,
  context: TContext,
  info: GraphQLResolveInfo
) => Maybe<TTypes> | Promise<Maybe<TTypes>>;

export type IsTypeOfResolverFn<T = {}, TContext = {}> = (obj: T, context: TContext, info: GraphQLResolveInfo) => boolean | Promise<boolean>;

export type NextResolverFn<T> = () => Promise<T>;

export type DirectiveResolverFn<TResult = {}, TParent = {}, TContext = {}, TArgs = {}> = (
  next: NextResolverFn<TResult>,
  parent: TParent,
  args: TArgs,
  context: TContext,
  info: GraphQLResolveInfo
) => TResult | Promise<TResult>;


/** Mapping of interface types */
export type ResolversInterfaceTypes<_RefType extends Record<string, unknown>> = {
  Node: ( ActionPlugin ) | ( ActionQueue ) | ( ActivityLog ) | ( Application ) | ( ApplicationNote ) | ( ApplicationResponse ) | ( ApplicationReviewerAction ) | ( ApplicationStageHistory ) | ( ApplicationStatusHistory ) | ( Counter ) | ( DataChangelog ) | ( DataTable ) | ( DataTableActiveIngredient ) | ( DataTableAdministrationRoute ) | ( DataTableAtcCode ) | ( DataTableContainer ) | ( DataTableCountry ) | ( DataTableDosageForm ) | ( DataTableDosageFormGroup ) | ( DataTableGenericIngredient ) | ( DataTableManufacturer ) | ( DataTableManufacturerApplicationJoin ) | ( DataTableManufacturerRepresentative ) | ( DataTableManufacturerRepresentativeApplicationJoin ) | ( DataTablePermitChemical ) | ( DataTablePermitChemicalApplicationJoin ) | ( DataTablePreRegisteredProductsProvisional ) | ( DataTablePrequalManufacturer ) | ( DataTablePrequalManufacturerApplicationJoin ) | ( DataTableProcessingStep ) | ( DataTableProduct ) | ( DataTableProductApplicationJoin ) | ( DataTableProvisionalProduct ) | ( DataTableProvisionalProductApplicationJoin ) | ( DataTableScheduledChemical ) | ( DataTableStorageCondition ) | ( DataTableStorageConditionsSimplified ) | ( DataTableUnitsOfProportion ) | ( DataTableWorldHealthOrganisationPqListOfFpp ) | ( DataView ) | ( DataViewColumnDefinition ) | ( ElementTypePlugin ) | ( File ) | ( Filter ) | ( GrafanaDashboardImage ) | ( Notification ) | ( Organisation ) | ( OrganisationApplicationJoin ) | ( PermissionJoin ) | ( PermissionName ) | ( PermissionPolicy ) | ( Omit<Query, 'actionPlugins' | 'node' | 'query'> & { actionPlugins?: Maybe<_RefType['ActionPluginsConnection']>, node?: Maybe<_RefType['Node']>, query: _RefType['Query'] } ) | ( Review ) | ( ReviewAssignment ) | ( ReviewAssignmentAssignerJoin ) | ( ReviewDecision ) | ( ReviewResponse ) | ( ReviewStatusHistory ) | ( SystemInfo ) | ( Template ) | ( TemplateAction ) | ( TemplateCategory ) | ( TemplateElement ) | ( TemplateFilterJoin ) | ( TemplatePermission ) | ( TemplateSection ) | ( TemplateStage ) | ( TemplateStageReviewLevel ) | ( TriggerQueue ) | ( TriggerSchedule ) | ( UserApplicationJoin ) | ( UserOrganisation ) | ( Verification );
};

/** Mapping between all available schema types and the resolvers types */
export type ResolversTypes = {
  ActionPlugin: ResolverTypeWrapper<ActionPlugin>;
  ActionPluginCondition: ActionPluginCondition;
  ActionPluginFilter: ActionPluginFilter;
  ActionPluginInput: ActionPluginInput;
  ActionPluginPatch: ActionPluginPatch;
  ActionPluginsConnection: ResolverTypeWrapper<ActionPluginsConnection>;
  ActionPluginsEdge: ResolverTypeWrapper<ActionPluginsEdge>;
  ActionPluginsOrderBy: ActionPluginsOrderBy;
  ActionQueue: ResolverTypeWrapper<ActionQueue>;
  ActionQueueActionQueuePkeyConnect: ActionQueueActionQueuePkeyConnect;
  ActionQueueActionQueuePkeyDelete: ActionQueueActionQueuePkeyDelete;
  ActionQueueApplicationIdFkeyActionQueueCreateInput: ActionQueueApplicationIdFkeyActionQueueCreateInput;
  ActionQueueApplicationIdFkeyApplicationCreateInput: ActionQueueApplicationIdFkeyApplicationCreateInput;
  ActionQueueApplicationIdFkeyInput: ActionQueueApplicationIdFkeyInput;
  ActionQueueApplicationIdFkeyInverseInput: ActionQueueApplicationIdFkeyInverseInput;
  ActionQueueCondition: ActionQueueCondition;
  ActionQueueFilter: ActionQueueFilter;
  ActionQueueInput: ActionQueueInput;
  ActionQueueNodeIdConnect: ActionQueueNodeIdConnect;
  ActionQueueNodeIdDelete: ActionQueueNodeIdDelete;
  ActionQueueOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate;
  ActionQueueOnActionQueueForActionQueueApplicationIdFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueApplicationIdFkeyUsingActionQueuePkeyUpdate;
  ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate;
  ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate;
  ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate;
  ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate;
  ActionQueuePatch: ActionQueuePatch;
  ActionQueueStatus: ActionQueueStatus;
  ActionQueueStatusFilter: ActionQueueStatusFilter;
  ActionQueueTemplateIdFkeyActionQueueCreateInput: ActionQueueTemplateIdFkeyActionQueueCreateInput;
  ActionQueueTemplateIdFkeyInput: ActionQueueTemplateIdFkeyInput;
  ActionQueueTemplateIdFkeyInverseInput: ActionQueueTemplateIdFkeyInverseInput;
  ActionQueueTemplateIdFkeyTemplateCreateInput: ActionQueueTemplateIdFkeyTemplateCreateInput;
  ActionQueueTriggerEventFkeyActionQueueCreateInput: ActionQueueTriggerEventFkeyActionQueueCreateInput;
  ActionQueueTriggerEventFkeyInput: ActionQueueTriggerEventFkeyInput;
  ActionQueueTriggerEventFkeyInverseInput: ActionQueueTriggerEventFkeyInverseInput;
  ActionQueueTriggerEventFkeyTriggerQueueCreateInput: ActionQueueTriggerEventFkeyTriggerQueueCreateInput;
  ActionQueuesConnection: ResolverTypeWrapper<ActionQueuesConnection>;
  ActionQueuesEdge: ResolverTypeWrapper<ActionQueuesEdge>;
  ActionQueuesOrderBy: ActionQueuesOrderBy;
  ActivityLog: ResolverTypeWrapper<ActivityLog>;
  ActivityLogActivityLogPkeyConnect: ActivityLogActivityLogPkeyConnect;
  ActivityLogActivityLogPkeyDelete: ActivityLogActivityLogPkeyDelete;
  ActivityLogApplicationIdFkeyActivityLogCreateInput: ActivityLogApplicationIdFkeyActivityLogCreateInput;
  ActivityLogApplicationIdFkeyApplicationCreateInput: ActivityLogApplicationIdFkeyApplicationCreateInput;
  ActivityLogApplicationIdFkeyInput: ActivityLogApplicationIdFkeyInput;
  ActivityLogApplicationIdFkeyInverseInput: ActivityLogApplicationIdFkeyInverseInput;
  ActivityLogCondition: ActivityLogCondition;
  ActivityLogFilter: ActivityLogFilter;
  ActivityLogInput: ActivityLogInput;
  ActivityLogNodeIdConnect: ActivityLogNodeIdConnect;
  ActivityLogNodeIdDelete: ActivityLogNodeIdDelete;
  ActivityLogOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate: ActivityLogOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate;
  ActivityLogOnActivityLogForActivityLogApplicationIdFkeyUsingActivityLogPkeyUpdate: ActivityLogOnActivityLogForActivityLogApplicationIdFkeyUsingActivityLogPkeyUpdate;
  ActivityLogPatch: ActivityLogPatch;
  ActivityLogsConnection: ResolverTypeWrapper<ActivityLogsConnection>;
  ActivityLogsEdge: ResolverTypeWrapper<ActivityLogsEdge>;
  ActivityLogsOrderBy: ActivityLogsOrderBy;
  AllowedSelfAssignableSectionsShape: ResolverTypeWrapper<AllowedSelfAssignableSectionsShape>;
  AllowedSelfAssignableSectionsShapeCondition: AllowedSelfAssignableSectionsShapeCondition;
  AllowedSelfAssignableSectionsShapeFilter: AllowedSelfAssignableSectionsShapeFilter;
  AllowedSelfAssignableSectionsShapeInput: AllowedSelfAssignableSectionsShapeInput;
  AllowedSelfAssignableSectionsShapesConnection: ResolverTypeWrapper<AllowedSelfAssignableSectionsShapesConnection>;
  AllowedSelfAssignableSectionsShapesEdge: ResolverTypeWrapper<AllowedSelfAssignableSectionsShapesEdge>;
  AllowedSelfAssignableSectionsShapesOrderBy: AllowedSelfAssignableSectionsShapesOrderBy;
  Application: ResolverTypeWrapper<Application>;
  ApplicationApplicationOutcomeRegistrationKeyConnect: ApplicationApplicationOutcomeRegistrationKeyConnect;
  ApplicationApplicationOutcomeRegistrationKeyDelete: ApplicationApplicationOutcomeRegistrationKeyDelete;
  ApplicationApplicationPkeyConnect: ApplicationApplicationPkeyConnect;
  ApplicationApplicationPkeyDelete: ApplicationApplicationPkeyDelete;
  ApplicationApplicationSerialKeyConnect: ApplicationApplicationSerialKeyConnect;
  ApplicationApplicationSerialKeyDelete: ApplicationApplicationSerialKeyDelete;
  ApplicationCondition: ApplicationCondition;
  ApplicationFilter: ApplicationFilter;
  ApplicationInput: ApplicationInput;
  ApplicationListFilterApplicantConnection: ResolverTypeWrapper<ApplicationListFilterApplicantConnection>;
  ApplicationListFilterApplicantEdge: ResolverTypeWrapper<ApplicationListFilterApplicantEdge>;
  ApplicationListFilterAssignerConnection: ResolverTypeWrapper<ApplicationListFilterAssignerConnection>;
  ApplicationListFilterAssignerEdge: ResolverTypeWrapper<ApplicationListFilterAssignerEdge>;
  ApplicationListFilterOrganisationConnection: ResolverTypeWrapper<ApplicationListFilterOrganisationConnection>;
  ApplicationListFilterOrganisationEdge: ResolverTypeWrapper<ApplicationListFilterOrganisationEdge>;
  ApplicationListFilterReviewerConnection: ResolverTypeWrapper<ApplicationListFilterReviewerConnection>;
  ApplicationListFilterReviewerEdge: ResolverTypeWrapper<ApplicationListFilterReviewerEdge>;
  ApplicationListFilterStageConnection: ResolverTypeWrapper<ApplicationListFilterStageConnection>;
  ApplicationListFilterStageEdge: ResolverTypeWrapper<ApplicationListFilterStageEdge>;
  ApplicationListShape: ResolverTypeWrapper<ApplicationListShape>;
  ApplicationListShapeCondition: ApplicationListShapeCondition;
  ApplicationListShapeFilter: ApplicationListShapeFilter;
  ApplicationListShapeInput: ApplicationListShapeInput;
  ApplicationListShapesConnection: ResolverTypeWrapper<ApplicationListShapesConnection>;
  ApplicationListShapesEdge: ResolverTypeWrapper<ApplicationListShapesEdge>;
  ApplicationListShapesOrderBy: ApplicationListShapesOrderBy;
  ApplicationNodeIdConnect: ApplicationNodeIdConnect;
  ApplicationNodeIdDelete: ApplicationNodeIdDelete;
  ApplicationNote: ResolverTypeWrapper<ApplicationNote>;
  ApplicationNoteApplicationIdFkeyApplicationCreateInput: ApplicationNoteApplicationIdFkeyApplicationCreateInput;
  ApplicationNoteApplicationIdFkeyApplicationNoteCreateInput: ApplicationNoteApplicationIdFkeyApplicationNoteCreateInput;
  ApplicationNoteApplicationIdFkeyInput: ApplicationNoteApplicationIdFkeyInput;
  ApplicationNoteApplicationIdFkeyInverseInput: ApplicationNoteApplicationIdFkeyInverseInput;
  ApplicationNoteApplicationNotePkeyConnect: ApplicationNoteApplicationNotePkeyConnect;
  ApplicationNoteApplicationNotePkeyDelete: ApplicationNoteApplicationNotePkeyDelete;
  ApplicationNoteCondition: ApplicationNoteCondition;
  ApplicationNoteFilter: ApplicationNoteFilter;
  ApplicationNoteInput: ApplicationNoteInput;
  ApplicationNoteNodeIdConnect: ApplicationNoteNodeIdConnect;
  ApplicationNoteNodeIdDelete: ApplicationNoteNodeIdDelete;
  ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate: ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate;
  ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationNotePkeyUpdate: ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationNotePkeyUpdate;
  ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate: ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate;
  ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyUsingApplicationNotePkeyUpdate: ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyUsingApplicationNotePkeyUpdate;
  ApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0UsingApplicationNotePkeyUpdate: ApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0UsingApplicationNotePkeyUpdate;
  ApplicationNoteOnFileForFileApplicationNoteIdFkeyNodeIdUpdate: ApplicationNoteOnFileForFileApplicationNoteIdFkeyNodeIdUpdate;
  ApplicationNoteOnFileForFileApplicationNoteIdFkeyUsingApplicationNotePkeyUpdate: ApplicationNoteOnFileForFileApplicationNoteIdFkeyUsingApplicationNotePkeyUpdate;
  ApplicationNoteOrgIdFkeyApplicationNoteCreateInput: ApplicationNoteOrgIdFkeyApplicationNoteCreateInput;
  ApplicationNoteOrgIdFkeyInput: ApplicationNoteOrgIdFkeyInput;
  ApplicationNoteOrgIdFkeyInverseInput: ApplicationNoteOrgIdFkeyInverseInput;
  ApplicationNoteOrgIdFkeyOrganisationCreateInput: ApplicationNoteOrgIdFkeyOrganisationCreateInput;
  ApplicationNotePatch: ApplicationNotePatch;
  ApplicationNoteToManyFileFilter: ApplicationNoteToManyFileFilter;
  ApplicationNotesConnection: ResolverTypeWrapper<ApplicationNotesConnection>;
  ApplicationNotesEdge: ResolverTypeWrapper<ApplicationNotesEdge>;
  ApplicationNotesOrderBy: ApplicationNotesOrderBy;
  ApplicationOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate: ApplicationOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate;
  ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate: ApplicationOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate;
  ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationPkeyUpdate: ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationPkeyUpdate;
  ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationSerialKeyUpdate: ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate;
  ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate;
  ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate: ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnFileForFileApplicationSerialFkeyNodeIdUpdate: ApplicationOnFileForFileApplicationSerialFkeyNodeIdUpdate;
  ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationPkeyUpdate: ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationPkeyUpdate;
  ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationSerialKeyUpdate: ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate: ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate: ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate;
  ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate: ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate;
  ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate: ApplicationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate;
  ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOrgIdFkeyApplicationCreateInput: ApplicationOrgIdFkeyApplicationCreateInput;
  ApplicationOrgIdFkeyInput: ApplicationOrgIdFkeyInput;
  ApplicationOrgIdFkeyInverseInput: ApplicationOrgIdFkeyInverseInput;
  ApplicationOrgIdFkeyOrganisationCreateInput: ApplicationOrgIdFkeyOrganisationCreateInput;
  ApplicationOutcome: ApplicationOutcome;
  ApplicationOutcomeFilter: ApplicationOutcomeFilter;
  ApplicationPatch: ApplicationPatch;
  ApplicationResponse: ResolverTypeWrapper<ApplicationResponse>;
  ApplicationResponseApplicationIdFkeyApplicationCreateInput: ApplicationResponseApplicationIdFkeyApplicationCreateInput;
  ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput: ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput;
  ApplicationResponseApplicationIdFkeyInput: ApplicationResponseApplicationIdFkeyInput;
  ApplicationResponseApplicationIdFkeyInverseInput: ApplicationResponseApplicationIdFkeyInverseInput;
  ApplicationResponseApplicationResponsePkeyConnect: ApplicationResponseApplicationResponsePkeyConnect;
  ApplicationResponseApplicationResponsePkeyDelete: ApplicationResponseApplicationResponsePkeyDelete;
  ApplicationResponseCondition: ApplicationResponseCondition;
  ApplicationResponseFilter: ApplicationResponseFilter;
  ApplicationResponseInput: ApplicationResponseInput;
  ApplicationResponseNodeIdConnect: ApplicationResponseNodeIdConnect;
  ApplicationResponseNodeIdDelete: ApplicationResponseNodeIdDelete;
  ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate;
  ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate;
  ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate;
  ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate;
  ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate: ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate;
  ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate;
  ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate: ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate;
  ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate;
  ApplicationResponsePatch: ApplicationResponsePatch;
  ApplicationResponseStatus: ApplicationResponseStatus;
  ApplicationResponseStatusFilter: ApplicationResponseStatusFilter;
  ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput: ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput;
  ApplicationResponseTemplateElementIdFkeyInput: ApplicationResponseTemplateElementIdFkeyInput;
  ApplicationResponseTemplateElementIdFkeyInverseInput: ApplicationResponseTemplateElementIdFkeyInverseInput;
  ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput: ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput;
  ApplicationResponseToManyFileFilter: ApplicationResponseToManyFileFilter;
  ApplicationResponseToManyReviewResponseFilter: ApplicationResponseToManyReviewResponseFilter;
  ApplicationResponsesConnection: ResolverTypeWrapper<ApplicationResponsesConnection>;
  ApplicationResponsesEdge: ResolverTypeWrapper<ApplicationResponsesEdge>;
  ApplicationResponsesOrderBy: ApplicationResponsesOrderBy;
  ApplicationReviewerAction: ResolverTypeWrapper<ApplicationReviewerAction>;
  ApplicationReviewerActionApplicationIdFkeyApplicationCreateInput: ApplicationReviewerActionApplicationIdFkeyApplicationCreateInput;
  ApplicationReviewerActionApplicationIdFkeyApplicationReviewerActionCreateInput: ApplicationReviewerActionApplicationIdFkeyApplicationReviewerActionCreateInput;
  ApplicationReviewerActionApplicationIdFkeyInput: ApplicationReviewerActionApplicationIdFkeyInput;
  ApplicationReviewerActionApplicationIdFkeyInverseInput: ApplicationReviewerActionApplicationIdFkeyInverseInput;
  ApplicationReviewerActionApplicationReviewerActionPkeyConnect: ApplicationReviewerActionApplicationReviewerActionPkeyConnect;
  ApplicationReviewerActionApplicationReviewerActionPkeyDelete: ApplicationReviewerActionApplicationReviewerActionPkeyDelete;
  ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyConnect: ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyConnect;
  ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyDelete: ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyDelete;
  ApplicationReviewerActionCondition: ApplicationReviewerActionCondition;
  ApplicationReviewerActionFilter: ApplicationReviewerActionFilter;
  ApplicationReviewerActionInput: ApplicationReviewerActionInput;
  ApplicationReviewerActionNodeIdConnect: ApplicationReviewerActionNodeIdConnect;
  ApplicationReviewerActionNodeIdDelete: ApplicationReviewerActionNodeIdDelete;
  ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate: ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate;
  ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionPkeyUpdate: ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionPkeyUpdate;
  ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionUserIdApplicationIdKeyUpdate: ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionUserIdApplicationIdKeyUpdate;
  ApplicationReviewerActionPatch: ApplicationReviewerActionPatch;
  ApplicationReviewerActionsConnection: ResolverTypeWrapper<ApplicationReviewerActionsConnection>;
  ApplicationReviewerActionsEdge: ResolverTypeWrapper<ApplicationReviewerActionsEdge>;
  ApplicationReviewerActionsOrderBy: ApplicationReviewerActionsOrderBy;
  ApplicationStageHistoriesConnection: ResolverTypeWrapper<ApplicationStageHistoriesConnection>;
  ApplicationStageHistoriesEdge: ResolverTypeWrapper<ApplicationStageHistoriesEdge>;
  ApplicationStageHistoriesOrderBy: ApplicationStageHistoriesOrderBy;
  ApplicationStageHistory: ResolverTypeWrapper<ApplicationStageHistory>;
  ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput: ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput;
  ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput: ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput;
  ApplicationStageHistoryApplicationIdFkeyInput: ApplicationStageHistoryApplicationIdFkeyInput;
  ApplicationStageHistoryApplicationIdFkeyInverseInput: ApplicationStageHistoryApplicationIdFkeyInverseInput;
  ApplicationStageHistoryApplicationStageHistoryPkeyConnect: ApplicationStageHistoryApplicationStageHistoryPkeyConnect;
  ApplicationStageHistoryApplicationStageHistoryPkeyDelete: ApplicationStageHistoryApplicationStageHistoryPkeyDelete;
  ApplicationStageHistoryCondition: ApplicationStageHistoryCondition;
  ApplicationStageHistoryFilter: ApplicationStageHistoryFilter;
  ApplicationStageHistoryInput: ApplicationStageHistoryInput;
  ApplicationStageHistoryNodeIdConnect: ApplicationStageHistoryNodeIdConnect;
  ApplicationStageHistoryNodeIdDelete: ApplicationStageHistoryNodeIdDelete;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate;
  ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  ApplicationStageHistoryPatch: ApplicationStageHistoryPatch;
  ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput: ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput;
  ApplicationStageHistoryStageIdFkeyInput: ApplicationStageHistoryStageIdFkeyInput;
  ApplicationStageHistoryStageIdFkeyInverseInput: ApplicationStageHistoryStageIdFkeyInverseInput;
  ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput: ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput;
  ApplicationStageHistoryToManyApplicationStatusHistoryFilter: ApplicationStageHistoryToManyApplicationStatusHistoryFilter;
  ApplicationStageStatusAll: ResolverTypeWrapper<ApplicationStageStatusAll>;
  ApplicationStageStatusAllCondition: ApplicationStageStatusAllCondition;
  ApplicationStageStatusAllFilter: ApplicationStageStatusAllFilter;
  ApplicationStageStatusAllsConnection: ResolverTypeWrapper<ApplicationStageStatusAllsConnection>;
  ApplicationStageStatusAllsEdge: ResolverTypeWrapper<ApplicationStageStatusAllsEdge>;
  ApplicationStageStatusAllsOrderBy: ApplicationStageStatusAllsOrderBy;
  ApplicationStageStatusLatest: ResolverTypeWrapper<ApplicationStageStatusLatest>;
  ApplicationStageStatusLatestCondition: ApplicationStageStatusLatestCondition;
  ApplicationStageStatusLatestFilter: ApplicationStageStatusLatestFilter;
  ApplicationStageStatusLatestsConnection: ResolverTypeWrapper<ApplicationStageStatusLatestsConnection>;
  ApplicationStageStatusLatestsEdge: ResolverTypeWrapper<ApplicationStageStatusLatestsEdge>;
  ApplicationStageStatusLatestsOrderBy: ApplicationStageStatusLatestsOrderBy;
  ApplicationStatus: ApplicationStatus;
  ApplicationStatusFilter: ApplicationStatusFilter;
  ApplicationStatusHistoriesConnection: ResolverTypeWrapper<ApplicationStatusHistoriesConnection>;
  ApplicationStatusHistoriesEdge: ResolverTypeWrapper<ApplicationStatusHistoriesEdge>;
  ApplicationStatusHistoriesOrderBy: ApplicationStatusHistoriesOrderBy;
  ApplicationStatusHistory: ResolverTypeWrapper<ApplicationStatusHistory>;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput;
  ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect: ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect;
  ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete: ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete;
  ApplicationStatusHistoryCondition: ApplicationStatusHistoryCondition;
  ApplicationStatusHistoryFilter: ApplicationStatusHistoryFilter;
  ApplicationStatusHistoryInput: ApplicationStatusHistoryInput;
  ApplicationStatusHistoryNodeIdConnect: ApplicationStatusHistoryNodeIdConnect;
  ApplicationStatusHistoryNodeIdDelete: ApplicationStatusHistoryNodeIdDelete;
  ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate: ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate;
  ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate: ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate;
  ApplicationStatusHistoryPatch: ApplicationStatusHistoryPatch;
  ApplicationTemplateIdFkeyApplicationCreateInput: ApplicationTemplateIdFkeyApplicationCreateInput;
  ApplicationTemplateIdFkeyInput: ApplicationTemplateIdFkeyInput;
  ApplicationTemplateIdFkeyInverseInput: ApplicationTemplateIdFkeyInverseInput;
  ApplicationTemplateIdFkeyTemplateCreateInput: ApplicationTemplateIdFkeyTemplateCreateInput;
  ApplicationToManyActionQueueFilter: ApplicationToManyActionQueueFilter;
  ApplicationToManyActivityLogFilter: ApplicationToManyActivityLogFilter;
  ApplicationToManyApplicationNoteFilter: ApplicationToManyApplicationNoteFilter;
  ApplicationToManyApplicationResponseFilter: ApplicationToManyApplicationResponseFilter;
  ApplicationToManyApplicationReviewerActionFilter: ApplicationToManyApplicationReviewerActionFilter;
  ApplicationToManyApplicationStageHistoryFilter: ApplicationToManyApplicationStageHistoryFilter;
  ApplicationToManyDataChangelogFilter: ApplicationToManyDataChangelogFilter;
  ApplicationToManyDataTableManufacturerApplicationJoinFilter: ApplicationToManyDataTableManufacturerApplicationJoinFilter;
  ApplicationToManyDataTableManufacturerRepresentativeApplicationJoinFilter: ApplicationToManyDataTableManufacturerRepresentativeApplicationJoinFilter;
  ApplicationToManyDataTablePermitChemicalApplicationJoinFilter: ApplicationToManyDataTablePermitChemicalApplicationJoinFilter;
  ApplicationToManyDataTablePrequalManufacturerApplicationJoinFilter: ApplicationToManyDataTablePrequalManufacturerApplicationJoinFilter;
  ApplicationToManyDataTableProductApplicationJoinFilter: ApplicationToManyDataTableProductApplicationJoinFilter;
  ApplicationToManyDataTableProvisionalProductApplicationJoinFilter: ApplicationToManyDataTableProvisionalProductApplicationJoinFilter;
  ApplicationToManyFileFilter: ApplicationToManyFileFilter;
  ApplicationToManyNotificationFilter: ApplicationToManyNotificationFilter;
  ApplicationToManyOrganisationApplicationJoinFilter: ApplicationToManyOrganisationApplicationJoinFilter;
  ApplicationToManyReviewAssignmentFilter: ApplicationToManyReviewAssignmentFilter;
  ApplicationToManyReviewFilter: ApplicationToManyReviewFilter;
  ApplicationToManyTriggerQueueFilter: ApplicationToManyTriggerQueueFilter;
  ApplicationToManyTriggerScheduleFilter: ApplicationToManyTriggerScheduleFilter;
  ApplicationToManyUserApplicationJoinFilter: ApplicationToManyUserApplicationJoinFilter;
  ApplicationToManyVerificationFilter: ApplicationToManyVerificationFilter;
  ApplicationsConnection: ResolverTypeWrapper<ApplicationsConnection>;
  ApplicationsEdge: ResolverTypeWrapper<ApplicationsEdge>;
  ApplicationsOrderBy: ApplicationsOrderBy;
  AssignedQuestionEdge: ResolverTypeWrapper<AssignedQuestionEdge>;
  AssignedQuestionsConnection: ResolverTypeWrapper<AssignedQuestionsConnection>;
  AssignedQuestionsRecord: ResolverTypeWrapper<AssignedQuestionsRecord>;
  AssignedQuestionsRecordFilter: AssignedQuestionsRecordFilter;
  AssignedSectionsByStageAndLevel: ResolverTypeWrapper<AssignedSectionsByStageAndLevel>;
  AssignedSectionsByStageAndLevelCondition: AssignedSectionsByStageAndLevelCondition;
  AssignedSectionsByStageAndLevelFilter: AssignedSectionsByStageAndLevelFilter;
  AssignedSectionsByStageAndLevelsConnection: ResolverTypeWrapper<AssignedSectionsByStageAndLevelsConnection>;
  AssignedSectionsByStageAndLevelsEdge: ResolverTypeWrapper<AssignedSectionsByStageAndLevelsEdge>;
  AssignedSectionsByStageAndLevelsOrderBy: AssignedSectionsByStageAndLevelsOrderBy;
  AssignerAction: AssignerAction;
  AssignerActionFilter: AssignerActionFilter;
  AssignerListConnection: ResolverTypeWrapper<AssignerListConnection>;
  AssignerListEdge: ResolverTypeWrapper<AssignerListEdge>;
  AssignerListRecord: ResolverTypeWrapper<AssignerListRecord>;
  AssignerListRecordFilter: AssignerListRecordFilter;
  AssignmentListConnection: ResolverTypeWrapper<AssignmentListConnection>;
  AssignmentListEdge: ResolverTypeWrapper<AssignmentListEdge>;
  AssignmentListRecord: ResolverTypeWrapper<AssignmentListRecord>;
  AssignmentListRecordFilter: AssignmentListRecordFilter;
  BigInt: ResolverTypeWrapper<Scalars['BigInt']['output']>;
  BigIntFilter: BigIntFilter;
  Boolean: ResolverTypeWrapper<Scalars['Boolean']['output']>;
  BooleanFilter: BooleanFilter;
  ChangelogType: ChangelogType;
  ChangelogTypeFilter: ChangelogTypeFilter;
  CharacterData: ResolverTypeWrapper<Scalars['CharacterData']['output']>;
  CharacterDataFilter: CharacterDataFilter;
  ConstraintsInfo: ResolverTypeWrapper<ConstraintsInfo>;
  ConstraintsInfoCondition: ConstraintsInfoCondition;
  ConstraintsInfoFilter: ConstraintsInfoFilter;
  ConstraintsInfosConnection: ResolverTypeWrapper<ConstraintsInfosConnection>;
  ConstraintsInfosEdge: ResolverTypeWrapper<ConstraintsInfosEdge>;
  ConstraintsInfosOrderBy: ConstraintsInfosOrderBy;
  Counter: ResolverTypeWrapper<Counter>;
  CounterCondition: CounterCondition;
  CounterFilter: CounterFilter;
  CounterInput: CounterInput;
  CounterPatch: CounterPatch;
  CountersConnection: ResolverTypeWrapper<CountersConnection>;
  CountersEdge: ResolverTypeWrapper<CountersEdge>;
  CountersOrderBy: CountersOrderBy;
  CreateActionPluginInput: CreateActionPluginInput;
  CreateActionPluginPayload: ResolverTypeWrapper<Omit<CreateActionPluginPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateActionQueueInput: CreateActionQueueInput;
  CreateActionQueuePayload: ResolverTypeWrapper<Omit<CreateActionQueuePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateActivityLogInput: CreateActivityLogInput;
  CreateActivityLogPayload: ResolverTypeWrapper<Omit<CreateActivityLogPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateAllowedSelfAssignableSectionsShapeInput: CreateAllowedSelfAssignableSectionsShapeInput;
  CreateAllowedSelfAssignableSectionsShapePayload: ResolverTypeWrapper<Omit<CreateAllowedSelfAssignableSectionsShapePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateApplicationInput: CreateApplicationInput;
  CreateApplicationListShapeInput: CreateApplicationListShapeInput;
  CreateApplicationListShapePayload: ResolverTypeWrapper<Omit<CreateApplicationListShapePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateApplicationNoteInput: CreateApplicationNoteInput;
  CreateApplicationNotePayload: ResolverTypeWrapper<Omit<CreateApplicationNotePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateApplicationPayload: ResolverTypeWrapper<Omit<CreateApplicationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateApplicationResponseInput: CreateApplicationResponseInput;
  CreateApplicationResponsePayload: ResolverTypeWrapper<Omit<CreateApplicationResponsePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateApplicationReviewerActionInput: CreateApplicationReviewerActionInput;
  CreateApplicationReviewerActionPayload: ResolverTypeWrapper<Omit<CreateApplicationReviewerActionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateApplicationStageHistoryInput: CreateApplicationStageHistoryInput;
  CreateApplicationStageHistoryPayload: ResolverTypeWrapper<Omit<CreateApplicationStageHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateApplicationStatusHistoryInput: CreateApplicationStatusHistoryInput;
  CreateApplicationStatusHistoryPayload: ResolverTypeWrapper<Omit<CreateApplicationStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateCounterInput: CreateCounterInput;
  CreateCounterPayload: ResolverTypeWrapper<Omit<CreateCounterPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataChangelogInput: CreateDataChangelogInput;
  CreateDataChangelogPayload: ResolverTypeWrapper<Omit<CreateDataChangelogPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableActiveIngredientInput: CreateDataTableActiveIngredientInput;
  CreateDataTableActiveIngredientPayload: ResolverTypeWrapper<Omit<CreateDataTableActiveIngredientPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableAdministrationRouteInput: CreateDataTableAdministrationRouteInput;
  CreateDataTableAdministrationRoutePayload: ResolverTypeWrapper<Omit<CreateDataTableAdministrationRoutePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableAtcCodeInput: CreateDataTableAtcCodeInput;
  CreateDataTableAtcCodePayload: ResolverTypeWrapper<Omit<CreateDataTableAtcCodePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableContainerInput: CreateDataTableContainerInput;
  CreateDataTableContainerPayload: ResolverTypeWrapper<Omit<CreateDataTableContainerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableCountryInput: CreateDataTableCountryInput;
  CreateDataTableCountryPayload: ResolverTypeWrapper<Omit<CreateDataTableCountryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableDosageFormGroupInput: CreateDataTableDosageFormGroupInput;
  CreateDataTableDosageFormGroupPayload: ResolverTypeWrapper<Omit<CreateDataTableDosageFormGroupPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableDosageFormInput: CreateDataTableDosageFormInput;
  CreateDataTableDosageFormPayload: ResolverTypeWrapper<Omit<CreateDataTableDosageFormPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableGenericIngredientInput: CreateDataTableGenericIngredientInput;
  CreateDataTableGenericIngredientPayload: ResolverTypeWrapper<Omit<CreateDataTableGenericIngredientPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableInput: CreateDataTableInput;
  CreateDataTableManufacturerApplicationJoinInput: CreateDataTableManufacturerApplicationJoinInput;
  CreateDataTableManufacturerApplicationJoinPayload: ResolverTypeWrapper<Omit<CreateDataTableManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableManufacturerInput: CreateDataTableManufacturerInput;
  CreateDataTableManufacturerPayload: ResolverTypeWrapper<Omit<CreateDataTableManufacturerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableManufacturerRepresentativeApplicationJoinInput: CreateDataTableManufacturerRepresentativeApplicationJoinInput;
  CreateDataTableManufacturerRepresentativeApplicationJoinPayload: ResolverTypeWrapper<Omit<CreateDataTableManufacturerRepresentativeApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableManufacturerRepresentativeInput: CreateDataTableManufacturerRepresentativeInput;
  CreateDataTableManufacturerRepresentativePayload: ResolverTypeWrapper<Omit<CreateDataTableManufacturerRepresentativePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTablePayload: ResolverTypeWrapper<Omit<CreateDataTablePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTablePermitChemicalApplicationJoinInput: CreateDataTablePermitChemicalApplicationJoinInput;
  CreateDataTablePermitChemicalApplicationJoinPayload: ResolverTypeWrapper<Omit<CreateDataTablePermitChemicalApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTablePermitChemicalInput: CreateDataTablePermitChemicalInput;
  CreateDataTablePermitChemicalPayload: ResolverTypeWrapper<Omit<CreateDataTablePermitChemicalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTablePreRegisteredProductsProvisionalInput: CreateDataTablePreRegisteredProductsProvisionalInput;
  CreateDataTablePreRegisteredProductsProvisionalPayload: ResolverTypeWrapper<Omit<CreateDataTablePreRegisteredProductsProvisionalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTablePrequalManufacturerApplicationJoinInput: CreateDataTablePrequalManufacturerApplicationJoinInput;
  CreateDataTablePrequalManufacturerApplicationJoinPayload: ResolverTypeWrapper<Omit<CreateDataTablePrequalManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTablePrequalManufacturerInput: CreateDataTablePrequalManufacturerInput;
  CreateDataTablePrequalManufacturerPayload: ResolverTypeWrapper<Omit<CreateDataTablePrequalManufacturerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableProcessingStepInput: CreateDataTableProcessingStepInput;
  CreateDataTableProcessingStepPayload: ResolverTypeWrapper<Omit<CreateDataTableProcessingStepPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableProductApplicationJoinInput: CreateDataTableProductApplicationJoinInput;
  CreateDataTableProductApplicationJoinPayload: ResolverTypeWrapper<Omit<CreateDataTableProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableProductInput: CreateDataTableProductInput;
  CreateDataTableProductPayload: ResolverTypeWrapper<Omit<CreateDataTableProductPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableProvisionalProductApplicationJoinInput: CreateDataTableProvisionalProductApplicationJoinInput;
  CreateDataTableProvisionalProductApplicationJoinPayload: ResolverTypeWrapper<Omit<CreateDataTableProvisionalProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableProvisionalProductInput: CreateDataTableProvisionalProductInput;
  CreateDataTableProvisionalProductPayload: ResolverTypeWrapper<Omit<CreateDataTableProvisionalProductPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableScheduledChemicalInput: CreateDataTableScheduledChemicalInput;
  CreateDataTableScheduledChemicalPayload: ResolverTypeWrapper<Omit<CreateDataTableScheduledChemicalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableStorageConditionInput: CreateDataTableStorageConditionInput;
  CreateDataTableStorageConditionPayload: ResolverTypeWrapper<Omit<CreateDataTableStorageConditionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableStorageConditionsSimplifiedInput: CreateDataTableStorageConditionsSimplifiedInput;
  CreateDataTableStorageConditionsSimplifiedPayload: ResolverTypeWrapper<Omit<CreateDataTableStorageConditionsSimplifiedPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableUnitsOfProportionInput: CreateDataTableUnitsOfProportionInput;
  CreateDataTableUnitsOfProportionPayload: ResolverTypeWrapper<Omit<CreateDataTableUnitsOfProportionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataTableWorldHealthOrganisationPqListOfFppInput: CreateDataTableWorldHealthOrganisationPqListOfFppInput;
  CreateDataTableWorldHealthOrganisationPqListOfFppPayload: ResolverTypeWrapper<Omit<CreateDataTableWorldHealthOrganisationPqListOfFppPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataViewColumnDefinitionInput: CreateDataViewColumnDefinitionInput;
  CreateDataViewColumnDefinitionPayload: ResolverTypeWrapper<Omit<CreateDataViewColumnDefinitionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateDataViewInput: CreateDataViewInput;
  CreateDataViewPayload: ResolverTypeWrapper<Omit<CreateDataViewPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateElementTypePluginInput: CreateElementTypePluginInput;
  CreateElementTypePluginPayload: ResolverTypeWrapper<Omit<CreateElementTypePluginPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateFileInput: CreateFileInput;
  CreateFilePayload: ResolverTypeWrapper<Omit<CreateFilePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateFilterInput: CreateFilterInput;
  CreateFilterPayload: ResolverTypeWrapper<Omit<CreateFilterPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateGrafanaDashboardImageInput: CreateGrafanaDashboardImageInput;
  CreateGrafanaDashboardImagePayload: ResolverTypeWrapper<Omit<CreateGrafanaDashboardImagePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateNotificationInput: CreateNotificationInput;
  CreateNotificationPayload: ResolverTypeWrapper<Omit<CreateNotificationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateOrganisationApplicationJoinInput: CreateOrganisationApplicationJoinInput;
  CreateOrganisationApplicationJoinPayload: ResolverTypeWrapper<Omit<CreateOrganisationApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateOrganisationInput: CreateOrganisationInput;
  CreateOrganisationPayload: ResolverTypeWrapper<Omit<CreateOrganisationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreatePermissionJoinInput: CreatePermissionJoinInput;
  CreatePermissionJoinPayload: ResolverTypeWrapper<Omit<CreatePermissionJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreatePermissionNameInput: CreatePermissionNameInput;
  CreatePermissionNamePayload: ResolverTypeWrapper<Omit<CreatePermissionNamePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreatePermissionPolicyInput: CreatePermissionPolicyInput;
  CreatePermissionPolicyPayload: ResolverTypeWrapper<Omit<CreatePermissionPolicyPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateReviewAssignmentAssignedSectionsShapeInput: CreateReviewAssignmentAssignedSectionsShapeInput;
  CreateReviewAssignmentAssignedSectionsShapePayload: ResolverTypeWrapper<Omit<CreateReviewAssignmentAssignedSectionsShapePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateReviewAssignmentAssignerJoinInput: CreateReviewAssignmentAssignerJoinInput;
  CreateReviewAssignmentAssignerJoinPayload: ResolverTypeWrapper<Omit<CreateReviewAssignmentAssignerJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateReviewAssignmentInput: CreateReviewAssignmentInput;
  CreateReviewAssignmentPayload: ResolverTypeWrapper<Omit<CreateReviewAssignmentPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateReviewDecisionInput: CreateReviewDecisionInput;
  CreateReviewDecisionPayload: ResolverTypeWrapper<Omit<CreateReviewDecisionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateReviewInput: CreateReviewInput;
  CreateReviewPayload: ResolverTypeWrapper<Omit<CreateReviewPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateReviewResponseInput: CreateReviewResponseInput;
  CreateReviewResponsePayload: ResolverTypeWrapper<Omit<CreateReviewResponsePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateReviewStatusHistoryInput: CreateReviewStatusHistoryInput;
  CreateReviewStatusHistoryPayload: ResolverTypeWrapper<Omit<CreateReviewStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateSystemInfoInput: CreateSystemInfoInput;
  CreateSystemInfoPayload: ResolverTypeWrapper<Omit<CreateSystemInfoPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplateActionInput: CreateTemplateActionInput;
  CreateTemplateActionPayload: ResolverTypeWrapper<Omit<CreateTemplateActionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplateCategoryInput: CreateTemplateCategoryInput;
  CreateTemplateCategoryPayload: ResolverTypeWrapper<Omit<CreateTemplateCategoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplateElementInput: CreateTemplateElementInput;
  CreateTemplateElementPayload: ResolverTypeWrapper<Omit<CreateTemplateElementPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplateFilterJoinInput: CreateTemplateFilterJoinInput;
  CreateTemplateFilterJoinPayload: ResolverTypeWrapper<Omit<CreateTemplateFilterJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplateInput: CreateTemplateInput;
  CreateTemplatePayload: ResolverTypeWrapper<Omit<CreateTemplatePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplatePermissionInput: CreateTemplatePermissionInput;
  CreateTemplatePermissionPayload: ResolverTypeWrapper<Omit<CreateTemplatePermissionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplateSectionInput: CreateTemplateSectionInput;
  CreateTemplateSectionPayload: ResolverTypeWrapper<Omit<CreateTemplateSectionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplateStageInput: CreateTemplateStageInput;
  CreateTemplateStagePayload: ResolverTypeWrapper<Omit<CreateTemplateStagePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTemplateStageReviewLevelInput: CreateTemplateStageReviewLevelInput;
  CreateTemplateStageReviewLevelPayload: ResolverTypeWrapper<Omit<CreateTemplateStageReviewLevelPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTriggerQueueInput: CreateTriggerQueueInput;
  CreateTriggerQueuePayload: ResolverTypeWrapper<Omit<CreateTriggerQueuePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateTriggerScheduleInput: CreateTriggerScheduleInput;
  CreateTriggerSchedulePayload: ResolverTypeWrapper<Omit<CreateTriggerSchedulePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateUserApplicationJoinInput: CreateUserApplicationJoinInput;
  CreateUserApplicationJoinPayload: ResolverTypeWrapper<Omit<CreateUserApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateUserInput: CreateUserInput;
  CreateUserListInput: CreateUserListInput;
  CreateUserListPayload: ResolverTypeWrapper<Omit<CreateUserListPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateUserOrganisationInput: CreateUserOrganisationInput;
  CreateUserOrganisationPayload: ResolverTypeWrapper<Omit<CreateUserOrganisationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateUserPayload: ResolverTypeWrapper<Omit<CreateUserPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  CreateVerificationInput: CreateVerificationInput;
  CreateVerificationPayload: ResolverTypeWrapper<Omit<CreateVerificationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  Cursor: ResolverTypeWrapper<Scalars['Cursor']['output']>;
  DataChangelog: ResolverTypeWrapper<DataChangelog>;
  DataChangelogApplicationIdFkeyApplicationCreateInput: DataChangelogApplicationIdFkeyApplicationCreateInput;
  DataChangelogApplicationIdFkeyDataChangelogCreateInput: DataChangelogApplicationIdFkeyDataChangelogCreateInput;
  DataChangelogApplicationIdFkeyInput: DataChangelogApplicationIdFkeyInput;
  DataChangelogApplicationIdFkeyInverseInput: DataChangelogApplicationIdFkeyInverseInput;
  DataChangelogCondition: DataChangelogCondition;
  DataChangelogDataChangelogPkeyConnect: DataChangelogDataChangelogPkeyConnect;
  DataChangelogDataChangelogPkeyDelete: DataChangelogDataChangelogPkeyDelete;
  DataChangelogFilter: DataChangelogFilter;
  DataChangelogInput: DataChangelogInput;
  DataChangelogNodeIdConnect: DataChangelogNodeIdConnect;
  DataChangelogNodeIdDelete: DataChangelogNodeIdDelete;
  DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate: DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate;
  DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyUsingDataChangelogPkeyUpdate: DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyUsingDataChangelogPkeyUpdate;
  DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate: DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate;
  DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyUsingDataChangelogPkeyUpdate: DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyUsingDataChangelogPkeyUpdate;
  DataChangelogOrgIdFkeyDataChangelogCreateInput: DataChangelogOrgIdFkeyDataChangelogCreateInput;
  DataChangelogOrgIdFkeyInput: DataChangelogOrgIdFkeyInput;
  DataChangelogOrgIdFkeyInverseInput: DataChangelogOrgIdFkeyInverseInput;
  DataChangelogOrgIdFkeyOrganisationCreateInput: DataChangelogOrgIdFkeyOrganisationCreateInput;
  DataChangelogPatch: DataChangelogPatch;
  DataChangelogsConnection: ResolverTypeWrapper<DataChangelogsConnection>;
  DataChangelogsEdge: ResolverTypeWrapper<DataChangelogsEdge>;
  DataChangelogsOrderBy: DataChangelogsOrderBy;
  DataTable: ResolverTypeWrapper<DataTable>;
  DataTableActiveIngredient: ResolverTypeWrapper<DataTableActiveIngredient>;
  DataTableActiveIngredientCondition: DataTableActiveIngredientCondition;
  DataTableActiveIngredientFilter: DataTableActiveIngredientFilter;
  DataTableActiveIngredientInput: DataTableActiveIngredientInput;
  DataTableActiveIngredientPatch: DataTableActiveIngredientPatch;
  DataTableActiveIngredientsConnection: ResolverTypeWrapper<DataTableActiveIngredientsConnection>;
  DataTableActiveIngredientsEdge: ResolverTypeWrapper<DataTableActiveIngredientsEdge>;
  DataTableActiveIngredientsOrderBy: DataTableActiveIngredientsOrderBy;
  DataTableAdministrationRoute: ResolverTypeWrapper<DataTableAdministrationRoute>;
  DataTableAdministrationRouteCondition: DataTableAdministrationRouteCondition;
  DataTableAdministrationRouteFilter: DataTableAdministrationRouteFilter;
  DataTableAdministrationRouteInput: DataTableAdministrationRouteInput;
  DataTableAdministrationRoutePatch: DataTableAdministrationRoutePatch;
  DataTableAdministrationRoutesConnection: ResolverTypeWrapper<DataTableAdministrationRoutesConnection>;
  DataTableAdministrationRoutesEdge: ResolverTypeWrapper<DataTableAdministrationRoutesEdge>;
  DataTableAdministrationRoutesOrderBy: DataTableAdministrationRoutesOrderBy;
  DataTableAtcCode: ResolverTypeWrapper<DataTableAtcCode>;
  DataTableAtcCodeCondition: DataTableAtcCodeCondition;
  DataTableAtcCodeFilter: DataTableAtcCodeFilter;
  DataTableAtcCodeInput: DataTableAtcCodeInput;
  DataTableAtcCodePatch: DataTableAtcCodePatch;
  DataTableAtcCodesConnection: ResolverTypeWrapper<DataTableAtcCodesConnection>;
  DataTableAtcCodesEdge: ResolverTypeWrapper<DataTableAtcCodesEdge>;
  DataTableAtcCodesOrderBy: DataTableAtcCodesOrderBy;
  DataTableCondition: DataTableCondition;
  DataTableContainer: ResolverTypeWrapper<DataTableContainer>;
  DataTableContainerCondition: DataTableContainerCondition;
  DataTableContainerFilter: DataTableContainerFilter;
  DataTableContainerInput: DataTableContainerInput;
  DataTableContainerPatch: DataTableContainerPatch;
  DataTableContainersConnection: ResolverTypeWrapper<DataTableContainersConnection>;
  DataTableContainersEdge: ResolverTypeWrapper<DataTableContainersEdge>;
  DataTableContainersOrderBy: DataTableContainersOrderBy;
  DataTableCountriesConnection: ResolverTypeWrapper<DataTableCountriesConnection>;
  DataTableCountriesEdge: ResolverTypeWrapper<DataTableCountriesEdge>;
  DataTableCountriesOrderBy: DataTableCountriesOrderBy;
  DataTableCountry: ResolverTypeWrapper<DataTableCountry>;
  DataTableCountryCondition: DataTableCountryCondition;
  DataTableCountryFilter: DataTableCountryFilter;
  DataTableCountryInput: DataTableCountryInput;
  DataTableCountryPatch: DataTableCountryPatch;
  DataTableDosageForm: ResolverTypeWrapper<DataTableDosageForm>;
  DataTableDosageFormCondition: DataTableDosageFormCondition;
  DataTableDosageFormFilter: DataTableDosageFormFilter;
  DataTableDosageFormGroup: ResolverTypeWrapper<DataTableDosageFormGroup>;
  DataTableDosageFormGroupCondition: DataTableDosageFormGroupCondition;
  DataTableDosageFormGroupFilter: DataTableDosageFormGroupFilter;
  DataTableDosageFormGroupInput: DataTableDosageFormGroupInput;
  DataTableDosageFormGroupPatch: DataTableDosageFormGroupPatch;
  DataTableDosageFormGroupsConnection: ResolverTypeWrapper<DataTableDosageFormGroupsConnection>;
  DataTableDosageFormGroupsEdge: ResolverTypeWrapper<DataTableDosageFormGroupsEdge>;
  DataTableDosageFormGroupsOrderBy: DataTableDosageFormGroupsOrderBy;
  DataTableDosageFormInput: DataTableDosageFormInput;
  DataTableDosageFormPatch: DataTableDosageFormPatch;
  DataTableDosageFormsConnection: ResolverTypeWrapper<DataTableDosageFormsConnection>;
  DataTableDosageFormsEdge: ResolverTypeWrapper<DataTableDosageFormsEdge>;
  DataTableDosageFormsOrderBy: DataTableDosageFormsOrderBy;
  DataTableFilter: DataTableFilter;
  DataTableGenericIngredient: ResolverTypeWrapper<DataTableGenericIngredient>;
  DataTableGenericIngredientCondition: DataTableGenericIngredientCondition;
  DataTableGenericIngredientFilter: DataTableGenericIngredientFilter;
  DataTableGenericIngredientInput: DataTableGenericIngredientInput;
  DataTableGenericIngredientPatch: DataTableGenericIngredientPatch;
  DataTableGenericIngredientsConnection: ResolverTypeWrapper<DataTableGenericIngredientsConnection>;
  DataTableGenericIngredientsEdge: ResolverTypeWrapper<DataTableGenericIngredientsEdge>;
  DataTableGenericIngredientsOrderBy: DataTableGenericIngredientsOrderBy;
  DataTableInput: DataTableInput;
  DataTableManufacturer: ResolverTypeWrapper<DataTableManufacturer>;
  DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerApplicationJoinCreateInput: DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerApplicationJoinCreateInput;
  DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerCreateInput: DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerCreateInput;
  DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput: DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput;
  DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput: DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput;
  DataTableManufacturerApplicationJoin: ResolverTypeWrapper<DataTableManufacturerApplicationJoin>;
  DataTableManufacturerApplicationJoinApplicationIdFkeyApplicationCreateInput: DataTableManufacturerApplicationJoinApplicationIdFkeyApplicationCreateInput;
  DataTableManufacturerApplicationJoinApplicationIdFkeyDataTableManufacturerApplicationJoinCreateInput: DataTableManufacturerApplicationJoinApplicationIdFkeyDataTableManufacturerApplicationJoinCreateInput;
  DataTableManufacturerApplicationJoinApplicationIdFkeyInput: DataTableManufacturerApplicationJoinApplicationIdFkeyInput;
  DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput: DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput;
  DataTableManufacturerApplicationJoinCondition: DataTableManufacturerApplicationJoinCondition;
  DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyConnect: DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyConnect;
  DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyDelete: DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyDelete;
  DataTableManufacturerApplicationJoinFilter: DataTableManufacturerApplicationJoinFilter;
  DataTableManufacturerApplicationJoinInput: DataTableManufacturerApplicationJoinInput;
  DataTableManufacturerApplicationJoinNodeIdConnect: DataTableManufacturerApplicationJoinNodeIdConnect;
  DataTableManufacturerApplicationJoinNodeIdDelete: DataTableManufacturerApplicationJoinNodeIdDelete;
  DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate: DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate;
  DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate: DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate;
  DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate: DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate;
  DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate: DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate;
  DataTableManufacturerApplicationJoinPatch: DataTableManufacturerApplicationJoinPatch;
  DataTableManufacturerApplicationJoinsConnection: ResolverTypeWrapper<DataTableManufacturerApplicationJoinsConnection>;
  DataTableManufacturerApplicationJoinsEdge: ResolverTypeWrapper<DataTableManufacturerApplicationJoinsEdge>;
  DataTableManufacturerApplicationJoinsOrderBy: DataTableManufacturerApplicationJoinsOrderBy;
  DataTableManufacturerCondition: DataTableManufacturerCondition;
  DataTableManufacturerDataTableManufacturerPkeyConnect: DataTableManufacturerDataTableManufacturerPkeyConnect;
  DataTableManufacturerDataTableManufacturerPkeyDelete: DataTableManufacturerDataTableManufacturerPkeyDelete;
  DataTableManufacturerFilter: DataTableManufacturerFilter;
  DataTableManufacturerInput: DataTableManufacturerInput;
  DataTableManufacturerNodeIdConnect: DataTableManufacturerNodeIdConnect;
  DataTableManufacturerNodeIdDelete: DataTableManufacturerNodeIdDelete;
  DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate: DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate;
  DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerPkeyUpdate: DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerPkeyUpdate;
  DataTableManufacturerPatch: DataTableManufacturerPatch;
  DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput: DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput;
  DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeCreateInput: DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeCreateInput;
  DataTableManufacturerRepreDataTableManufacturerReprFkeyInput: DataTableManufacturerRepreDataTableManufacturerReprFkeyInput;
  DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput: DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput;
  DataTableManufacturerRepresentative: ResolverTypeWrapper<DataTableManufacturerRepresentative>;
  DataTableManufacturerRepresentativeApplApplicationIdFkeyApplicationCreateInput: DataTableManufacturerRepresentativeApplApplicationIdFkeyApplicationCreateInput;
  DataTableManufacturerRepresentativeApplApplicationIdFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput: DataTableManufacturerRepresentativeApplApplicationIdFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput;
  DataTableManufacturerRepresentativeApplApplicationIdFkeyInput: DataTableManufacturerRepresentativeApplApplicationIdFkeyInput;
  DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput: DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput;
  DataTableManufacturerRepresentativeApplicationJoin: ResolverTypeWrapper<DataTableManufacturerRepresentativeApplicationJoin>;
  DataTableManufacturerRepresentativeApplicationJoinCondition: DataTableManufacturerRepresentativeApplicationJoinCondition;
  DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyConnect: DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyConnect;
  DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyDelete: DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyDelete;
  DataTableManufacturerRepresentativeApplicationJoinFilter: DataTableManufacturerRepresentativeApplicationJoinFilter;
  DataTableManufacturerRepresentativeApplicationJoinInput: DataTableManufacturerRepresentativeApplicationJoinInput;
  DataTableManufacturerRepresentativeApplicationJoinNodeIdConnect: DataTableManufacturerRepresentativeApplicationJoinNodeIdConnect;
  DataTableManufacturerRepresentativeApplicationJoinNodeIdDelete: DataTableManufacturerRepresentativeApplicationJoinNodeIdDelete;
  DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate: DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate;
  DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate: DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate;
  DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate: DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate;
  DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate: DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate;
  DataTableManufacturerRepresentativeApplicationJoinPatch: DataTableManufacturerRepresentativeApplicationJoinPatch;
  DataTableManufacturerRepresentativeApplicationJoinsConnection: ResolverTypeWrapper<DataTableManufacturerRepresentativeApplicationJoinsConnection>;
  DataTableManufacturerRepresentativeApplicationJoinsEdge: ResolverTypeWrapper<DataTableManufacturerRepresentativeApplicationJoinsEdge>;
  DataTableManufacturerRepresentativeApplicationJoinsOrderBy: DataTableManufacturerRepresentativeApplicationJoinsOrderBy;
  DataTableManufacturerRepresentativeCondition: DataTableManufacturerRepresentativeCondition;
  DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyConnect: DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyConnect;
  DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyDelete: DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyDelete;
  DataTableManufacturerRepresentativeFilter: DataTableManufacturerRepresentativeFilter;
  DataTableManufacturerRepresentativeInput: DataTableManufacturerRepresentativeInput;
  DataTableManufacturerRepresentativeNodeIdConnect: DataTableManufacturerRepresentativeNodeIdConnect;
  DataTableManufacturerRepresentativeNodeIdDelete: DataTableManufacturerRepresentativeNodeIdDelete;
  DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate: DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate;
  DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativePkeyUpdate: DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativePkeyUpdate;
  DataTableManufacturerRepresentativePatch: DataTableManufacturerRepresentativePatch;
  DataTableManufacturerRepresentativeToManyDataTableManufacturerRepresentativeApplicationJoinFilter: DataTableManufacturerRepresentativeToManyDataTableManufacturerRepresentativeApplicationJoinFilter;
  DataTableManufacturerRepresentativesConnection: ResolverTypeWrapper<DataTableManufacturerRepresentativesConnection>;
  DataTableManufacturerRepresentativesEdge: ResolverTypeWrapper<DataTableManufacturerRepresentativesEdge>;
  DataTableManufacturerRepresentativesOrderBy: DataTableManufacturerRepresentativesOrderBy;
  DataTableManufacturerToManyDataTableManufacturerApplicationJoinFilter: DataTableManufacturerToManyDataTableManufacturerApplicationJoinFilter;
  DataTableManufacturersConnection: ResolverTypeWrapper<DataTableManufacturersConnection>;
  DataTableManufacturersEdge: ResolverTypeWrapper<DataTableManufacturersEdge>;
  DataTableManufacturersOrderBy: DataTableManufacturersOrderBy;
  DataTablePatch: DataTablePatch;
  DataTablePermitChemical: ResolverTypeWrapper<DataTablePermitChemical>;
  DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalApplicationJoinCreateInput: DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalApplicationJoinCreateInput;
  DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalCreateInput: DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalCreateInput;
  DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput: DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput;
  DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput: DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput;
  DataTablePermitChemicalApplicationJoin: ResolverTypeWrapper<DataTablePermitChemicalApplicationJoin>;
  DataTablePermitChemicalApplicationJoinApplicationIdFkeyApplicationCreateInput: DataTablePermitChemicalApplicationJoinApplicationIdFkeyApplicationCreateInput;
  DataTablePermitChemicalApplicationJoinApplicationIdFkeyDataTablePermitChemicalApplicationJoinCreateInput: DataTablePermitChemicalApplicationJoinApplicationIdFkeyDataTablePermitChemicalApplicationJoinCreateInput;
  DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput: DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput;
  DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput: DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput;
  DataTablePermitChemicalApplicationJoinCondition: DataTablePermitChemicalApplicationJoinCondition;
  DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyConnect: DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyConnect;
  DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyDelete: DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyDelete;
  DataTablePermitChemicalApplicationJoinFilter: DataTablePermitChemicalApplicationJoinFilter;
  DataTablePermitChemicalApplicationJoinInput: DataTablePermitChemicalApplicationJoinInput;
  DataTablePermitChemicalApplicationJoinNodeIdConnect: DataTablePermitChemicalApplicationJoinNodeIdConnect;
  DataTablePermitChemicalApplicationJoinNodeIdDelete: DataTablePermitChemicalApplicationJoinNodeIdDelete;
  DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate: DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate;
  DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate: DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate;
  DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate: DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate;
  DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate: DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate;
  DataTablePermitChemicalApplicationJoinPatch: DataTablePermitChemicalApplicationJoinPatch;
  DataTablePermitChemicalApplicationJoinsConnection: ResolverTypeWrapper<DataTablePermitChemicalApplicationJoinsConnection>;
  DataTablePermitChemicalApplicationJoinsEdge: ResolverTypeWrapper<DataTablePermitChemicalApplicationJoinsEdge>;
  DataTablePermitChemicalApplicationJoinsOrderBy: DataTablePermitChemicalApplicationJoinsOrderBy;
  DataTablePermitChemicalCondition: DataTablePermitChemicalCondition;
  DataTablePermitChemicalDataTablePermitChemicalPkeyConnect: DataTablePermitChemicalDataTablePermitChemicalPkeyConnect;
  DataTablePermitChemicalDataTablePermitChemicalPkeyDelete: DataTablePermitChemicalDataTablePermitChemicalPkeyDelete;
  DataTablePermitChemicalFilter: DataTablePermitChemicalFilter;
  DataTablePermitChemicalInput: DataTablePermitChemicalInput;
  DataTablePermitChemicalNodeIdConnect: DataTablePermitChemicalNodeIdConnect;
  DataTablePermitChemicalNodeIdDelete: DataTablePermitChemicalNodeIdDelete;
  DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate: DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate;
  DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalPkeyUpdate: DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalPkeyUpdate;
  DataTablePermitChemicalPatch: DataTablePermitChemicalPatch;
  DataTablePermitChemicalToManyDataTablePermitChemicalApplicationJoinFilter: DataTablePermitChemicalToManyDataTablePermitChemicalApplicationJoinFilter;
  DataTablePermitChemicalsConnection: ResolverTypeWrapper<DataTablePermitChemicalsConnection>;
  DataTablePermitChemicalsEdge: ResolverTypeWrapper<DataTablePermitChemicalsEdge>;
  DataTablePermitChemicalsOrderBy: DataTablePermitChemicalsOrderBy;
  DataTablePreRegisteredProductsProvisional: ResolverTypeWrapper<DataTablePreRegisteredProductsProvisional>;
  DataTablePreRegisteredProductsProvisionalCondition: DataTablePreRegisteredProductsProvisionalCondition;
  DataTablePreRegisteredProductsProvisionalFilter: DataTablePreRegisteredProductsProvisionalFilter;
  DataTablePreRegisteredProductsProvisionalInput: DataTablePreRegisteredProductsProvisionalInput;
  DataTablePreRegisteredProductsProvisionalPatch: DataTablePreRegisteredProductsProvisionalPatch;
  DataTablePreRegisteredProductsProvisionalsConnection: ResolverTypeWrapper<DataTablePreRegisteredProductsProvisionalsConnection>;
  DataTablePreRegisteredProductsProvisionalsEdge: ResolverTypeWrapper<DataTablePreRegisteredProductsProvisionalsEdge>;
  DataTablePreRegisteredProductsProvisionalsOrderBy: DataTablePreRegisteredProductsProvisionalsOrderBy;
  DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerApplicationJoinCreateInput: DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerApplicationJoinCreateInput;
  DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerCreateInput: DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerCreateInput;
  DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput: DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput;
  DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput: DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput;
  DataTablePrequalManufacturer: ResolverTypeWrapper<DataTablePrequalManufacturer>;
  DataTablePrequalManufacturerApplicationApplicationIdFkeyApplicationCreateInput: DataTablePrequalManufacturerApplicationApplicationIdFkeyApplicationCreateInput;
  DataTablePrequalManufacturerApplicationApplicationIdFkeyDataTablePrequalManufacturerApplicationJoinCreateInput: DataTablePrequalManufacturerApplicationApplicationIdFkeyDataTablePrequalManufacturerApplicationJoinCreateInput;
  DataTablePrequalManufacturerApplicationApplicationIdFkeyInput: DataTablePrequalManufacturerApplicationApplicationIdFkeyInput;
  DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput: DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput;
  DataTablePrequalManufacturerApplicationJoin: ResolverTypeWrapper<DataTablePrequalManufacturerApplicationJoin>;
  DataTablePrequalManufacturerApplicationJoinCondition: DataTablePrequalManufacturerApplicationJoinCondition;
  DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyConnect: DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyConnect;
  DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyDelete: DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyDelete;
  DataTablePrequalManufacturerApplicationJoinFilter: DataTablePrequalManufacturerApplicationJoinFilter;
  DataTablePrequalManufacturerApplicationJoinInput: DataTablePrequalManufacturerApplicationJoinInput;
  DataTablePrequalManufacturerApplicationJoinNodeIdConnect: DataTablePrequalManufacturerApplicationJoinNodeIdConnect;
  DataTablePrequalManufacturerApplicationJoinNodeIdDelete: DataTablePrequalManufacturerApplicationJoinNodeIdDelete;
  DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate: DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate;
  DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate: DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate;
  DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate: DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate;
  DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate: DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate;
  DataTablePrequalManufacturerApplicationJoinPatch: DataTablePrequalManufacturerApplicationJoinPatch;
  DataTablePrequalManufacturerApplicationJoinsConnection: ResolverTypeWrapper<DataTablePrequalManufacturerApplicationJoinsConnection>;
  DataTablePrequalManufacturerApplicationJoinsEdge: ResolverTypeWrapper<DataTablePrequalManufacturerApplicationJoinsEdge>;
  DataTablePrequalManufacturerApplicationJoinsOrderBy: DataTablePrequalManufacturerApplicationJoinsOrderBy;
  DataTablePrequalManufacturerCondition: DataTablePrequalManufacturerCondition;
  DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyConnect: DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyConnect;
  DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyDelete: DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyDelete;
  DataTablePrequalManufacturerFilter: DataTablePrequalManufacturerFilter;
  DataTablePrequalManufacturerInput: DataTablePrequalManufacturerInput;
  DataTablePrequalManufacturerNodeIdConnect: DataTablePrequalManufacturerNodeIdConnect;
  DataTablePrequalManufacturerNodeIdDelete: DataTablePrequalManufacturerNodeIdDelete;
  DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate: DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate;
  DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerPkeyUpdate: DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerPkeyUpdate;
  DataTablePrequalManufacturerPatch: DataTablePrequalManufacturerPatch;
  DataTablePrequalManufacturerToManyDataTablePrequalManufacturerApplicationJoinFilter: DataTablePrequalManufacturerToManyDataTablePrequalManufacturerApplicationJoinFilter;
  DataTablePrequalManufacturersConnection: ResolverTypeWrapper<DataTablePrequalManufacturersConnection>;
  DataTablePrequalManufacturersEdge: ResolverTypeWrapper<DataTablePrequalManufacturersEdge>;
  DataTablePrequalManufacturersOrderBy: DataTablePrequalManufacturersOrderBy;
  DataTableProcessingStep: ResolverTypeWrapper<DataTableProcessingStep>;
  DataTableProcessingStepCondition: DataTableProcessingStepCondition;
  DataTableProcessingStepFilter: DataTableProcessingStepFilter;
  DataTableProcessingStepInput: DataTableProcessingStepInput;
  DataTableProcessingStepPatch: DataTableProcessingStepPatch;
  DataTableProcessingStepsConnection: ResolverTypeWrapper<DataTableProcessingStepsConnection>;
  DataTableProcessingStepsEdge: ResolverTypeWrapper<DataTableProcessingStepsEdge>;
  DataTableProcessingStepsOrderBy: DataTableProcessingStepsOrderBy;
  DataTableProduct: ResolverTypeWrapper<DataTableProduct>;
  DataTableProductApplicationJoin: ResolverTypeWrapper<DataTableProductApplicationJoin>;
  DataTableProductApplicationJoinApplicationIdFkeyApplicationCreateInput: DataTableProductApplicationJoinApplicationIdFkeyApplicationCreateInput;
  DataTableProductApplicationJoinApplicationIdFkeyDataTableProductApplicationJoinCreateInput: DataTableProductApplicationJoinApplicationIdFkeyDataTableProductApplicationJoinCreateInput;
  DataTableProductApplicationJoinApplicationIdFkeyInput: DataTableProductApplicationJoinApplicationIdFkeyInput;
  DataTableProductApplicationJoinApplicationIdFkeyInverseInput: DataTableProductApplicationJoinApplicationIdFkeyInverseInput;
  DataTableProductApplicationJoinCondition: DataTableProductApplicationJoinCondition;
  DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect: DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect;
  DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete: DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete;
  DataTableProductApplicationJoinFilter: DataTableProductApplicationJoinFilter;
  DataTableProductApplicationJoinInput: DataTableProductApplicationJoinInput;
  DataTableProductApplicationJoinNodeIdConnect: DataTableProductApplicationJoinNodeIdConnect;
  DataTableProductApplicationJoinNodeIdDelete: DataTableProductApplicationJoinNodeIdDelete;
  DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate: DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate;
  DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate: DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate;
  DataTableProductApplicationJoinPatch: DataTableProductApplicationJoinPatch;
  DataTableProductApplicationJoinsConnection: ResolverTypeWrapper<DataTableProductApplicationJoinsConnection>;
  DataTableProductApplicationJoinsEdge: ResolverTypeWrapper<DataTableProductApplicationJoinsEdge>;
  DataTableProductApplicationJoinsOrderBy: DataTableProductApplicationJoinsOrderBy;
  DataTableProductCondition: DataTableProductCondition;
  DataTableProductFilter: DataTableProductFilter;
  DataTableProductInput: DataTableProductInput;
  DataTableProductPatch: DataTableProductPatch;
  DataTableProductsConnection: ResolverTypeWrapper<DataTableProductsConnection>;
  DataTableProductsEdge: ResolverTypeWrapper<DataTableProductsEdge>;
  DataTableProductsOrderBy: DataTableProductsOrderBy;
  DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductApplicationJoinCreateInput: DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductApplicationJoinCreateInput;
  DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductCreateInput: DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductCreateInput;
  DataTableProvisionalProducDataTableProvisionalProduFkeyInput: DataTableProvisionalProducDataTableProvisionalProduFkeyInput;
  DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput: DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput;
  DataTableProvisionalProduct: ResolverTypeWrapper<DataTableProvisionalProduct>;
  DataTableProvisionalProductApplicationApplicationIdFkeyApplicationCreateInput: DataTableProvisionalProductApplicationApplicationIdFkeyApplicationCreateInput;
  DataTableProvisionalProductApplicationApplicationIdFkeyDataTableProvisionalProductApplicationJoinCreateInput: DataTableProvisionalProductApplicationApplicationIdFkeyDataTableProvisionalProductApplicationJoinCreateInput;
  DataTableProvisionalProductApplicationApplicationIdFkeyInput: DataTableProvisionalProductApplicationApplicationIdFkeyInput;
  DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput: DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput;
  DataTableProvisionalProductApplicationJoin: ResolverTypeWrapper<DataTableProvisionalProductApplicationJoin>;
  DataTableProvisionalProductApplicationJoinCondition: DataTableProvisionalProductApplicationJoinCondition;
  DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyConnect: DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyConnect;
  DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyDelete: DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyDelete;
  DataTableProvisionalProductApplicationJoinFilter: DataTableProvisionalProductApplicationJoinFilter;
  DataTableProvisionalProductApplicationJoinInput: DataTableProvisionalProductApplicationJoinInput;
  DataTableProvisionalProductApplicationJoinNodeIdConnect: DataTableProvisionalProductApplicationJoinNodeIdConnect;
  DataTableProvisionalProductApplicationJoinNodeIdDelete: DataTableProvisionalProductApplicationJoinNodeIdDelete;
  DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate: DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate;
  DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate: DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate;
  DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate: DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate;
  DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate: DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate;
  DataTableProvisionalProductApplicationJoinPatch: DataTableProvisionalProductApplicationJoinPatch;
  DataTableProvisionalProductApplicationJoinsConnection: ResolverTypeWrapper<DataTableProvisionalProductApplicationJoinsConnection>;
  DataTableProvisionalProductApplicationJoinsEdge: ResolverTypeWrapper<DataTableProvisionalProductApplicationJoinsEdge>;
  DataTableProvisionalProductApplicationJoinsOrderBy: DataTableProvisionalProductApplicationJoinsOrderBy;
  DataTableProvisionalProductCondition: DataTableProvisionalProductCondition;
  DataTableProvisionalProductDataTableProvisionalProductPkeyConnect: DataTableProvisionalProductDataTableProvisionalProductPkeyConnect;
  DataTableProvisionalProductDataTableProvisionalProductPkeyDelete: DataTableProvisionalProductDataTableProvisionalProductPkeyDelete;
  DataTableProvisionalProductFilter: DataTableProvisionalProductFilter;
  DataTableProvisionalProductInput: DataTableProvisionalProductInput;
  DataTableProvisionalProductNodeIdConnect: DataTableProvisionalProductNodeIdConnect;
  DataTableProvisionalProductNodeIdDelete: DataTableProvisionalProductNodeIdDelete;
  DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate: DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate;
  DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductPkeyUpdate: DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductPkeyUpdate;
  DataTableProvisionalProductPatch: DataTableProvisionalProductPatch;
  DataTableProvisionalProductToManyDataTableProvisionalProductApplicationJoinFilter: DataTableProvisionalProductToManyDataTableProvisionalProductApplicationJoinFilter;
  DataTableProvisionalProductsConnection: ResolverTypeWrapper<DataTableProvisionalProductsConnection>;
  DataTableProvisionalProductsEdge: ResolverTypeWrapper<DataTableProvisionalProductsEdge>;
  DataTableProvisionalProductsOrderBy: DataTableProvisionalProductsOrderBy;
  DataTableScheduledChemical: ResolverTypeWrapper<DataTableScheduledChemical>;
  DataTableScheduledChemicalCondition: DataTableScheduledChemicalCondition;
  DataTableScheduledChemicalFilter: DataTableScheduledChemicalFilter;
  DataTableScheduledChemicalInput: DataTableScheduledChemicalInput;
  DataTableScheduledChemicalPatch: DataTableScheduledChemicalPatch;
  DataTableScheduledChemicalsConnection: ResolverTypeWrapper<DataTableScheduledChemicalsConnection>;
  DataTableScheduledChemicalsEdge: ResolverTypeWrapper<DataTableScheduledChemicalsEdge>;
  DataTableScheduledChemicalsOrderBy: DataTableScheduledChemicalsOrderBy;
  DataTableStorageCondition: ResolverTypeWrapper<DataTableStorageCondition>;
  DataTableStorageConditionCondition: DataTableStorageConditionCondition;
  DataTableStorageConditionFilter: DataTableStorageConditionFilter;
  DataTableStorageConditionInput: DataTableStorageConditionInput;
  DataTableStorageConditionPatch: DataTableStorageConditionPatch;
  DataTableStorageConditionsConnection: ResolverTypeWrapper<DataTableStorageConditionsConnection>;
  DataTableStorageConditionsEdge: ResolverTypeWrapper<DataTableStorageConditionsEdge>;
  DataTableStorageConditionsOrderBy: DataTableStorageConditionsOrderBy;
  DataTableStorageConditionsSimplified: ResolverTypeWrapper<DataTableStorageConditionsSimplified>;
  DataTableStorageConditionsSimplifiedCondition: DataTableStorageConditionsSimplifiedCondition;
  DataTableStorageConditionsSimplifiedFilter: DataTableStorageConditionsSimplifiedFilter;
  DataTableStorageConditionsSimplifiedInput: DataTableStorageConditionsSimplifiedInput;
  DataTableStorageConditionsSimplifiedPatch: DataTableStorageConditionsSimplifiedPatch;
  DataTableStorageConditionsSimplifiedsConnection: ResolverTypeWrapper<DataTableStorageConditionsSimplifiedsConnection>;
  DataTableStorageConditionsSimplifiedsEdge: ResolverTypeWrapper<DataTableStorageConditionsSimplifiedsEdge>;
  DataTableStorageConditionsSimplifiedsOrderBy: DataTableStorageConditionsSimplifiedsOrderBy;
  DataTableUnitsOfProportion: ResolverTypeWrapper<DataTableUnitsOfProportion>;
  DataTableUnitsOfProportionCondition: DataTableUnitsOfProportionCondition;
  DataTableUnitsOfProportionFilter: DataTableUnitsOfProportionFilter;
  DataTableUnitsOfProportionInput: DataTableUnitsOfProportionInput;
  DataTableUnitsOfProportionPatch: DataTableUnitsOfProportionPatch;
  DataTableUnitsOfProportionsConnection: ResolverTypeWrapper<DataTableUnitsOfProportionsConnection>;
  DataTableUnitsOfProportionsEdge: ResolverTypeWrapper<DataTableUnitsOfProportionsEdge>;
  DataTableUnitsOfProportionsOrderBy: DataTableUnitsOfProportionsOrderBy;
  DataTableWorldHealthOrganisationPqListOfFpp: ResolverTypeWrapper<DataTableWorldHealthOrganisationPqListOfFpp>;
  DataTableWorldHealthOrganisationPqListOfFppCondition: DataTableWorldHealthOrganisationPqListOfFppCondition;
  DataTableWorldHealthOrganisationPqListOfFppFilter: DataTableWorldHealthOrganisationPqListOfFppFilter;
  DataTableWorldHealthOrganisationPqListOfFppInput: DataTableWorldHealthOrganisationPqListOfFppInput;
  DataTableWorldHealthOrganisationPqListOfFppPatch: DataTableWorldHealthOrganisationPqListOfFppPatch;
  DataTableWorldHealthOrganisationPqListOfFppsConnection: ResolverTypeWrapper<DataTableWorldHealthOrganisationPqListOfFppsConnection>;
  DataTableWorldHealthOrganisationPqListOfFppsEdge: ResolverTypeWrapper<DataTableWorldHealthOrganisationPqListOfFppsEdge>;
  DataTableWorldHealthOrganisationPqListOfFppsOrderBy: DataTableWorldHealthOrganisationPqListOfFppsOrderBy;
  DataTablesConnection: ResolverTypeWrapper<DataTablesConnection>;
  DataTablesEdge: ResolverTypeWrapper<DataTablesEdge>;
  DataTablesOrderBy: DataTablesOrderBy;
  DataView: ResolverTypeWrapper<DataView>;
  DataViewColumnDefinition: ResolverTypeWrapper<DataViewColumnDefinition>;
  DataViewColumnDefinitionCondition: DataViewColumnDefinitionCondition;
  DataViewColumnDefinitionFilter: DataViewColumnDefinitionFilter;
  DataViewColumnDefinitionInput: DataViewColumnDefinitionInput;
  DataViewColumnDefinitionPatch: DataViewColumnDefinitionPatch;
  DataViewColumnDefinitionsConnection: ResolverTypeWrapper<DataViewColumnDefinitionsConnection>;
  DataViewColumnDefinitionsEdge: ResolverTypeWrapper<DataViewColumnDefinitionsEdge>;
  DataViewColumnDefinitionsOrderBy: DataViewColumnDefinitionsOrderBy;
  DataViewCondition: DataViewCondition;
  DataViewFilter: DataViewFilter;
  DataViewInput: DataViewInput;
  DataViewPatch: DataViewPatch;
  DataViewsConnection: ResolverTypeWrapper<DataViewsConnection>;
  DataViewsEdge: ResolverTypeWrapper<DataViewsEdge>;
  DataViewsOrderBy: DataViewsOrderBy;
  Date: ResolverTypeWrapper<Scalars['Date']['output']>;
  DateFilter: DateFilter;
  Datetime: ResolverTypeWrapper<Scalars['Datetime']['output']>;
  DatetimeFilter: DatetimeFilter;
  Decision: Decision;
  DecisionFilter: DecisionFilter;
  DeleteActionPluginByCodeInput: DeleteActionPluginByCodeInput;
  DeleteActionPluginByNodeIdInput: DeleteActionPluginByNodeIdInput;
  DeleteActionPluginInput: DeleteActionPluginInput;
  DeleteActionPluginPayload: ResolverTypeWrapper<Omit<DeleteActionPluginPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteActionQueueByNodeIdInput: DeleteActionQueueByNodeIdInput;
  DeleteActionQueueInput: DeleteActionQueueInput;
  DeleteActionQueuePayload: ResolverTypeWrapper<Omit<DeleteActionQueuePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteActivityLogByNodeIdInput: DeleteActivityLogByNodeIdInput;
  DeleteActivityLogInput: DeleteActivityLogInput;
  DeleteActivityLogPayload: ResolverTypeWrapper<Omit<DeleteActivityLogPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteApplicationByNodeIdInput: DeleteApplicationByNodeIdInput;
  DeleteApplicationByOutcomeRegistrationInput: DeleteApplicationByOutcomeRegistrationInput;
  DeleteApplicationBySerialInput: DeleteApplicationBySerialInput;
  DeleteApplicationInput: DeleteApplicationInput;
  DeleteApplicationNoteByNodeIdInput: DeleteApplicationNoteByNodeIdInput;
  DeleteApplicationNoteInput: DeleteApplicationNoteInput;
  DeleteApplicationNotePayload: ResolverTypeWrapper<Omit<DeleteApplicationNotePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteApplicationPayload: ResolverTypeWrapper<Omit<DeleteApplicationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteApplicationResponseByNodeIdInput: DeleteApplicationResponseByNodeIdInput;
  DeleteApplicationResponseInput: DeleteApplicationResponseInput;
  DeleteApplicationResponsePayload: ResolverTypeWrapper<Omit<DeleteApplicationResponsePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteApplicationReviewerActionByNodeIdInput: DeleteApplicationReviewerActionByNodeIdInput;
  DeleteApplicationReviewerActionByUserIdAndApplicationIdInput: DeleteApplicationReviewerActionByUserIdAndApplicationIdInput;
  DeleteApplicationReviewerActionInput: DeleteApplicationReviewerActionInput;
  DeleteApplicationReviewerActionPayload: ResolverTypeWrapper<Omit<DeleteApplicationReviewerActionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteApplicationStageHistoryByNodeIdInput: DeleteApplicationStageHistoryByNodeIdInput;
  DeleteApplicationStageHistoryInput: DeleteApplicationStageHistoryInput;
  DeleteApplicationStageHistoryPayload: ResolverTypeWrapper<Omit<DeleteApplicationStageHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteApplicationStatusHistoryByNodeIdInput: DeleteApplicationStatusHistoryByNodeIdInput;
  DeleteApplicationStatusHistoryInput: DeleteApplicationStatusHistoryInput;
  DeleteApplicationStatusHistoryPayload: ResolverTypeWrapper<Omit<DeleteApplicationStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteCounterByNameInput: DeleteCounterByNameInput;
  DeleteCounterByNodeIdInput: DeleteCounterByNodeIdInput;
  DeleteCounterInput: DeleteCounterInput;
  DeleteCounterPayload: ResolverTypeWrapper<Omit<DeleteCounterPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataChangelogByNodeIdInput: DeleteDataChangelogByNodeIdInput;
  DeleteDataChangelogInput: DeleteDataChangelogInput;
  DeleteDataChangelogPayload: ResolverTypeWrapper<Omit<DeleteDataChangelogPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableActiveIngredientByNodeIdInput: DeleteDataTableActiveIngredientByNodeIdInput;
  DeleteDataTableActiveIngredientInput: DeleteDataTableActiveIngredientInput;
  DeleteDataTableActiveIngredientPayload: ResolverTypeWrapper<Omit<DeleteDataTableActiveIngredientPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableAdministrationRouteByNodeIdInput: DeleteDataTableAdministrationRouteByNodeIdInput;
  DeleteDataTableAdministrationRouteInput: DeleteDataTableAdministrationRouteInput;
  DeleteDataTableAdministrationRoutePayload: ResolverTypeWrapper<Omit<DeleteDataTableAdministrationRoutePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableAtcCodeByNodeIdInput: DeleteDataTableAtcCodeByNodeIdInput;
  DeleteDataTableAtcCodeInput: DeleteDataTableAtcCodeInput;
  DeleteDataTableAtcCodePayload: ResolverTypeWrapper<Omit<DeleteDataTableAtcCodePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableByNodeIdInput: DeleteDataTableByNodeIdInput;
  DeleteDataTableByTableNameInput: DeleteDataTableByTableNameInput;
  DeleteDataTableContainerByNodeIdInput: DeleteDataTableContainerByNodeIdInput;
  DeleteDataTableContainerInput: DeleteDataTableContainerInput;
  DeleteDataTableContainerPayload: ResolverTypeWrapper<Omit<DeleteDataTableContainerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableCountryByNodeIdInput: DeleteDataTableCountryByNodeIdInput;
  DeleteDataTableCountryInput: DeleteDataTableCountryInput;
  DeleteDataTableCountryPayload: ResolverTypeWrapper<Omit<DeleteDataTableCountryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableDosageFormByNodeIdInput: DeleteDataTableDosageFormByNodeIdInput;
  DeleteDataTableDosageFormGroupByNodeIdInput: DeleteDataTableDosageFormGroupByNodeIdInput;
  DeleteDataTableDosageFormGroupInput: DeleteDataTableDosageFormGroupInput;
  DeleteDataTableDosageFormGroupPayload: ResolverTypeWrapper<Omit<DeleteDataTableDosageFormGroupPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableDosageFormInput: DeleteDataTableDosageFormInput;
  DeleteDataTableDosageFormPayload: ResolverTypeWrapper<Omit<DeleteDataTableDosageFormPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableGenericIngredientByNodeIdInput: DeleteDataTableGenericIngredientByNodeIdInput;
  DeleteDataTableGenericIngredientInput: DeleteDataTableGenericIngredientInput;
  DeleteDataTableGenericIngredientPayload: ResolverTypeWrapper<Omit<DeleteDataTableGenericIngredientPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableInput: DeleteDataTableInput;
  DeleteDataTableManufacturerApplicationJoinByNodeIdInput: DeleteDataTableManufacturerApplicationJoinByNodeIdInput;
  DeleteDataTableManufacturerApplicationJoinInput: DeleteDataTableManufacturerApplicationJoinInput;
  DeleteDataTableManufacturerApplicationJoinPayload: ResolverTypeWrapper<Omit<DeleteDataTableManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableManufacturerByNodeIdInput: DeleteDataTableManufacturerByNodeIdInput;
  DeleteDataTableManufacturerInput: DeleteDataTableManufacturerInput;
  DeleteDataTableManufacturerPayload: ResolverTypeWrapper<Omit<DeleteDataTableManufacturerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput: DeleteDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput;
  DeleteDataTableManufacturerRepresentativeApplicationJoinInput: DeleteDataTableManufacturerRepresentativeApplicationJoinInput;
  DeleteDataTableManufacturerRepresentativeApplicationJoinPayload: ResolverTypeWrapper<Omit<DeleteDataTableManufacturerRepresentativeApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableManufacturerRepresentativeByNodeIdInput: DeleteDataTableManufacturerRepresentativeByNodeIdInput;
  DeleteDataTableManufacturerRepresentativeInput: DeleteDataTableManufacturerRepresentativeInput;
  DeleteDataTableManufacturerRepresentativePayload: ResolverTypeWrapper<Omit<DeleteDataTableManufacturerRepresentativePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTablePayload: ResolverTypeWrapper<Omit<DeleteDataTablePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTablePermitChemicalApplicationJoinByNodeIdInput: DeleteDataTablePermitChemicalApplicationJoinByNodeIdInput;
  DeleteDataTablePermitChemicalApplicationJoinInput: DeleteDataTablePermitChemicalApplicationJoinInput;
  DeleteDataTablePermitChemicalApplicationJoinPayload: ResolverTypeWrapper<Omit<DeleteDataTablePermitChemicalApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTablePermitChemicalByNodeIdInput: DeleteDataTablePermitChemicalByNodeIdInput;
  DeleteDataTablePermitChemicalInput: DeleteDataTablePermitChemicalInput;
  DeleteDataTablePermitChemicalPayload: ResolverTypeWrapper<Omit<DeleteDataTablePermitChemicalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTablePreRegisteredProductsProvisionalByNodeIdInput: DeleteDataTablePreRegisteredProductsProvisionalByNodeIdInput;
  DeleteDataTablePreRegisteredProductsProvisionalInput: DeleteDataTablePreRegisteredProductsProvisionalInput;
  DeleteDataTablePreRegisteredProductsProvisionalPayload: ResolverTypeWrapper<Omit<DeleteDataTablePreRegisteredProductsProvisionalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTablePrequalManufacturerApplicationJoinByNodeIdInput: DeleteDataTablePrequalManufacturerApplicationJoinByNodeIdInput;
  DeleteDataTablePrequalManufacturerApplicationJoinInput: DeleteDataTablePrequalManufacturerApplicationJoinInput;
  DeleteDataTablePrequalManufacturerApplicationJoinPayload: ResolverTypeWrapper<Omit<DeleteDataTablePrequalManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTablePrequalManufacturerByNodeIdInput: DeleteDataTablePrequalManufacturerByNodeIdInput;
  DeleteDataTablePrequalManufacturerInput: DeleteDataTablePrequalManufacturerInput;
  DeleteDataTablePrequalManufacturerPayload: ResolverTypeWrapper<Omit<DeleteDataTablePrequalManufacturerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableProcessingStepByNodeIdInput: DeleteDataTableProcessingStepByNodeIdInput;
  DeleteDataTableProcessingStepInput: DeleteDataTableProcessingStepInput;
  DeleteDataTableProcessingStepPayload: ResolverTypeWrapper<Omit<DeleteDataTableProcessingStepPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableProductApplicationJoinByNodeIdInput: DeleteDataTableProductApplicationJoinByNodeIdInput;
  DeleteDataTableProductApplicationJoinInput: DeleteDataTableProductApplicationJoinInput;
  DeleteDataTableProductApplicationJoinPayload: ResolverTypeWrapper<Omit<DeleteDataTableProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableProductByNodeIdInput: DeleteDataTableProductByNodeIdInput;
  DeleteDataTableProductInput: DeleteDataTableProductInput;
  DeleteDataTableProductPayload: ResolverTypeWrapper<Omit<DeleteDataTableProductPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableProvisionalProductApplicationJoinByNodeIdInput: DeleteDataTableProvisionalProductApplicationJoinByNodeIdInput;
  DeleteDataTableProvisionalProductApplicationJoinInput: DeleteDataTableProvisionalProductApplicationJoinInput;
  DeleteDataTableProvisionalProductApplicationJoinPayload: ResolverTypeWrapper<Omit<DeleteDataTableProvisionalProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableProvisionalProductByNodeIdInput: DeleteDataTableProvisionalProductByNodeIdInput;
  DeleteDataTableProvisionalProductInput: DeleteDataTableProvisionalProductInput;
  DeleteDataTableProvisionalProductPayload: ResolverTypeWrapper<Omit<DeleteDataTableProvisionalProductPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableScheduledChemicalByNodeIdInput: DeleteDataTableScheduledChemicalByNodeIdInput;
  DeleteDataTableScheduledChemicalInput: DeleteDataTableScheduledChemicalInput;
  DeleteDataTableScheduledChemicalPayload: ResolverTypeWrapper<Omit<DeleteDataTableScheduledChemicalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableStorageConditionByNodeIdInput: DeleteDataTableStorageConditionByNodeIdInput;
  DeleteDataTableStorageConditionInput: DeleteDataTableStorageConditionInput;
  DeleteDataTableStorageConditionPayload: ResolverTypeWrapper<Omit<DeleteDataTableStorageConditionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableStorageConditionsSimplifiedByNodeIdInput: DeleteDataTableStorageConditionsSimplifiedByNodeIdInput;
  DeleteDataTableStorageConditionsSimplifiedInput: DeleteDataTableStorageConditionsSimplifiedInput;
  DeleteDataTableStorageConditionsSimplifiedPayload: ResolverTypeWrapper<Omit<DeleteDataTableStorageConditionsSimplifiedPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableUnitsOfProportionByNodeIdInput: DeleteDataTableUnitsOfProportionByNodeIdInput;
  DeleteDataTableUnitsOfProportionInput: DeleteDataTableUnitsOfProportionInput;
  DeleteDataTableUnitsOfProportionPayload: ResolverTypeWrapper<Omit<DeleteDataTableUnitsOfProportionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput: DeleteDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput;
  DeleteDataTableWorldHealthOrganisationPqListOfFppInput: DeleteDataTableWorldHealthOrganisationPqListOfFppInput;
  DeleteDataTableWorldHealthOrganisationPqListOfFppPayload: ResolverTypeWrapper<Omit<DeleteDataTableWorldHealthOrganisationPqListOfFppPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataViewByIdentifierInput: DeleteDataViewByIdentifierInput;
  DeleteDataViewByNodeIdInput: DeleteDataViewByNodeIdInput;
  DeleteDataViewColumnDefinitionByNodeIdInput: DeleteDataViewColumnDefinitionByNodeIdInput;
  DeleteDataViewColumnDefinitionByTableNameAndColumnNameInput: DeleteDataViewColumnDefinitionByTableNameAndColumnNameInput;
  DeleteDataViewColumnDefinitionInput: DeleteDataViewColumnDefinitionInput;
  DeleteDataViewColumnDefinitionPayload: ResolverTypeWrapper<Omit<DeleteDataViewColumnDefinitionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteDataViewInput: DeleteDataViewInput;
  DeleteDataViewPayload: ResolverTypeWrapper<Omit<DeleteDataViewPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteElementTypePluginByNodeIdInput: DeleteElementTypePluginByNodeIdInput;
  DeleteElementTypePluginInput: DeleteElementTypePluginInput;
  DeleteElementTypePluginPayload: ResolverTypeWrapper<Omit<DeleteElementTypePluginPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteFileByNodeIdInput: DeleteFileByNodeIdInput;
  DeleteFileByUniqueIdInput: DeleteFileByUniqueIdInput;
  DeleteFileInput: DeleteFileInput;
  DeleteFilePayload: ResolverTypeWrapper<Omit<DeleteFilePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteFilterByCodeInput: DeleteFilterByCodeInput;
  DeleteFilterByNodeIdInput: DeleteFilterByNodeIdInput;
  DeleteFilterInput: DeleteFilterInput;
  DeleteFilterPayload: ResolverTypeWrapper<Omit<DeleteFilterPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteGrafanaDashboardImageByNodeIdInput: DeleteGrafanaDashboardImageByNodeIdInput;
  DeleteGrafanaDashboardImageInput: DeleteGrafanaDashboardImageInput;
  DeleteGrafanaDashboardImagePayload: ResolverTypeWrapper<Omit<DeleteGrafanaDashboardImagePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteNotificationByNodeIdInput: DeleteNotificationByNodeIdInput;
  DeleteNotificationInput: DeleteNotificationInput;
  DeleteNotificationPayload: ResolverTypeWrapper<Omit<DeleteNotificationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteOrganisationApplicationJoinByNodeIdInput: DeleteOrganisationApplicationJoinByNodeIdInput;
  DeleteOrganisationApplicationJoinInput: DeleteOrganisationApplicationJoinInput;
  DeleteOrganisationApplicationJoinPayload: ResolverTypeWrapper<Omit<DeleteOrganisationApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteOrganisationByNameInput: DeleteOrganisationByNameInput;
  DeleteOrganisationByNodeIdInput: DeleteOrganisationByNodeIdInput;
  DeleteOrganisationByRegistrationInput: DeleteOrganisationByRegistrationInput;
  DeleteOrganisationInput: DeleteOrganisationInput;
  DeleteOrganisationPayload: ResolverTypeWrapper<Omit<DeleteOrganisationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeletePermissionJoinByNodeIdInput: DeletePermissionJoinByNodeIdInput;
  DeletePermissionJoinInput: DeletePermissionJoinInput;
  DeletePermissionJoinPayload: ResolverTypeWrapper<Omit<DeletePermissionJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeletePermissionNameByNameInput: DeletePermissionNameByNameInput;
  DeletePermissionNameByNodeIdInput: DeletePermissionNameByNodeIdInput;
  DeletePermissionNameInput: DeletePermissionNameInput;
  DeletePermissionNamePayload: ResolverTypeWrapper<Omit<DeletePermissionNamePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeletePermissionPolicyByNameInput: DeletePermissionPolicyByNameInput;
  DeletePermissionPolicyByNodeIdInput: DeletePermissionPolicyByNodeIdInput;
  DeletePermissionPolicyInput: DeletePermissionPolicyInput;
  DeletePermissionPolicyPayload: ResolverTypeWrapper<Omit<DeletePermissionPolicyPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteReviewAssignmentAssignerJoinByNodeIdInput: DeleteReviewAssignmentAssignerJoinByNodeIdInput;
  DeleteReviewAssignmentAssignerJoinInput: DeleteReviewAssignmentAssignerJoinInput;
  DeleteReviewAssignmentAssignerJoinPayload: ResolverTypeWrapper<Omit<DeleteReviewAssignmentAssignerJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteReviewAssignmentByNodeIdInput: DeleteReviewAssignmentByNodeIdInput;
  DeleteReviewAssignmentInput: DeleteReviewAssignmentInput;
  DeleteReviewAssignmentPayload: ResolverTypeWrapper<Omit<DeleteReviewAssignmentPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteReviewByNodeIdInput: DeleteReviewByNodeIdInput;
  DeleteReviewByReviewAssignmentIdInput: DeleteReviewByReviewAssignmentIdInput;
  DeleteReviewDecisionByNodeIdInput: DeleteReviewDecisionByNodeIdInput;
  DeleteReviewDecisionInput: DeleteReviewDecisionInput;
  DeleteReviewDecisionPayload: ResolverTypeWrapper<Omit<DeleteReviewDecisionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteReviewInput: DeleteReviewInput;
  DeleteReviewPayload: ResolverTypeWrapper<Omit<DeleteReviewPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteReviewResponseByNodeIdInput: DeleteReviewResponseByNodeIdInput;
  DeleteReviewResponseInput: DeleteReviewResponseInput;
  DeleteReviewResponsePayload: ResolverTypeWrapper<Omit<DeleteReviewResponsePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteReviewStatusHistoryByNodeIdInput: DeleteReviewStatusHistoryByNodeIdInput;
  DeleteReviewStatusHistoryInput: DeleteReviewStatusHistoryInput;
  DeleteReviewStatusHistoryPayload: ResolverTypeWrapper<Omit<DeleteReviewStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteSystemInfoByNodeIdInput: DeleteSystemInfoByNodeIdInput;
  DeleteSystemInfoInput: DeleteSystemInfoInput;
  DeleteSystemInfoPayload: ResolverTypeWrapper<Omit<DeleteSystemInfoPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplateActionByNodeIdInput: DeleteTemplateActionByNodeIdInput;
  DeleteTemplateActionInput: DeleteTemplateActionInput;
  DeleteTemplateActionPayload: ResolverTypeWrapper<Omit<DeleteTemplateActionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplateByCodeAndVersionIdInput: DeleteTemplateByCodeAndVersionIdInput;
  DeleteTemplateByNodeIdInput: DeleteTemplateByNodeIdInput;
  DeleteTemplateCategoryByCodeInput: DeleteTemplateCategoryByCodeInput;
  DeleteTemplateCategoryByNodeIdInput: DeleteTemplateCategoryByNodeIdInput;
  DeleteTemplateCategoryInput: DeleteTemplateCategoryInput;
  DeleteTemplateCategoryPayload: ResolverTypeWrapper<Omit<DeleteTemplateCategoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplateElementByNodeIdInput: DeleteTemplateElementByNodeIdInput;
  DeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput: DeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput;
  DeleteTemplateElementInput: DeleteTemplateElementInput;
  DeleteTemplateElementPayload: ResolverTypeWrapper<Omit<DeleteTemplateElementPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplateFilterJoinByNodeIdInput: DeleteTemplateFilterJoinByNodeIdInput;
  DeleteTemplateFilterJoinInput: DeleteTemplateFilterJoinInput;
  DeleteTemplateFilterJoinPayload: ResolverTypeWrapper<Omit<DeleteTemplateFilterJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplateInput: DeleteTemplateInput;
  DeleteTemplatePayload: ResolverTypeWrapper<Omit<DeleteTemplatePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplatePermissionByNodeIdInput: DeleteTemplatePermissionByNodeIdInput;
  DeleteTemplatePermissionInput: DeleteTemplatePermissionInput;
  DeleteTemplatePermissionPayload: ResolverTypeWrapper<Omit<DeleteTemplatePermissionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplateSectionByNodeIdInput: DeleteTemplateSectionByNodeIdInput;
  DeleteTemplateSectionByTemplateIdAndCodeInput: DeleteTemplateSectionByTemplateIdAndCodeInput;
  DeleteTemplateSectionInput: DeleteTemplateSectionInput;
  DeleteTemplateSectionPayload: ResolverTypeWrapper<Omit<DeleteTemplateSectionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplateStageByNodeIdInput: DeleteTemplateStageByNodeIdInput;
  DeleteTemplateStageInput: DeleteTemplateStageInput;
  DeleteTemplateStagePayload: ResolverTypeWrapper<Omit<DeleteTemplateStagePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTemplateStageReviewLevelByNodeIdInput: DeleteTemplateStageReviewLevelByNodeIdInput;
  DeleteTemplateStageReviewLevelInput: DeleteTemplateStageReviewLevelInput;
  DeleteTemplateStageReviewLevelPayload: ResolverTypeWrapper<Omit<DeleteTemplateStageReviewLevelPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTriggerQueueByNodeIdInput: DeleteTriggerQueueByNodeIdInput;
  DeleteTriggerQueueInput: DeleteTriggerQueueInput;
  DeleteTriggerQueuePayload: ResolverTypeWrapper<Omit<DeleteTriggerQueuePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteTriggerScheduleByNodeIdInput: DeleteTriggerScheduleByNodeIdInput;
  DeleteTriggerScheduleInput: DeleteTriggerScheduleInput;
  DeleteTriggerSchedulePayload: ResolverTypeWrapper<Omit<DeleteTriggerSchedulePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteUserApplicationJoinByNodeIdInput: DeleteUserApplicationJoinByNodeIdInput;
  DeleteUserApplicationJoinInput: DeleteUserApplicationJoinInput;
  DeleteUserApplicationJoinPayload: ResolverTypeWrapper<Omit<DeleteUserApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteUserOrganisationByNodeIdInput: DeleteUserOrganisationByNodeIdInput;
  DeleteUserOrganisationInput: DeleteUserOrganisationInput;
  DeleteUserOrganisationPayload: ResolverTypeWrapper<Omit<DeleteUserOrganisationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteVerificationByNodeIdInput: DeleteVerificationByNodeIdInput;
  DeleteVerificationByUniqueIdInput: DeleteVerificationByUniqueIdInput;
  DeleteVerificationInput: DeleteVerificationInput;
  DeleteVerificationPayload: ResolverTypeWrapper<Omit<DeleteVerificationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  DeleteWholeApplicationInput: DeleteWholeApplicationInput;
  DeleteWholeApplicationPayload: ResolverTypeWrapper<Omit<DeleteWholeApplicationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  ElementTypePlugin: ResolverTypeWrapper<ElementTypePlugin>;
  ElementTypePluginCondition: ElementTypePluginCondition;
  ElementTypePluginFilter: ElementTypePluginFilter;
  ElementTypePluginInput: ElementTypePluginInput;
  ElementTypePluginPatch: ElementTypePluginPatch;
  ElementTypePluginsConnection: ResolverTypeWrapper<ElementTypePluginsConnection>;
  ElementTypePluginsEdge: ResolverTypeWrapper<ElementTypePluginsEdge>;
  ElementTypePluginsOrderBy: ElementTypePluginsOrderBy;
  EventType: EventType;
  EventTypeFilter: EventTypeFilter;
  FakePublicApplicationForeignKey0ApplicationCreateInput: FakePublicApplicationForeignKey0ApplicationCreateInput;
  FakePublicApplicationForeignKey0Input: FakePublicApplicationForeignKey0Input;
  FakePublicApplicationForeignKey0InverseInput: FakePublicApplicationForeignKey0InverseInput;
  FakePublicApplicationForeignKey0UserListCreateInput: FakePublicApplicationForeignKey0UserListCreateInput;
  FakePublicApplicationNoteForeignKey0ApplicationNoteCreateInput: FakePublicApplicationNoteForeignKey0ApplicationNoteCreateInput;
  FakePublicApplicationNoteForeignKey0Input: FakePublicApplicationNoteForeignKey0Input;
  FakePublicApplicationNoteForeignKey0InverseInput: FakePublicApplicationNoteForeignKey0InverseInput;
  FakePublicApplicationNoteForeignKey0UserListCreateInput: FakePublicApplicationNoteForeignKey0UserListCreateInput;
  FakePublicPermissionJoinForeignKey0Input: FakePublicPermissionJoinForeignKey0Input;
  FakePublicPermissionJoinForeignKey0InverseInput: FakePublicPermissionJoinForeignKey0InverseInput;
  FakePublicPermissionJoinForeignKey0PermissionJoinCreateInput: FakePublicPermissionJoinForeignKey0PermissionJoinCreateInput;
  FakePublicPermissionJoinForeignKey0UserListCreateInput: FakePublicPermissionJoinForeignKey0UserListCreateInput;
  FakePublicReviewAssignmentAssignerJoinForeignKey0Input: FakePublicReviewAssignmentAssignerJoinForeignKey0Input;
  FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput: FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput;
  FakePublicReviewAssignmentAssignerJoinForeignKey0ReviewAssignmentAssignerJoinCreateInput: FakePublicReviewAssignmentAssignerJoinForeignKey0ReviewAssignmentAssignerJoinCreateInput;
  FakePublicReviewAssignmentAssignerJoinForeignKey0UserListCreateInput: FakePublicReviewAssignmentAssignerJoinForeignKey0UserListCreateInput;
  FakePublicReviewAssignmentForeignKey0Input: FakePublicReviewAssignmentForeignKey0Input;
  FakePublicReviewAssignmentForeignKey0InverseInput: FakePublicReviewAssignmentForeignKey0InverseInput;
  FakePublicReviewAssignmentForeignKey0ReviewAssignmentCreateInput: FakePublicReviewAssignmentForeignKey0ReviewAssignmentCreateInput;
  FakePublicReviewAssignmentForeignKey0UserListCreateInput: FakePublicReviewAssignmentForeignKey0UserListCreateInput;
  FakePublicReviewAssignmentForeignKey1Input: FakePublicReviewAssignmentForeignKey1Input;
  FakePublicReviewAssignmentForeignKey1InverseInput: FakePublicReviewAssignmentForeignKey1InverseInput;
  FakePublicReviewAssignmentForeignKey1ReviewAssignmentCreateInput: FakePublicReviewAssignmentForeignKey1ReviewAssignmentCreateInput;
  FakePublicReviewAssignmentForeignKey1UserListCreateInput: FakePublicReviewAssignmentForeignKey1UserListCreateInput;
  FakePublicReviewForeignKey0Input: FakePublicReviewForeignKey0Input;
  FakePublicReviewForeignKey0InverseInput: FakePublicReviewForeignKey0InverseInput;
  FakePublicReviewForeignKey0ReviewCreateInput: FakePublicReviewForeignKey0ReviewCreateInput;
  FakePublicReviewForeignKey0UserListCreateInput: FakePublicReviewForeignKey0UserListCreateInput;
  FakePublicUserOrganisationForeignKey0Input: FakePublicUserOrganisationForeignKey0Input;
  FakePublicUserOrganisationForeignKey0InverseInput: FakePublicUserOrganisationForeignKey0InverseInput;
  FakePublicUserOrganisationForeignKey0UserListAdminCreateInput: FakePublicUserOrganisationForeignKey0UserListAdminCreateInput;
  FakePublicUserOrganisationForeignKey0UserOrganisationCreateInput: FakePublicUserOrganisationForeignKey0UserOrganisationCreateInput;
  File: ResolverTypeWrapper<File>;
  FileApplicationNoteIdFkeyApplicationNoteCreateInput: FileApplicationNoteIdFkeyApplicationNoteCreateInput;
  FileApplicationNoteIdFkeyFileCreateInput: FileApplicationNoteIdFkeyFileCreateInput;
  FileApplicationNoteIdFkeyInput: FileApplicationNoteIdFkeyInput;
  FileApplicationNoteIdFkeyInverseInput: FileApplicationNoteIdFkeyInverseInput;
  FileApplicationResponseIdFkeyApplicationResponseCreateInput: FileApplicationResponseIdFkeyApplicationResponseCreateInput;
  FileApplicationResponseIdFkeyFileCreateInput: FileApplicationResponseIdFkeyFileCreateInput;
  FileApplicationResponseIdFkeyInput: FileApplicationResponseIdFkeyInput;
  FileApplicationResponseIdFkeyInverseInput: FileApplicationResponseIdFkeyInverseInput;
  FileApplicationSerialFkeyApplicationCreateInput: FileApplicationSerialFkeyApplicationCreateInput;
  FileApplicationSerialFkeyFileCreateInput: FileApplicationSerialFkeyFileCreateInput;
  FileApplicationSerialFkeyInput: FileApplicationSerialFkeyInput;
  FileApplicationSerialFkeyInverseInput: FileApplicationSerialFkeyInverseInput;
  FileCondition: FileCondition;
  FileFilePkeyConnect: FileFilePkeyConnect;
  FileFilePkeyDelete: FileFilePkeyDelete;
  FileFileUniqueIdKeyConnect: FileFileUniqueIdKeyConnect;
  FileFileUniqueIdKeyDelete: FileFileUniqueIdKeyDelete;
  FileFilter: FileFilter;
  FileInput: FileInput;
  FileNodeIdConnect: FileNodeIdConnect;
  FileNodeIdDelete: FileNodeIdDelete;
  FileOnFileForFileApplicationNoteIdFkeyNodeIdUpdate: FileOnFileForFileApplicationNoteIdFkeyNodeIdUpdate;
  FileOnFileForFileApplicationNoteIdFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationNoteIdFkeyUsingFilePkeyUpdate;
  FileOnFileForFileApplicationNoteIdFkeyUsingFileUniqueIdKeyUpdate: FileOnFileForFileApplicationNoteIdFkeyUsingFileUniqueIdKeyUpdate;
  FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate: FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate;
  FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate;
  FileOnFileForFileApplicationResponseIdFkeyUsingFileUniqueIdKeyUpdate: FileOnFileForFileApplicationResponseIdFkeyUsingFileUniqueIdKeyUpdate;
  FileOnFileForFileApplicationSerialFkeyNodeIdUpdate: FileOnFileForFileApplicationSerialFkeyNodeIdUpdate;
  FileOnFileForFileApplicationSerialFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationSerialFkeyUsingFilePkeyUpdate;
  FileOnFileForFileApplicationSerialFkeyUsingFileUniqueIdKeyUpdate: FileOnFileForFileApplicationSerialFkeyUsingFileUniqueIdKeyUpdate;
  FileOnFileForFileTemplateIdFkeyNodeIdUpdate: FileOnFileForFileTemplateIdFkeyNodeIdUpdate;
  FileOnFileForFileTemplateIdFkeyUsingFilePkeyUpdate: FileOnFileForFileTemplateIdFkeyUsingFilePkeyUpdate;
  FileOnFileForFileTemplateIdFkeyUsingFileUniqueIdKeyUpdate: FileOnFileForFileTemplateIdFkeyUsingFileUniqueIdKeyUpdate;
  FilePatch: FilePatch;
  FileTemplateIdFkeyFileCreateInput: FileTemplateIdFkeyFileCreateInput;
  FileTemplateIdFkeyInput: FileTemplateIdFkeyInput;
  FileTemplateIdFkeyInverseInput: FileTemplateIdFkeyInverseInput;
  FileTemplateIdFkeyTemplateCreateInput: FileTemplateIdFkeyTemplateCreateInput;
  FilesConnection: ResolverTypeWrapper<FilesConnection>;
  FilesEdge: ResolverTypeWrapper<FilesEdge>;
  FilesOrderBy: FilesOrderBy;
  Filter: ResolverTypeWrapper<Filter>;
  FilterCondition: FilterCondition;
  FilterFilter: FilterFilter;
  FilterFilterCodeKeyConnect: FilterFilterCodeKeyConnect;
  FilterFilterCodeKeyDelete: FilterFilterCodeKeyDelete;
  FilterFilterPkeyConnect: FilterFilterPkeyConnect;
  FilterFilterPkeyDelete: FilterFilterPkeyDelete;
  FilterInput: FilterInput;
  FilterNodeIdConnect: FilterNodeIdConnect;
  FilterNodeIdDelete: FilterNodeIdDelete;
  FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate: FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate;
  FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterCodeKeyUpdate: FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterCodeKeyUpdate;
  FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterPkeyUpdate: FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterPkeyUpdate;
  FilterPatch: FilterPatch;
  FilterToManyTemplateFilterJoinFilter: FilterToManyTemplateFilterJoinFilter;
  FiltersConnection: ResolverTypeWrapper<FiltersConnection>;
  FiltersEdge: ResolverTypeWrapper<FiltersEdge>;
  FiltersOrderBy: FiltersOrderBy;
  GrafanaDashboardImage: ResolverTypeWrapper<GrafanaDashboardImage>;
  GrafanaDashboardImageCondition: GrafanaDashboardImageCondition;
  GrafanaDashboardImageFilter: GrafanaDashboardImageFilter;
  GrafanaDashboardImageInput: GrafanaDashboardImageInput;
  GrafanaDashboardImagePatch: GrafanaDashboardImagePatch;
  GrafanaDashboardImagesConnection: ResolverTypeWrapper<GrafanaDashboardImagesConnection>;
  GrafanaDashboardImagesEdge: ResolverTypeWrapper<GrafanaDashboardImagesEdge>;
  GrafanaDashboardImagesOrderBy: GrafanaDashboardImagesOrderBy;
  ID: ResolverTypeWrapper<Scalars['ID']['output']>;
  Int: ResolverTypeWrapper<Scalars['Int']['output']>;
  IntFilter: IntFilter;
  JSON: ResolverTypeWrapper<Scalars['JSON']['output']>;
  JSONFilter: JsonFilter;
  Mutation: ResolverTypeWrapper<{}>;
  Node: ResolverTypeWrapper<ResolversInterfaceTypes<ResolversTypes>['Node']>;
  Notification: ResolverTypeWrapper<Notification>;
  NotificationApplicationIdFkeyApplicationCreateInput: NotificationApplicationIdFkeyApplicationCreateInput;
  NotificationApplicationIdFkeyInput: NotificationApplicationIdFkeyInput;
  NotificationApplicationIdFkeyInverseInput: NotificationApplicationIdFkeyInverseInput;
  NotificationApplicationIdFkeyNotificationCreateInput: NotificationApplicationIdFkeyNotificationCreateInput;
  NotificationCondition: NotificationCondition;
  NotificationFilter: NotificationFilter;
  NotificationInput: NotificationInput;
  NotificationNodeIdConnect: NotificationNodeIdConnect;
  NotificationNodeIdDelete: NotificationNodeIdDelete;
  NotificationNotificationPkeyConnect: NotificationNotificationPkeyConnect;
  NotificationNotificationPkeyDelete: NotificationNotificationPkeyDelete;
  NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate;
  NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate;
  NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate;
  NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate;
  NotificationPatch: NotificationPatch;
  NotificationReviewIdFkeyInput: NotificationReviewIdFkeyInput;
  NotificationReviewIdFkeyInverseInput: NotificationReviewIdFkeyInverseInput;
  NotificationReviewIdFkeyNotificationCreateInput: NotificationReviewIdFkeyNotificationCreateInput;
  NotificationReviewIdFkeyReviewCreateInput: NotificationReviewIdFkeyReviewCreateInput;
  NotificationsConnection: ResolverTypeWrapper<NotificationsConnection>;
  NotificationsEdge: ResolverTypeWrapper<NotificationsEdge>;
  NotificationsOrderBy: NotificationsOrderBy;
  Organisation: ResolverTypeWrapper<Organisation>;
  OrganisationApplicationJoin: ResolverTypeWrapper<OrganisationApplicationJoin>;
  OrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput: OrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput;
  OrganisationApplicationJoinApplicationIdFkeyInput: OrganisationApplicationJoinApplicationIdFkeyInput;
  OrganisationApplicationJoinApplicationIdFkeyInverseInput: OrganisationApplicationJoinApplicationIdFkeyInverseInput;
  OrganisationApplicationJoinApplicationIdFkeyOrganisationApplicationJoinCreateInput: OrganisationApplicationJoinApplicationIdFkeyOrganisationApplicationJoinCreateInput;
  OrganisationApplicationJoinCondition: OrganisationApplicationJoinCondition;
  OrganisationApplicationJoinFilter: OrganisationApplicationJoinFilter;
  OrganisationApplicationJoinInput: OrganisationApplicationJoinInput;
  OrganisationApplicationJoinNodeIdConnect: OrganisationApplicationJoinNodeIdConnect;
  OrganisationApplicationJoinNodeIdDelete: OrganisationApplicationJoinNodeIdDelete;
  OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate: OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate;
  OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate: OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate;
  OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate: OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate;
  OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate: OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate;
  OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect: OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect;
  OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete: OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete;
  OrganisationApplicationJoinOrganisationIdFkeyInput: OrganisationApplicationJoinOrganisationIdFkeyInput;
  OrganisationApplicationJoinOrganisationIdFkeyInverseInput: OrganisationApplicationJoinOrganisationIdFkeyInverseInput;
  OrganisationApplicationJoinOrganisationIdFkeyOrganisationApplicationJoinCreateInput: OrganisationApplicationJoinOrganisationIdFkeyOrganisationApplicationJoinCreateInput;
  OrganisationApplicationJoinOrganisationIdFkeyOrganisationCreateInput: OrganisationApplicationJoinOrganisationIdFkeyOrganisationCreateInput;
  OrganisationApplicationJoinPatch: OrganisationApplicationJoinPatch;
  OrganisationApplicationJoinsConnection: ResolverTypeWrapper<OrganisationApplicationJoinsConnection>;
  OrganisationApplicationJoinsEdge: ResolverTypeWrapper<OrganisationApplicationJoinsEdge>;
  OrganisationApplicationJoinsOrderBy: OrganisationApplicationJoinsOrderBy;
  OrganisationCondition: OrganisationCondition;
  OrganisationFilter: OrganisationFilter;
  OrganisationInput: OrganisationInput;
  OrganisationNodeIdConnect: OrganisationNodeIdConnect;
  OrganisationNodeIdDelete: OrganisationNodeIdDelete;
  OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate: OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate;
  OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate: OrganisationOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate;
  OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate: OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate: OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOrganisationNameKeyConnect: OrganisationOrganisationNameKeyConnect;
  OrganisationOrganisationNameKeyDelete: OrganisationOrganisationNameKeyDelete;
  OrganisationOrganisationPkeyConnect: OrganisationOrganisationPkeyConnect;
  OrganisationOrganisationPkeyDelete: OrganisationOrganisationPkeyDelete;
  OrganisationOrganisationRegistrationKeyConnect: OrganisationOrganisationRegistrationKeyConnect;
  OrganisationOrganisationRegistrationKeyDelete: OrganisationOrganisationRegistrationKeyDelete;
  OrganisationPatch: OrganisationPatch;
  OrganisationToManyApplicationFilter: OrganisationToManyApplicationFilter;
  OrganisationToManyApplicationNoteFilter: OrganisationToManyApplicationNoteFilter;
  OrganisationToManyDataChangelogFilter: OrganisationToManyDataChangelogFilter;
  OrganisationToManyOrganisationApplicationJoinFilter: OrganisationToManyOrganisationApplicationJoinFilter;
  OrganisationToManyPermissionJoinFilter: OrganisationToManyPermissionJoinFilter;
  OrganisationToManyReviewAssignmentAssignerJoinFilter: OrganisationToManyReviewAssignmentAssignerJoinFilter;
  OrganisationToManyReviewAssignmentFilter: OrganisationToManyReviewAssignmentFilter;
  OrganisationToManyUserOrganisationFilter: OrganisationToManyUserOrganisationFilter;
  OrganisationsConnection: ResolverTypeWrapper<OrganisationsConnection>;
  OrganisationsEdge: ResolverTypeWrapper<OrganisationsEdge>;
  OrganisationsOrderBy: OrganisationsOrderBy;
  PageInfo: ResolverTypeWrapper<PageInfo>;
  PermissionFlattened: ResolverTypeWrapper<PermissionFlattened>;
  PermissionFlattenedCondition: PermissionFlattenedCondition;
  PermissionFlattenedFilter: PermissionFlattenedFilter;
  PermissionFlattenedsConnection: ResolverTypeWrapper<PermissionFlattenedsConnection>;
  PermissionFlattenedsEdge: ResolverTypeWrapper<PermissionFlattenedsEdge>;
  PermissionFlattenedsOrderBy: PermissionFlattenedsOrderBy;
  PermissionJoin: ResolverTypeWrapper<PermissionJoin>;
  PermissionJoinCondition: PermissionJoinCondition;
  PermissionJoinFilter: PermissionJoinFilter;
  PermissionJoinInput: PermissionJoinInput;
  PermissionJoinNodeIdConnect: PermissionJoinNodeIdConnect;
  PermissionJoinNodeIdDelete: PermissionJoinNodeIdDelete;
  PermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0UsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0UsingPermissionJoinPkeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate;
  PermissionJoinOrganisationIdFkeyInput: PermissionJoinOrganisationIdFkeyInput;
  PermissionJoinOrganisationIdFkeyInverseInput: PermissionJoinOrganisationIdFkeyInverseInput;
  PermissionJoinOrganisationIdFkeyOrganisationCreateInput: PermissionJoinOrganisationIdFkeyOrganisationCreateInput;
  PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput: PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput;
  PermissionJoinPatch: PermissionJoinPatch;
  PermissionJoinPermissionJoinPkeyConnect: PermissionJoinPermissionJoinPkeyConnect;
  PermissionJoinPermissionJoinPkeyDelete: PermissionJoinPermissionJoinPkeyDelete;
  PermissionJoinPermissionNameIdFkeyInput: PermissionJoinPermissionNameIdFkeyInput;
  PermissionJoinPermissionNameIdFkeyInverseInput: PermissionJoinPermissionNameIdFkeyInverseInput;
  PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput: PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput;
  PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput: PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput;
  PermissionJoinsConnection: ResolverTypeWrapper<PermissionJoinsConnection>;
  PermissionJoinsEdge: ResolverTypeWrapper<PermissionJoinsEdge>;
  PermissionJoinsOrderBy: PermissionJoinsOrderBy;
  PermissionName: ResolverTypeWrapper<PermissionName>;
  PermissionNameCondition: PermissionNameCondition;
  PermissionNameFilter: PermissionNameFilter;
  PermissionNameInput: PermissionNameInput;
  PermissionNameNodeIdConnect: PermissionNameNodeIdConnect;
  PermissionNameNodeIdDelete: PermissionNameNodeIdDelete;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate;
  PermissionNamePatch: PermissionNamePatch;
  PermissionNamePermissionNameNameKeyConnect: PermissionNamePermissionNameNameKeyConnect;
  PermissionNamePermissionNameNameKeyDelete: PermissionNamePermissionNameNameKeyDelete;
  PermissionNamePermissionNamePkeyConnect: PermissionNamePermissionNamePkeyConnect;
  PermissionNamePermissionNamePkeyDelete: PermissionNamePermissionNamePkeyDelete;
  PermissionNamePermissionPolicyIdFkeyInput: PermissionNamePermissionPolicyIdFkeyInput;
  PermissionNamePermissionPolicyIdFkeyInverseInput: PermissionNamePermissionPolicyIdFkeyInverseInput;
  PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput: PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput;
  PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput: PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput;
  PermissionNameToManyPermissionJoinFilter: PermissionNameToManyPermissionJoinFilter;
  PermissionNameToManyTemplatePermissionFilter: PermissionNameToManyTemplatePermissionFilter;
  PermissionNamesConnection: ResolverTypeWrapper<PermissionNamesConnection>;
  PermissionNamesEdge: ResolverTypeWrapper<PermissionNamesEdge>;
  PermissionNamesOrderBy: PermissionNamesOrderBy;
  PermissionPoliciesConnection: ResolverTypeWrapper<PermissionPoliciesConnection>;
  PermissionPoliciesEdge: ResolverTypeWrapper<PermissionPoliciesEdge>;
  PermissionPoliciesOrderBy: PermissionPoliciesOrderBy;
  PermissionPolicy: ResolverTypeWrapper<PermissionPolicy>;
  PermissionPolicyCondition: PermissionPolicyCondition;
  PermissionPolicyFilter: PermissionPolicyFilter;
  PermissionPolicyInput: PermissionPolicyInput;
  PermissionPolicyNodeIdConnect: PermissionPolicyNodeIdConnect;
  PermissionPolicyNodeIdDelete: PermissionPolicyNodeIdDelete;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyNameKeyUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyNameKeyUpdate;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate;
  PermissionPolicyPatch: PermissionPolicyPatch;
  PermissionPolicyPermissionPolicyNameKeyConnect: PermissionPolicyPermissionPolicyNameKeyConnect;
  PermissionPolicyPermissionPolicyNameKeyDelete: PermissionPolicyPermissionPolicyNameKeyDelete;
  PermissionPolicyPermissionPolicyPkeyConnect: PermissionPolicyPermissionPolicyPkeyConnect;
  PermissionPolicyPermissionPolicyPkeyDelete: PermissionPolicyPermissionPolicyPkeyDelete;
  PermissionPolicyToManyPermissionNameFilter: PermissionPolicyToManyPermissionNameFilter;
  PermissionPolicyType: PermissionPolicyType;
  PermissionPolicyTypeFilter: PermissionPolicyTypeFilter;
  PermissionsAll: ResolverTypeWrapper<PermissionsAll>;
  PermissionsAllCondition: PermissionsAllCondition;
  PermissionsAllFilter: PermissionsAllFilter;
  PermissionsAllsConnection: ResolverTypeWrapper<PermissionsAllsConnection>;
  PermissionsAllsEdge: ResolverTypeWrapper<PermissionsAllsEdge>;
  PermissionsAllsOrderBy: PermissionsAllsOrderBy;
  PostgresRowLevel: ResolverTypeWrapper<PostgresRowLevel>;
  PostgresRowLevelCondition: PostgresRowLevelCondition;
  PostgresRowLevelFilter: PostgresRowLevelFilter;
  PostgresRowLevelsConnection: ResolverTypeWrapper<PostgresRowLevelsConnection>;
  PostgresRowLevelsEdge: ResolverTypeWrapper<PostgresRowLevelsEdge>;
  PostgresRowLevelsOrderBy: PostgresRowLevelsOrderBy;
  Query: ResolverTypeWrapper<{}>;
  Review: ResolverTypeWrapper<Review>;
  ReviewApplicationIdFkeyApplicationCreateInput: ReviewApplicationIdFkeyApplicationCreateInput;
  ReviewApplicationIdFkeyInput: ReviewApplicationIdFkeyInput;
  ReviewApplicationIdFkeyInverseInput: ReviewApplicationIdFkeyInverseInput;
  ReviewApplicationIdFkeyReviewCreateInput: ReviewApplicationIdFkeyReviewCreateInput;
  ReviewAssignment: ResolverTypeWrapper<ReviewAssignment>;
  ReviewAssignmentApplicationIdFkeyApplicationCreateInput: ReviewAssignmentApplicationIdFkeyApplicationCreateInput;
  ReviewAssignmentApplicationIdFkeyInput: ReviewAssignmentApplicationIdFkeyInput;
  ReviewAssignmentApplicationIdFkeyInverseInput: ReviewAssignmentApplicationIdFkeyInverseInput;
  ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput: ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentAssignedSectionsShape: ResolverTypeWrapper<ReviewAssignmentAssignedSectionsShape>;
  ReviewAssignmentAssignedSectionsShapeCondition: ReviewAssignmentAssignedSectionsShapeCondition;
  ReviewAssignmentAssignedSectionsShapeFilter: ReviewAssignmentAssignedSectionsShapeFilter;
  ReviewAssignmentAssignedSectionsShapeInput: ReviewAssignmentAssignedSectionsShapeInput;
  ReviewAssignmentAssignedSectionsShapesConnection: ResolverTypeWrapper<ReviewAssignmentAssignedSectionsShapesConnection>;
  ReviewAssignmentAssignedSectionsShapesEdge: ResolverTypeWrapper<ReviewAssignmentAssignedSectionsShapesEdge>;
  ReviewAssignmentAssignedSectionsShapesOrderBy: ReviewAssignmentAssignedSectionsShapesOrderBy;
  ReviewAssignmentAssignerJoin: ResolverTypeWrapper<ReviewAssignmentAssignerJoin>;
  ReviewAssignmentAssignerJoinCondition: ReviewAssignmentAssignerJoinCondition;
  ReviewAssignmentAssignerJoinFilter: ReviewAssignmentAssignerJoinFilter;
  ReviewAssignmentAssignerJoinInput: ReviewAssignmentAssignerJoinInput;
  ReviewAssignmentAssignerJoinNodeIdConnect: ReviewAssignmentAssignerJoinNodeIdConnect;
  ReviewAssignmentAssignerJoinNodeIdDelete: ReviewAssignmentAssignerJoinNodeIdDelete;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0UsingReviewAssignmentAssignerJoinPkeyUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0UsingReviewAssignmentAssignerJoinPkeyUpdate;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate;
  ReviewAssignmentAssignerJoinOrganisationIdFkeyInput: ReviewAssignmentAssignerJoinOrganisationIdFkeyInput;
  ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput: ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput;
  ReviewAssignmentAssignerJoinOrganisationIdFkeyOrganisationCreateInput: ReviewAssignmentAssignerJoinOrganisationIdFkeyOrganisationCreateInput;
  ReviewAssignmentAssignerJoinOrganisationIdFkeyReviewAssignmentAssignerJoinCreateInput: ReviewAssignmentAssignerJoinOrganisationIdFkeyReviewAssignmentAssignerJoinCreateInput;
  ReviewAssignmentAssignerJoinPatch: ReviewAssignmentAssignerJoinPatch;
  ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect: ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect;
  ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete: ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete;
  ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput: ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput;
  ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput: ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput;
  ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentAssignerJoinCreateInput: ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentAssignerJoinCreateInput;
  ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentCreateInput: ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentAssignerJoinsConnection: ResolverTypeWrapper<ReviewAssignmentAssignerJoinsConnection>;
  ReviewAssignmentAssignerJoinsEdge: ResolverTypeWrapper<ReviewAssignmentAssignerJoinsEdge>;
  ReviewAssignmentAssignerJoinsOrderBy: ReviewAssignmentAssignerJoinsOrderBy;
  ReviewAssignmentCondition: ReviewAssignmentCondition;
  ReviewAssignmentFilter: ReviewAssignmentFilter;
  ReviewAssignmentInput: ReviewAssignmentInput;
  ReviewAssignmentLevelIdFkeyInput: ReviewAssignmentLevelIdFkeyInput;
  ReviewAssignmentLevelIdFkeyInverseInput: ReviewAssignmentLevelIdFkeyInverseInput;
  ReviewAssignmentLevelIdFkeyReviewAssignmentCreateInput: ReviewAssignmentLevelIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentLevelIdFkeyTemplateStageReviewLevelCreateInput: ReviewAssignmentLevelIdFkeyTemplateStageReviewLevelCreateInput;
  ReviewAssignmentNodeIdConnect: ReviewAssignmentNodeIdConnect;
  ReviewAssignmentNodeIdDelete: ReviewAssignmentNodeIdDelete;
  ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0UsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0UsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1UsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1UsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOrganisationIdFkeyInput: ReviewAssignmentOrganisationIdFkeyInput;
  ReviewAssignmentOrganisationIdFkeyInverseInput: ReviewAssignmentOrganisationIdFkeyInverseInput;
  ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput: ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput;
  ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput: ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentPatch: ReviewAssignmentPatch;
  ReviewAssignmentReviewAssignmentPkeyConnect: ReviewAssignmentReviewAssignmentPkeyConnect;
  ReviewAssignmentReviewAssignmentPkeyDelete: ReviewAssignmentReviewAssignmentPkeyDelete;
  ReviewAssignmentStageIdFkeyInput: ReviewAssignmentStageIdFkeyInput;
  ReviewAssignmentStageIdFkeyInverseInput: ReviewAssignmentStageIdFkeyInverseInput;
  ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput: ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentStageIdFkeyTemplateStageCreateInput: ReviewAssignmentStageIdFkeyTemplateStageCreateInput;
  ReviewAssignmentStatus: ReviewAssignmentStatus;
  ReviewAssignmentStatusFilter: ReviewAssignmentStatusFilter;
  ReviewAssignmentTemplateIdFkeyInput: ReviewAssignmentTemplateIdFkeyInput;
  ReviewAssignmentTemplateIdFkeyInverseInput: ReviewAssignmentTemplateIdFkeyInverseInput;
  ReviewAssignmentTemplateIdFkeyReviewAssignmentCreateInput: ReviewAssignmentTemplateIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentTemplateIdFkeyTemplateCreateInput: ReviewAssignmentTemplateIdFkeyTemplateCreateInput;
  ReviewAssignmentToManyReviewAssignmentAssignerJoinFilter: ReviewAssignmentToManyReviewAssignmentAssignerJoinFilter;
  ReviewAssignmentsConnection: ResolverTypeWrapper<ReviewAssignmentsConnection>;
  ReviewAssignmentsEdge: ResolverTypeWrapper<ReviewAssignmentsEdge>;
  ReviewAssignmentsOrderBy: ReviewAssignmentsOrderBy;
  ReviewCondition: ReviewCondition;
  ReviewDecision: ResolverTypeWrapper<ReviewDecision>;
  ReviewDecisionCondition: ReviewDecisionCondition;
  ReviewDecisionFilter: ReviewDecisionFilter;
  ReviewDecisionInput: ReviewDecisionInput;
  ReviewDecisionNodeIdConnect: ReviewDecisionNodeIdConnect;
  ReviewDecisionNodeIdDelete: ReviewDecisionNodeIdDelete;
  ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate: ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate;
  ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate: ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate;
  ReviewDecisionPatch: ReviewDecisionPatch;
  ReviewDecisionReviewDecisionPkeyConnect: ReviewDecisionReviewDecisionPkeyConnect;
  ReviewDecisionReviewDecisionPkeyDelete: ReviewDecisionReviewDecisionPkeyDelete;
  ReviewDecisionReviewIdFkeyInput: ReviewDecisionReviewIdFkeyInput;
  ReviewDecisionReviewIdFkeyInverseInput: ReviewDecisionReviewIdFkeyInverseInput;
  ReviewDecisionReviewIdFkeyReviewCreateInput: ReviewDecisionReviewIdFkeyReviewCreateInput;
  ReviewDecisionReviewIdFkeyReviewDecisionCreateInput: ReviewDecisionReviewIdFkeyReviewDecisionCreateInput;
  ReviewDecisionsConnection: ResolverTypeWrapper<ReviewDecisionsConnection>;
  ReviewDecisionsEdge: ResolverTypeWrapper<ReviewDecisionsEdge>;
  ReviewDecisionsOrderBy: ReviewDecisionsOrderBy;
  ReviewFilter: ReviewFilter;
  ReviewInput: ReviewInput;
  ReviewListConnection: ResolverTypeWrapper<ReviewListConnection>;
  ReviewListEdge: ResolverTypeWrapper<ReviewListEdge>;
  ReviewListRecord: ResolverTypeWrapper<ReviewListRecord>;
  ReviewListRecordFilter: ReviewListRecordFilter;
  ReviewNodeIdConnect: ReviewNodeIdConnect;
  ReviewNodeIdDelete: ReviewNodeIdDelete;
  ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate: ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate;
  ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate;
  ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewPkeyUpdate: ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewPkeyUpdate;
  ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate: ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate;
  ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewForReviewApplicationIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewForReviewApplicationIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewPatch: ReviewPatch;
  ReviewResponse: ResolverTypeWrapper<ReviewResponse>;
  ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput: ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput;
  ReviewResponseApplicationResponseIdFkeyInput: ReviewResponseApplicationResponseIdFkeyInput;
  ReviewResponseApplicationResponseIdFkeyInverseInput: ReviewResponseApplicationResponseIdFkeyInverseInput;
  ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput: ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput;
  ReviewResponseCondition: ReviewResponseCondition;
  ReviewResponseDecision: ReviewResponseDecision;
  ReviewResponseDecisionFilter: ReviewResponseDecisionFilter;
  ReviewResponseFilter: ReviewResponseFilter;
  ReviewResponseInput: ReviewResponseInput;
  ReviewResponseNodeIdConnect: ReviewResponseNodeIdConnect;
  ReviewResponseNodeIdDelete: ReviewResponseNodeIdDelete;
  ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOriginalReviewResponseIdFkeyInput: ReviewResponseOriginalReviewResponseIdFkeyInput;
  ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput: ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput;
  ReviewResponsePatch: ReviewResponsePatch;
  ReviewResponseRecommendedApplicantVisibility: ReviewResponseRecommendedApplicantVisibility;
  ReviewResponseRecommendedApplicantVisibilityFilter: ReviewResponseRecommendedApplicantVisibilityFilter;
  ReviewResponseReviewIdFkeyInput: ReviewResponseReviewIdFkeyInput;
  ReviewResponseReviewIdFkeyInverseInput: ReviewResponseReviewIdFkeyInverseInput;
  ReviewResponseReviewIdFkeyReviewCreateInput: ReviewResponseReviewIdFkeyReviewCreateInput;
  ReviewResponseReviewIdFkeyReviewResponseCreateInput: ReviewResponseReviewIdFkeyReviewResponseCreateInput;
  ReviewResponseReviewResponseLinkIdFkeyInput: ReviewResponseReviewResponseLinkIdFkeyInput;
  ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput: ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput;
  ReviewResponseReviewResponsePkeyConnect: ReviewResponseReviewResponsePkeyConnect;
  ReviewResponseReviewResponsePkeyDelete: ReviewResponseReviewResponsePkeyDelete;
  ReviewResponseStatus: ReviewResponseStatus;
  ReviewResponseStatusFilter: ReviewResponseStatusFilter;
  ReviewResponseTemplateElementIdFkeyInput: ReviewResponseTemplateElementIdFkeyInput;
  ReviewResponseTemplateElementIdFkeyInverseInput: ReviewResponseTemplateElementIdFkeyInverseInput;
  ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput: ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput;
  ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput: ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput;
  ReviewResponseToManyReviewResponseFilter: ReviewResponseToManyReviewResponseFilter;
  ReviewResponsesConnection: ResolverTypeWrapper<ReviewResponsesConnection>;
  ReviewResponsesEdge: ResolverTypeWrapper<ReviewResponsesEdge>;
  ReviewResponsesOrderBy: ReviewResponsesOrderBy;
  ReviewReviewAssignmentIdFkeyInput: ReviewReviewAssignmentIdFkeyInput;
  ReviewReviewAssignmentIdFkeyInverseInput: ReviewReviewAssignmentIdFkeyInverseInput;
  ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput: ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput;
  ReviewReviewAssignmentIdFkeyReviewCreateInput: ReviewReviewAssignmentIdFkeyReviewCreateInput;
  ReviewReviewPkeyConnect: ReviewReviewPkeyConnect;
  ReviewReviewPkeyDelete: ReviewReviewPkeyDelete;
  ReviewReviewReviewAssignmentIdKeyConnect: ReviewReviewReviewAssignmentIdKeyConnect;
  ReviewReviewReviewAssignmentIdKeyDelete: ReviewReviewReviewAssignmentIdKeyDelete;
  ReviewStatus: ReviewStatus;
  ReviewStatusFilter: ReviewStatusFilter;
  ReviewStatusHistoriesConnection: ResolverTypeWrapper<ReviewStatusHistoriesConnection>;
  ReviewStatusHistoriesEdge: ResolverTypeWrapper<ReviewStatusHistoriesEdge>;
  ReviewStatusHistoriesOrderBy: ReviewStatusHistoriesOrderBy;
  ReviewStatusHistory: ResolverTypeWrapper<ReviewStatusHistory>;
  ReviewStatusHistoryCondition: ReviewStatusHistoryCondition;
  ReviewStatusHistoryFilter: ReviewStatusHistoryFilter;
  ReviewStatusHistoryInput: ReviewStatusHistoryInput;
  ReviewStatusHistoryNodeIdConnect: ReviewStatusHistoryNodeIdConnect;
  ReviewStatusHistoryNodeIdDelete: ReviewStatusHistoryNodeIdDelete;
  ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate: ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate;
  ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate: ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate;
  ReviewStatusHistoryPatch: ReviewStatusHistoryPatch;
  ReviewStatusHistoryReviewIdFkeyInput: ReviewStatusHistoryReviewIdFkeyInput;
  ReviewStatusHistoryReviewIdFkeyInverseInput: ReviewStatusHistoryReviewIdFkeyInverseInput;
  ReviewStatusHistoryReviewIdFkeyReviewCreateInput: ReviewStatusHistoryReviewIdFkeyReviewCreateInput;
  ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput: ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput;
  ReviewStatusHistoryReviewStatusHistoryPkeyConnect: ReviewStatusHistoryReviewStatusHistoryPkeyConnect;
  ReviewStatusHistoryReviewStatusHistoryPkeyDelete: ReviewStatusHistoryReviewStatusHistoryPkeyDelete;
  ReviewToManyNotificationFilter: ReviewToManyNotificationFilter;
  ReviewToManyReviewDecisionFilter: ReviewToManyReviewDecisionFilter;
  ReviewToManyReviewResponseFilter: ReviewToManyReviewResponseFilter;
  ReviewToManyReviewStatusHistoryFilter: ReviewToManyReviewStatusHistoryFilter;
  Reviewability: Reviewability;
  ReviewabilityFilter: ReviewabilityFilter;
  ReviewableQuestionEdge: ResolverTypeWrapper<ReviewableQuestionEdge>;
  ReviewableQuestionsConnection: ResolverTypeWrapper<ReviewableQuestionsConnection>;
  ReviewableQuestionsRecord: ResolverTypeWrapper<ReviewableQuestionsRecord>;
  ReviewableQuestionsRecordFilter: ReviewableQuestionsRecordFilter;
  ReviewerAction: ReviewerAction;
  ReviewerActionFilter: ReviewerActionFilter;
  ReviewsConnection: ResolverTypeWrapper<ReviewsConnection>;
  ReviewsEdge: ResolverTypeWrapper<ReviewsEdge>;
  ReviewsOrderBy: ReviewsOrderBy;
  SchemaColumn: ResolverTypeWrapper<SchemaColumn>;
  SchemaColumnCondition: SchemaColumnCondition;
  SchemaColumnFilter: SchemaColumnFilter;
  SchemaColumnsConnection: ResolverTypeWrapper<SchemaColumnsConnection>;
  SchemaColumnsEdge: ResolverTypeWrapper<SchemaColumnsEdge>;
  SchemaColumnsOrderBy: SchemaColumnsOrderBy;
  SingleApplicationDetailConnection: ResolverTypeWrapper<SingleApplicationDetailConnection>;
  SingleApplicationDetailEdge: ResolverTypeWrapper<SingleApplicationDetailEdge>;
  SingleApplicationDetailRecord: ResolverTypeWrapper<SingleApplicationDetailRecord>;
  SingleApplicationDetailRecordFilter: SingleApplicationDetailRecordFilter;
  SqlIdentifier: ResolverTypeWrapper<Scalars['SqlIdentifier']['output']>;
  SqlIdentifierFilter: SqlIdentifierFilter;
  String: ResolverTypeWrapper<Scalars['String']['output']>;
  StringFilter: StringFilter;
  StringListFilter: StringListFilter;
  SystemInfo: ResolverTypeWrapper<SystemInfo>;
  SystemInfoCondition: SystemInfoCondition;
  SystemInfoFilter: SystemInfoFilter;
  SystemInfoInput: SystemInfoInput;
  SystemInfoPatch: SystemInfoPatch;
  SystemInfosConnection: ResolverTypeWrapper<SystemInfosConnection>;
  SystemInfosEdge: ResolverTypeWrapper<SystemInfosEdge>;
  SystemInfosOrderBy: SystemInfosOrderBy;
  Template: ResolverTypeWrapper<Template>;
  TemplateAction: ResolverTypeWrapper<TemplateAction>;
  TemplateActionCondition: TemplateActionCondition;
  TemplateActionFilter: TemplateActionFilter;
  TemplateActionInput: TemplateActionInput;
  TemplateActionNodeIdConnect: TemplateActionNodeIdConnect;
  TemplateActionNodeIdDelete: TemplateActionNodeIdDelete;
  TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate: TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate;
  TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate: TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate;
  TemplateActionPatch: TemplateActionPatch;
  TemplateActionTemplateActionPkeyConnect: TemplateActionTemplateActionPkeyConnect;
  TemplateActionTemplateActionPkeyDelete: TemplateActionTemplateActionPkeyDelete;
  TemplateActionTemplateIdFkeyInput: TemplateActionTemplateIdFkeyInput;
  TemplateActionTemplateIdFkeyInverseInput: TemplateActionTemplateIdFkeyInverseInput;
  TemplateActionTemplateIdFkeyTemplateActionCreateInput: TemplateActionTemplateIdFkeyTemplateActionCreateInput;
  TemplateActionTemplateIdFkeyTemplateCreateInput: TemplateActionTemplateIdFkeyTemplateCreateInput;
  TemplateActionsConnection: ResolverTypeWrapper<TemplateActionsConnection>;
  TemplateActionsEdge: ResolverTypeWrapper<TemplateActionsEdge>;
  TemplateActionsOrderBy: TemplateActionsOrderBy;
  TemplateCategoriesConnection: ResolverTypeWrapper<TemplateCategoriesConnection>;
  TemplateCategoriesEdge: ResolverTypeWrapper<TemplateCategoriesEdge>;
  TemplateCategoriesOrderBy: TemplateCategoriesOrderBy;
  TemplateCategory: ResolverTypeWrapper<TemplateCategory>;
  TemplateCategoryCondition: TemplateCategoryCondition;
  TemplateCategoryFilter: TemplateCategoryFilter;
  TemplateCategoryInput: TemplateCategoryInput;
  TemplateCategoryNodeIdConnect: TemplateCategoryNodeIdConnect;
  TemplateCategoryNodeIdDelete: TemplateCategoryNodeIdDelete;
  TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate: TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate;
  TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryCodeKeyUpdate: TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryCodeKeyUpdate;
  TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryPkeyUpdate: TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryPkeyUpdate;
  TemplateCategoryPatch: TemplateCategoryPatch;
  TemplateCategoryTemplateCategoryCodeKeyConnect: TemplateCategoryTemplateCategoryCodeKeyConnect;
  TemplateCategoryTemplateCategoryCodeKeyDelete: TemplateCategoryTemplateCategoryCodeKeyDelete;
  TemplateCategoryTemplateCategoryPkeyConnect: TemplateCategoryTemplateCategoryPkeyConnect;
  TemplateCategoryTemplateCategoryPkeyDelete: TemplateCategoryTemplateCategoryPkeyDelete;
  TemplateCategoryToManyTemplateFilter: TemplateCategoryToManyTemplateFilter;
  TemplateCondition: TemplateCondition;
  TemplateElement: ResolverTypeWrapper<TemplateElement>;
  TemplateElementCategory: TemplateElementCategory;
  TemplateElementCategoryFilter: TemplateElementCategoryFilter;
  TemplateElementCondition: TemplateElementCondition;
  TemplateElementFilter: TemplateElementFilter;
  TemplateElementInput: TemplateElementInput;
  TemplateElementNodeIdConnect: TemplateElementNodeIdConnect;
  TemplateElementNodeIdDelete: TemplateElementNodeIdDelete;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate;
  TemplateElementPatch: TemplateElementPatch;
  TemplateElementSectionIdFkeyInput: TemplateElementSectionIdFkeyInput;
  TemplateElementSectionIdFkeyInverseInput: TemplateElementSectionIdFkeyInverseInput;
  TemplateElementSectionIdFkeyTemplateElementCreateInput: TemplateElementSectionIdFkeyTemplateElementCreateInput;
  TemplateElementSectionIdFkeyTemplateSectionCreateInput: TemplateElementSectionIdFkeyTemplateSectionCreateInput;
  TemplateElementTemplateElementPkeyConnect: TemplateElementTemplateElementPkeyConnect;
  TemplateElementTemplateElementPkeyDelete: TemplateElementTemplateElementPkeyDelete;
  TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect: TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect;
  TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete: TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete;
  TemplateElementToManyApplicationResponseFilter: TemplateElementToManyApplicationResponseFilter;
  TemplateElementToManyReviewResponseFilter: TemplateElementToManyReviewResponseFilter;
  TemplateElementsConnection: ResolverTypeWrapper<TemplateElementsConnection>;
  TemplateElementsEdge: ResolverTypeWrapper<TemplateElementsEdge>;
  TemplateElementsOrderBy: TemplateElementsOrderBy;
  TemplateFilter: TemplateFilter;
  TemplateFilterJoin: ResolverTypeWrapper<TemplateFilterJoin>;
  TemplateFilterJoinCondition: TemplateFilterJoinCondition;
  TemplateFilterJoinFilter: TemplateFilterJoinFilter;
  TemplateFilterJoinFilterIdFkeyFilterCreateInput: TemplateFilterJoinFilterIdFkeyFilterCreateInput;
  TemplateFilterJoinFilterIdFkeyInput: TemplateFilterJoinFilterIdFkeyInput;
  TemplateFilterJoinFilterIdFkeyInverseInput: TemplateFilterJoinFilterIdFkeyInverseInput;
  TemplateFilterJoinFilterIdFkeyTemplateFilterJoinCreateInput: TemplateFilterJoinFilterIdFkeyTemplateFilterJoinCreateInput;
  TemplateFilterJoinInput: TemplateFilterJoinInput;
  TemplateFilterJoinNodeIdConnect: TemplateFilterJoinNodeIdConnect;
  TemplateFilterJoinNodeIdDelete: TemplateFilterJoinNodeIdDelete;
  TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate: TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate;
  TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingTemplateFilterJoinPkeyUpdate: TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingTemplateFilterJoinPkeyUpdate;
  TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate: TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate;
  TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateFilterJoinPkeyUpdate: TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateFilterJoinPkeyUpdate;
  TemplateFilterJoinPatch: TemplateFilterJoinPatch;
  TemplateFilterJoinTemplateFilterJoinPkeyConnect: TemplateFilterJoinTemplateFilterJoinPkeyConnect;
  TemplateFilterJoinTemplateFilterJoinPkeyDelete: TemplateFilterJoinTemplateFilterJoinPkeyDelete;
  TemplateFilterJoinTemplateIdFkeyInput: TemplateFilterJoinTemplateIdFkeyInput;
  TemplateFilterJoinTemplateIdFkeyInverseInput: TemplateFilterJoinTemplateIdFkeyInverseInput;
  TemplateFilterJoinTemplateIdFkeyTemplateCreateInput: TemplateFilterJoinTemplateIdFkeyTemplateCreateInput;
  TemplateFilterJoinTemplateIdFkeyTemplateFilterJoinCreateInput: TemplateFilterJoinTemplateIdFkeyTemplateFilterJoinCreateInput;
  TemplateFilterJoinsConnection: ResolverTypeWrapper<TemplateFilterJoinsConnection>;
  TemplateFilterJoinsEdge: ResolverTypeWrapper<TemplateFilterJoinsEdge>;
  TemplateFilterJoinsOrderBy: TemplateFilterJoinsOrderBy;
  TemplateInput: TemplateInput;
  TemplateNodeIdConnect: TemplateNodeIdConnect;
  TemplateNodeIdDelete: TemplateNodeIdDelete;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate;
  TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnFileForFileTemplateIdFkeyNodeIdUpdate: TemplateOnFileForFileTemplateIdFkeyNodeIdUpdate;
  TemplateOnFileForFileTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnFileForFileTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnFileForFileTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnFileForFileTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate: TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate;
  TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate: TemplateOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate;
  TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate: TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate;
  TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplatePatch: TemplatePatch;
  TemplatePermission: ResolverTypeWrapper<TemplatePermission>;
  TemplatePermissionCondition: TemplatePermissionCondition;
  TemplatePermissionFilter: TemplatePermissionFilter;
  TemplatePermissionInput: TemplatePermissionInput;
  TemplatePermissionNodeIdConnect: TemplatePermissionNodeIdConnect;
  TemplatePermissionNodeIdDelete: TemplatePermissionNodeIdDelete;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate;
  TemplatePermissionPatch: TemplatePermissionPatch;
  TemplatePermissionPermissionNameIdFkeyInput: TemplatePermissionPermissionNameIdFkeyInput;
  TemplatePermissionPermissionNameIdFkeyInverseInput: TemplatePermissionPermissionNameIdFkeyInverseInput;
  TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput: TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput;
  TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput: TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput;
  TemplatePermissionTemplateIdFkeyInput: TemplatePermissionTemplateIdFkeyInput;
  TemplatePermissionTemplateIdFkeyInverseInput: TemplatePermissionTemplateIdFkeyInverseInput;
  TemplatePermissionTemplateIdFkeyTemplateCreateInput: TemplatePermissionTemplateIdFkeyTemplateCreateInput;
  TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput: TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput;
  TemplatePermissionTemplatePermissionPkeyConnect: TemplatePermissionTemplatePermissionPkeyConnect;
  TemplatePermissionTemplatePermissionPkeyDelete: TemplatePermissionTemplatePermissionPkeyDelete;
  TemplatePermissionsConnection: ResolverTypeWrapper<TemplatePermissionsConnection>;
  TemplatePermissionsEdge: ResolverTypeWrapper<TemplatePermissionsEdge>;
  TemplatePermissionsOrderBy: TemplatePermissionsOrderBy;
  TemplateSection: ResolverTypeWrapper<TemplateSection>;
  TemplateSectionCondition: TemplateSectionCondition;
  TemplateSectionFilter: TemplateSectionFilter;
  TemplateSectionInput: TemplateSectionInput;
  TemplateSectionNodeIdConnect: TemplateSectionNodeIdConnect;
  TemplateSectionNodeIdDelete: TemplateSectionNodeIdDelete;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate;
  TemplateSectionPatch: TemplateSectionPatch;
  TemplateSectionTemplateIdFkeyInput: TemplateSectionTemplateIdFkeyInput;
  TemplateSectionTemplateIdFkeyInverseInput: TemplateSectionTemplateIdFkeyInverseInput;
  TemplateSectionTemplateIdFkeyTemplateCreateInput: TemplateSectionTemplateIdFkeyTemplateCreateInput;
  TemplateSectionTemplateIdFkeyTemplateSectionCreateInput: TemplateSectionTemplateIdFkeyTemplateSectionCreateInput;
  TemplateSectionTemplateSectionPkeyConnect: TemplateSectionTemplateSectionPkeyConnect;
  TemplateSectionTemplateSectionPkeyDelete: TemplateSectionTemplateSectionPkeyDelete;
  TemplateSectionTemplateSectionTemplateIdCodeKeyConnect: TemplateSectionTemplateSectionTemplateIdCodeKeyConnect;
  TemplateSectionTemplateSectionTemplateIdCodeKeyDelete: TemplateSectionTemplateSectionTemplateIdCodeKeyDelete;
  TemplateSectionToManyTemplateElementFilter: TemplateSectionToManyTemplateElementFilter;
  TemplateSectionsConnection: ResolverTypeWrapper<TemplateSectionsConnection>;
  TemplateSectionsEdge: ResolverTypeWrapper<TemplateSectionsEdge>;
  TemplateSectionsOrderBy: TemplateSectionsOrderBy;
  TemplateStage: ResolverTypeWrapper<TemplateStage>;
  TemplateStageCondition: TemplateStageCondition;
  TemplateStageFilter: TemplateStageFilter;
  TemplateStageInput: TemplateStageInput;
  TemplateStageNodeIdConnect: TemplateStageNodeIdConnect;
  TemplateStageNodeIdDelete: TemplateStageNodeIdDelete;
  TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate: TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate;
  TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate;
  TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate: TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate;
  TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate;
  TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate: TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate;
  TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate;
  TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate: TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate;
  TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStagePkeyUpdate;
  TemplateStagePatch: TemplateStagePatch;
  TemplateStageReviewLevel: ResolverTypeWrapper<TemplateStageReviewLevel>;
  TemplateStageReviewLevelCondition: TemplateStageReviewLevelCondition;
  TemplateStageReviewLevelFilter: TemplateStageReviewLevelFilter;
  TemplateStageReviewLevelInput: TemplateStageReviewLevelInput;
  TemplateStageReviewLevelNodeIdConnect: TemplateStageReviewLevelNodeIdConnect;
  TemplateStageReviewLevelNodeIdDelete: TemplateStageReviewLevelNodeIdDelete;
  TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate: TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate;
  TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingTemplateStageReviewLevelPkeyUpdate: TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingTemplateStageReviewLevelPkeyUpdate;
  TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate: TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate;
  TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStageReviewLevelPkeyUpdate: TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStageReviewLevelPkeyUpdate;
  TemplateStageReviewLevelPatch: TemplateStageReviewLevelPatch;
  TemplateStageReviewLevelStageIdFkeyInput: TemplateStageReviewLevelStageIdFkeyInput;
  TemplateStageReviewLevelStageIdFkeyInverseInput: TemplateStageReviewLevelStageIdFkeyInverseInput;
  TemplateStageReviewLevelStageIdFkeyTemplateStageCreateInput: TemplateStageReviewLevelStageIdFkeyTemplateStageCreateInput;
  TemplateStageReviewLevelStageIdFkeyTemplateStageReviewLevelCreateInput: TemplateStageReviewLevelStageIdFkeyTemplateStageReviewLevelCreateInput;
  TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect: TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect;
  TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete: TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete;
  TemplateStageReviewLevelToManyReviewAssignmentFilter: TemplateStageReviewLevelToManyReviewAssignmentFilter;
  TemplateStageReviewLevelsConnection: ResolverTypeWrapper<TemplateStageReviewLevelsConnection>;
  TemplateStageReviewLevelsEdge: ResolverTypeWrapper<TemplateStageReviewLevelsEdge>;
  TemplateStageReviewLevelsOrderBy: TemplateStageReviewLevelsOrderBy;
  TemplateStageTemplateIdFkeyInput: TemplateStageTemplateIdFkeyInput;
  TemplateStageTemplateIdFkeyInverseInput: TemplateStageTemplateIdFkeyInverseInput;
  TemplateStageTemplateIdFkeyTemplateCreateInput: TemplateStageTemplateIdFkeyTemplateCreateInput;
  TemplateStageTemplateIdFkeyTemplateStageCreateInput: TemplateStageTemplateIdFkeyTemplateStageCreateInput;
  TemplateStageTemplateStagePkeyConnect: TemplateStageTemplateStagePkeyConnect;
  TemplateStageTemplateStagePkeyDelete: TemplateStageTemplateStagePkeyDelete;
  TemplateStageToManyApplicationStageHistoryFilter: TemplateStageToManyApplicationStageHistoryFilter;
  TemplateStageToManyReviewAssignmentFilter: TemplateStageToManyReviewAssignmentFilter;
  TemplateStageToManyTemplateStageReviewLevelFilter: TemplateStageToManyTemplateStageReviewLevelFilter;
  TemplateStagesConnection: ResolverTypeWrapper<TemplateStagesConnection>;
  TemplateStagesEdge: ResolverTypeWrapper<TemplateStagesEdge>;
  TemplateStagesOrderBy: TemplateStagesOrderBy;
  TemplateStatus: TemplateStatus;
  TemplateStatusFilter: TemplateStatusFilter;
  TemplateTemplateCategoryIdFkeyInput: TemplateTemplateCategoryIdFkeyInput;
  TemplateTemplateCategoryIdFkeyInverseInput: TemplateTemplateCategoryIdFkeyInverseInput;
  TemplateTemplateCategoryIdFkeyTemplateCategoryCreateInput: TemplateTemplateCategoryIdFkeyTemplateCategoryCreateInput;
  TemplateTemplateCategoryIdFkeyTemplateCreateInput: TemplateTemplateCategoryIdFkeyTemplateCreateInput;
  TemplateTemplateCodeVersionIdKeyConnect: TemplateTemplateCodeVersionIdKeyConnect;
  TemplateTemplateCodeVersionIdKeyDelete: TemplateTemplateCodeVersionIdKeyDelete;
  TemplateTemplatePkeyConnect: TemplateTemplatePkeyConnect;
  TemplateTemplatePkeyDelete: TemplateTemplatePkeyDelete;
  TemplateToManyActionQueueFilter: TemplateToManyActionQueueFilter;
  TemplateToManyApplicationFilter: TemplateToManyApplicationFilter;
  TemplateToManyFileFilter: TemplateToManyFileFilter;
  TemplateToManyReviewAssignmentFilter: TemplateToManyReviewAssignmentFilter;
  TemplateToManyTemplateActionFilter: TemplateToManyTemplateActionFilter;
  TemplateToManyTemplateFilterJoinFilter: TemplateToManyTemplateFilterJoinFilter;
  TemplateToManyTemplatePermissionFilter: TemplateToManyTemplatePermissionFilter;
  TemplateToManyTemplateSectionFilter: TemplateToManyTemplateSectionFilter;
  TemplateToManyTemplateStageFilter: TemplateToManyTemplateStageFilter;
  TemplateToManyTriggerScheduleFilter: TemplateToManyTriggerScheduleFilter;
  TemplatesConnection: ResolverTypeWrapper<TemplatesConnection>;
  TemplatesEdge: ResolverTypeWrapper<TemplatesEdge>;
  TemplatesOrderBy: TemplatesOrderBy;
  Trigger: Trigger;
  TriggerFilter: TriggerFilter;
  TriggerQueue: ResolverTypeWrapper<TriggerQueue>;
  TriggerQueueApplicationIdFkeyApplicationCreateInput: TriggerQueueApplicationIdFkeyApplicationCreateInput;
  TriggerQueueApplicationIdFkeyInput: TriggerQueueApplicationIdFkeyInput;
  TriggerQueueApplicationIdFkeyInverseInput: TriggerQueueApplicationIdFkeyInverseInput;
  TriggerQueueApplicationIdFkeyTriggerQueueCreateInput: TriggerQueueApplicationIdFkeyTriggerQueueCreateInput;
  TriggerQueueCondition: TriggerQueueCondition;
  TriggerQueueFilter: TriggerQueueFilter;
  TriggerQueueInput: TriggerQueueInput;
  TriggerQueueNodeIdConnect: TriggerQueueNodeIdConnect;
  TriggerQueueNodeIdDelete: TriggerQueueNodeIdDelete;
  TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate: TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate;
  TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate: TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate;
  TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate: TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate;
  TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingTriggerQueuePkeyUpdate: TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingTriggerQueuePkeyUpdate;
  TriggerQueuePatch: TriggerQueuePatch;
  TriggerQueueStatus: TriggerQueueStatus;
  TriggerQueueStatusFilter: TriggerQueueStatusFilter;
  TriggerQueueToManyActionQueueFilter: TriggerQueueToManyActionQueueFilter;
  TriggerQueueTriggerQueuePkeyConnect: TriggerQueueTriggerQueuePkeyConnect;
  TriggerQueueTriggerQueuePkeyDelete: TriggerQueueTriggerQueuePkeyDelete;
  TriggerQueuesConnection: ResolverTypeWrapper<TriggerQueuesConnection>;
  TriggerQueuesEdge: ResolverTypeWrapper<TriggerQueuesEdge>;
  TriggerQueuesOrderBy: TriggerQueuesOrderBy;
  TriggerSchedule: ResolverTypeWrapper<TriggerSchedule>;
  TriggerScheduleApplicationIdFkeyApplicationCreateInput: TriggerScheduleApplicationIdFkeyApplicationCreateInput;
  TriggerScheduleApplicationIdFkeyInput: TriggerScheduleApplicationIdFkeyInput;
  TriggerScheduleApplicationIdFkeyInverseInput: TriggerScheduleApplicationIdFkeyInverseInput;
  TriggerScheduleApplicationIdFkeyTriggerScheduleCreateInput: TriggerScheduleApplicationIdFkeyTriggerScheduleCreateInput;
  TriggerScheduleCondition: TriggerScheduleCondition;
  TriggerScheduleFilter: TriggerScheduleFilter;
  TriggerScheduleInput: TriggerScheduleInput;
  TriggerScheduleNodeIdConnect: TriggerScheduleNodeIdConnect;
  TriggerScheduleNodeIdDelete: TriggerScheduleNodeIdDelete;
  TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate: TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate;
  TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingTriggerSchedulePkeyUpdate: TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingTriggerSchedulePkeyUpdate;
  TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate: TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate;
  TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTriggerSchedulePkeyUpdate: TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTriggerSchedulePkeyUpdate;
  TriggerSchedulePatch: TriggerSchedulePatch;
  TriggerScheduleTemplateIdFkeyInput: TriggerScheduleTemplateIdFkeyInput;
  TriggerScheduleTemplateIdFkeyInverseInput: TriggerScheduleTemplateIdFkeyInverseInput;
  TriggerScheduleTemplateIdFkeyTemplateCreateInput: TriggerScheduleTemplateIdFkeyTemplateCreateInput;
  TriggerScheduleTemplateIdFkeyTriggerScheduleCreateInput: TriggerScheduleTemplateIdFkeyTriggerScheduleCreateInput;
  TriggerScheduleTriggerSchedulePkeyConnect: TriggerScheduleTriggerSchedulePkeyConnect;
  TriggerScheduleTriggerSchedulePkeyDelete: TriggerScheduleTriggerSchedulePkeyDelete;
  TriggerSchedulesConnection: ResolverTypeWrapper<TriggerSchedulesConnection>;
  TriggerSchedulesEdge: ResolverTypeWrapper<TriggerSchedulesEdge>;
  TriggerSchedulesOrderBy: TriggerSchedulesOrderBy;
  UiLocation: UiLocation;
  UiLocationListFilter: UiLocationListFilter;
  UnnestedSection: ResolverTypeWrapper<UnnestedSection>;
  UnnestedSectionCondition: UnnestedSectionCondition;
  UnnestedSectionFilter: UnnestedSectionFilter;
  UnnestedSectionsConnection: ResolverTypeWrapper<UnnestedSectionsConnection>;
  UnnestedSectionsEdge: ResolverTypeWrapper<UnnestedSectionsEdge>;
  UnnestedSectionsOrderBy: UnnestedSectionsOrderBy;
  UpdateActionPluginByCodeInput: UpdateActionPluginByCodeInput;
  UpdateActionPluginByNodeIdInput: UpdateActionPluginByNodeIdInput;
  UpdateActionPluginInput: UpdateActionPluginInput;
  UpdateActionPluginPayload: ResolverTypeWrapper<Omit<UpdateActionPluginPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateActionQueueByNodeIdInput: UpdateActionQueueByNodeIdInput;
  UpdateActionQueueInput: UpdateActionQueueInput;
  UpdateActionQueuePayload: ResolverTypeWrapper<Omit<UpdateActionQueuePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateActivityLogByNodeIdInput: UpdateActivityLogByNodeIdInput;
  UpdateActivityLogInput: UpdateActivityLogInput;
  UpdateActivityLogPayload: ResolverTypeWrapper<Omit<UpdateActivityLogPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateApplicationByNodeIdInput: UpdateApplicationByNodeIdInput;
  UpdateApplicationByOutcomeRegistrationInput: UpdateApplicationByOutcomeRegistrationInput;
  UpdateApplicationBySerialInput: UpdateApplicationBySerialInput;
  UpdateApplicationInput: UpdateApplicationInput;
  UpdateApplicationNoteByNodeIdInput: UpdateApplicationNoteByNodeIdInput;
  UpdateApplicationNoteInput: UpdateApplicationNoteInput;
  UpdateApplicationNotePayload: ResolverTypeWrapper<Omit<UpdateApplicationNotePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateApplicationPayload: ResolverTypeWrapper<Omit<UpdateApplicationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateApplicationResponseByNodeIdInput: UpdateApplicationResponseByNodeIdInput;
  UpdateApplicationResponseInput: UpdateApplicationResponseInput;
  UpdateApplicationResponsePayload: ResolverTypeWrapper<Omit<UpdateApplicationResponsePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateApplicationReviewerActionByNodeIdInput: UpdateApplicationReviewerActionByNodeIdInput;
  UpdateApplicationReviewerActionByUserIdAndApplicationIdInput: UpdateApplicationReviewerActionByUserIdAndApplicationIdInput;
  UpdateApplicationReviewerActionInput: UpdateApplicationReviewerActionInput;
  UpdateApplicationReviewerActionPayload: ResolverTypeWrapper<Omit<UpdateApplicationReviewerActionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateApplicationStageHistoryByNodeIdInput: UpdateApplicationStageHistoryByNodeIdInput;
  UpdateApplicationStageHistoryInput: UpdateApplicationStageHistoryInput;
  UpdateApplicationStageHistoryPayload: ResolverTypeWrapper<Omit<UpdateApplicationStageHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateApplicationStatusHistoryByNodeIdInput: UpdateApplicationStatusHistoryByNodeIdInput;
  UpdateApplicationStatusHistoryInput: UpdateApplicationStatusHistoryInput;
  UpdateApplicationStatusHistoryPayload: ResolverTypeWrapper<Omit<UpdateApplicationStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateCounterByNameInput: UpdateCounterByNameInput;
  UpdateCounterByNodeIdInput: UpdateCounterByNodeIdInput;
  UpdateCounterInput: UpdateCounterInput;
  UpdateCounterPayload: ResolverTypeWrapper<Omit<UpdateCounterPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataChangelogByNodeIdInput: UpdateDataChangelogByNodeIdInput;
  UpdateDataChangelogInput: UpdateDataChangelogInput;
  UpdateDataChangelogPayload: ResolverTypeWrapper<Omit<UpdateDataChangelogPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableActiveIngredientByNodeIdInput: UpdateDataTableActiveIngredientByNodeIdInput;
  UpdateDataTableActiveIngredientInput: UpdateDataTableActiveIngredientInput;
  UpdateDataTableActiveIngredientPayload: ResolverTypeWrapper<Omit<UpdateDataTableActiveIngredientPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableAdministrationRouteByNodeIdInput: UpdateDataTableAdministrationRouteByNodeIdInput;
  UpdateDataTableAdministrationRouteInput: UpdateDataTableAdministrationRouteInput;
  UpdateDataTableAdministrationRoutePayload: ResolverTypeWrapper<Omit<UpdateDataTableAdministrationRoutePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableAtcCodeByNodeIdInput: UpdateDataTableAtcCodeByNodeIdInput;
  UpdateDataTableAtcCodeInput: UpdateDataTableAtcCodeInput;
  UpdateDataTableAtcCodePayload: ResolverTypeWrapper<Omit<UpdateDataTableAtcCodePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableByNodeIdInput: UpdateDataTableByNodeIdInput;
  UpdateDataTableByTableNameInput: UpdateDataTableByTableNameInput;
  UpdateDataTableContainerByNodeIdInput: UpdateDataTableContainerByNodeIdInput;
  UpdateDataTableContainerInput: UpdateDataTableContainerInput;
  UpdateDataTableContainerPayload: ResolverTypeWrapper<Omit<UpdateDataTableContainerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableCountryByNodeIdInput: UpdateDataTableCountryByNodeIdInput;
  UpdateDataTableCountryInput: UpdateDataTableCountryInput;
  UpdateDataTableCountryPayload: ResolverTypeWrapper<Omit<UpdateDataTableCountryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableDosageFormByNodeIdInput: UpdateDataTableDosageFormByNodeIdInput;
  UpdateDataTableDosageFormGroupByNodeIdInput: UpdateDataTableDosageFormGroupByNodeIdInput;
  UpdateDataTableDosageFormGroupInput: UpdateDataTableDosageFormGroupInput;
  UpdateDataTableDosageFormGroupPayload: ResolverTypeWrapper<Omit<UpdateDataTableDosageFormGroupPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableDosageFormInput: UpdateDataTableDosageFormInput;
  UpdateDataTableDosageFormPayload: ResolverTypeWrapper<Omit<UpdateDataTableDosageFormPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableGenericIngredientByNodeIdInput: UpdateDataTableGenericIngredientByNodeIdInput;
  UpdateDataTableGenericIngredientInput: UpdateDataTableGenericIngredientInput;
  UpdateDataTableGenericIngredientPayload: ResolverTypeWrapper<Omit<UpdateDataTableGenericIngredientPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableInput: UpdateDataTableInput;
  UpdateDataTableManufacturerApplicationJoinByNodeIdInput: UpdateDataTableManufacturerApplicationJoinByNodeIdInput;
  UpdateDataTableManufacturerApplicationJoinInput: UpdateDataTableManufacturerApplicationJoinInput;
  UpdateDataTableManufacturerApplicationJoinPayload: ResolverTypeWrapper<Omit<UpdateDataTableManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableManufacturerByNodeIdInput: UpdateDataTableManufacturerByNodeIdInput;
  UpdateDataTableManufacturerInput: UpdateDataTableManufacturerInput;
  UpdateDataTableManufacturerPayload: ResolverTypeWrapper<Omit<UpdateDataTableManufacturerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput: UpdateDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput;
  UpdateDataTableManufacturerRepresentativeApplicationJoinInput: UpdateDataTableManufacturerRepresentativeApplicationJoinInput;
  UpdateDataTableManufacturerRepresentativeApplicationJoinPayload: ResolverTypeWrapper<Omit<UpdateDataTableManufacturerRepresentativeApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableManufacturerRepresentativeByNodeIdInput: UpdateDataTableManufacturerRepresentativeByNodeIdInput;
  UpdateDataTableManufacturerRepresentativeInput: UpdateDataTableManufacturerRepresentativeInput;
  UpdateDataTableManufacturerRepresentativePayload: ResolverTypeWrapper<Omit<UpdateDataTableManufacturerRepresentativePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTablePayload: ResolverTypeWrapper<Omit<UpdateDataTablePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTablePermitChemicalApplicationJoinByNodeIdInput: UpdateDataTablePermitChemicalApplicationJoinByNodeIdInput;
  UpdateDataTablePermitChemicalApplicationJoinInput: UpdateDataTablePermitChemicalApplicationJoinInput;
  UpdateDataTablePermitChemicalApplicationJoinPayload: ResolverTypeWrapper<Omit<UpdateDataTablePermitChemicalApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTablePermitChemicalByNodeIdInput: UpdateDataTablePermitChemicalByNodeIdInput;
  UpdateDataTablePermitChemicalInput: UpdateDataTablePermitChemicalInput;
  UpdateDataTablePermitChemicalPayload: ResolverTypeWrapper<Omit<UpdateDataTablePermitChemicalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTablePreRegisteredProductsProvisionalByNodeIdInput: UpdateDataTablePreRegisteredProductsProvisionalByNodeIdInput;
  UpdateDataTablePreRegisteredProductsProvisionalInput: UpdateDataTablePreRegisteredProductsProvisionalInput;
  UpdateDataTablePreRegisteredProductsProvisionalPayload: ResolverTypeWrapper<Omit<UpdateDataTablePreRegisteredProductsProvisionalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTablePrequalManufacturerApplicationJoinByNodeIdInput: UpdateDataTablePrequalManufacturerApplicationJoinByNodeIdInput;
  UpdateDataTablePrequalManufacturerApplicationJoinInput: UpdateDataTablePrequalManufacturerApplicationJoinInput;
  UpdateDataTablePrequalManufacturerApplicationJoinPayload: ResolverTypeWrapper<Omit<UpdateDataTablePrequalManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTablePrequalManufacturerByNodeIdInput: UpdateDataTablePrequalManufacturerByNodeIdInput;
  UpdateDataTablePrequalManufacturerInput: UpdateDataTablePrequalManufacturerInput;
  UpdateDataTablePrequalManufacturerPayload: ResolverTypeWrapper<Omit<UpdateDataTablePrequalManufacturerPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableProcessingStepByNodeIdInput: UpdateDataTableProcessingStepByNodeIdInput;
  UpdateDataTableProcessingStepInput: UpdateDataTableProcessingStepInput;
  UpdateDataTableProcessingStepPayload: ResolverTypeWrapper<Omit<UpdateDataTableProcessingStepPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableProductApplicationJoinByNodeIdInput: UpdateDataTableProductApplicationJoinByNodeIdInput;
  UpdateDataTableProductApplicationJoinInput: UpdateDataTableProductApplicationJoinInput;
  UpdateDataTableProductApplicationJoinPayload: ResolverTypeWrapper<Omit<UpdateDataTableProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableProductByNodeIdInput: UpdateDataTableProductByNodeIdInput;
  UpdateDataTableProductInput: UpdateDataTableProductInput;
  UpdateDataTableProductPayload: ResolverTypeWrapper<Omit<UpdateDataTableProductPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableProvisionalProductApplicationJoinByNodeIdInput: UpdateDataTableProvisionalProductApplicationJoinByNodeIdInput;
  UpdateDataTableProvisionalProductApplicationJoinInput: UpdateDataTableProvisionalProductApplicationJoinInput;
  UpdateDataTableProvisionalProductApplicationJoinPayload: ResolverTypeWrapper<Omit<UpdateDataTableProvisionalProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableProvisionalProductByNodeIdInput: UpdateDataTableProvisionalProductByNodeIdInput;
  UpdateDataTableProvisionalProductInput: UpdateDataTableProvisionalProductInput;
  UpdateDataTableProvisionalProductPayload: ResolverTypeWrapper<Omit<UpdateDataTableProvisionalProductPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableScheduledChemicalByNodeIdInput: UpdateDataTableScheduledChemicalByNodeIdInput;
  UpdateDataTableScheduledChemicalInput: UpdateDataTableScheduledChemicalInput;
  UpdateDataTableScheduledChemicalPayload: ResolverTypeWrapper<Omit<UpdateDataTableScheduledChemicalPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableStorageConditionByNodeIdInput: UpdateDataTableStorageConditionByNodeIdInput;
  UpdateDataTableStorageConditionInput: UpdateDataTableStorageConditionInput;
  UpdateDataTableStorageConditionPayload: ResolverTypeWrapper<Omit<UpdateDataTableStorageConditionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableStorageConditionsSimplifiedByNodeIdInput: UpdateDataTableStorageConditionsSimplifiedByNodeIdInput;
  UpdateDataTableStorageConditionsSimplifiedInput: UpdateDataTableStorageConditionsSimplifiedInput;
  UpdateDataTableStorageConditionsSimplifiedPayload: ResolverTypeWrapper<Omit<UpdateDataTableStorageConditionsSimplifiedPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableUnitsOfProportionByNodeIdInput: UpdateDataTableUnitsOfProportionByNodeIdInput;
  UpdateDataTableUnitsOfProportionInput: UpdateDataTableUnitsOfProportionInput;
  UpdateDataTableUnitsOfProportionPayload: ResolverTypeWrapper<Omit<UpdateDataTableUnitsOfProportionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput: UpdateDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput;
  UpdateDataTableWorldHealthOrganisationPqListOfFppInput: UpdateDataTableWorldHealthOrganisationPqListOfFppInput;
  UpdateDataTableWorldHealthOrganisationPqListOfFppPayload: ResolverTypeWrapper<Omit<UpdateDataTableWorldHealthOrganisationPqListOfFppPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataViewByIdentifierInput: UpdateDataViewByIdentifierInput;
  UpdateDataViewByNodeIdInput: UpdateDataViewByNodeIdInput;
  UpdateDataViewColumnDefinitionByNodeIdInput: UpdateDataViewColumnDefinitionByNodeIdInput;
  UpdateDataViewColumnDefinitionByTableNameAndColumnNameInput: UpdateDataViewColumnDefinitionByTableNameAndColumnNameInput;
  UpdateDataViewColumnDefinitionInput: UpdateDataViewColumnDefinitionInput;
  UpdateDataViewColumnDefinitionPayload: ResolverTypeWrapper<Omit<UpdateDataViewColumnDefinitionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateDataViewInput: UpdateDataViewInput;
  UpdateDataViewPayload: ResolverTypeWrapper<Omit<UpdateDataViewPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateElementTypePluginByNodeIdInput: UpdateElementTypePluginByNodeIdInput;
  UpdateElementTypePluginInput: UpdateElementTypePluginInput;
  UpdateElementTypePluginPayload: ResolverTypeWrapper<Omit<UpdateElementTypePluginPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateFileByNodeIdInput: UpdateFileByNodeIdInput;
  UpdateFileByUniqueIdInput: UpdateFileByUniqueIdInput;
  UpdateFileInput: UpdateFileInput;
  UpdateFilePayload: ResolverTypeWrapper<Omit<UpdateFilePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateFilterByCodeInput: UpdateFilterByCodeInput;
  UpdateFilterByNodeIdInput: UpdateFilterByNodeIdInput;
  UpdateFilterInput: UpdateFilterInput;
  UpdateFilterPayload: ResolverTypeWrapper<Omit<UpdateFilterPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateGrafanaDashboardImageByNodeIdInput: UpdateGrafanaDashboardImageByNodeIdInput;
  UpdateGrafanaDashboardImageInput: UpdateGrafanaDashboardImageInput;
  UpdateGrafanaDashboardImagePayload: ResolverTypeWrapper<Omit<UpdateGrafanaDashboardImagePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateNotificationByNodeIdInput: UpdateNotificationByNodeIdInput;
  UpdateNotificationInput: UpdateNotificationInput;
  UpdateNotificationPayload: ResolverTypeWrapper<Omit<UpdateNotificationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateOrganisationApplicationJoinByNodeIdInput: UpdateOrganisationApplicationJoinByNodeIdInput;
  UpdateOrganisationApplicationJoinInput: UpdateOrganisationApplicationJoinInput;
  UpdateOrganisationApplicationJoinPayload: ResolverTypeWrapper<Omit<UpdateOrganisationApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateOrganisationByNameInput: UpdateOrganisationByNameInput;
  UpdateOrganisationByNodeIdInput: UpdateOrganisationByNodeIdInput;
  UpdateOrganisationByRegistrationInput: UpdateOrganisationByRegistrationInput;
  UpdateOrganisationInput: UpdateOrganisationInput;
  UpdateOrganisationPayload: ResolverTypeWrapper<Omit<UpdateOrganisationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdatePermissionJoinByNodeIdInput: UpdatePermissionJoinByNodeIdInput;
  UpdatePermissionJoinInput: UpdatePermissionJoinInput;
  UpdatePermissionJoinPayload: ResolverTypeWrapper<Omit<UpdatePermissionJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdatePermissionNameByNameInput: UpdatePermissionNameByNameInput;
  UpdatePermissionNameByNodeIdInput: UpdatePermissionNameByNodeIdInput;
  UpdatePermissionNameInput: UpdatePermissionNameInput;
  UpdatePermissionNamePayload: ResolverTypeWrapper<Omit<UpdatePermissionNamePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdatePermissionPolicyByNameInput: UpdatePermissionPolicyByNameInput;
  UpdatePermissionPolicyByNodeIdInput: UpdatePermissionPolicyByNodeIdInput;
  UpdatePermissionPolicyInput: UpdatePermissionPolicyInput;
  UpdatePermissionPolicyPayload: ResolverTypeWrapper<Omit<UpdatePermissionPolicyPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateReviewAssignmentAssignerJoinByNodeIdInput: UpdateReviewAssignmentAssignerJoinByNodeIdInput;
  UpdateReviewAssignmentAssignerJoinInput: UpdateReviewAssignmentAssignerJoinInput;
  UpdateReviewAssignmentAssignerJoinPayload: ResolverTypeWrapper<Omit<UpdateReviewAssignmentAssignerJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateReviewAssignmentByNodeIdInput: UpdateReviewAssignmentByNodeIdInput;
  UpdateReviewAssignmentInput: UpdateReviewAssignmentInput;
  UpdateReviewAssignmentPayload: ResolverTypeWrapper<Omit<UpdateReviewAssignmentPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateReviewByNodeIdInput: UpdateReviewByNodeIdInput;
  UpdateReviewByReviewAssignmentIdInput: UpdateReviewByReviewAssignmentIdInput;
  UpdateReviewDecisionByNodeIdInput: UpdateReviewDecisionByNodeIdInput;
  UpdateReviewDecisionInput: UpdateReviewDecisionInput;
  UpdateReviewDecisionPayload: ResolverTypeWrapper<Omit<UpdateReviewDecisionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateReviewInput: UpdateReviewInput;
  UpdateReviewPayload: ResolverTypeWrapper<Omit<UpdateReviewPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateReviewResponseByNodeIdInput: UpdateReviewResponseByNodeIdInput;
  UpdateReviewResponseInput: UpdateReviewResponseInput;
  UpdateReviewResponsePayload: ResolverTypeWrapper<Omit<UpdateReviewResponsePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateReviewStatusHistoryByNodeIdInput: UpdateReviewStatusHistoryByNodeIdInput;
  UpdateReviewStatusHistoryInput: UpdateReviewStatusHistoryInput;
  UpdateReviewStatusHistoryPayload: ResolverTypeWrapper<Omit<UpdateReviewStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateSystemInfoByNodeIdInput: UpdateSystemInfoByNodeIdInput;
  UpdateSystemInfoInput: UpdateSystemInfoInput;
  UpdateSystemInfoPayload: ResolverTypeWrapper<Omit<UpdateSystemInfoPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplateActionByNodeIdInput: UpdateTemplateActionByNodeIdInput;
  UpdateTemplateActionInput: UpdateTemplateActionInput;
  UpdateTemplateActionPayload: ResolverTypeWrapper<Omit<UpdateTemplateActionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplateByCodeAndVersionIdInput: UpdateTemplateByCodeAndVersionIdInput;
  UpdateTemplateByNodeIdInput: UpdateTemplateByNodeIdInput;
  UpdateTemplateCategoryByCodeInput: UpdateTemplateCategoryByCodeInput;
  UpdateTemplateCategoryByNodeIdInput: UpdateTemplateCategoryByNodeIdInput;
  UpdateTemplateCategoryInput: UpdateTemplateCategoryInput;
  UpdateTemplateCategoryPayload: ResolverTypeWrapper<Omit<UpdateTemplateCategoryPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplateElementByNodeIdInput: UpdateTemplateElementByNodeIdInput;
  UpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput: UpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput;
  UpdateTemplateElementInput: UpdateTemplateElementInput;
  UpdateTemplateElementPayload: ResolverTypeWrapper<Omit<UpdateTemplateElementPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplateFilterJoinByNodeIdInput: UpdateTemplateFilterJoinByNodeIdInput;
  UpdateTemplateFilterJoinInput: UpdateTemplateFilterJoinInput;
  UpdateTemplateFilterJoinPayload: ResolverTypeWrapper<Omit<UpdateTemplateFilterJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplateInput: UpdateTemplateInput;
  UpdateTemplatePayload: ResolverTypeWrapper<Omit<UpdateTemplatePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplatePermissionByNodeIdInput: UpdateTemplatePermissionByNodeIdInput;
  UpdateTemplatePermissionInput: UpdateTemplatePermissionInput;
  UpdateTemplatePermissionPayload: ResolverTypeWrapper<Omit<UpdateTemplatePermissionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplateSectionByNodeIdInput: UpdateTemplateSectionByNodeIdInput;
  UpdateTemplateSectionByTemplateIdAndCodeInput: UpdateTemplateSectionByTemplateIdAndCodeInput;
  UpdateTemplateSectionInput: UpdateTemplateSectionInput;
  UpdateTemplateSectionPayload: ResolverTypeWrapper<Omit<UpdateTemplateSectionPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplateStageByNodeIdInput: UpdateTemplateStageByNodeIdInput;
  UpdateTemplateStageInput: UpdateTemplateStageInput;
  UpdateTemplateStagePayload: ResolverTypeWrapper<Omit<UpdateTemplateStagePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTemplateStageReviewLevelByNodeIdInput: UpdateTemplateStageReviewLevelByNodeIdInput;
  UpdateTemplateStageReviewLevelInput: UpdateTemplateStageReviewLevelInput;
  UpdateTemplateStageReviewLevelPayload: ResolverTypeWrapper<Omit<UpdateTemplateStageReviewLevelPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTriggerQueueByNodeIdInput: UpdateTriggerQueueByNodeIdInput;
  UpdateTriggerQueueInput: UpdateTriggerQueueInput;
  UpdateTriggerQueuePayload: ResolverTypeWrapper<Omit<UpdateTriggerQueuePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateTriggerScheduleByNodeIdInput: UpdateTriggerScheduleByNodeIdInput;
  UpdateTriggerScheduleInput: UpdateTriggerScheduleInput;
  UpdateTriggerSchedulePayload: ResolverTypeWrapper<Omit<UpdateTriggerSchedulePayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateUserApplicationJoinByNodeIdInput: UpdateUserApplicationJoinByNodeIdInput;
  UpdateUserApplicationJoinInput: UpdateUserApplicationJoinInput;
  UpdateUserApplicationJoinPayload: ResolverTypeWrapper<Omit<UpdateUserApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateUserOrganisationByNodeIdInput: UpdateUserOrganisationByNodeIdInput;
  UpdateUserOrganisationInput: UpdateUserOrganisationInput;
  UpdateUserOrganisationPayload: ResolverTypeWrapper<Omit<UpdateUserOrganisationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  UpdateVerificationByNodeIdInput: UpdateVerificationByNodeIdInput;
  UpdateVerificationByUniqueIdInput: UpdateVerificationByUniqueIdInput;
  UpdateVerificationInput: UpdateVerificationInput;
  UpdateVerificationPayload: ResolverTypeWrapper<Omit<UpdateVerificationPayload, 'query'> & { query?: Maybe<ResolversTypes['Query']> }>;
  User: ResolverTypeWrapper<User>;
  UserApplicationJoin: ResolverTypeWrapper<UserApplicationJoin>;
  UserApplicationJoinApplicationIdFkeyApplicationCreateInput: UserApplicationJoinApplicationIdFkeyApplicationCreateInput;
  UserApplicationJoinApplicationIdFkeyInput: UserApplicationJoinApplicationIdFkeyInput;
  UserApplicationJoinApplicationIdFkeyInverseInput: UserApplicationJoinApplicationIdFkeyInverseInput;
  UserApplicationJoinApplicationIdFkeyUserApplicationJoinCreateInput: UserApplicationJoinApplicationIdFkeyUserApplicationJoinCreateInput;
  UserApplicationJoinCondition: UserApplicationJoinCondition;
  UserApplicationJoinFilter: UserApplicationJoinFilter;
  UserApplicationJoinInput: UserApplicationJoinInput;
  UserApplicationJoinNodeIdConnect: UserApplicationJoinNodeIdConnect;
  UserApplicationJoinNodeIdDelete: UserApplicationJoinNodeIdDelete;
  UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate: UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate;
  UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingUserApplicationJoinPkeyUpdate: UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingUserApplicationJoinPkeyUpdate;
  UserApplicationJoinPatch: UserApplicationJoinPatch;
  UserApplicationJoinUserApplicationJoinPkeyConnect: UserApplicationJoinUserApplicationJoinPkeyConnect;
  UserApplicationJoinUserApplicationJoinPkeyDelete: UserApplicationJoinUserApplicationJoinPkeyDelete;
  UserApplicationJoinsConnection: ResolverTypeWrapper<UserApplicationJoinsConnection>;
  UserApplicationJoinsEdge: ResolverTypeWrapper<UserApplicationJoinsEdge>;
  UserApplicationJoinsOrderBy: UserApplicationJoinsOrderBy;
  UserCondition: UserCondition;
  UserFilter: UserFilter;
  UserInput: UserInput;
  UserList: ResolverTypeWrapper<UserList>;
  UserListCondition: UserListCondition;
  UserListFilter: UserListFilter;
  UserListInput: UserListInput;
  UserListOnApplicationForFakePublicApplicationForeignKey0NodeIdUpdate: UserListOnApplicationForFakePublicApplicationForeignKey0NodeIdUpdate;
  UserListOnApplicationNoteForFakePublicApplicationNoteForeignKey0NodeIdUpdate: UserListOnApplicationNoteForFakePublicApplicationNoteForeignKey0NodeIdUpdate;
  UserListOnPermissionJoinForFakePublicPermissionJoinForeignKey0NodeIdUpdate: UserListOnPermissionJoinForFakePublicPermissionJoinForeignKey0NodeIdUpdate;
  UserListOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0NodeIdUpdate: UserListOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0NodeIdUpdate;
  UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0NodeIdUpdate: UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0NodeIdUpdate;
  UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1NodeIdUpdate: UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1NodeIdUpdate;
  UserListOnReviewForFakePublicReviewForeignKey0NodeIdUpdate: UserListOnReviewForFakePublicReviewForeignKey0NodeIdUpdate;
  UserListToManyApplicationFilter: UserListToManyApplicationFilter;
  UserListToManyApplicationNoteFilter: UserListToManyApplicationNoteFilter;
  UserListToManyPermissionJoinFilter: UserListToManyPermissionJoinFilter;
  UserListToManyReviewAssignmentAssignerJoinFilter: UserListToManyReviewAssignmentAssignerJoinFilter;
  UserListToManyReviewAssignmentFilter: UserListToManyReviewAssignmentFilter;
  UserListToManyReviewFilter: UserListToManyReviewFilter;
  UserListsConnection: ResolverTypeWrapper<UserListsConnection>;
  UserListsEdge: ResolverTypeWrapper<UserListsEdge>;
  UserListsOrderBy: UserListsOrderBy;
  UserOnUserOrganisationForFakePublicUserOrganisationForeignKey0NodeIdUpdate: UserOnUserOrganisationForFakePublicUserOrganisationForeignKey0NodeIdUpdate;
  UserOrgJoin: ResolverTypeWrapper<UserOrgJoin>;
  UserOrgJoinCondition: UserOrgJoinCondition;
  UserOrgJoinFilter: UserOrgJoinFilter;
  UserOrgJoinsConnection: ResolverTypeWrapper<UserOrgJoinsConnection>;
  UserOrgJoinsEdge: ResolverTypeWrapper<UserOrgJoinsEdge>;
  UserOrgJoinsOrderBy: UserOrgJoinsOrderBy;
  UserOrganisation: ResolverTypeWrapper<UserOrganisation>;
  UserOrganisationCondition: UserOrganisationCondition;
  UserOrganisationFilter: UserOrganisationFilter;
  UserOrganisationInput: UserOrganisationInput;
  UserOrganisationNodeIdConnect: UserOrganisationNodeIdConnect;
  UserOrganisationNodeIdDelete: UserOrganisationNodeIdDelete;
  UserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0UsingUserOrganisationPkeyUpdate: UserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0UsingUserOrganisationPkeyUpdate;
  UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate: UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate;
  UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate: UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate;
  UserOrganisationOrganisationIdFkeyInput: UserOrganisationOrganisationIdFkeyInput;
  UserOrganisationOrganisationIdFkeyInverseInput: UserOrganisationOrganisationIdFkeyInverseInput;
  UserOrganisationOrganisationIdFkeyOrganisationCreateInput: UserOrganisationOrganisationIdFkeyOrganisationCreateInput;
  UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput: UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput;
  UserOrganisationPatch: UserOrganisationPatch;
  UserOrganisationUserOrganisationPkeyConnect: UserOrganisationUserOrganisationPkeyConnect;
  UserOrganisationUserOrganisationPkeyDelete: UserOrganisationUserOrganisationPkeyDelete;
  UserOrganisationsConnection: ResolverTypeWrapper<UserOrganisationsConnection>;
  UserOrganisationsEdge: ResolverTypeWrapper<UserOrganisationsEdge>;
  UserOrganisationsOrderBy: UserOrganisationsOrderBy;
  UserToManyUserOrganisationFilter: UserToManyUserOrganisationFilter;
  UsersConnection: ResolverTypeWrapper<UsersConnection>;
  UsersEdge: ResolverTypeWrapper<UsersEdge>;
  UsersOrderBy: UsersOrderBy;
  Verification: ResolverTypeWrapper<Verification>;
  VerificationApplicationIdFkeyApplicationCreateInput: VerificationApplicationIdFkeyApplicationCreateInput;
  VerificationApplicationIdFkeyInput: VerificationApplicationIdFkeyInput;
  VerificationApplicationIdFkeyInverseInput: VerificationApplicationIdFkeyInverseInput;
  VerificationApplicationIdFkeyVerificationCreateInput: VerificationApplicationIdFkeyVerificationCreateInput;
  VerificationCondition: VerificationCondition;
  VerificationFilter: VerificationFilter;
  VerificationInput: VerificationInput;
  VerificationNodeIdConnect: VerificationNodeIdConnect;
  VerificationNodeIdDelete: VerificationNodeIdDelete;
  VerificationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate: VerificationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate;
  VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationPkeyUpdate: VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationPkeyUpdate;
  VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationUniqueIdKeyUpdate: VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationUniqueIdKeyUpdate;
  VerificationPatch: VerificationPatch;
  VerificationVerificationPkeyConnect: VerificationVerificationPkeyConnect;
  VerificationVerificationPkeyDelete: VerificationVerificationPkeyDelete;
  VerificationVerificationUniqueIdKeyConnect: VerificationVerificationUniqueIdKeyConnect;
  VerificationVerificationUniqueIdKeyDelete: VerificationVerificationUniqueIdKeyDelete;
  VerificationsConnection: ResolverTypeWrapper<VerificationsConnection>;
  VerificationsEdge: ResolverTypeWrapper<VerificationsEdge>;
  VerificationsOrderBy: VerificationsOrderBy;
  YesOrNo: ResolverTypeWrapper<Scalars['YesOrNo']['output']>;
  YesOrNoFilter: YesOrNoFilter;
  updateActionQueueOnActionQueueForActionQueueApplicationIdFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueApplicationIdFkeyPatch;
  updateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch;
  updateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  updateActivityLogOnActivityLogForActivityLogApplicationIdFkeyPatch: UpdateActivityLogOnActivityLogForActivityLogApplicationIdFkeyPatch;
  updateApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
  updateApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyPatch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
  updateApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0Patch: UpdateApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0Patch;
  updateApplicationNoteOnFileForFileApplicationNoteIdFkeyPatch: UpdateApplicationNoteOnFileForFileApplicationNoteIdFkeyPatch;
  updateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch: UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch;
  updateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch: UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch;
  updateApplicationOnApplicationForApplicationOrgIdFkeyPatch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
  updateApplicationOnApplicationForApplicationTemplateIdFkeyPatch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
  updateApplicationOnApplicationForFakePublicApplicationForeignKey0Patch: UpdateApplicationOnApplicationForFakePublicApplicationForeignKey0Patch;
  updateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch: UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
  updateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  updateApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch: UpdateApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
  updateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  updateApplicationOnDataChangelogForDataChangelogApplicationIdFkeyPatch: UpdateApplicationOnDataChangelogForDataChangelogApplicationIdFkeyPatch;
  updateApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch: UpdateApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch;
  updateApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch: UpdateApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch;
  updateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch: UpdateApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch;
  updateApplicationOnFileForFileApplicationSerialFkeyPatch: UpdateApplicationOnFileForFileApplicationSerialFkeyPatch;
  updateApplicationOnNotificationForNotificationApplicationIdFkeyPatch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
  updateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  updateApplicationOnReviewForReviewApplicationIdFkeyPatch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
  updateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch: UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
  updateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch: UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
  updateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnVerificationForVerificationApplicationIdFkeyPatch: UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch;
  updateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  updateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  updateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch: UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch;
  updateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch: UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  updateApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch: UpdateApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
  updateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  updateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  updateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  updateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch: UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  updateDataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyPatch: UpdateDataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyPatch;
  updateDataChangelogOnDataChangelogForDataChangelogOrgIdFkeyPatch: UpdateDataChangelogOnDataChangelogForDataChangelogOrgIdFkeyPatch;
  updateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch: UpdateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch;
  updateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch: UpdateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch;
  updateDataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch: UpdateDataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch;
  updateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch: UpdateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch;
  updateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch: UpdateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch;
  updateDataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch: UpdateDataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch;
  updateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch: UpdateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch;
  updateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch: UpdateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch;
  updateDataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch: UpdateDataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch;
  updateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch: UpdateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch;
  updateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch: UpdateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch;
  updateDataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch: UpdateDataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch;
  updateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch: UpdateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
  updateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch: UpdateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch;
  updateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch: UpdateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch;
  updateDataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch: UpdateDataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch;
  updateFileOnFileForFileApplicationNoteIdFkeyPatch: UpdateFileOnFileForFileApplicationNoteIdFkeyPatch;
  updateFileOnFileForFileApplicationResponseIdFkeyPatch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
  updateFileOnFileForFileApplicationSerialFkeyPatch: UpdateFileOnFileForFileApplicationSerialFkeyPatch;
  updateFileOnFileForFileTemplateIdFkeyPatch: UpdateFileOnFileForFileTemplateIdFkeyPatch;
  updateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch: UpdateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
  updateNotificationOnNotificationForNotificationApplicationIdFkeyPatch: UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch;
  updateNotificationOnNotificationForNotificationReviewIdFkeyPatch: UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch;
  updateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch: UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
  updateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch: UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
  updateOrganisationOnApplicationForApplicationOrgIdFkeyPatch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
  updateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch: UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
  updateOrganisationOnDataChangelogForDataChangelogOrgIdFkeyPatch: UpdateOrganisationOnDataChangelogForDataChangelogOrgIdFkeyPatch;
  updateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch: UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
  updateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  updateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch: UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
  updateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  updateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  updatePermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0Patch: UpdatePermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0Patch;
  updatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  updatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  updatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  updatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  updatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  updatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  updateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0Patch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0Patch;
  updateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
  updateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0Patch: UpdateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0Patch;
  updateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1Patch: UpdateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1Patch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
  updateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch;
  updateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch: UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  updateReviewOnNotificationForNotificationReviewIdFkeyPatch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
  updateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  updateReviewOnReviewForFakePublicReviewForeignKey0Patch: UpdateReviewOnReviewForFakePublicReviewForeignKey0Patch;
  updateReviewOnReviewForReviewApplicationIdFkeyPatch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
  updateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
  updateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  updateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  updateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch: UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  updateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch: UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  updateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch: UpdateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
  updateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  updateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  updateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  updateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch: UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
  updateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch: UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
  updateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
  updateTemplateOnApplicationForApplicationTemplateIdFkeyPatch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
  updateTemplateOnFileForFileTemplateIdFkeyPatch: UpdateTemplateOnFileForFileTemplateIdFkeyPatch;
  updateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch: UpdateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
  updateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  updateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch: UpdateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
  updateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch: UpdateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
  updateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  updateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  updateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  updateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch: UpdateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
  updateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  updateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  updateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  updateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  updateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch: UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  updateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch: UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  updateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch: UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  updateTemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch: UpdateTemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch;
  updateTemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch: UpdateTemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch;
  updateTemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch: UpdateTemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch;
  updateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch: UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  updateTriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch: UpdateTriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
  updateTriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
  updateTriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
  updateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch: UpdateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
  updateUserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0Patch: UpdateUserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0Patch;
  updateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  updateVerificationOnVerificationForVerificationApplicationIdFkeyPatch: UpdateVerificationOnVerificationForVerificationApplicationIdFkeyPatch;
};

/** Mapping between all available schema types and the resolvers parents */
export type ResolversParentTypes = {
  ActionPlugin: ActionPlugin;
  ActionPluginCondition: ActionPluginCondition;
  ActionPluginFilter: ActionPluginFilter;
  ActionPluginInput: ActionPluginInput;
  ActionPluginPatch: ActionPluginPatch;
  ActionPluginsConnection: ActionPluginsConnection;
  ActionPluginsEdge: ActionPluginsEdge;
  ActionQueue: ActionQueue;
  ActionQueueActionQueuePkeyConnect: ActionQueueActionQueuePkeyConnect;
  ActionQueueActionQueuePkeyDelete: ActionQueueActionQueuePkeyDelete;
  ActionQueueApplicationIdFkeyActionQueueCreateInput: ActionQueueApplicationIdFkeyActionQueueCreateInput;
  ActionQueueApplicationIdFkeyApplicationCreateInput: ActionQueueApplicationIdFkeyApplicationCreateInput;
  ActionQueueApplicationIdFkeyInput: ActionQueueApplicationIdFkeyInput;
  ActionQueueApplicationIdFkeyInverseInput: ActionQueueApplicationIdFkeyInverseInput;
  ActionQueueCondition: ActionQueueCondition;
  ActionQueueFilter: ActionQueueFilter;
  ActionQueueInput: ActionQueueInput;
  ActionQueueNodeIdConnect: ActionQueueNodeIdConnect;
  ActionQueueNodeIdDelete: ActionQueueNodeIdDelete;
  ActionQueueOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate;
  ActionQueueOnActionQueueForActionQueueApplicationIdFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueApplicationIdFkeyUsingActionQueuePkeyUpdate;
  ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate;
  ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueTemplateIdFkeyUsingActionQueuePkeyUpdate;
  ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate: ActionQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate;
  ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate: ActionQueueOnActionQueueForActionQueueTriggerEventFkeyUsingActionQueuePkeyUpdate;
  ActionQueuePatch: ActionQueuePatch;
  ActionQueueStatusFilter: ActionQueueStatusFilter;
  ActionQueueTemplateIdFkeyActionQueueCreateInput: ActionQueueTemplateIdFkeyActionQueueCreateInput;
  ActionQueueTemplateIdFkeyInput: ActionQueueTemplateIdFkeyInput;
  ActionQueueTemplateIdFkeyInverseInput: ActionQueueTemplateIdFkeyInverseInput;
  ActionQueueTemplateIdFkeyTemplateCreateInput: ActionQueueTemplateIdFkeyTemplateCreateInput;
  ActionQueueTriggerEventFkeyActionQueueCreateInput: ActionQueueTriggerEventFkeyActionQueueCreateInput;
  ActionQueueTriggerEventFkeyInput: ActionQueueTriggerEventFkeyInput;
  ActionQueueTriggerEventFkeyInverseInput: ActionQueueTriggerEventFkeyInverseInput;
  ActionQueueTriggerEventFkeyTriggerQueueCreateInput: ActionQueueTriggerEventFkeyTriggerQueueCreateInput;
  ActionQueuesConnection: ActionQueuesConnection;
  ActionQueuesEdge: ActionQueuesEdge;
  ActivityLog: ActivityLog;
  ActivityLogActivityLogPkeyConnect: ActivityLogActivityLogPkeyConnect;
  ActivityLogActivityLogPkeyDelete: ActivityLogActivityLogPkeyDelete;
  ActivityLogApplicationIdFkeyActivityLogCreateInput: ActivityLogApplicationIdFkeyActivityLogCreateInput;
  ActivityLogApplicationIdFkeyApplicationCreateInput: ActivityLogApplicationIdFkeyApplicationCreateInput;
  ActivityLogApplicationIdFkeyInput: ActivityLogApplicationIdFkeyInput;
  ActivityLogApplicationIdFkeyInverseInput: ActivityLogApplicationIdFkeyInverseInput;
  ActivityLogCondition: ActivityLogCondition;
  ActivityLogFilter: ActivityLogFilter;
  ActivityLogInput: ActivityLogInput;
  ActivityLogNodeIdConnect: ActivityLogNodeIdConnect;
  ActivityLogNodeIdDelete: ActivityLogNodeIdDelete;
  ActivityLogOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate: ActivityLogOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate;
  ActivityLogOnActivityLogForActivityLogApplicationIdFkeyUsingActivityLogPkeyUpdate: ActivityLogOnActivityLogForActivityLogApplicationIdFkeyUsingActivityLogPkeyUpdate;
  ActivityLogPatch: ActivityLogPatch;
  ActivityLogsConnection: ActivityLogsConnection;
  ActivityLogsEdge: ActivityLogsEdge;
  AllowedSelfAssignableSectionsShape: AllowedSelfAssignableSectionsShape;
  AllowedSelfAssignableSectionsShapeCondition: AllowedSelfAssignableSectionsShapeCondition;
  AllowedSelfAssignableSectionsShapeFilter: AllowedSelfAssignableSectionsShapeFilter;
  AllowedSelfAssignableSectionsShapeInput: AllowedSelfAssignableSectionsShapeInput;
  AllowedSelfAssignableSectionsShapesConnection: AllowedSelfAssignableSectionsShapesConnection;
  AllowedSelfAssignableSectionsShapesEdge: AllowedSelfAssignableSectionsShapesEdge;
  Application: Application;
  ApplicationApplicationOutcomeRegistrationKeyConnect: ApplicationApplicationOutcomeRegistrationKeyConnect;
  ApplicationApplicationOutcomeRegistrationKeyDelete: ApplicationApplicationOutcomeRegistrationKeyDelete;
  ApplicationApplicationPkeyConnect: ApplicationApplicationPkeyConnect;
  ApplicationApplicationPkeyDelete: ApplicationApplicationPkeyDelete;
  ApplicationApplicationSerialKeyConnect: ApplicationApplicationSerialKeyConnect;
  ApplicationApplicationSerialKeyDelete: ApplicationApplicationSerialKeyDelete;
  ApplicationCondition: ApplicationCondition;
  ApplicationFilter: ApplicationFilter;
  ApplicationInput: ApplicationInput;
  ApplicationListFilterApplicantConnection: ApplicationListFilterApplicantConnection;
  ApplicationListFilterApplicantEdge: ApplicationListFilterApplicantEdge;
  ApplicationListFilterAssignerConnection: ApplicationListFilterAssignerConnection;
  ApplicationListFilterAssignerEdge: ApplicationListFilterAssignerEdge;
  ApplicationListFilterOrganisationConnection: ApplicationListFilterOrganisationConnection;
  ApplicationListFilterOrganisationEdge: ApplicationListFilterOrganisationEdge;
  ApplicationListFilterReviewerConnection: ApplicationListFilterReviewerConnection;
  ApplicationListFilterReviewerEdge: ApplicationListFilterReviewerEdge;
  ApplicationListFilterStageConnection: ApplicationListFilterStageConnection;
  ApplicationListFilterStageEdge: ApplicationListFilterStageEdge;
  ApplicationListShape: ApplicationListShape;
  ApplicationListShapeCondition: ApplicationListShapeCondition;
  ApplicationListShapeFilter: ApplicationListShapeFilter;
  ApplicationListShapeInput: ApplicationListShapeInput;
  ApplicationListShapesConnection: ApplicationListShapesConnection;
  ApplicationListShapesEdge: ApplicationListShapesEdge;
  ApplicationNodeIdConnect: ApplicationNodeIdConnect;
  ApplicationNodeIdDelete: ApplicationNodeIdDelete;
  ApplicationNote: ApplicationNote;
  ApplicationNoteApplicationIdFkeyApplicationCreateInput: ApplicationNoteApplicationIdFkeyApplicationCreateInput;
  ApplicationNoteApplicationIdFkeyApplicationNoteCreateInput: ApplicationNoteApplicationIdFkeyApplicationNoteCreateInput;
  ApplicationNoteApplicationIdFkeyInput: ApplicationNoteApplicationIdFkeyInput;
  ApplicationNoteApplicationIdFkeyInverseInput: ApplicationNoteApplicationIdFkeyInverseInput;
  ApplicationNoteApplicationNotePkeyConnect: ApplicationNoteApplicationNotePkeyConnect;
  ApplicationNoteApplicationNotePkeyDelete: ApplicationNoteApplicationNotePkeyDelete;
  ApplicationNoteCondition: ApplicationNoteCondition;
  ApplicationNoteFilter: ApplicationNoteFilter;
  ApplicationNoteInput: ApplicationNoteInput;
  ApplicationNoteNodeIdConnect: ApplicationNoteNodeIdConnect;
  ApplicationNoteNodeIdDelete: ApplicationNoteNodeIdDelete;
  ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate: ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate;
  ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationNotePkeyUpdate: ApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationNotePkeyUpdate;
  ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate: ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate;
  ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyUsingApplicationNotePkeyUpdate: ApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyUsingApplicationNotePkeyUpdate;
  ApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0UsingApplicationNotePkeyUpdate: ApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0UsingApplicationNotePkeyUpdate;
  ApplicationNoteOnFileForFileApplicationNoteIdFkeyNodeIdUpdate: ApplicationNoteOnFileForFileApplicationNoteIdFkeyNodeIdUpdate;
  ApplicationNoteOnFileForFileApplicationNoteIdFkeyUsingApplicationNotePkeyUpdate: ApplicationNoteOnFileForFileApplicationNoteIdFkeyUsingApplicationNotePkeyUpdate;
  ApplicationNoteOrgIdFkeyApplicationNoteCreateInput: ApplicationNoteOrgIdFkeyApplicationNoteCreateInput;
  ApplicationNoteOrgIdFkeyInput: ApplicationNoteOrgIdFkeyInput;
  ApplicationNoteOrgIdFkeyInverseInput: ApplicationNoteOrgIdFkeyInverseInput;
  ApplicationNoteOrgIdFkeyOrganisationCreateInput: ApplicationNoteOrgIdFkeyOrganisationCreateInput;
  ApplicationNotePatch: ApplicationNotePatch;
  ApplicationNoteToManyFileFilter: ApplicationNoteToManyFileFilter;
  ApplicationNotesConnection: ApplicationNotesConnection;
  ApplicationNotesEdge: ApplicationNotesEdge;
  ApplicationOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate: ApplicationOnActionQueueForActionQueueApplicationIdFkeyNodeIdUpdate;
  ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnActionQueueForActionQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate: ApplicationOnActivityLogForActivityLogApplicationIdFkeyNodeIdUpdate;
  ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnActivityLogForActivityLogApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationOrgIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationForApplicationTemplateIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationPkeyUpdate: ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationPkeyUpdate;
  ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationSerialKeyUpdate: ApplicationOnApplicationForFakePublicApplicationForeignKey0UsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyNodeIdUpdate;
  ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate;
  ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate: ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataChangelogForDataChangelogApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate: ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate;
  ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnFileForFileApplicationSerialFkeyNodeIdUpdate: ApplicationOnFileForFileApplicationSerialFkeyNodeIdUpdate;
  ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationPkeyUpdate: ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationPkeyUpdate;
  ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationSerialKeyUpdate: ApplicationOnFileForFileApplicationSerialFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnNotificationForNotificationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate: ApplicationOnReviewForReviewApplicationIdFkeyNodeIdUpdate;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnReviewForReviewApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate: ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate;
  ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate: ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate;
  ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate: ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate;
  ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate: ApplicationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate;
  ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate: ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationOutcomeRegistrationKeyUpdate;
  ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationPkeyUpdate: ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationPkeyUpdate;
  ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationSerialKeyUpdate: ApplicationOnVerificationForVerificationApplicationIdFkeyUsingApplicationSerialKeyUpdate;
  ApplicationOrgIdFkeyApplicationCreateInput: ApplicationOrgIdFkeyApplicationCreateInput;
  ApplicationOrgIdFkeyInput: ApplicationOrgIdFkeyInput;
  ApplicationOrgIdFkeyInverseInput: ApplicationOrgIdFkeyInverseInput;
  ApplicationOrgIdFkeyOrganisationCreateInput: ApplicationOrgIdFkeyOrganisationCreateInput;
  ApplicationOutcomeFilter: ApplicationOutcomeFilter;
  ApplicationPatch: ApplicationPatch;
  ApplicationResponse: ApplicationResponse;
  ApplicationResponseApplicationIdFkeyApplicationCreateInput: ApplicationResponseApplicationIdFkeyApplicationCreateInput;
  ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput: ApplicationResponseApplicationIdFkeyApplicationResponseCreateInput;
  ApplicationResponseApplicationIdFkeyInput: ApplicationResponseApplicationIdFkeyInput;
  ApplicationResponseApplicationIdFkeyInverseInput: ApplicationResponseApplicationIdFkeyInverseInput;
  ApplicationResponseApplicationResponsePkeyConnect: ApplicationResponseApplicationResponsePkeyConnect;
  ApplicationResponseApplicationResponsePkeyDelete: ApplicationResponseApplicationResponsePkeyDelete;
  ApplicationResponseCondition: ApplicationResponseCondition;
  ApplicationResponseFilter: ApplicationResponseFilter;
  ApplicationResponseInput: ApplicationResponseInput;
  ApplicationResponseNodeIdConnect: ApplicationResponseNodeIdConnect;
  ApplicationResponseNodeIdDelete: ApplicationResponseNodeIdDelete;
  ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyNodeIdUpdate;
  ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyUsingApplicationResponsePkeyUpdate;
  ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate;
  ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingApplicationResponsePkeyUpdate;
  ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate: ApplicationResponseOnFileForFileApplicationResponseIdFkeyNodeIdUpdate;
  ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnFileForFileApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate;
  ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate: ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate;
  ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate: ApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingApplicationResponsePkeyUpdate;
  ApplicationResponsePatch: ApplicationResponsePatch;
  ApplicationResponseStatusFilter: ApplicationResponseStatusFilter;
  ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput: ApplicationResponseTemplateElementIdFkeyApplicationResponseCreateInput;
  ApplicationResponseTemplateElementIdFkeyInput: ApplicationResponseTemplateElementIdFkeyInput;
  ApplicationResponseTemplateElementIdFkeyInverseInput: ApplicationResponseTemplateElementIdFkeyInverseInput;
  ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput: ApplicationResponseTemplateElementIdFkeyTemplateElementCreateInput;
  ApplicationResponseToManyFileFilter: ApplicationResponseToManyFileFilter;
  ApplicationResponseToManyReviewResponseFilter: ApplicationResponseToManyReviewResponseFilter;
  ApplicationResponsesConnection: ApplicationResponsesConnection;
  ApplicationResponsesEdge: ApplicationResponsesEdge;
  ApplicationReviewerAction: ApplicationReviewerAction;
  ApplicationReviewerActionApplicationIdFkeyApplicationCreateInput: ApplicationReviewerActionApplicationIdFkeyApplicationCreateInput;
  ApplicationReviewerActionApplicationIdFkeyApplicationReviewerActionCreateInput: ApplicationReviewerActionApplicationIdFkeyApplicationReviewerActionCreateInput;
  ApplicationReviewerActionApplicationIdFkeyInput: ApplicationReviewerActionApplicationIdFkeyInput;
  ApplicationReviewerActionApplicationIdFkeyInverseInput: ApplicationReviewerActionApplicationIdFkeyInverseInput;
  ApplicationReviewerActionApplicationReviewerActionPkeyConnect: ApplicationReviewerActionApplicationReviewerActionPkeyConnect;
  ApplicationReviewerActionApplicationReviewerActionPkeyDelete: ApplicationReviewerActionApplicationReviewerActionPkeyDelete;
  ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyConnect: ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyConnect;
  ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyDelete: ApplicationReviewerActionApplicationReviewerActionUserIdApplicationIdKeyDelete;
  ApplicationReviewerActionCondition: ApplicationReviewerActionCondition;
  ApplicationReviewerActionFilter: ApplicationReviewerActionFilter;
  ApplicationReviewerActionInput: ApplicationReviewerActionInput;
  ApplicationReviewerActionNodeIdConnect: ApplicationReviewerActionNodeIdConnect;
  ApplicationReviewerActionNodeIdDelete: ApplicationReviewerActionNodeIdDelete;
  ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate: ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyNodeIdUpdate;
  ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionPkeyUpdate: ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionPkeyUpdate;
  ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionUserIdApplicationIdKeyUpdate: ApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyUsingApplicationReviewerActionUserIdApplicationIdKeyUpdate;
  ApplicationReviewerActionPatch: ApplicationReviewerActionPatch;
  ApplicationReviewerActionsConnection: ApplicationReviewerActionsConnection;
  ApplicationReviewerActionsEdge: ApplicationReviewerActionsEdge;
  ApplicationStageHistoriesConnection: ApplicationStageHistoriesConnection;
  ApplicationStageHistoriesEdge: ApplicationStageHistoriesEdge;
  ApplicationStageHistory: ApplicationStageHistory;
  ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput: ApplicationStageHistoryApplicationIdFkeyApplicationCreateInput;
  ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput: ApplicationStageHistoryApplicationIdFkeyApplicationStageHistoryCreateInput;
  ApplicationStageHistoryApplicationIdFkeyInput: ApplicationStageHistoryApplicationIdFkeyInput;
  ApplicationStageHistoryApplicationIdFkeyInverseInput: ApplicationStageHistoryApplicationIdFkeyInverseInput;
  ApplicationStageHistoryApplicationStageHistoryPkeyConnect: ApplicationStageHistoryApplicationStageHistoryPkeyConnect;
  ApplicationStageHistoryApplicationStageHistoryPkeyDelete: ApplicationStageHistoryApplicationStageHistoryPkeyDelete;
  ApplicationStageHistoryCondition: ApplicationStageHistoryCondition;
  ApplicationStageHistoryFilter: ApplicationStageHistoryFilter;
  ApplicationStageHistoryInput: ApplicationStageHistoryInput;
  ApplicationStageHistoryNodeIdConnect: ApplicationStageHistoryNodeIdConnect;
  ApplicationStageHistoryNodeIdDelete: ApplicationStageHistoryNodeIdDelete;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyNodeIdUpdate;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate;
  ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate: ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate;
  ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate: ApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStageHistoryPkeyUpdate;
  ApplicationStageHistoryPatch: ApplicationStageHistoryPatch;
  ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput: ApplicationStageHistoryStageIdFkeyApplicationStageHistoryCreateInput;
  ApplicationStageHistoryStageIdFkeyInput: ApplicationStageHistoryStageIdFkeyInput;
  ApplicationStageHistoryStageIdFkeyInverseInput: ApplicationStageHistoryStageIdFkeyInverseInput;
  ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput: ApplicationStageHistoryStageIdFkeyTemplateStageCreateInput;
  ApplicationStageHistoryToManyApplicationStatusHistoryFilter: ApplicationStageHistoryToManyApplicationStatusHistoryFilter;
  ApplicationStageStatusAll: ApplicationStageStatusAll;
  ApplicationStageStatusAllCondition: ApplicationStageStatusAllCondition;
  ApplicationStageStatusAllFilter: ApplicationStageStatusAllFilter;
  ApplicationStageStatusAllsConnection: ApplicationStageStatusAllsConnection;
  ApplicationStageStatusAllsEdge: ApplicationStageStatusAllsEdge;
  ApplicationStageStatusLatest: ApplicationStageStatusLatest;
  ApplicationStageStatusLatestCondition: ApplicationStageStatusLatestCondition;
  ApplicationStageStatusLatestFilter: ApplicationStageStatusLatestFilter;
  ApplicationStageStatusLatestsConnection: ApplicationStageStatusLatestsConnection;
  ApplicationStageStatusLatestsEdge: ApplicationStageStatusLatestsEdge;
  ApplicationStatusFilter: ApplicationStatusFilter;
  ApplicationStatusHistoriesConnection: ApplicationStatusHistoriesConnection;
  ApplicationStatusHistoriesEdge: ApplicationStatusHistoriesEdge;
  ApplicationStatusHistory: ApplicationStatusHistory;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStageHistoryCreateInput;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyApplicationStatusHistoryCreateInput;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyInput;
  ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput: ApplicationStatusHistoryApplicationStageHistoryIdFkeyInverseInput;
  ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect: ApplicationStatusHistoryApplicationStatusHistoryPkeyConnect;
  ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete: ApplicationStatusHistoryApplicationStatusHistoryPkeyDelete;
  ApplicationStatusHistoryCondition: ApplicationStatusHistoryCondition;
  ApplicationStatusHistoryFilter: ApplicationStatusHistoryFilter;
  ApplicationStatusHistoryInput: ApplicationStatusHistoryInput;
  ApplicationStatusHistoryNodeIdConnect: ApplicationStatusHistoryNodeIdConnect;
  ApplicationStatusHistoryNodeIdDelete: ApplicationStatusHistoryNodeIdDelete;
  ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate: ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyNodeIdUpdate;
  ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate: ApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyUsingApplicationStatusHistoryPkeyUpdate;
  ApplicationStatusHistoryPatch: ApplicationStatusHistoryPatch;
  ApplicationTemplateIdFkeyApplicationCreateInput: ApplicationTemplateIdFkeyApplicationCreateInput;
  ApplicationTemplateIdFkeyInput: ApplicationTemplateIdFkeyInput;
  ApplicationTemplateIdFkeyInverseInput: ApplicationTemplateIdFkeyInverseInput;
  ApplicationTemplateIdFkeyTemplateCreateInput: ApplicationTemplateIdFkeyTemplateCreateInput;
  ApplicationToManyActionQueueFilter: ApplicationToManyActionQueueFilter;
  ApplicationToManyActivityLogFilter: ApplicationToManyActivityLogFilter;
  ApplicationToManyApplicationNoteFilter: ApplicationToManyApplicationNoteFilter;
  ApplicationToManyApplicationResponseFilter: ApplicationToManyApplicationResponseFilter;
  ApplicationToManyApplicationReviewerActionFilter: ApplicationToManyApplicationReviewerActionFilter;
  ApplicationToManyApplicationStageHistoryFilter: ApplicationToManyApplicationStageHistoryFilter;
  ApplicationToManyDataChangelogFilter: ApplicationToManyDataChangelogFilter;
  ApplicationToManyDataTableManufacturerApplicationJoinFilter: ApplicationToManyDataTableManufacturerApplicationJoinFilter;
  ApplicationToManyDataTableManufacturerRepresentativeApplicationJoinFilter: ApplicationToManyDataTableManufacturerRepresentativeApplicationJoinFilter;
  ApplicationToManyDataTablePermitChemicalApplicationJoinFilter: ApplicationToManyDataTablePermitChemicalApplicationJoinFilter;
  ApplicationToManyDataTablePrequalManufacturerApplicationJoinFilter: ApplicationToManyDataTablePrequalManufacturerApplicationJoinFilter;
  ApplicationToManyDataTableProductApplicationJoinFilter: ApplicationToManyDataTableProductApplicationJoinFilter;
  ApplicationToManyDataTableProvisionalProductApplicationJoinFilter: ApplicationToManyDataTableProvisionalProductApplicationJoinFilter;
  ApplicationToManyFileFilter: ApplicationToManyFileFilter;
  ApplicationToManyNotificationFilter: ApplicationToManyNotificationFilter;
  ApplicationToManyOrganisationApplicationJoinFilter: ApplicationToManyOrganisationApplicationJoinFilter;
  ApplicationToManyReviewAssignmentFilter: ApplicationToManyReviewAssignmentFilter;
  ApplicationToManyReviewFilter: ApplicationToManyReviewFilter;
  ApplicationToManyTriggerQueueFilter: ApplicationToManyTriggerQueueFilter;
  ApplicationToManyTriggerScheduleFilter: ApplicationToManyTriggerScheduleFilter;
  ApplicationToManyUserApplicationJoinFilter: ApplicationToManyUserApplicationJoinFilter;
  ApplicationToManyVerificationFilter: ApplicationToManyVerificationFilter;
  ApplicationsConnection: ApplicationsConnection;
  ApplicationsEdge: ApplicationsEdge;
  AssignedQuestionEdge: AssignedQuestionEdge;
  AssignedQuestionsConnection: AssignedQuestionsConnection;
  AssignedQuestionsRecord: AssignedQuestionsRecord;
  AssignedQuestionsRecordFilter: AssignedQuestionsRecordFilter;
  AssignedSectionsByStageAndLevel: AssignedSectionsByStageAndLevel;
  AssignedSectionsByStageAndLevelCondition: AssignedSectionsByStageAndLevelCondition;
  AssignedSectionsByStageAndLevelFilter: AssignedSectionsByStageAndLevelFilter;
  AssignedSectionsByStageAndLevelsConnection: AssignedSectionsByStageAndLevelsConnection;
  AssignedSectionsByStageAndLevelsEdge: AssignedSectionsByStageAndLevelsEdge;
  AssignerActionFilter: AssignerActionFilter;
  AssignerListConnection: AssignerListConnection;
  AssignerListEdge: AssignerListEdge;
  AssignerListRecord: AssignerListRecord;
  AssignerListRecordFilter: AssignerListRecordFilter;
  AssignmentListConnection: AssignmentListConnection;
  AssignmentListEdge: AssignmentListEdge;
  AssignmentListRecord: AssignmentListRecord;
  AssignmentListRecordFilter: AssignmentListRecordFilter;
  BigInt: Scalars['BigInt']['output'];
  BigIntFilter: BigIntFilter;
  Boolean: Scalars['Boolean']['output'];
  BooleanFilter: BooleanFilter;
  ChangelogTypeFilter: ChangelogTypeFilter;
  CharacterData: Scalars['CharacterData']['output'];
  CharacterDataFilter: CharacterDataFilter;
  ConstraintsInfo: ConstraintsInfo;
  ConstraintsInfoCondition: ConstraintsInfoCondition;
  ConstraintsInfoFilter: ConstraintsInfoFilter;
  ConstraintsInfosConnection: ConstraintsInfosConnection;
  ConstraintsInfosEdge: ConstraintsInfosEdge;
  Counter: Counter;
  CounterCondition: CounterCondition;
  CounterFilter: CounterFilter;
  CounterInput: CounterInput;
  CounterPatch: CounterPatch;
  CountersConnection: CountersConnection;
  CountersEdge: CountersEdge;
  CreateActionPluginInput: CreateActionPluginInput;
  CreateActionPluginPayload: Omit<CreateActionPluginPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateActionQueueInput: CreateActionQueueInput;
  CreateActionQueuePayload: Omit<CreateActionQueuePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateActivityLogInput: CreateActivityLogInput;
  CreateActivityLogPayload: Omit<CreateActivityLogPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateAllowedSelfAssignableSectionsShapeInput: CreateAllowedSelfAssignableSectionsShapeInput;
  CreateAllowedSelfAssignableSectionsShapePayload: Omit<CreateAllowedSelfAssignableSectionsShapePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateApplicationInput: CreateApplicationInput;
  CreateApplicationListShapeInput: CreateApplicationListShapeInput;
  CreateApplicationListShapePayload: Omit<CreateApplicationListShapePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateApplicationNoteInput: CreateApplicationNoteInput;
  CreateApplicationNotePayload: Omit<CreateApplicationNotePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateApplicationPayload: Omit<CreateApplicationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateApplicationResponseInput: CreateApplicationResponseInput;
  CreateApplicationResponsePayload: Omit<CreateApplicationResponsePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateApplicationReviewerActionInput: CreateApplicationReviewerActionInput;
  CreateApplicationReviewerActionPayload: Omit<CreateApplicationReviewerActionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateApplicationStageHistoryInput: CreateApplicationStageHistoryInput;
  CreateApplicationStageHistoryPayload: Omit<CreateApplicationStageHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateApplicationStatusHistoryInput: CreateApplicationStatusHistoryInput;
  CreateApplicationStatusHistoryPayload: Omit<CreateApplicationStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateCounterInput: CreateCounterInput;
  CreateCounterPayload: Omit<CreateCounterPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataChangelogInput: CreateDataChangelogInput;
  CreateDataChangelogPayload: Omit<CreateDataChangelogPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableActiveIngredientInput: CreateDataTableActiveIngredientInput;
  CreateDataTableActiveIngredientPayload: Omit<CreateDataTableActiveIngredientPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableAdministrationRouteInput: CreateDataTableAdministrationRouteInput;
  CreateDataTableAdministrationRoutePayload: Omit<CreateDataTableAdministrationRoutePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableAtcCodeInput: CreateDataTableAtcCodeInput;
  CreateDataTableAtcCodePayload: Omit<CreateDataTableAtcCodePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableContainerInput: CreateDataTableContainerInput;
  CreateDataTableContainerPayload: Omit<CreateDataTableContainerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableCountryInput: CreateDataTableCountryInput;
  CreateDataTableCountryPayload: Omit<CreateDataTableCountryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableDosageFormGroupInput: CreateDataTableDosageFormGroupInput;
  CreateDataTableDosageFormGroupPayload: Omit<CreateDataTableDosageFormGroupPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableDosageFormInput: CreateDataTableDosageFormInput;
  CreateDataTableDosageFormPayload: Omit<CreateDataTableDosageFormPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableGenericIngredientInput: CreateDataTableGenericIngredientInput;
  CreateDataTableGenericIngredientPayload: Omit<CreateDataTableGenericIngredientPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableInput: CreateDataTableInput;
  CreateDataTableManufacturerApplicationJoinInput: CreateDataTableManufacturerApplicationJoinInput;
  CreateDataTableManufacturerApplicationJoinPayload: Omit<CreateDataTableManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableManufacturerInput: CreateDataTableManufacturerInput;
  CreateDataTableManufacturerPayload: Omit<CreateDataTableManufacturerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableManufacturerRepresentativeApplicationJoinInput: CreateDataTableManufacturerRepresentativeApplicationJoinInput;
  CreateDataTableManufacturerRepresentativeApplicationJoinPayload: Omit<CreateDataTableManufacturerRepresentativeApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableManufacturerRepresentativeInput: CreateDataTableManufacturerRepresentativeInput;
  CreateDataTableManufacturerRepresentativePayload: Omit<CreateDataTableManufacturerRepresentativePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTablePayload: Omit<CreateDataTablePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTablePermitChemicalApplicationJoinInput: CreateDataTablePermitChemicalApplicationJoinInput;
  CreateDataTablePermitChemicalApplicationJoinPayload: Omit<CreateDataTablePermitChemicalApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTablePermitChemicalInput: CreateDataTablePermitChemicalInput;
  CreateDataTablePermitChemicalPayload: Omit<CreateDataTablePermitChemicalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTablePreRegisteredProductsProvisionalInput: CreateDataTablePreRegisteredProductsProvisionalInput;
  CreateDataTablePreRegisteredProductsProvisionalPayload: Omit<CreateDataTablePreRegisteredProductsProvisionalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTablePrequalManufacturerApplicationJoinInput: CreateDataTablePrequalManufacturerApplicationJoinInput;
  CreateDataTablePrequalManufacturerApplicationJoinPayload: Omit<CreateDataTablePrequalManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTablePrequalManufacturerInput: CreateDataTablePrequalManufacturerInput;
  CreateDataTablePrequalManufacturerPayload: Omit<CreateDataTablePrequalManufacturerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableProcessingStepInput: CreateDataTableProcessingStepInput;
  CreateDataTableProcessingStepPayload: Omit<CreateDataTableProcessingStepPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableProductApplicationJoinInput: CreateDataTableProductApplicationJoinInput;
  CreateDataTableProductApplicationJoinPayload: Omit<CreateDataTableProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableProductInput: CreateDataTableProductInput;
  CreateDataTableProductPayload: Omit<CreateDataTableProductPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableProvisionalProductApplicationJoinInput: CreateDataTableProvisionalProductApplicationJoinInput;
  CreateDataTableProvisionalProductApplicationJoinPayload: Omit<CreateDataTableProvisionalProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableProvisionalProductInput: CreateDataTableProvisionalProductInput;
  CreateDataTableProvisionalProductPayload: Omit<CreateDataTableProvisionalProductPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableScheduledChemicalInput: CreateDataTableScheduledChemicalInput;
  CreateDataTableScheduledChemicalPayload: Omit<CreateDataTableScheduledChemicalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableStorageConditionInput: CreateDataTableStorageConditionInput;
  CreateDataTableStorageConditionPayload: Omit<CreateDataTableStorageConditionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableStorageConditionsSimplifiedInput: CreateDataTableStorageConditionsSimplifiedInput;
  CreateDataTableStorageConditionsSimplifiedPayload: Omit<CreateDataTableStorageConditionsSimplifiedPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableUnitsOfProportionInput: CreateDataTableUnitsOfProportionInput;
  CreateDataTableUnitsOfProportionPayload: Omit<CreateDataTableUnitsOfProportionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataTableWorldHealthOrganisationPqListOfFppInput: CreateDataTableWorldHealthOrganisationPqListOfFppInput;
  CreateDataTableWorldHealthOrganisationPqListOfFppPayload: Omit<CreateDataTableWorldHealthOrganisationPqListOfFppPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataViewColumnDefinitionInput: CreateDataViewColumnDefinitionInput;
  CreateDataViewColumnDefinitionPayload: Omit<CreateDataViewColumnDefinitionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateDataViewInput: CreateDataViewInput;
  CreateDataViewPayload: Omit<CreateDataViewPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateElementTypePluginInput: CreateElementTypePluginInput;
  CreateElementTypePluginPayload: Omit<CreateElementTypePluginPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateFileInput: CreateFileInput;
  CreateFilePayload: Omit<CreateFilePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateFilterInput: CreateFilterInput;
  CreateFilterPayload: Omit<CreateFilterPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateGrafanaDashboardImageInput: CreateGrafanaDashboardImageInput;
  CreateGrafanaDashboardImagePayload: Omit<CreateGrafanaDashboardImagePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateNotificationInput: CreateNotificationInput;
  CreateNotificationPayload: Omit<CreateNotificationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateOrganisationApplicationJoinInput: CreateOrganisationApplicationJoinInput;
  CreateOrganisationApplicationJoinPayload: Omit<CreateOrganisationApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateOrganisationInput: CreateOrganisationInput;
  CreateOrganisationPayload: Omit<CreateOrganisationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreatePermissionJoinInput: CreatePermissionJoinInput;
  CreatePermissionJoinPayload: Omit<CreatePermissionJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreatePermissionNameInput: CreatePermissionNameInput;
  CreatePermissionNamePayload: Omit<CreatePermissionNamePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreatePermissionPolicyInput: CreatePermissionPolicyInput;
  CreatePermissionPolicyPayload: Omit<CreatePermissionPolicyPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateReviewAssignmentAssignedSectionsShapeInput: CreateReviewAssignmentAssignedSectionsShapeInput;
  CreateReviewAssignmentAssignedSectionsShapePayload: Omit<CreateReviewAssignmentAssignedSectionsShapePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateReviewAssignmentAssignerJoinInput: CreateReviewAssignmentAssignerJoinInput;
  CreateReviewAssignmentAssignerJoinPayload: Omit<CreateReviewAssignmentAssignerJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateReviewAssignmentInput: CreateReviewAssignmentInput;
  CreateReviewAssignmentPayload: Omit<CreateReviewAssignmentPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateReviewDecisionInput: CreateReviewDecisionInput;
  CreateReviewDecisionPayload: Omit<CreateReviewDecisionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateReviewInput: CreateReviewInput;
  CreateReviewPayload: Omit<CreateReviewPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateReviewResponseInput: CreateReviewResponseInput;
  CreateReviewResponsePayload: Omit<CreateReviewResponsePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateReviewStatusHistoryInput: CreateReviewStatusHistoryInput;
  CreateReviewStatusHistoryPayload: Omit<CreateReviewStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateSystemInfoInput: CreateSystemInfoInput;
  CreateSystemInfoPayload: Omit<CreateSystemInfoPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplateActionInput: CreateTemplateActionInput;
  CreateTemplateActionPayload: Omit<CreateTemplateActionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplateCategoryInput: CreateTemplateCategoryInput;
  CreateTemplateCategoryPayload: Omit<CreateTemplateCategoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplateElementInput: CreateTemplateElementInput;
  CreateTemplateElementPayload: Omit<CreateTemplateElementPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplateFilterJoinInput: CreateTemplateFilterJoinInput;
  CreateTemplateFilterJoinPayload: Omit<CreateTemplateFilterJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplateInput: CreateTemplateInput;
  CreateTemplatePayload: Omit<CreateTemplatePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplatePermissionInput: CreateTemplatePermissionInput;
  CreateTemplatePermissionPayload: Omit<CreateTemplatePermissionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplateSectionInput: CreateTemplateSectionInput;
  CreateTemplateSectionPayload: Omit<CreateTemplateSectionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplateStageInput: CreateTemplateStageInput;
  CreateTemplateStagePayload: Omit<CreateTemplateStagePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTemplateStageReviewLevelInput: CreateTemplateStageReviewLevelInput;
  CreateTemplateStageReviewLevelPayload: Omit<CreateTemplateStageReviewLevelPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTriggerQueueInput: CreateTriggerQueueInput;
  CreateTriggerQueuePayload: Omit<CreateTriggerQueuePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateTriggerScheduleInput: CreateTriggerScheduleInput;
  CreateTriggerSchedulePayload: Omit<CreateTriggerSchedulePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateUserApplicationJoinInput: CreateUserApplicationJoinInput;
  CreateUserApplicationJoinPayload: Omit<CreateUserApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateUserInput: CreateUserInput;
  CreateUserListInput: CreateUserListInput;
  CreateUserListPayload: Omit<CreateUserListPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateUserOrganisationInput: CreateUserOrganisationInput;
  CreateUserOrganisationPayload: Omit<CreateUserOrganisationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateUserPayload: Omit<CreateUserPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  CreateVerificationInput: CreateVerificationInput;
  CreateVerificationPayload: Omit<CreateVerificationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  Cursor: Scalars['Cursor']['output'];
  DataChangelog: DataChangelog;
  DataChangelogApplicationIdFkeyApplicationCreateInput: DataChangelogApplicationIdFkeyApplicationCreateInput;
  DataChangelogApplicationIdFkeyDataChangelogCreateInput: DataChangelogApplicationIdFkeyDataChangelogCreateInput;
  DataChangelogApplicationIdFkeyInput: DataChangelogApplicationIdFkeyInput;
  DataChangelogApplicationIdFkeyInverseInput: DataChangelogApplicationIdFkeyInverseInput;
  DataChangelogCondition: DataChangelogCondition;
  DataChangelogDataChangelogPkeyConnect: DataChangelogDataChangelogPkeyConnect;
  DataChangelogDataChangelogPkeyDelete: DataChangelogDataChangelogPkeyDelete;
  DataChangelogFilter: DataChangelogFilter;
  DataChangelogInput: DataChangelogInput;
  DataChangelogNodeIdConnect: DataChangelogNodeIdConnect;
  DataChangelogNodeIdDelete: DataChangelogNodeIdDelete;
  DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate: DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyNodeIdUpdate;
  DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyUsingDataChangelogPkeyUpdate: DataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyUsingDataChangelogPkeyUpdate;
  DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate: DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate;
  DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyUsingDataChangelogPkeyUpdate: DataChangelogOnDataChangelogForDataChangelogOrgIdFkeyUsingDataChangelogPkeyUpdate;
  DataChangelogOrgIdFkeyDataChangelogCreateInput: DataChangelogOrgIdFkeyDataChangelogCreateInput;
  DataChangelogOrgIdFkeyInput: DataChangelogOrgIdFkeyInput;
  DataChangelogOrgIdFkeyInverseInput: DataChangelogOrgIdFkeyInverseInput;
  DataChangelogOrgIdFkeyOrganisationCreateInput: DataChangelogOrgIdFkeyOrganisationCreateInput;
  DataChangelogPatch: DataChangelogPatch;
  DataChangelogsConnection: DataChangelogsConnection;
  DataChangelogsEdge: DataChangelogsEdge;
  DataTable: DataTable;
  DataTableActiveIngredient: DataTableActiveIngredient;
  DataTableActiveIngredientCondition: DataTableActiveIngredientCondition;
  DataTableActiveIngredientFilter: DataTableActiveIngredientFilter;
  DataTableActiveIngredientInput: DataTableActiveIngredientInput;
  DataTableActiveIngredientPatch: DataTableActiveIngredientPatch;
  DataTableActiveIngredientsConnection: DataTableActiveIngredientsConnection;
  DataTableActiveIngredientsEdge: DataTableActiveIngredientsEdge;
  DataTableAdministrationRoute: DataTableAdministrationRoute;
  DataTableAdministrationRouteCondition: DataTableAdministrationRouteCondition;
  DataTableAdministrationRouteFilter: DataTableAdministrationRouteFilter;
  DataTableAdministrationRouteInput: DataTableAdministrationRouteInput;
  DataTableAdministrationRoutePatch: DataTableAdministrationRoutePatch;
  DataTableAdministrationRoutesConnection: DataTableAdministrationRoutesConnection;
  DataTableAdministrationRoutesEdge: DataTableAdministrationRoutesEdge;
  DataTableAtcCode: DataTableAtcCode;
  DataTableAtcCodeCondition: DataTableAtcCodeCondition;
  DataTableAtcCodeFilter: DataTableAtcCodeFilter;
  DataTableAtcCodeInput: DataTableAtcCodeInput;
  DataTableAtcCodePatch: DataTableAtcCodePatch;
  DataTableAtcCodesConnection: DataTableAtcCodesConnection;
  DataTableAtcCodesEdge: DataTableAtcCodesEdge;
  DataTableCondition: DataTableCondition;
  DataTableContainer: DataTableContainer;
  DataTableContainerCondition: DataTableContainerCondition;
  DataTableContainerFilter: DataTableContainerFilter;
  DataTableContainerInput: DataTableContainerInput;
  DataTableContainerPatch: DataTableContainerPatch;
  DataTableContainersConnection: DataTableContainersConnection;
  DataTableContainersEdge: DataTableContainersEdge;
  DataTableCountriesConnection: DataTableCountriesConnection;
  DataTableCountriesEdge: DataTableCountriesEdge;
  DataTableCountry: DataTableCountry;
  DataTableCountryCondition: DataTableCountryCondition;
  DataTableCountryFilter: DataTableCountryFilter;
  DataTableCountryInput: DataTableCountryInput;
  DataTableCountryPatch: DataTableCountryPatch;
  DataTableDosageForm: DataTableDosageForm;
  DataTableDosageFormCondition: DataTableDosageFormCondition;
  DataTableDosageFormFilter: DataTableDosageFormFilter;
  DataTableDosageFormGroup: DataTableDosageFormGroup;
  DataTableDosageFormGroupCondition: DataTableDosageFormGroupCondition;
  DataTableDosageFormGroupFilter: DataTableDosageFormGroupFilter;
  DataTableDosageFormGroupInput: DataTableDosageFormGroupInput;
  DataTableDosageFormGroupPatch: DataTableDosageFormGroupPatch;
  DataTableDosageFormGroupsConnection: DataTableDosageFormGroupsConnection;
  DataTableDosageFormGroupsEdge: DataTableDosageFormGroupsEdge;
  DataTableDosageFormInput: DataTableDosageFormInput;
  DataTableDosageFormPatch: DataTableDosageFormPatch;
  DataTableDosageFormsConnection: DataTableDosageFormsConnection;
  DataTableDosageFormsEdge: DataTableDosageFormsEdge;
  DataTableFilter: DataTableFilter;
  DataTableGenericIngredient: DataTableGenericIngredient;
  DataTableGenericIngredientCondition: DataTableGenericIngredientCondition;
  DataTableGenericIngredientFilter: DataTableGenericIngredientFilter;
  DataTableGenericIngredientInput: DataTableGenericIngredientInput;
  DataTableGenericIngredientPatch: DataTableGenericIngredientPatch;
  DataTableGenericIngredientsConnection: DataTableGenericIngredientsConnection;
  DataTableGenericIngredientsEdge: DataTableGenericIngredientsEdge;
  DataTableInput: DataTableInput;
  DataTableManufacturer: DataTableManufacturer;
  DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerApplicationJoinCreateInput: DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerApplicationJoinCreateInput;
  DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerCreateInput: DataTableManufacturerApplicaDataTableManufacturerIdFkeyDataTableManufacturerCreateInput;
  DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput: DataTableManufacturerApplicaDataTableManufacturerIdFkeyInput;
  DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput: DataTableManufacturerApplicaDataTableManufacturerIdFkeyInverseInput;
  DataTableManufacturerApplicationJoin: DataTableManufacturerApplicationJoin;
  DataTableManufacturerApplicationJoinApplicationIdFkeyApplicationCreateInput: DataTableManufacturerApplicationJoinApplicationIdFkeyApplicationCreateInput;
  DataTableManufacturerApplicationJoinApplicationIdFkeyDataTableManufacturerApplicationJoinCreateInput: DataTableManufacturerApplicationJoinApplicationIdFkeyDataTableManufacturerApplicationJoinCreateInput;
  DataTableManufacturerApplicationJoinApplicationIdFkeyInput: DataTableManufacturerApplicationJoinApplicationIdFkeyInput;
  DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput: DataTableManufacturerApplicationJoinApplicationIdFkeyInverseInput;
  DataTableManufacturerApplicationJoinCondition: DataTableManufacturerApplicationJoinCondition;
  DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyConnect: DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyConnect;
  DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyDelete: DataTableManufacturerApplicationJoinDataTableManufacturerApplicationJoinPkeyDelete;
  DataTableManufacturerApplicationJoinFilter: DataTableManufacturerApplicationJoinFilter;
  DataTableManufacturerApplicationJoinInput: DataTableManufacturerApplicationJoinInput;
  DataTableManufacturerApplicationJoinNodeIdConnect: DataTableManufacturerApplicationJoinNodeIdConnect;
  DataTableManufacturerApplicationJoinNodeIdDelete: DataTableManufacturerApplicationJoinNodeIdDelete;
  DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate: DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate;
  DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate: DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate;
  DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate: DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyNodeIdUpdate;
  DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate: DataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyUsingDataTableManufacturerApplicationJoinPkeyUpdate;
  DataTableManufacturerApplicationJoinPatch: DataTableManufacturerApplicationJoinPatch;
  DataTableManufacturerApplicationJoinsConnection: DataTableManufacturerApplicationJoinsConnection;
  DataTableManufacturerApplicationJoinsEdge: DataTableManufacturerApplicationJoinsEdge;
  DataTableManufacturerCondition: DataTableManufacturerCondition;
  DataTableManufacturerDataTableManufacturerPkeyConnect: DataTableManufacturerDataTableManufacturerPkeyConnect;
  DataTableManufacturerDataTableManufacturerPkeyDelete: DataTableManufacturerDataTableManufacturerPkeyDelete;
  DataTableManufacturerFilter: DataTableManufacturerFilter;
  DataTableManufacturerInput: DataTableManufacturerInput;
  DataTableManufacturerNodeIdConnect: DataTableManufacturerNodeIdConnect;
  DataTableManufacturerNodeIdDelete: DataTableManufacturerNodeIdDelete;
  DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate: DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyNodeIdUpdate;
  DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerPkeyUpdate: DataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyUsingDataTableManufacturerPkeyUpdate;
  DataTableManufacturerPatch: DataTableManufacturerPatch;
  DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput: DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput;
  DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeCreateInput: DataTableManufacturerRepreDataTableManufacturerReprFkeyDataTableManufacturerRepresentativeCreateInput;
  DataTableManufacturerRepreDataTableManufacturerReprFkeyInput: DataTableManufacturerRepreDataTableManufacturerReprFkeyInput;
  DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput: DataTableManufacturerRepreDataTableManufacturerReprFkeyInverseInput;
  DataTableManufacturerRepresentative: DataTableManufacturerRepresentative;
  DataTableManufacturerRepresentativeApplApplicationIdFkeyApplicationCreateInput: DataTableManufacturerRepresentativeApplApplicationIdFkeyApplicationCreateInput;
  DataTableManufacturerRepresentativeApplApplicationIdFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput: DataTableManufacturerRepresentativeApplApplicationIdFkeyDataTableManufacturerRepresentativeApplicationJoinCreateInput;
  DataTableManufacturerRepresentativeApplApplicationIdFkeyInput: DataTableManufacturerRepresentativeApplApplicationIdFkeyInput;
  DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput: DataTableManufacturerRepresentativeApplApplicationIdFkeyInverseInput;
  DataTableManufacturerRepresentativeApplicationJoin: DataTableManufacturerRepresentativeApplicationJoin;
  DataTableManufacturerRepresentativeApplicationJoinCondition: DataTableManufacturerRepresentativeApplicationJoinCondition;
  DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyConnect: DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyConnect;
  DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyDelete: DataTableManufacturerRepresentativeApplicationJoinDataTableManufacturerRepresentativeApplicationJoinPkeyDelete;
  DataTableManufacturerRepresentativeApplicationJoinFilter: DataTableManufacturerRepresentativeApplicationJoinFilter;
  DataTableManufacturerRepresentativeApplicationJoinInput: DataTableManufacturerRepresentativeApplicationJoinInput;
  DataTableManufacturerRepresentativeApplicationJoinNodeIdConnect: DataTableManufacturerRepresentativeApplicationJoinNodeIdConnect;
  DataTableManufacturerRepresentativeApplicationJoinNodeIdDelete: DataTableManufacturerRepresentativeApplicationJoinNodeIdDelete;
  DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate: DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate;
  DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate: DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate;
  DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate: DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyNodeIdUpdate;
  DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate: DataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyUsingDataTableManufacturerRepresentativeApplicationJoinPkeyUpdate;
  DataTableManufacturerRepresentativeApplicationJoinPatch: DataTableManufacturerRepresentativeApplicationJoinPatch;
  DataTableManufacturerRepresentativeApplicationJoinsConnection: DataTableManufacturerRepresentativeApplicationJoinsConnection;
  DataTableManufacturerRepresentativeApplicationJoinsEdge: DataTableManufacturerRepresentativeApplicationJoinsEdge;
  DataTableManufacturerRepresentativeCondition: DataTableManufacturerRepresentativeCondition;
  DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyConnect: DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyConnect;
  DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyDelete: DataTableManufacturerRepresentativeDataTableManufacturerRepresentativePkeyDelete;
  DataTableManufacturerRepresentativeFilter: DataTableManufacturerRepresentativeFilter;
  DataTableManufacturerRepresentativeInput: DataTableManufacturerRepresentativeInput;
  DataTableManufacturerRepresentativeNodeIdConnect: DataTableManufacturerRepresentativeNodeIdConnect;
  DataTableManufacturerRepresentativeNodeIdDelete: DataTableManufacturerRepresentativeNodeIdDelete;
  DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate: DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyNodeIdUpdate;
  DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativePkeyUpdate: DataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyUsingDataTableManufacturerRepresentativePkeyUpdate;
  DataTableManufacturerRepresentativePatch: DataTableManufacturerRepresentativePatch;
  DataTableManufacturerRepresentativeToManyDataTableManufacturerRepresentativeApplicationJoinFilter: DataTableManufacturerRepresentativeToManyDataTableManufacturerRepresentativeApplicationJoinFilter;
  DataTableManufacturerRepresentativesConnection: DataTableManufacturerRepresentativesConnection;
  DataTableManufacturerRepresentativesEdge: DataTableManufacturerRepresentativesEdge;
  DataTableManufacturerToManyDataTableManufacturerApplicationJoinFilter: DataTableManufacturerToManyDataTableManufacturerApplicationJoinFilter;
  DataTableManufacturersConnection: DataTableManufacturersConnection;
  DataTableManufacturersEdge: DataTableManufacturersEdge;
  DataTablePatch: DataTablePatch;
  DataTablePermitChemical: DataTablePermitChemical;
  DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalApplicationJoinCreateInput: DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalApplicationJoinCreateInput;
  DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalCreateInput: DataTablePermitChemicalApDataTablePermitChemicalIFkeyDataTablePermitChemicalCreateInput;
  DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput: DataTablePermitChemicalApDataTablePermitChemicalIFkeyInput;
  DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput: DataTablePermitChemicalApDataTablePermitChemicalIFkeyInverseInput;
  DataTablePermitChemicalApplicationJoin: DataTablePermitChemicalApplicationJoin;
  DataTablePermitChemicalApplicationJoinApplicationIdFkeyApplicationCreateInput: DataTablePermitChemicalApplicationJoinApplicationIdFkeyApplicationCreateInput;
  DataTablePermitChemicalApplicationJoinApplicationIdFkeyDataTablePermitChemicalApplicationJoinCreateInput: DataTablePermitChemicalApplicationJoinApplicationIdFkeyDataTablePermitChemicalApplicationJoinCreateInput;
  DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput: DataTablePermitChemicalApplicationJoinApplicationIdFkeyInput;
  DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput: DataTablePermitChemicalApplicationJoinApplicationIdFkeyInverseInput;
  DataTablePermitChemicalApplicationJoinCondition: DataTablePermitChemicalApplicationJoinCondition;
  DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyConnect: DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyConnect;
  DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyDelete: DataTablePermitChemicalApplicationJoinDataTablePermitChemicalApplicationJoinPkeyDelete;
  DataTablePermitChemicalApplicationJoinFilter: DataTablePermitChemicalApplicationJoinFilter;
  DataTablePermitChemicalApplicationJoinInput: DataTablePermitChemicalApplicationJoinInput;
  DataTablePermitChemicalApplicationJoinNodeIdConnect: DataTablePermitChemicalApplicationJoinNodeIdConnect;
  DataTablePermitChemicalApplicationJoinNodeIdDelete: DataTablePermitChemicalApplicationJoinNodeIdDelete;
  DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate: DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate;
  DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate: DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate;
  DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate: DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyNodeIdUpdate;
  DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate: DataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyUsingDataTablePermitChemicalApplicationJoinPkeyUpdate;
  DataTablePermitChemicalApplicationJoinPatch: DataTablePermitChemicalApplicationJoinPatch;
  DataTablePermitChemicalApplicationJoinsConnection: DataTablePermitChemicalApplicationJoinsConnection;
  DataTablePermitChemicalApplicationJoinsEdge: DataTablePermitChemicalApplicationJoinsEdge;
  DataTablePermitChemicalCondition: DataTablePermitChemicalCondition;
  DataTablePermitChemicalDataTablePermitChemicalPkeyConnect: DataTablePermitChemicalDataTablePermitChemicalPkeyConnect;
  DataTablePermitChemicalDataTablePermitChemicalPkeyDelete: DataTablePermitChemicalDataTablePermitChemicalPkeyDelete;
  DataTablePermitChemicalFilter: DataTablePermitChemicalFilter;
  DataTablePermitChemicalInput: DataTablePermitChemicalInput;
  DataTablePermitChemicalNodeIdConnect: DataTablePermitChemicalNodeIdConnect;
  DataTablePermitChemicalNodeIdDelete: DataTablePermitChemicalNodeIdDelete;
  DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate: DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyNodeIdUpdate;
  DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalPkeyUpdate: DataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyUsingDataTablePermitChemicalPkeyUpdate;
  DataTablePermitChemicalPatch: DataTablePermitChemicalPatch;
  DataTablePermitChemicalToManyDataTablePermitChemicalApplicationJoinFilter: DataTablePermitChemicalToManyDataTablePermitChemicalApplicationJoinFilter;
  DataTablePermitChemicalsConnection: DataTablePermitChemicalsConnection;
  DataTablePermitChemicalsEdge: DataTablePermitChemicalsEdge;
  DataTablePreRegisteredProductsProvisional: DataTablePreRegisteredProductsProvisional;
  DataTablePreRegisteredProductsProvisionalCondition: DataTablePreRegisteredProductsProvisionalCondition;
  DataTablePreRegisteredProductsProvisionalFilter: DataTablePreRegisteredProductsProvisionalFilter;
  DataTablePreRegisteredProductsProvisionalInput: DataTablePreRegisteredProductsProvisionalInput;
  DataTablePreRegisteredProductsProvisionalPatch: DataTablePreRegisteredProductsProvisionalPatch;
  DataTablePreRegisteredProductsProvisionalsConnection: DataTablePreRegisteredProductsProvisionalsConnection;
  DataTablePreRegisteredProductsProvisionalsEdge: DataTablePreRegisteredProductsProvisionalsEdge;
  DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerApplicationJoinCreateInput: DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerApplicationJoinCreateInput;
  DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerCreateInput: DataTablePrequalManufacturDataTablePrequalManufactuFkeyDataTablePrequalManufacturerCreateInput;
  DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput: DataTablePrequalManufacturDataTablePrequalManufactuFkeyInput;
  DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput: DataTablePrequalManufacturDataTablePrequalManufactuFkeyInverseInput;
  DataTablePrequalManufacturer: DataTablePrequalManufacturer;
  DataTablePrequalManufacturerApplicationApplicationIdFkeyApplicationCreateInput: DataTablePrequalManufacturerApplicationApplicationIdFkeyApplicationCreateInput;
  DataTablePrequalManufacturerApplicationApplicationIdFkeyDataTablePrequalManufacturerApplicationJoinCreateInput: DataTablePrequalManufacturerApplicationApplicationIdFkeyDataTablePrequalManufacturerApplicationJoinCreateInput;
  DataTablePrequalManufacturerApplicationApplicationIdFkeyInput: DataTablePrequalManufacturerApplicationApplicationIdFkeyInput;
  DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput: DataTablePrequalManufacturerApplicationApplicationIdFkeyInverseInput;
  DataTablePrequalManufacturerApplicationJoin: DataTablePrequalManufacturerApplicationJoin;
  DataTablePrequalManufacturerApplicationJoinCondition: DataTablePrequalManufacturerApplicationJoinCondition;
  DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyConnect: DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyConnect;
  DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyDelete: DataTablePrequalManufacturerApplicationJoinDataTablePrequalManufacturerApplicationJoinPkeyDelete;
  DataTablePrequalManufacturerApplicationJoinFilter: DataTablePrequalManufacturerApplicationJoinFilter;
  DataTablePrequalManufacturerApplicationJoinInput: DataTablePrequalManufacturerApplicationJoinInput;
  DataTablePrequalManufacturerApplicationJoinNodeIdConnect: DataTablePrequalManufacturerApplicationJoinNodeIdConnect;
  DataTablePrequalManufacturerApplicationJoinNodeIdDelete: DataTablePrequalManufacturerApplicationJoinNodeIdDelete;
  DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate: DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate;
  DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate: DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate;
  DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate: DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyNodeIdUpdate;
  DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate: DataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyUsingDataTablePrequalManufacturerApplicationJoinPkeyUpdate;
  DataTablePrequalManufacturerApplicationJoinPatch: DataTablePrequalManufacturerApplicationJoinPatch;
  DataTablePrequalManufacturerApplicationJoinsConnection: DataTablePrequalManufacturerApplicationJoinsConnection;
  DataTablePrequalManufacturerApplicationJoinsEdge: DataTablePrequalManufacturerApplicationJoinsEdge;
  DataTablePrequalManufacturerCondition: DataTablePrequalManufacturerCondition;
  DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyConnect: DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyConnect;
  DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyDelete: DataTablePrequalManufacturerDataTablePrequalManufacturerPkeyDelete;
  DataTablePrequalManufacturerFilter: DataTablePrequalManufacturerFilter;
  DataTablePrequalManufacturerInput: DataTablePrequalManufacturerInput;
  DataTablePrequalManufacturerNodeIdConnect: DataTablePrequalManufacturerNodeIdConnect;
  DataTablePrequalManufacturerNodeIdDelete: DataTablePrequalManufacturerNodeIdDelete;
  DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate: DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyNodeIdUpdate;
  DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerPkeyUpdate: DataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyUsingDataTablePrequalManufacturerPkeyUpdate;
  DataTablePrequalManufacturerPatch: DataTablePrequalManufacturerPatch;
  DataTablePrequalManufacturerToManyDataTablePrequalManufacturerApplicationJoinFilter: DataTablePrequalManufacturerToManyDataTablePrequalManufacturerApplicationJoinFilter;
  DataTablePrequalManufacturersConnection: DataTablePrequalManufacturersConnection;
  DataTablePrequalManufacturersEdge: DataTablePrequalManufacturersEdge;
  DataTableProcessingStep: DataTableProcessingStep;
  DataTableProcessingStepCondition: DataTableProcessingStepCondition;
  DataTableProcessingStepFilter: DataTableProcessingStepFilter;
  DataTableProcessingStepInput: DataTableProcessingStepInput;
  DataTableProcessingStepPatch: DataTableProcessingStepPatch;
  DataTableProcessingStepsConnection: DataTableProcessingStepsConnection;
  DataTableProcessingStepsEdge: DataTableProcessingStepsEdge;
  DataTableProduct: DataTableProduct;
  DataTableProductApplicationJoin: DataTableProductApplicationJoin;
  DataTableProductApplicationJoinApplicationIdFkeyApplicationCreateInput: DataTableProductApplicationJoinApplicationIdFkeyApplicationCreateInput;
  DataTableProductApplicationJoinApplicationIdFkeyDataTableProductApplicationJoinCreateInput: DataTableProductApplicationJoinApplicationIdFkeyDataTableProductApplicationJoinCreateInput;
  DataTableProductApplicationJoinApplicationIdFkeyInput: DataTableProductApplicationJoinApplicationIdFkeyInput;
  DataTableProductApplicationJoinApplicationIdFkeyInverseInput: DataTableProductApplicationJoinApplicationIdFkeyInverseInput;
  DataTableProductApplicationJoinCondition: DataTableProductApplicationJoinCondition;
  DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect: DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyConnect;
  DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete: DataTableProductApplicationJoinDataTableProductApplicationJoinPkeyDelete;
  DataTableProductApplicationJoinFilter: DataTableProductApplicationJoinFilter;
  DataTableProductApplicationJoinInput: DataTableProductApplicationJoinInput;
  DataTableProductApplicationJoinNodeIdConnect: DataTableProductApplicationJoinNodeIdConnect;
  DataTableProductApplicationJoinNodeIdDelete: DataTableProductApplicationJoinNodeIdDelete;
  DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate: DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyNodeIdUpdate;
  DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate: DataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyUsingDataTableProductApplicationJoinPkeyUpdate;
  DataTableProductApplicationJoinPatch: DataTableProductApplicationJoinPatch;
  DataTableProductApplicationJoinsConnection: DataTableProductApplicationJoinsConnection;
  DataTableProductApplicationJoinsEdge: DataTableProductApplicationJoinsEdge;
  DataTableProductCondition: DataTableProductCondition;
  DataTableProductFilter: DataTableProductFilter;
  DataTableProductInput: DataTableProductInput;
  DataTableProductPatch: DataTableProductPatch;
  DataTableProductsConnection: DataTableProductsConnection;
  DataTableProductsEdge: DataTableProductsEdge;
  DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductApplicationJoinCreateInput: DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductApplicationJoinCreateInput;
  DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductCreateInput: DataTableProvisionalProducDataTableProvisionalProduFkeyDataTableProvisionalProductCreateInput;
  DataTableProvisionalProducDataTableProvisionalProduFkeyInput: DataTableProvisionalProducDataTableProvisionalProduFkeyInput;
  DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput: DataTableProvisionalProducDataTableProvisionalProduFkeyInverseInput;
  DataTableProvisionalProduct: DataTableProvisionalProduct;
  DataTableProvisionalProductApplicationApplicationIdFkeyApplicationCreateInput: DataTableProvisionalProductApplicationApplicationIdFkeyApplicationCreateInput;
  DataTableProvisionalProductApplicationApplicationIdFkeyDataTableProvisionalProductApplicationJoinCreateInput: DataTableProvisionalProductApplicationApplicationIdFkeyDataTableProvisionalProductApplicationJoinCreateInput;
  DataTableProvisionalProductApplicationApplicationIdFkeyInput: DataTableProvisionalProductApplicationApplicationIdFkeyInput;
  DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput: DataTableProvisionalProductApplicationApplicationIdFkeyInverseInput;
  DataTableProvisionalProductApplicationJoin: DataTableProvisionalProductApplicationJoin;
  DataTableProvisionalProductApplicationJoinCondition: DataTableProvisionalProductApplicationJoinCondition;
  DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyConnect: DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyConnect;
  DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyDelete: DataTableProvisionalProductApplicationJoinDataTableProvisionalProductApplicationJoinPkeyDelete;
  DataTableProvisionalProductApplicationJoinFilter: DataTableProvisionalProductApplicationJoinFilter;
  DataTableProvisionalProductApplicationJoinInput: DataTableProvisionalProductApplicationJoinInput;
  DataTableProvisionalProductApplicationJoinNodeIdConnect: DataTableProvisionalProductApplicationJoinNodeIdConnect;
  DataTableProvisionalProductApplicationJoinNodeIdDelete: DataTableProvisionalProductApplicationJoinNodeIdDelete;
  DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate: DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate;
  DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate: DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate;
  DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate: DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyNodeIdUpdate;
  DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate: DataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyUsingDataTableProvisionalProductApplicationJoinPkeyUpdate;
  DataTableProvisionalProductApplicationJoinPatch: DataTableProvisionalProductApplicationJoinPatch;
  DataTableProvisionalProductApplicationJoinsConnection: DataTableProvisionalProductApplicationJoinsConnection;
  DataTableProvisionalProductApplicationJoinsEdge: DataTableProvisionalProductApplicationJoinsEdge;
  DataTableProvisionalProductCondition: DataTableProvisionalProductCondition;
  DataTableProvisionalProductDataTableProvisionalProductPkeyConnect: DataTableProvisionalProductDataTableProvisionalProductPkeyConnect;
  DataTableProvisionalProductDataTableProvisionalProductPkeyDelete: DataTableProvisionalProductDataTableProvisionalProductPkeyDelete;
  DataTableProvisionalProductFilter: DataTableProvisionalProductFilter;
  DataTableProvisionalProductInput: DataTableProvisionalProductInput;
  DataTableProvisionalProductNodeIdConnect: DataTableProvisionalProductNodeIdConnect;
  DataTableProvisionalProductNodeIdDelete: DataTableProvisionalProductNodeIdDelete;
  DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate: DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyNodeIdUpdate;
  DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductPkeyUpdate: DataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyUsingDataTableProvisionalProductPkeyUpdate;
  DataTableProvisionalProductPatch: DataTableProvisionalProductPatch;
  DataTableProvisionalProductToManyDataTableProvisionalProductApplicationJoinFilter: DataTableProvisionalProductToManyDataTableProvisionalProductApplicationJoinFilter;
  DataTableProvisionalProductsConnection: DataTableProvisionalProductsConnection;
  DataTableProvisionalProductsEdge: DataTableProvisionalProductsEdge;
  DataTableScheduledChemical: DataTableScheduledChemical;
  DataTableScheduledChemicalCondition: DataTableScheduledChemicalCondition;
  DataTableScheduledChemicalFilter: DataTableScheduledChemicalFilter;
  DataTableScheduledChemicalInput: DataTableScheduledChemicalInput;
  DataTableScheduledChemicalPatch: DataTableScheduledChemicalPatch;
  DataTableScheduledChemicalsConnection: DataTableScheduledChemicalsConnection;
  DataTableScheduledChemicalsEdge: DataTableScheduledChemicalsEdge;
  DataTableStorageCondition: DataTableStorageCondition;
  DataTableStorageConditionCondition: DataTableStorageConditionCondition;
  DataTableStorageConditionFilter: DataTableStorageConditionFilter;
  DataTableStorageConditionInput: DataTableStorageConditionInput;
  DataTableStorageConditionPatch: DataTableStorageConditionPatch;
  DataTableStorageConditionsConnection: DataTableStorageConditionsConnection;
  DataTableStorageConditionsEdge: DataTableStorageConditionsEdge;
  DataTableStorageConditionsSimplified: DataTableStorageConditionsSimplified;
  DataTableStorageConditionsSimplifiedCondition: DataTableStorageConditionsSimplifiedCondition;
  DataTableStorageConditionsSimplifiedFilter: DataTableStorageConditionsSimplifiedFilter;
  DataTableStorageConditionsSimplifiedInput: DataTableStorageConditionsSimplifiedInput;
  DataTableStorageConditionsSimplifiedPatch: DataTableStorageConditionsSimplifiedPatch;
  DataTableStorageConditionsSimplifiedsConnection: DataTableStorageConditionsSimplifiedsConnection;
  DataTableStorageConditionsSimplifiedsEdge: DataTableStorageConditionsSimplifiedsEdge;
  DataTableUnitsOfProportion: DataTableUnitsOfProportion;
  DataTableUnitsOfProportionCondition: DataTableUnitsOfProportionCondition;
  DataTableUnitsOfProportionFilter: DataTableUnitsOfProportionFilter;
  DataTableUnitsOfProportionInput: DataTableUnitsOfProportionInput;
  DataTableUnitsOfProportionPatch: DataTableUnitsOfProportionPatch;
  DataTableUnitsOfProportionsConnection: DataTableUnitsOfProportionsConnection;
  DataTableUnitsOfProportionsEdge: DataTableUnitsOfProportionsEdge;
  DataTableWorldHealthOrganisationPqListOfFpp: DataTableWorldHealthOrganisationPqListOfFpp;
  DataTableWorldHealthOrganisationPqListOfFppCondition: DataTableWorldHealthOrganisationPqListOfFppCondition;
  DataTableWorldHealthOrganisationPqListOfFppFilter: DataTableWorldHealthOrganisationPqListOfFppFilter;
  DataTableWorldHealthOrganisationPqListOfFppInput: DataTableWorldHealthOrganisationPqListOfFppInput;
  DataTableWorldHealthOrganisationPqListOfFppPatch: DataTableWorldHealthOrganisationPqListOfFppPatch;
  DataTableWorldHealthOrganisationPqListOfFppsConnection: DataTableWorldHealthOrganisationPqListOfFppsConnection;
  DataTableWorldHealthOrganisationPqListOfFppsEdge: DataTableWorldHealthOrganisationPqListOfFppsEdge;
  DataTablesConnection: DataTablesConnection;
  DataTablesEdge: DataTablesEdge;
  DataView: DataView;
  DataViewColumnDefinition: DataViewColumnDefinition;
  DataViewColumnDefinitionCondition: DataViewColumnDefinitionCondition;
  DataViewColumnDefinitionFilter: DataViewColumnDefinitionFilter;
  DataViewColumnDefinitionInput: DataViewColumnDefinitionInput;
  DataViewColumnDefinitionPatch: DataViewColumnDefinitionPatch;
  DataViewColumnDefinitionsConnection: DataViewColumnDefinitionsConnection;
  DataViewColumnDefinitionsEdge: DataViewColumnDefinitionsEdge;
  DataViewCondition: DataViewCondition;
  DataViewFilter: DataViewFilter;
  DataViewInput: DataViewInput;
  DataViewPatch: DataViewPatch;
  DataViewsConnection: DataViewsConnection;
  DataViewsEdge: DataViewsEdge;
  Date: Scalars['Date']['output'];
  DateFilter: DateFilter;
  Datetime: Scalars['Datetime']['output'];
  DatetimeFilter: DatetimeFilter;
  DecisionFilter: DecisionFilter;
  DeleteActionPluginByCodeInput: DeleteActionPluginByCodeInput;
  DeleteActionPluginByNodeIdInput: DeleteActionPluginByNodeIdInput;
  DeleteActionPluginInput: DeleteActionPluginInput;
  DeleteActionPluginPayload: Omit<DeleteActionPluginPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteActionQueueByNodeIdInput: DeleteActionQueueByNodeIdInput;
  DeleteActionQueueInput: DeleteActionQueueInput;
  DeleteActionQueuePayload: Omit<DeleteActionQueuePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteActivityLogByNodeIdInput: DeleteActivityLogByNodeIdInput;
  DeleteActivityLogInput: DeleteActivityLogInput;
  DeleteActivityLogPayload: Omit<DeleteActivityLogPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteApplicationByNodeIdInput: DeleteApplicationByNodeIdInput;
  DeleteApplicationByOutcomeRegistrationInput: DeleteApplicationByOutcomeRegistrationInput;
  DeleteApplicationBySerialInput: DeleteApplicationBySerialInput;
  DeleteApplicationInput: DeleteApplicationInput;
  DeleteApplicationNoteByNodeIdInput: DeleteApplicationNoteByNodeIdInput;
  DeleteApplicationNoteInput: DeleteApplicationNoteInput;
  DeleteApplicationNotePayload: Omit<DeleteApplicationNotePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteApplicationPayload: Omit<DeleteApplicationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteApplicationResponseByNodeIdInput: DeleteApplicationResponseByNodeIdInput;
  DeleteApplicationResponseInput: DeleteApplicationResponseInput;
  DeleteApplicationResponsePayload: Omit<DeleteApplicationResponsePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteApplicationReviewerActionByNodeIdInput: DeleteApplicationReviewerActionByNodeIdInput;
  DeleteApplicationReviewerActionByUserIdAndApplicationIdInput: DeleteApplicationReviewerActionByUserIdAndApplicationIdInput;
  DeleteApplicationReviewerActionInput: DeleteApplicationReviewerActionInput;
  DeleteApplicationReviewerActionPayload: Omit<DeleteApplicationReviewerActionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteApplicationStageHistoryByNodeIdInput: DeleteApplicationStageHistoryByNodeIdInput;
  DeleteApplicationStageHistoryInput: DeleteApplicationStageHistoryInput;
  DeleteApplicationStageHistoryPayload: Omit<DeleteApplicationStageHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteApplicationStatusHistoryByNodeIdInput: DeleteApplicationStatusHistoryByNodeIdInput;
  DeleteApplicationStatusHistoryInput: DeleteApplicationStatusHistoryInput;
  DeleteApplicationStatusHistoryPayload: Omit<DeleteApplicationStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteCounterByNameInput: DeleteCounterByNameInput;
  DeleteCounterByNodeIdInput: DeleteCounterByNodeIdInput;
  DeleteCounterInput: DeleteCounterInput;
  DeleteCounterPayload: Omit<DeleteCounterPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataChangelogByNodeIdInput: DeleteDataChangelogByNodeIdInput;
  DeleteDataChangelogInput: DeleteDataChangelogInput;
  DeleteDataChangelogPayload: Omit<DeleteDataChangelogPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableActiveIngredientByNodeIdInput: DeleteDataTableActiveIngredientByNodeIdInput;
  DeleteDataTableActiveIngredientInput: DeleteDataTableActiveIngredientInput;
  DeleteDataTableActiveIngredientPayload: Omit<DeleteDataTableActiveIngredientPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableAdministrationRouteByNodeIdInput: DeleteDataTableAdministrationRouteByNodeIdInput;
  DeleteDataTableAdministrationRouteInput: DeleteDataTableAdministrationRouteInput;
  DeleteDataTableAdministrationRoutePayload: Omit<DeleteDataTableAdministrationRoutePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableAtcCodeByNodeIdInput: DeleteDataTableAtcCodeByNodeIdInput;
  DeleteDataTableAtcCodeInput: DeleteDataTableAtcCodeInput;
  DeleteDataTableAtcCodePayload: Omit<DeleteDataTableAtcCodePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableByNodeIdInput: DeleteDataTableByNodeIdInput;
  DeleteDataTableByTableNameInput: DeleteDataTableByTableNameInput;
  DeleteDataTableContainerByNodeIdInput: DeleteDataTableContainerByNodeIdInput;
  DeleteDataTableContainerInput: DeleteDataTableContainerInput;
  DeleteDataTableContainerPayload: Omit<DeleteDataTableContainerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableCountryByNodeIdInput: DeleteDataTableCountryByNodeIdInput;
  DeleteDataTableCountryInput: DeleteDataTableCountryInput;
  DeleteDataTableCountryPayload: Omit<DeleteDataTableCountryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableDosageFormByNodeIdInput: DeleteDataTableDosageFormByNodeIdInput;
  DeleteDataTableDosageFormGroupByNodeIdInput: DeleteDataTableDosageFormGroupByNodeIdInput;
  DeleteDataTableDosageFormGroupInput: DeleteDataTableDosageFormGroupInput;
  DeleteDataTableDosageFormGroupPayload: Omit<DeleteDataTableDosageFormGroupPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableDosageFormInput: DeleteDataTableDosageFormInput;
  DeleteDataTableDosageFormPayload: Omit<DeleteDataTableDosageFormPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableGenericIngredientByNodeIdInput: DeleteDataTableGenericIngredientByNodeIdInput;
  DeleteDataTableGenericIngredientInput: DeleteDataTableGenericIngredientInput;
  DeleteDataTableGenericIngredientPayload: Omit<DeleteDataTableGenericIngredientPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableInput: DeleteDataTableInput;
  DeleteDataTableManufacturerApplicationJoinByNodeIdInput: DeleteDataTableManufacturerApplicationJoinByNodeIdInput;
  DeleteDataTableManufacturerApplicationJoinInput: DeleteDataTableManufacturerApplicationJoinInput;
  DeleteDataTableManufacturerApplicationJoinPayload: Omit<DeleteDataTableManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableManufacturerByNodeIdInput: DeleteDataTableManufacturerByNodeIdInput;
  DeleteDataTableManufacturerInput: DeleteDataTableManufacturerInput;
  DeleteDataTableManufacturerPayload: Omit<DeleteDataTableManufacturerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput: DeleteDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput;
  DeleteDataTableManufacturerRepresentativeApplicationJoinInput: DeleteDataTableManufacturerRepresentativeApplicationJoinInput;
  DeleteDataTableManufacturerRepresentativeApplicationJoinPayload: Omit<DeleteDataTableManufacturerRepresentativeApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableManufacturerRepresentativeByNodeIdInput: DeleteDataTableManufacturerRepresentativeByNodeIdInput;
  DeleteDataTableManufacturerRepresentativeInput: DeleteDataTableManufacturerRepresentativeInput;
  DeleteDataTableManufacturerRepresentativePayload: Omit<DeleteDataTableManufacturerRepresentativePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTablePayload: Omit<DeleteDataTablePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTablePermitChemicalApplicationJoinByNodeIdInput: DeleteDataTablePermitChemicalApplicationJoinByNodeIdInput;
  DeleteDataTablePermitChemicalApplicationJoinInput: DeleteDataTablePermitChemicalApplicationJoinInput;
  DeleteDataTablePermitChemicalApplicationJoinPayload: Omit<DeleteDataTablePermitChemicalApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTablePermitChemicalByNodeIdInput: DeleteDataTablePermitChemicalByNodeIdInput;
  DeleteDataTablePermitChemicalInput: DeleteDataTablePermitChemicalInput;
  DeleteDataTablePermitChemicalPayload: Omit<DeleteDataTablePermitChemicalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTablePreRegisteredProductsProvisionalByNodeIdInput: DeleteDataTablePreRegisteredProductsProvisionalByNodeIdInput;
  DeleteDataTablePreRegisteredProductsProvisionalInput: DeleteDataTablePreRegisteredProductsProvisionalInput;
  DeleteDataTablePreRegisteredProductsProvisionalPayload: Omit<DeleteDataTablePreRegisteredProductsProvisionalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTablePrequalManufacturerApplicationJoinByNodeIdInput: DeleteDataTablePrequalManufacturerApplicationJoinByNodeIdInput;
  DeleteDataTablePrequalManufacturerApplicationJoinInput: DeleteDataTablePrequalManufacturerApplicationJoinInput;
  DeleteDataTablePrequalManufacturerApplicationJoinPayload: Omit<DeleteDataTablePrequalManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTablePrequalManufacturerByNodeIdInput: DeleteDataTablePrequalManufacturerByNodeIdInput;
  DeleteDataTablePrequalManufacturerInput: DeleteDataTablePrequalManufacturerInput;
  DeleteDataTablePrequalManufacturerPayload: Omit<DeleteDataTablePrequalManufacturerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableProcessingStepByNodeIdInput: DeleteDataTableProcessingStepByNodeIdInput;
  DeleteDataTableProcessingStepInput: DeleteDataTableProcessingStepInput;
  DeleteDataTableProcessingStepPayload: Omit<DeleteDataTableProcessingStepPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableProductApplicationJoinByNodeIdInput: DeleteDataTableProductApplicationJoinByNodeIdInput;
  DeleteDataTableProductApplicationJoinInput: DeleteDataTableProductApplicationJoinInput;
  DeleteDataTableProductApplicationJoinPayload: Omit<DeleteDataTableProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableProductByNodeIdInput: DeleteDataTableProductByNodeIdInput;
  DeleteDataTableProductInput: DeleteDataTableProductInput;
  DeleteDataTableProductPayload: Omit<DeleteDataTableProductPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableProvisionalProductApplicationJoinByNodeIdInput: DeleteDataTableProvisionalProductApplicationJoinByNodeIdInput;
  DeleteDataTableProvisionalProductApplicationJoinInput: DeleteDataTableProvisionalProductApplicationJoinInput;
  DeleteDataTableProvisionalProductApplicationJoinPayload: Omit<DeleteDataTableProvisionalProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableProvisionalProductByNodeIdInput: DeleteDataTableProvisionalProductByNodeIdInput;
  DeleteDataTableProvisionalProductInput: DeleteDataTableProvisionalProductInput;
  DeleteDataTableProvisionalProductPayload: Omit<DeleteDataTableProvisionalProductPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableScheduledChemicalByNodeIdInput: DeleteDataTableScheduledChemicalByNodeIdInput;
  DeleteDataTableScheduledChemicalInput: DeleteDataTableScheduledChemicalInput;
  DeleteDataTableScheduledChemicalPayload: Omit<DeleteDataTableScheduledChemicalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableStorageConditionByNodeIdInput: DeleteDataTableStorageConditionByNodeIdInput;
  DeleteDataTableStorageConditionInput: DeleteDataTableStorageConditionInput;
  DeleteDataTableStorageConditionPayload: Omit<DeleteDataTableStorageConditionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableStorageConditionsSimplifiedByNodeIdInput: DeleteDataTableStorageConditionsSimplifiedByNodeIdInput;
  DeleteDataTableStorageConditionsSimplifiedInput: DeleteDataTableStorageConditionsSimplifiedInput;
  DeleteDataTableStorageConditionsSimplifiedPayload: Omit<DeleteDataTableStorageConditionsSimplifiedPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableUnitsOfProportionByNodeIdInput: DeleteDataTableUnitsOfProportionByNodeIdInput;
  DeleteDataTableUnitsOfProportionInput: DeleteDataTableUnitsOfProportionInput;
  DeleteDataTableUnitsOfProportionPayload: Omit<DeleteDataTableUnitsOfProportionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput: DeleteDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput;
  DeleteDataTableWorldHealthOrganisationPqListOfFppInput: DeleteDataTableWorldHealthOrganisationPqListOfFppInput;
  DeleteDataTableWorldHealthOrganisationPqListOfFppPayload: Omit<DeleteDataTableWorldHealthOrganisationPqListOfFppPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataViewByIdentifierInput: DeleteDataViewByIdentifierInput;
  DeleteDataViewByNodeIdInput: DeleteDataViewByNodeIdInput;
  DeleteDataViewColumnDefinitionByNodeIdInput: DeleteDataViewColumnDefinitionByNodeIdInput;
  DeleteDataViewColumnDefinitionByTableNameAndColumnNameInput: DeleteDataViewColumnDefinitionByTableNameAndColumnNameInput;
  DeleteDataViewColumnDefinitionInput: DeleteDataViewColumnDefinitionInput;
  DeleteDataViewColumnDefinitionPayload: Omit<DeleteDataViewColumnDefinitionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteDataViewInput: DeleteDataViewInput;
  DeleteDataViewPayload: Omit<DeleteDataViewPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteElementTypePluginByNodeIdInput: DeleteElementTypePluginByNodeIdInput;
  DeleteElementTypePluginInput: DeleteElementTypePluginInput;
  DeleteElementTypePluginPayload: Omit<DeleteElementTypePluginPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteFileByNodeIdInput: DeleteFileByNodeIdInput;
  DeleteFileByUniqueIdInput: DeleteFileByUniqueIdInput;
  DeleteFileInput: DeleteFileInput;
  DeleteFilePayload: Omit<DeleteFilePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteFilterByCodeInput: DeleteFilterByCodeInput;
  DeleteFilterByNodeIdInput: DeleteFilterByNodeIdInput;
  DeleteFilterInput: DeleteFilterInput;
  DeleteFilterPayload: Omit<DeleteFilterPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteGrafanaDashboardImageByNodeIdInput: DeleteGrafanaDashboardImageByNodeIdInput;
  DeleteGrafanaDashboardImageInput: DeleteGrafanaDashboardImageInput;
  DeleteGrafanaDashboardImagePayload: Omit<DeleteGrafanaDashboardImagePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteNotificationByNodeIdInput: DeleteNotificationByNodeIdInput;
  DeleteNotificationInput: DeleteNotificationInput;
  DeleteNotificationPayload: Omit<DeleteNotificationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteOrganisationApplicationJoinByNodeIdInput: DeleteOrganisationApplicationJoinByNodeIdInput;
  DeleteOrganisationApplicationJoinInput: DeleteOrganisationApplicationJoinInput;
  DeleteOrganisationApplicationJoinPayload: Omit<DeleteOrganisationApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteOrganisationByNameInput: DeleteOrganisationByNameInput;
  DeleteOrganisationByNodeIdInput: DeleteOrganisationByNodeIdInput;
  DeleteOrganisationByRegistrationInput: DeleteOrganisationByRegistrationInput;
  DeleteOrganisationInput: DeleteOrganisationInput;
  DeleteOrganisationPayload: Omit<DeleteOrganisationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeletePermissionJoinByNodeIdInput: DeletePermissionJoinByNodeIdInput;
  DeletePermissionJoinInput: DeletePermissionJoinInput;
  DeletePermissionJoinPayload: Omit<DeletePermissionJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeletePermissionNameByNameInput: DeletePermissionNameByNameInput;
  DeletePermissionNameByNodeIdInput: DeletePermissionNameByNodeIdInput;
  DeletePermissionNameInput: DeletePermissionNameInput;
  DeletePermissionNamePayload: Omit<DeletePermissionNamePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeletePermissionPolicyByNameInput: DeletePermissionPolicyByNameInput;
  DeletePermissionPolicyByNodeIdInput: DeletePermissionPolicyByNodeIdInput;
  DeletePermissionPolicyInput: DeletePermissionPolicyInput;
  DeletePermissionPolicyPayload: Omit<DeletePermissionPolicyPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteReviewAssignmentAssignerJoinByNodeIdInput: DeleteReviewAssignmentAssignerJoinByNodeIdInput;
  DeleteReviewAssignmentAssignerJoinInput: DeleteReviewAssignmentAssignerJoinInput;
  DeleteReviewAssignmentAssignerJoinPayload: Omit<DeleteReviewAssignmentAssignerJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteReviewAssignmentByNodeIdInput: DeleteReviewAssignmentByNodeIdInput;
  DeleteReviewAssignmentInput: DeleteReviewAssignmentInput;
  DeleteReviewAssignmentPayload: Omit<DeleteReviewAssignmentPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteReviewByNodeIdInput: DeleteReviewByNodeIdInput;
  DeleteReviewByReviewAssignmentIdInput: DeleteReviewByReviewAssignmentIdInput;
  DeleteReviewDecisionByNodeIdInput: DeleteReviewDecisionByNodeIdInput;
  DeleteReviewDecisionInput: DeleteReviewDecisionInput;
  DeleteReviewDecisionPayload: Omit<DeleteReviewDecisionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteReviewInput: DeleteReviewInput;
  DeleteReviewPayload: Omit<DeleteReviewPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteReviewResponseByNodeIdInput: DeleteReviewResponseByNodeIdInput;
  DeleteReviewResponseInput: DeleteReviewResponseInput;
  DeleteReviewResponsePayload: Omit<DeleteReviewResponsePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteReviewStatusHistoryByNodeIdInput: DeleteReviewStatusHistoryByNodeIdInput;
  DeleteReviewStatusHistoryInput: DeleteReviewStatusHistoryInput;
  DeleteReviewStatusHistoryPayload: Omit<DeleteReviewStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteSystemInfoByNodeIdInput: DeleteSystemInfoByNodeIdInput;
  DeleteSystemInfoInput: DeleteSystemInfoInput;
  DeleteSystemInfoPayload: Omit<DeleteSystemInfoPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplateActionByNodeIdInput: DeleteTemplateActionByNodeIdInput;
  DeleteTemplateActionInput: DeleteTemplateActionInput;
  DeleteTemplateActionPayload: Omit<DeleteTemplateActionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplateByCodeAndVersionIdInput: DeleteTemplateByCodeAndVersionIdInput;
  DeleteTemplateByNodeIdInput: DeleteTemplateByNodeIdInput;
  DeleteTemplateCategoryByCodeInput: DeleteTemplateCategoryByCodeInput;
  DeleteTemplateCategoryByNodeIdInput: DeleteTemplateCategoryByNodeIdInput;
  DeleteTemplateCategoryInput: DeleteTemplateCategoryInput;
  DeleteTemplateCategoryPayload: Omit<DeleteTemplateCategoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplateElementByNodeIdInput: DeleteTemplateElementByNodeIdInput;
  DeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput: DeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput;
  DeleteTemplateElementInput: DeleteTemplateElementInput;
  DeleteTemplateElementPayload: Omit<DeleteTemplateElementPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplateFilterJoinByNodeIdInput: DeleteTemplateFilterJoinByNodeIdInput;
  DeleteTemplateFilterJoinInput: DeleteTemplateFilterJoinInput;
  DeleteTemplateFilterJoinPayload: Omit<DeleteTemplateFilterJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplateInput: DeleteTemplateInput;
  DeleteTemplatePayload: Omit<DeleteTemplatePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplatePermissionByNodeIdInput: DeleteTemplatePermissionByNodeIdInput;
  DeleteTemplatePermissionInput: DeleteTemplatePermissionInput;
  DeleteTemplatePermissionPayload: Omit<DeleteTemplatePermissionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplateSectionByNodeIdInput: DeleteTemplateSectionByNodeIdInput;
  DeleteTemplateSectionByTemplateIdAndCodeInput: DeleteTemplateSectionByTemplateIdAndCodeInput;
  DeleteTemplateSectionInput: DeleteTemplateSectionInput;
  DeleteTemplateSectionPayload: Omit<DeleteTemplateSectionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplateStageByNodeIdInput: DeleteTemplateStageByNodeIdInput;
  DeleteTemplateStageInput: DeleteTemplateStageInput;
  DeleteTemplateStagePayload: Omit<DeleteTemplateStagePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTemplateStageReviewLevelByNodeIdInput: DeleteTemplateStageReviewLevelByNodeIdInput;
  DeleteTemplateStageReviewLevelInput: DeleteTemplateStageReviewLevelInput;
  DeleteTemplateStageReviewLevelPayload: Omit<DeleteTemplateStageReviewLevelPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTriggerQueueByNodeIdInput: DeleteTriggerQueueByNodeIdInput;
  DeleteTriggerQueueInput: DeleteTriggerQueueInput;
  DeleteTriggerQueuePayload: Omit<DeleteTriggerQueuePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteTriggerScheduleByNodeIdInput: DeleteTriggerScheduleByNodeIdInput;
  DeleteTriggerScheduleInput: DeleteTriggerScheduleInput;
  DeleteTriggerSchedulePayload: Omit<DeleteTriggerSchedulePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteUserApplicationJoinByNodeIdInput: DeleteUserApplicationJoinByNodeIdInput;
  DeleteUserApplicationJoinInput: DeleteUserApplicationJoinInput;
  DeleteUserApplicationJoinPayload: Omit<DeleteUserApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteUserOrganisationByNodeIdInput: DeleteUserOrganisationByNodeIdInput;
  DeleteUserOrganisationInput: DeleteUserOrganisationInput;
  DeleteUserOrganisationPayload: Omit<DeleteUserOrganisationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteVerificationByNodeIdInput: DeleteVerificationByNodeIdInput;
  DeleteVerificationByUniqueIdInput: DeleteVerificationByUniqueIdInput;
  DeleteVerificationInput: DeleteVerificationInput;
  DeleteVerificationPayload: Omit<DeleteVerificationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  DeleteWholeApplicationInput: DeleteWholeApplicationInput;
  DeleteWholeApplicationPayload: Omit<DeleteWholeApplicationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  ElementTypePlugin: ElementTypePlugin;
  ElementTypePluginCondition: ElementTypePluginCondition;
  ElementTypePluginFilter: ElementTypePluginFilter;
  ElementTypePluginInput: ElementTypePluginInput;
  ElementTypePluginPatch: ElementTypePluginPatch;
  ElementTypePluginsConnection: ElementTypePluginsConnection;
  ElementTypePluginsEdge: ElementTypePluginsEdge;
  EventTypeFilter: EventTypeFilter;
  FakePublicApplicationForeignKey0ApplicationCreateInput: FakePublicApplicationForeignKey0ApplicationCreateInput;
  FakePublicApplicationForeignKey0Input: FakePublicApplicationForeignKey0Input;
  FakePublicApplicationForeignKey0InverseInput: FakePublicApplicationForeignKey0InverseInput;
  FakePublicApplicationForeignKey0UserListCreateInput: FakePublicApplicationForeignKey0UserListCreateInput;
  FakePublicApplicationNoteForeignKey0ApplicationNoteCreateInput: FakePublicApplicationNoteForeignKey0ApplicationNoteCreateInput;
  FakePublicApplicationNoteForeignKey0Input: FakePublicApplicationNoteForeignKey0Input;
  FakePublicApplicationNoteForeignKey0InverseInput: FakePublicApplicationNoteForeignKey0InverseInput;
  FakePublicApplicationNoteForeignKey0UserListCreateInput: FakePublicApplicationNoteForeignKey0UserListCreateInput;
  FakePublicPermissionJoinForeignKey0Input: FakePublicPermissionJoinForeignKey0Input;
  FakePublicPermissionJoinForeignKey0InverseInput: FakePublicPermissionJoinForeignKey0InverseInput;
  FakePublicPermissionJoinForeignKey0PermissionJoinCreateInput: FakePublicPermissionJoinForeignKey0PermissionJoinCreateInput;
  FakePublicPermissionJoinForeignKey0UserListCreateInput: FakePublicPermissionJoinForeignKey0UserListCreateInput;
  FakePublicReviewAssignmentAssignerJoinForeignKey0Input: FakePublicReviewAssignmentAssignerJoinForeignKey0Input;
  FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput: FakePublicReviewAssignmentAssignerJoinForeignKey0InverseInput;
  FakePublicReviewAssignmentAssignerJoinForeignKey0ReviewAssignmentAssignerJoinCreateInput: FakePublicReviewAssignmentAssignerJoinForeignKey0ReviewAssignmentAssignerJoinCreateInput;
  FakePublicReviewAssignmentAssignerJoinForeignKey0UserListCreateInput: FakePublicReviewAssignmentAssignerJoinForeignKey0UserListCreateInput;
  FakePublicReviewAssignmentForeignKey0Input: FakePublicReviewAssignmentForeignKey0Input;
  FakePublicReviewAssignmentForeignKey0InverseInput: FakePublicReviewAssignmentForeignKey0InverseInput;
  FakePublicReviewAssignmentForeignKey0ReviewAssignmentCreateInput: FakePublicReviewAssignmentForeignKey0ReviewAssignmentCreateInput;
  FakePublicReviewAssignmentForeignKey0UserListCreateInput: FakePublicReviewAssignmentForeignKey0UserListCreateInput;
  FakePublicReviewAssignmentForeignKey1Input: FakePublicReviewAssignmentForeignKey1Input;
  FakePublicReviewAssignmentForeignKey1InverseInput: FakePublicReviewAssignmentForeignKey1InverseInput;
  FakePublicReviewAssignmentForeignKey1ReviewAssignmentCreateInput: FakePublicReviewAssignmentForeignKey1ReviewAssignmentCreateInput;
  FakePublicReviewAssignmentForeignKey1UserListCreateInput: FakePublicReviewAssignmentForeignKey1UserListCreateInput;
  FakePublicReviewForeignKey0Input: FakePublicReviewForeignKey0Input;
  FakePublicReviewForeignKey0InverseInput: FakePublicReviewForeignKey0InverseInput;
  FakePublicReviewForeignKey0ReviewCreateInput: FakePublicReviewForeignKey0ReviewCreateInput;
  FakePublicReviewForeignKey0UserListCreateInput: FakePublicReviewForeignKey0UserListCreateInput;
  FakePublicUserOrganisationForeignKey0Input: FakePublicUserOrganisationForeignKey0Input;
  FakePublicUserOrganisationForeignKey0InverseInput: FakePublicUserOrganisationForeignKey0InverseInput;
  FakePublicUserOrganisationForeignKey0UserListAdminCreateInput: FakePublicUserOrganisationForeignKey0UserListAdminCreateInput;
  FakePublicUserOrganisationForeignKey0UserOrganisationCreateInput: FakePublicUserOrganisationForeignKey0UserOrganisationCreateInput;
  File: File;
  FileApplicationNoteIdFkeyApplicationNoteCreateInput: FileApplicationNoteIdFkeyApplicationNoteCreateInput;
  FileApplicationNoteIdFkeyFileCreateInput: FileApplicationNoteIdFkeyFileCreateInput;
  FileApplicationNoteIdFkeyInput: FileApplicationNoteIdFkeyInput;
  FileApplicationNoteIdFkeyInverseInput: FileApplicationNoteIdFkeyInverseInput;
  FileApplicationResponseIdFkeyApplicationResponseCreateInput: FileApplicationResponseIdFkeyApplicationResponseCreateInput;
  FileApplicationResponseIdFkeyFileCreateInput: FileApplicationResponseIdFkeyFileCreateInput;
  FileApplicationResponseIdFkeyInput: FileApplicationResponseIdFkeyInput;
  FileApplicationResponseIdFkeyInverseInput: FileApplicationResponseIdFkeyInverseInput;
  FileApplicationSerialFkeyApplicationCreateInput: FileApplicationSerialFkeyApplicationCreateInput;
  FileApplicationSerialFkeyFileCreateInput: FileApplicationSerialFkeyFileCreateInput;
  FileApplicationSerialFkeyInput: FileApplicationSerialFkeyInput;
  FileApplicationSerialFkeyInverseInput: FileApplicationSerialFkeyInverseInput;
  FileCondition: FileCondition;
  FileFilePkeyConnect: FileFilePkeyConnect;
  FileFilePkeyDelete: FileFilePkeyDelete;
  FileFileUniqueIdKeyConnect: FileFileUniqueIdKeyConnect;
  FileFileUniqueIdKeyDelete: FileFileUniqueIdKeyDelete;
  FileFilter: FileFilter;
  FileInput: FileInput;
  FileNodeIdConnect: FileNodeIdConnect;
  FileNodeIdDelete: FileNodeIdDelete;
  FileOnFileForFileApplicationNoteIdFkeyNodeIdUpdate: FileOnFileForFileApplicationNoteIdFkeyNodeIdUpdate;
  FileOnFileForFileApplicationNoteIdFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationNoteIdFkeyUsingFilePkeyUpdate;
  FileOnFileForFileApplicationNoteIdFkeyUsingFileUniqueIdKeyUpdate: FileOnFileForFileApplicationNoteIdFkeyUsingFileUniqueIdKeyUpdate;
  FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate: FileOnFileForFileApplicationResponseIdFkeyNodeIdUpdate;
  FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationResponseIdFkeyUsingFilePkeyUpdate;
  FileOnFileForFileApplicationResponseIdFkeyUsingFileUniqueIdKeyUpdate: FileOnFileForFileApplicationResponseIdFkeyUsingFileUniqueIdKeyUpdate;
  FileOnFileForFileApplicationSerialFkeyNodeIdUpdate: FileOnFileForFileApplicationSerialFkeyNodeIdUpdate;
  FileOnFileForFileApplicationSerialFkeyUsingFilePkeyUpdate: FileOnFileForFileApplicationSerialFkeyUsingFilePkeyUpdate;
  FileOnFileForFileApplicationSerialFkeyUsingFileUniqueIdKeyUpdate: FileOnFileForFileApplicationSerialFkeyUsingFileUniqueIdKeyUpdate;
  FileOnFileForFileTemplateIdFkeyNodeIdUpdate: FileOnFileForFileTemplateIdFkeyNodeIdUpdate;
  FileOnFileForFileTemplateIdFkeyUsingFilePkeyUpdate: FileOnFileForFileTemplateIdFkeyUsingFilePkeyUpdate;
  FileOnFileForFileTemplateIdFkeyUsingFileUniqueIdKeyUpdate: FileOnFileForFileTemplateIdFkeyUsingFileUniqueIdKeyUpdate;
  FilePatch: FilePatch;
  FileTemplateIdFkeyFileCreateInput: FileTemplateIdFkeyFileCreateInput;
  FileTemplateIdFkeyInput: FileTemplateIdFkeyInput;
  FileTemplateIdFkeyInverseInput: FileTemplateIdFkeyInverseInput;
  FileTemplateIdFkeyTemplateCreateInput: FileTemplateIdFkeyTemplateCreateInput;
  FilesConnection: FilesConnection;
  FilesEdge: FilesEdge;
  Filter: Filter;
  FilterCondition: FilterCondition;
  FilterFilter: FilterFilter;
  FilterFilterCodeKeyConnect: FilterFilterCodeKeyConnect;
  FilterFilterCodeKeyDelete: FilterFilterCodeKeyDelete;
  FilterFilterPkeyConnect: FilterFilterPkeyConnect;
  FilterFilterPkeyDelete: FilterFilterPkeyDelete;
  FilterInput: FilterInput;
  FilterNodeIdConnect: FilterNodeIdConnect;
  FilterNodeIdDelete: FilterNodeIdDelete;
  FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate: FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate;
  FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterCodeKeyUpdate: FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterCodeKeyUpdate;
  FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterPkeyUpdate: FilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingFilterPkeyUpdate;
  FilterPatch: FilterPatch;
  FilterToManyTemplateFilterJoinFilter: FilterToManyTemplateFilterJoinFilter;
  FiltersConnection: FiltersConnection;
  FiltersEdge: FiltersEdge;
  GrafanaDashboardImage: GrafanaDashboardImage;
  GrafanaDashboardImageCondition: GrafanaDashboardImageCondition;
  GrafanaDashboardImageFilter: GrafanaDashboardImageFilter;
  GrafanaDashboardImageInput: GrafanaDashboardImageInput;
  GrafanaDashboardImagePatch: GrafanaDashboardImagePatch;
  GrafanaDashboardImagesConnection: GrafanaDashboardImagesConnection;
  GrafanaDashboardImagesEdge: GrafanaDashboardImagesEdge;
  ID: Scalars['ID']['output'];
  Int: Scalars['Int']['output'];
  IntFilter: IntFilter;
  JSON: Scalars['JSON']['output'];
  JSONFilter: JsonFilter;
  Mutation: {};
  Node: ResolversInterfaceTypes<ResolversParentTypes>['Node'];
  Notification: Notification;
  NotificationApplicationIdFkeyApplicationCreateInput: NotificationApplicationIdFkeyApplicationCreateInput;
  NotificationApplicationIdFkeyInput: NotificationApplicationIdFkeyInput;
  NotificationApplicationIdFkeyInverseInput: NotificationApplicationIdFkeyInverseInput;
  NotificationApplicationIdFkeyNotificationCreateInput: NotificationApplicationIdFkeyNotificationCreateInput;
  NotificationCondition: NotificationCondition;
  NotificationFilter: NotificationFilter;
  NotificationInput: NotificationInput;
  NotificationNodeIdConnect: NotificationNodeIdConnect;
  NotificationNodeIdDelete: NotificationNodeIdDelete;
  NotificationNotificationPkeyConnect: NotificationNotificationPkeyConnect;
  NotificationNotificationPkeyDelete: NotificationNotificationPkeyDelete;
  NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationApplicationIdFkeyNodeIdUpdate;
  NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationApplicationIdFkeyUsingNotificationPkeyUpdate;
  NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate: NotificationOnNotificationForNotificationReviewIdFkeyNodeIdUpdate;
  NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate: NotificationOnNotificationForNotificationReviewIdFkeyUsingNotificationPkeyUpdate;
  NotificationPatch: NotificationPatch;
  NotificationReviewIdFkeyInput: NotificationReviewIdFkeyInput;
  NotificationReviewIdFkeyInverseInput: NotificationReviewIdFkeyInverseInput;
  NotificationReviewIdFkeyNotificationCreateInput: NotificationReviewIdFkeyNotificationCreateInput;
  NotificationReviewIdFkeyReviewCreateInput: NotificationReviewIdFkeyReviewCreateInput;
  NotificationsConnection: NotificationsConnection;
  NotificationsEdge: NotificationsEdge;
  Organisation: Organisation;
  OrganisationApplicationJoin: OrganisationApplicationJoin;
  OrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput: OrganisationApplicationJoinApplicationIdFkeyApplicationCreateInput;
  OrganisationApplicationJoinApplicationIdFkeyInput: OrganisationApplicationJoinApplicationIdFkeyInput;
  OrganisationApplicationJoinApplicationIdFkeyInverseInput: OrganisationApplicationJoinApplicationIdFkeyInverseInput;
  OrganisationApplicationJoinApplicationIdFkeyOrganisationApplicationJoinCreateInput: OrganisationApplicationJoinApplicationIdFkeyOrganisationApplicationJoinCreateInput;
  OrganisationApplicationJoinCondition: OrganisationApplicationJoinCondition;
  OrganisationApplicationJoinFilter: OrganisationApplicationJoinFilter;
  OrganisationApplicationJoinInput: OrganisationApplicationJoinInput;
  OrganisationApplicationJoinNodeIdConnect: OrganisationApplicationJoinNodeIdConnect;
  OrganisationApplicationJoinNodeIdDelete: OrganisationApplicationJoinNodeIdDelete;
  OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate: OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyNodeIdUpdate;
  OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate: OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate;
  OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate: OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate;
  OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate: OrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationApplicationJoinPkeyUpdate;
  OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect: OrganisationApplicationJoinOrganisationApplicationJoinPkeyConnect;
  OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete: OrganisationApplicationJoinOrganisationApplicationJoinPkeyDelete;
  OrganisationApplicationJoinOrganisationIdFkeyInput: OrganisationApplicationJoinOrganisationIdFkeyInput;
  OrganisationApplicationJoinOrganisationIdFkeyInverseInput: OrganisationApplicationJoinOrganisationIdFkeyInverseInput;
  OrganisationApplicationJoinOrganisationIdFkeyOrganisationApplicationJoinCreateInput: OrganisationApplicationJoinOrganisationIdFkeyOrganisationApplicationJoinCreateInput;
  OrganisationApplicationJoinOrganisationIdFkeyOrganisationCreateInput: OrganisationApplicationJoinOrganisationIdFkeyOrganisationCreateInput;
  OrganisationApplicationJoinPatch: OrganisationApplicationJoinPatch;
  OrganisationApplicationJoinsConnection: OrganisationApplicationJoinsConnection;
  OrganisationApplicationJoinsEdge: OrganisationApplicationJoinsEdge;
  OrganisationCondition: OrganisationCondition;
  OrganisationFilter: OrganisationFilter;
  OrganisationInput: OrganisationInput;
  OrganisationNodeIdConnect: OrganisationNodeIdConnect;
  OrganisationNodeIdDelete: OrganisationNodeIdDelete;
  OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyNodeIdUpdate;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnApplicationForApplicationOrgIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate: OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyNodeIdUpdate;
  OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate: OrganisationOnDataChangelogForDataChangelogOrgIdFkeyNodeIdUpdate;
  OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnDataChangelogForDataChangelogOrgIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate: OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate: OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationNameKeyUpdate;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationPkeyUpdate;
  OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate: OrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingOrganisationRegistrationKeyUpdate;
  OrganisationOrganisationNameKeyConnect: OrganisationOrganisationNameKeyConnect;
  OrganisationOrganisationNameKeyDelete: OrganisationOrganisationNameKeyDelete;
  OrganisationOrganisationPkeyConnect: OrganisationOrganisationPkeyConnect;
  OrganisationOrganisationPkeyDelete: OrganisationOrganisationPkeyDelete;
  OrganisationOrganisationRegistrationKeyConnect: OrganisationOrganisationRegistrationKeyConnect;
  OrganisationOrganisationRegistrationKeyDelete: OrganisationOrganisationRegistrationKeyDelete;
  OrganisationPatch: OrganisationPatch;
  OrganisationToManyApplicationFilter: OrganisationToManyApplicationFilter;
  OrganisationToManyApplicationNoteFilter: OrganisationToManyApplicationNoteFilter;
  OrganisationToManyDataChangelogFilter: OrganisationToManyDataChangelogFilter;
  OrganisationToManyOrganisationApplicationJoinFilter: OrganisationToManyOrganisationApplicationJoinFilter;
  OrganisationToManyPermissionJoinFilter: OrganisationToManyPermissionJoinFilter;
  OrganisationToManyReviewAssignmentAssignerJoinFilter: OrganisationToManyReviewAssignmentAssignerJoinFilter;
  OrganisationToManyReviewAssignmentFilter: OrganisationToManyReviewAssignmentFilter;
  OrganisationToManyUserOrganisationFilter: OrganisationToManyUserOrganisationFilter;
  OrganisationsConnection: OrganisationsConnection;
  OrganisationsEdge: OrganisationsEdge;
  PageInfo: PageInfo;
  PermissionFlattened: PermissionFlattened;
  PermissionFlattenedCondition: PermissionFlattenedCondition;
  PermissionFlattenedFilter: PermissionFlattenedFilter;
  PermissionFlattenedsConnection: PermissionFlattenedsConnection;
  PermissionFlattenedsEdge: PermissionFlattenedsEdge;
  PermissionJoin: PermissionJoin;
  PermissionJoinCondition: PermissionJoinCondition;
  PermissionJoinFilter: PermissionJoinFilter;
  PermissionJoinInput: PermissionJoinInput;
  PermissionJoinNodeIdConnect: PermissionJoinNodeIdConnect;
  PermissionJoinNodeIdDelete: PermissionJoinNodeIdDelete;
  PermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0UsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0UsingPermissionJoinPkeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyNodeIdUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyUsingPermissionJoinPkeyUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate: PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate;
  PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate: PermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionJoinPkeyUpdate;
  PermissionJoinOrganisationIdFkeyInput: PermissionJoinOrganisationIdFkeyInput;
  PermissionJoinOrganisationIdFkeyInverseInput: PermissionJoinOrganisationIdFkeyInverseInput;
  PermissionJoinOrganisationIdFkeyOrganisationCreateInput: PermissionJoinOrganisationIdFkeyOrganisationCreateInput;
  PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput: PermissionJoinOrganisationIdFkeyPermissionJoinCreateInput;
  PermissionJoinPatch: PermissionJoinPatch;
  PermissionJoinPermissionJoinPkeyConnect: PermissionJoinPermissionJoinPkeyConnect;
  PermissionJoinPermissionJoinPkeyDelete: PermissionJoinPermissionJoinPkeyDelete;
  PermissionJoinPermissionNameIdFkeyInput: PermissionJoinPermissionNameIdFkeyInput;
  PermissionJoinPermissionNameIdFkeyInverseInput: PermissionJoinPermissionNameIdFkeyInverseInput;
  PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput: PermissionJoinPermissionNameIdFkeyPermissionJoinCreateInput;
  PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput: PermissionJoinPermissionNameIdFkeyPermissionNameCreateInput;
  PermissionJoinsConnection: PermissionJoinsConnection;
  PermissionJoinsEdge: PermissionJoinsEdge;
  PermissionName: PermissionName;
  PermissionNameCondition: PermissionNameCondition;
  PermissionNameFilter: PermissionNameFilter;
  PermissionNameInput: PermissionNameInput;
  PermissionNameNodeIdConnect: PermissionNameNodeIdConnect;
  PermissionNameNodeIdDelete: PermissionNameNodeIdDelete;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyNodeIdUpdate;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyUsingPermissionNamePkeyUpdate;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionNamePkeyUpdate;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNameNameKeyUpdate;
  PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate: PermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingPermissionNamePkeyUpdate;
  PermissionNamePatch: PermissionNamePatch;
  PermissionNamePermissionNameNameKeyConnect: PermissionNamePermissionNameNameKeyConnect;
  PermissionNamePermissionNameNameKeyDelete: PermissionNamePermissionNameNameKeyDelete;
  PermissionNamePermissionNamePkeyConnect: PermissionNamePermissionNamePkeyConnect;
  PermissionNamePermissionNamePkeyDelete: PermissionNamePermissionNamePkeyDelete;
  PermissionNamePermissionPolicyIdFkeyInput: PermissionNamePermissionPolicyIdFkeyInput;
  PermissionNamePermissionPolicyIdFkeyInverseInput: PermissionNamePermissionPolicyIdFkeyInverseInput;
  PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput: PermissionNamePermissionPolicyIdFkeyPermissionNameCreateInput;
  PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput: PermissionNamePermissionPolicyIdFkeyPermissionPolicyCreateInput;
  PermissionNameToManyPermissionJoinFilter: PermissionNameToManyPermissionJoinFilter;
  PermissionNameToManyTemplatePermissionFilter: PermissionNameToManyTemplatePermissionFilter;
  PermissionNamesConnection: PermissionNamesConnection;
  PermissionNamesEdge: PermissionNamesEdge;
  PermissionPoliciesConnection: PermissionPoliciesConnection;
  PermissionPoliciesEdge: PermissionPoliciesEdge;
  PermissionPolicy: PermissionPolicy;
  PermissionPolicyCondition: PermissionPolicyCondition;
  PermissionPolicyFilter: PermissionPolicyFilter;
  PermissionPolicyInput: PermissionPolicyInput;
  PermissionPolicyNodeIdConnect: PermissionPolicyNodeIdConnect;
  PermissionPolicyNodeIdDelete: PermissionPolicyNodeIdDelete;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyNodeIdUpdate;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyNameKeyUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyNameKeyUpdate;
  PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate: PermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyUsingPermissionPolicyPkeyUpdate;
  PermissionPolicyPatch: PermissionPolicyPatch;
  PermissionPolicyPermissionPolicyNameKeyConnect: PermissionPolicyPermissionPolicyNameKeyConnect;
  PermissionPolicyPermissionPolicyNameKeyDelete: PermissionPolicyPermissionPolicyNameKeyDelete;
  PermissionPolicyPermissionPolicyPkeyConnect: PermissionPolicyPermissionPolicyPkeyConnect;
  PermissionPolicyPermissionPolicyPkeyDelete: PermissionPolicyPermissionPolicyPkeyDelete;
  PermissionPolicyToManyPermissionNameFilter: PermissionPolicyToManyPermissionNameFilter;
  PermissionPolicyTypeFilter: PermissionPolicyTypeFilter;
  PermissionsAll: PermissionsAll;
  PermissionsAllCondition: PermissionsAllCondition;
  PermissionsAllFilter: PermissionsAllFilter;
  PermissionsAllsConnection: PermissionsAllsConnection;
  PermissionsAllsEdge: PermissionsAllsEdge;
  PostgresRowLevel: PostgresRowLevel;
  PostgresRowLevelCondition: PostgresRowLevelCondition;
  PostgresRowLevelFilter: PostgresRowLevelFilter;
  PostgresRowLevelsConnection: PostgresRowLevelsConnection;
  PostgresRowLevelsEdge: PostgresRowLevelsEdge;
  Query: {};
  Review: Review;
  ReviewApplicationIdFkeyApplicationCreateInput: ReviewApplicationIdFkeyApplicationCreateInput;
  ReviewApplicationIdFkeyInput: ReviewApplicationIdFkeyInput;
  ReviewApplicationIdFkeyInverseInput: ReviewApplicationIdFkeyInverseInput;
  ReviewApplicationIdFkeyReviewCreateInput: ReviewApplicationIdFkeyReviewCreateInput;
  ReviewAssignment: ReviewAssignment;
  ReviewAssignmentApplicationIdFkeyApplicationCreateInput: ReviewAssignmentApplicationIdFkeyApplicationCreateInput;
  ReviewAssignmentApplicationIdFkeyInput: ReviewAssignmentApplicationIdFkeyInput;
  ReviewAssignmentApplicationIdFkeyInverseInput: ReviewAssignmentApplicationIdFkeyInverseInput;
  ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput: ReviewAssignmentApplicationIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentAssignedSectionsShape: ReviewAssignmentAssignedSectionsShape;
  ReviewAssignmentAssignedSectionsShapeCondition: ReviewAssignmentAssignedSectionsShapeCondition;
  ReviewAssignmentAssignedSectionsShapeFilter: ReviewAssignmentAssignedSectionsShapeFilter;
  ReviewAssignmentAssignedSectionsShapeInput: ReviewAssignmentAssignedSectionsShapeInput;
  ReviewAssignmentAssignedSectionsShapesConnection: ReviewAssignmentAssignedSectionsShapesConnection;
  ReviewAssignmentAssignedSectionsShapesEdge: ReviewAssignmentAssignedSectionsShapesEdge;
  ReviewAssignmentAssignerJoin: ReviewAssignmentAssignerJoin;
  ReviewAssignmentAssignerJoinCondition: ReviewAssignmentAssignerJoinCondition;
  ReviewAssignmentAssignerJoinFilter: ReviewAssignmentAssignerJoinFilter;
  ReviewAssignmentAssignerJoinInput: ReviewAssignmentAssignerJoinInput;
  ReviewAssignmentAssignerJoinNodeIdConnect: ReviewAssignmentAssignerJoinNodeIdConnect;
  ReviewAssignmentAssignerJoinNodeIdDelete: ReviewAssignmentAssignerJoinNodeIdDelete;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0UsingReviewAssignmentAssignerJoinPkeyUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0UsingReviewAssignmentAssignerJoinPkeyUpdate;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyNodeIdUpdate;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate: ReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentAssignerJoinPkeyUpdate;
  ReviewAssignmentAssignerJoinOrganisationIdFkeyInput: ReviewAssignmentAssignerJoinOrganisationIdFkeyInput;
  ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput: ReviewAssignmentAssignerJoinOrganisationIdFkeyInverseInput;
  ReviewAssignmentAssignerJoinOrganisationIdFkeyOrganisationCreateInput: ReviewAssignmentAssignerJoinOrganisationIdFkeyOrganisationCreateInput;
  ReviewAssignmentAssignerJoinOrganisationIdFkeyReviewAssignmentAssignerJoinCreateInput: ReviewAssignmentAssignerJoinOrganisationIdFkeyReviewAssignmentAssignerJoinCreateInput;
  ReviewAssignmentAssignerJoinPatch: ReviewAssignmentAssignerJoinPatch;
  ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect: ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyConnect;
  ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete: ReviewAssignmentAssignerJoinReviewAssignmentAssignerJoinPkeyDelete;
  ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput: ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInput;
  ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput: ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyInverseInput;
  ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentAssignerJoinCreateInput: ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentAssignerJoinCreateInput;
  ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentCreateInput: ReviewAssignmentAssignerJoinReviewAssignmentIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentAssignerJoinsConnection: ReviewAssignmentAssignerJoinsConnection;
  ReviewAssignmentAssignerJoinsEdge: ReviewAssignmentAssignerJoinsEdge;
  ReviewAssignmentCondition: ReviewAssignmentCondition;
  ReviewAssignmentFilter: ReviewAssignmentFilter;
  ReviewAssignmentInput: ReviewAssignmentInput;
  ReviewAssignmentLevelIdFkeyInput: ReviewAssignmentLevelIdFkeyInput;
  ReviewAssignmentLevelIdFkeyInverseInput: ReviewAssignmentLevelIdFkeyInverseInput;
  ReviewAssignmentLevelIdFkeyReviewAssignmentCreateInput: ReviewAssignmentLevelIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentLevelIdFkeyTemplateStageReviewLevelCreateInput: ReviewAssignmentLevelIdFkeyTemplateStageReviewLevelCreateInput;
  ReviewAssignmentNodeIdConnect: ReviewAssignmentNodeIdConnect;
  ReviewAssignmentNodeIdDelete: ReviewAssignmentNodeIdDelete;
  ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0UsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0UsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1UsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1UsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate: ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate: ReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyUsingReviewAssignmentPkeyUpdate;
  ReviewAssignmentOrganisationIdFkeyInput: ReviewAssignmentOrganisationIdFkeyInput;
  ReviewAssignmentOrganisationIdFkeyInverseInput: ReviewAssignmentOrganisationIdFkeyInverseInput;
  ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput: ReviewAssignmentOrganisationIdFkeyOrganisationCreateInput;
  ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput: ReviewAssignmentOrganisationIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentPatch: ReviewAssignmentPatch;
  ReviewAssignmentReviewAssignmentPkeyConnect: ReviewAssignmentReviewAssignmentPkeyConnect;
  ReviewAssignmentReviewAssignmentPkeyDelete: ReviewAssignmentReviewAssignmentPkeyDelete;
  ReviewAssignmentStageIdFkeyInput: ReviewAssignmentStageIdFkeyInput;
  ReviewAssignmentStageIdFkeyInverseInput: ReviewAssignmentStageIdFkeyInverseInput;
  ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput: ReviewAssignmentStageIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentStageIdFkeyTemplateStageCreateInput: ReviewAssignmentStageIdFkeyTemplateStageCreateInput;
  ReviewAssignmentStatusFilter: ReviewAssignmentStatusFilter;
  ReviewAssignmentTemplateIdFkeyInput: ReviewAssignmentTemplateIdFkeyInput;
  ReviewAssignmentTemplateIdFkeyInverseInput: ReviewAssignmentTemplateIdFkeyInverseInput;
  ReviewAssignmentTemplateIdFkeyReviewAssignmentCreateInput: ReviewAssignmentTemplateIdFkeyReviewAssignmentCreateInput;
  ReviewAssignmentTemplateIdFkeyTemplateCreateInput: ReviewAssignmentTemplateIdFkeyTemplateCreateInput;
  ReviewAssignmentToManyReviewAssignmentAssignerJoinFilter: ReviewAssignmentToManyReviewAssignmentAssignerJoinFilter;
  ReviewAssignmentsConnection: ReviewAssignmentsConnection;
  ReviewAssignmentsEdge: ReviewAssignmentsEdge;
  ReviewCondition: ReviewCondition;
  ReviewDecision: ReviewDecision;
  ReviewDecisionCondition: ReviewDecisionCondition;
  ReviewDecisionFilter: ReviewDecisionFilter;
  ReviewDecisionInput: ReviewDecisionInput;
  ReviewDecisionNodeIdConnect: ReviewDecisionNodeIdConnect;
  ReviewDecisionNodeIdDelete: ReviewDecisionNodeIdDelete;
  ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate: ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate;
  ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate: ReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewDecisionPkeyUpdate;
  ReviewDecisionPatch: ReviewDecisionPatch;
  ReviewDecisionReviewDecisionPkeyConnect: ReviewDecisionReviewDecisionPkeyConnect;
  ReviewDecisionReviewDecisionPkeyDelete: ReviewDecisionReviewDecisionPkeyDelete;
  ReviewDecisionReviewIdFkeyInput: ReviewDecisionReviewIdFkeyInput;
  ReviewDecisionReviewIdFkeyInverseInput: ReviewDecisionReviewIdFkeyInverseInput;
  ReviewDecisionReviewIdFkeyReviewCreateInput: ReviewDecisionReviewIdFkeyReviewCreateInput;
  ReviewDecisionReviewIdFkeyReviewDecisionCreateInput: ReviewDecisionReviewIdFkeyReviewDecisionCreateInput;
  ReviewDecisionsConnection: ReviewDecisionsConnection;
  ReviewDecisionsEdge: ReviewDecisionsEdge;
  ReviewFilter: ReviewFilter;
  ReviewInput: ReviewInput;
  ReviewListConnection: ReviewListConnection;
  ReviewListEdge: ReviewListEdge;
  ReviewListRecord: ReviewListRecord;
  ReviewListRecordFilter: ReviewListRecordFilter;
  ReviewNodeIdConnect: ReviewNodeIdConnect;
  ReviewNodeIdDelete: ReviewNodeIdDelete;
  ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate: ReviewOnNotificationForNotificationReviewIdFkeyNodeIdUpdate;
  ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewPkeyUpdate;
  ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnNotificationForNotificationReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyNodeIdUpdate;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewDecisionForReviewDecisionReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewPkeyUpdate: ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewPkeyUpdate;
  ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewForFakePublicReviewForeignKey0UsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate: ReviewOnReviewForReviewApplicationIdFkeyNodeIdUpdate;
  ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewApplicationIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewForReviewApplicationIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewForReviewApplicationIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyNodeIdUpdate;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewForReviewReviewAssignmentIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewPkeyUpdate;
  ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate: ReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewReviewAssignmentIdKeyUpdate;
  ReviewPatch: ReviewPatch;
  ReviewResponse: ReviewResponse;
  ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput: ReviewResponseApplicationResponseIdFkeyApplicationResponseCreateInput;
  ReviewResponseApplicationResponseIdFkeyInput: ReviewResponseApplicationResponseIdFkeyInput;
  ReviewResponseApplicationResponseIdFkeyInverseInput: ReviewResponseApplicationResponseIdFkeyInverseInput;
  ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput: ReviewResponseApplicationResponseIdFkeyReviewResponseCreateInput;
  ReviewResponseCondition: ReviewResponseCondition;
  ReviewResponseDecisionFilter: ReviewResponseDecisionFilter;
  ReviewResponseFilter: ReviewResponseFilter;
  ReviewResponseInput: ReviewResponseInput;
  ReviewResponseNodeIdConnect: ReviewResponseNodeIdConnect;
  ReviewResponseNodeIdDelete: ReviewResponseNodeIdDelete;
  ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate: ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate;
  ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate: ReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingReviewResponsePkeyUpdate;
  ReviewResponseOriginalReviewResponseIdFkeyInput: ReviewResponseOriginalReviewResponseIdFkeyInput;
  ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput: ReviewResponseOriginalReviewResponseIdFkeyReviewResponseCreateInput;
  ReviewResponsePatch: ReviewResponsePatch;
  ReviewResponseRecommendedApplicantVisibilityFilter: ReviewResponseRecommendedApplicantVisibilityFilter;
  ReviewResponseReviewIdFkeyInput: ReviewResponseReviewIdFkeyInput;
  ReviewResponseReviewIdFkeyInverseInput: ReviewResponseReviewIdFkeyInverseInput;
  ReviewResponseReviewIdFkeyReviewCreateInput: ReviewResponseReviewIdFkeyReviewCreateInput;
  ReviewResponseReviewIdFkeyReviewResponseCreateInput: ReviewResponseReviewIdFkeyReviewResponseCreateInput;
  ReviewResponseReviewResponseLinkIdFkeyInput: ReviewResponseReviewResponseLinkIdFkeyInput;
  ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput: ReviewResponseReviewResponseLinkIdFkeyReviewResponseCreateInput;
  ReviewResponseReviewResponsePkeyConnect: ReviewResponseReviewResponsePkeyConnect;
  ReviewResponseReviewResponsePkeyDelete: ReviewResponseReviewResponsePkeyDelete;
  ReviewResponseStatusFilter: ReviewResponseStatusFilter;
  ReviewResponseTemplateElementIdFkeyInput: ReviewResponseTemplateElementIdFkeyInput;
  ReviewResponseTemplateElementIdFkeyInverseInput: ReviewResponseTemplateElementIdFkeyInverseInput;
  ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput: ReviewResponseTemplateElementIdFkeyReviewResponseCreateInput;
  ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput: ReviewResponseTemplateElementIdFkeyTemplateElementCreateInput;
  ReviewResponseToManyReviewResponseFilter: ReviewResponseToManyReviewResponseFilter;
  ReviewResponsesConnection: ReviewResponsesConnection;
  ReviewResponsesEdge: ReviewResponsesEdge;
  ReviewReviewAssignmentIdFkeyInput: ReviewReviewAssignmentIdFkeyInput;
  ReviewReviewAssignmentIdFkeyInverseInput: ReviewReviewAssignmentIdFkeyInverseInput;
  ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput: ReviewReviewAssignmentIdFkeyReviewAssignmentCreateInput;
  ReviewReviewAssignmentIdFkeyReviewCreateInput: ReviewReviewAssignmentIdFkeyReviewCreateInput;
  ReviewReviewPkeyConnect: ReviewReviewPkeyConnect;
  ReviewReviewPkeyDelete: ReviewReviewPkeyDelete;
  ReviewReviewReviewAssignmentIdKeyConnect: ReviewReviewReviewAssignmentIdKeyConnect;
  ReviewReviewReviewAssignmentIdKeyDelete: ReviewReviewReviewAssignmentIdKeyDelete;
  ReviewStatusFilter: ReviewStatusFilter;
  ReviewStatusHistoriesConnection: ReviewStatusHistoriesConnection;
  ReviewStatusHistoriesEdge: ReviewStatusHistoriesEdge;
  ReviewStatusHistory: ReviewStatusHistory;
  ReviewStatusHistoryCondition: ReviewStatusHistoryCondition;
  ReviewStatusHistoryFilter: ReviewStatusHistoryFilter;
  ReviewStatusHistoryInput: ReviewStatusHistoryInput;
  ReviewStatusHistoryNodeIdConnect: ReviewStatusHistoryNodeIdConnect;
  ReviewStatusHistoryNodeIdDelete: ReviewStatusHistoryNodeIdDelete;
  ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate: ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyNodeIdUpdate;
  ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate: ReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyUsingReviewStatusHistoryPkeyUpdate;
  ReviewStatusHistoryPatch: ReviewStatusHistoryPatch;
  ReviewStatusHistoryReviewIdFkeyInput: ReviewStatusHistoryReviewIdFkeyInput;
  ReviewStatusHistoryReviewIdFkeyInverseInput: ReviewStatusHistoryReviewIdFkeyInverseInput;
  ReviewStatusHistoryReviewIdFkeyReviewCreateInput: ReviewStatusHistoryReviewIdFkeyReviewCreateInput;
  ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput: ReviewStatusHistoryReviewIdFkeyReviewStatusHistoryCreateInput;
  ReviewStatusHistoryReviewStatusHistoryPkeyConnect: ReviewStatusHistoryReviewStatusHistoryPkeyConnect;
  ReviewStatusHistoryReviewStatusHistoryPkeyDelete: ReviewStatusHistoryReviewStatusHistoryPkeyDelete;
  ReviewToManyNotificationFilter: ReviewToManyNotificationFilter;
  ReviewToManyReviewDecisionFilter: ReviewToManyReviewDecisionFilter;
  ReviewToManyReviewResponseFilter: ReviewToManyReviewResponseFilter;
  ReviewToManyReviewStatusHistoryFilter: ReviewToManyReviewStatusHistoryFilter;
  ReviewabilityFilter: ReviewabilityFilter;
  ReviewableQuestionEdge: ReviewableQuestionEdge;
  ReviewableQuestionsConnection: ReviewableQuestionsConnection;
  ReviewableQuestionsRecord: ReviewableQuestionsRecord;
  ReviewableQuestionsRecordFilter: ReviewableQuestionsRecordFilter;
  ReviewerActionFilter: ReviewerActionFilter;
  ReviewsConnection: ReviewsConnection;
  ReviewsEdge: ReviewsEdge;
  SchemaColumn: SchemaColumn;
  SchemaColumnCondition: SchemaColumnCondition;
  SchemaColumnFilter: SchemaColumnFilter;
  SchemaColumnsConnection: SchemaColumnsConnection;
  SchemaColumnsEdge: SchemaColumnsEdge;
  SingleApplicationDetailConnection: SingleApplicationDetailConnection;
  SingleApplicationDetailEdge: SingleApplicationDetailEdge;
  SingleApplicationDetailRecord: SingleApplicationDetailRecord;
  SingleApplicationDetailRecordFilter: SingleApplicationDetailRecordFilter;
  SqlIdentifier: Scalars['SqlIdentifier']['output'];
  SqlIdentifierFilter: SqlIdentifierFilter;
  String: Scalars['String']['output'];
  StringFilter: StringFilter;
  StringListFilter: StringListFilter;
  SystemInfo: SystemInfo;
  SystemInfoCondition: SystemInfoCondition;
  SystemInfoFilter: SystemInfoFilter;
  SystemInfoInput: SystemInfoInput;
  SystemInfoPatch: SystemInfoPatch;
  SystemInfosConnection: SystemInfosConnection;
  SystemInfosEdge: SystemInfosEdge;
  Template: Template;
  TemplateAction: TemplateAction;
  TemplateActionCondition: TemplateActionCondition;
  TemplateActionFilter: TemplateActionFilter;
  TemplateActionInput: TemplateActionInput;
  TemplateActionNodeIdConnect: TemplateActionNodeIdConnect;
  TemplateActionNodeIdDelete: TemplateActionNodeIdDelete;
  TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate: TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate;
  TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate: TemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateActionPkeyUpdate;
  TemplateActionPatch: TemplateActionPatch;
  TemplateActionTemplateActionPkeyConnect: TemplateActionTemplateActionPkeyConnect;
  TemplateActionTemplateActionPkeyDelete: TemplateActionTemplateActionPkeyDelete;
  TemplateActionTemplateIdFkeyInput: TemplateActionTemplateIdFkeyInput;
  TemplateActionTemplateIdFkeyInverseInput: TemplateActionTemplateIdFkeyInverseInput;
  TemplateActionTemplateIdFkeyTemplateActionCreateInput: TemplateActionTemplateIdFkeyTemplateActionCreateInput;
  TemplateActionTemplateIdFkeyTemplateCreateInput: TemplateActionTemplateIdFkeyTemplateCreateInput;
  TemplateActionsConnection: TemplateActionsConnection;
  TemplateActionsEdge: TemplateActionsEdge;
  TemplateCategoriesConnection: TemplateCategoriesConnection;
  TemplateCategoriesEdge: TemplateCategoriesEdge;
  TemplateCategory: TemplateCategory;
  TemplateCategoryCondition: TemplateCategoryCondition;
  TemplateCategoryFilter: TemplateCategoryFilter;
  TemplateCategoryInput: TemplateCategoryInput;
  TemplateCategoryNodeIdConnect: TemplateCategoryNodeIdConnect;
  TemplateCategoryNodeIdDelete: TemplateCategoryNodeIdDelete;
  TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate: TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate;
  TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryCodeKeyUpdate: TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryCodeKeyUpdate;
  TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryPkeyUpdate: TemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCategoryPkeyUpdate;
  TemplateCategoryPatch: TemplateCategoryPatch;
  TemplateCategoryTemplateCategoryCodeKeyConnect: TemplateCategoryTemplateCategoryCodeKeyConnect;
  TemplateCategoryTemplateCategoryCodeKeyDelete: TemplateCategoryTemplateCategoryCodeKeyDelete;
  TemplateCategoryTemplateCategoryPkeyConnect: TemplateCategoryTemplateCategoryPkeyConnect;
  TemplateCategoryTemplateCategoryPkeyDelete: TemplateCategoryTemplateCategoryPkeyDelete;
  TemplateCategoryToManyTemplateFilter: TemplateCategoryToManyTemplateFilter;
  TemplateCondition: TemplateCondition;
  TemplateElement: TemplateElement;
  TemplateElementCategoryFilter: TemplateElementCategoryFilter;
  TemplateElementCondition: TemplateElementCondition;
  TemplateElementFilter: TemplateElementFilter;
  TemplateElementInput: TemplateElementInput;
  TemplateElementNodeIdConnect: TemplateElementNodeIdConnect;
  TemplateElementNodeIdDelete: TemplateElementNodeIdDelete;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyNodeIdUpdate;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate: TemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyNodeIdUpdate;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementPkeyUpdate;
  TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate: TemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementPkeyUpdate;
  TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate: TemplateElementOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateElementTemplateCodeCodeTemplateVersionKeyUpdate;
  TemplateElementPatch: TemplateElementPatch;
  TemplateElementSectionIdFkeyInput: TemplateElementSectionIdFkeyInput;
  TemplateElementSectionIdFkeyInverseInput: TemplateElementSectionIdFkeyInverseInput;
  TemplateElementSectionIdFkeyTemplateElementCreateInput: TemplateElementSectionIdFkeyTemplateElementCreateInput;
  TemplateElementSectionIdFkeyTemplateSectionCreateInput: TemplateElementSectionIdFkeyTemplateSectionCreateInput;
  TemplateElementTemplateElementPkeyConnect: TemplateElementTemplateElementPkeyConnect;
  TemplateElementTemplateElementPkeyDelete: TemplateElementTemplateElementPkeyDelete;
  TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect: TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyConnect;
  TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete: TemplateElementTemplateElementTemplateCodeCodeTemplateVersionKeyDelete;
  TemplateElementToManyApplicationResponseFilter: TemplateElementToManyApplicationResponseFilter;
  TemplateElementToManyReviewResponseFilter: TemplateElementToManyReviewResponseFilter;
  TemplateElementsConnection: TemplateElementsConnection;
  TemplateElementsEdge: TemplateElementsEdge;
  TemplateFilter: TemplateFilter;
  TemplateFilterJoin: TemplateFilterJoin;
  TemplateFilterJoinCondition: TemplateFilterJoinCondition;
  TemplateFilterJoinFilter: TemplateFilterJoinFilter;
  TemplateFilterJoinFilterIdFkeyFilterCreateInput: TemplateFilterJoinFilterIdFkeyFilterCreateInput;
  TemplateFilterJoinFilterIdFkeyInput: TemplateFilterJoinFilterIdFkeyInput;
  TemplateFilterJoinFilterIdFkeyInverseInput: TemplateFilterJoinFilterIdFkeyInverseInput;
  TemplateFilterJoinFilterIdFkeyTemplateFilterJoinCreateInput: TemplateFilterJoinFilterIdFkeyTemplateFilterJoinCreateInput;
  TemplateFilterJoinInput: TemplateFilterJoinInput;
  TemplateFilterJoinNodeIdConnect: TemplateFilterJoinNodeIdConnect;
  TemplateFilterJoinNodeIdDelete: TemplateFilterJoinNodeIdDelete;
  TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate: TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyNodeIdUpdate;
  TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingTemplateFilterJoinPkeyUpdate: TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyUsingTemplateFilterJoinPkeyUpdate;
  TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate: TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate;
  TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateFilterJoinPkeyUpdate: TemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateFilterJoinPkeyUpdate;
  TemplateFilterJoinPatch: TemplateFilterJoinPatch;
  TemplateFilterJoinTemplateFilterJoinPkeyConnect: TemplateFilterJoinTemplateFilterJoinPkeyConnect;
  TemplateFilterJoinTemplateFilterJoinPkeyDelete: TemplateFilterJoinTemplateFilterJoinPkeyDelete;
  TemplateFilterJoinTemplateIdFkeyInput: TemplateFilterJoinTemplateIdFkeyInput;
  TemplateFilterJoinTemplateIdFkeyInverseInput: TemplateFilterJoinTemplateIdFkeyInverseInput;
  TemplateFilterJoinTemplateIdFkeyTemplateCreateInput: TemplateFilterJoinTemplateIdFkeyTemplateCreateInput;
  TemplateFilterJoinTemplateIdFkeyTemplateFilterJoinCreateInput: TemplateFilterJoinTemplateIdFkeyTemplateFilterJoinCreateInput;
  TemplateFilterJoinsConnection: TemplateFilterJoinsConnection;
  TemplateFilterJoinsEdge: TemplateFilterJoinsEdge;
  TemplateInput: TemplateInput;
  TemplateNodeIdConnect: TemplateNodeIdConnect;
  TemplateNodeIdDelete: TemplateNodeIdDelete;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyNodeIdUpdate;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnActionQueueForActionQueueTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyNodeIdUpdate;
  TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnApplicationForApplicationTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnFileForFileTemplateIdFkeyNodeIdUpdate: TemplateOnFileForFileTemplateIdFkeyNodeIdUpdate;
  TemplateOnFileForFileTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnFileForFileTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnFileForFileTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnFileForFileTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate: TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyNodeIdUpdate;
  TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateActionForTemplateActionTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate: TemplateOnTemplateForTemplateTemplateCategoryIdFkeyNodeIdUpdate;
  TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateForTemplateTemplateCategoryIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate: TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate;
  TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate: TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplateCodeVersionIdKeyUpdate;
  TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplatePkeyUpdate: TemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTemplatePkeyUpdate;
  TemplatePatch: TemplatePatch;
  TemplatePermission: TemplatePermission;
  TemplatePermissionCondition: TemplatePermissionCondition;
  TemplatePermissionFilter: TemplatePermissionFilter;
  TemplatePermissionInput: TemplatePermissionInput;
  TemplatePermissionNodeIdConnect: TemplatePermissionNodeIdConnect;
  TemplatePermissionNodeIdDelete: TemplatePermissionNodeIdDelete;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyNodeIdUpdate;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyUsingTemplatePermissionPkeyUpdate;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyNodeIdUpdate;
  TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate: TemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyUsingTemplatePermissionPkeyUpdate;
  TemplatePermissionPatch: TemplatePermissionPatch;
  TemplatePermissionPermissionNameIdFkeyInput: TemplatePermissionPermissionNameIdFkeyInput;
  TemplatePermissionPermissionNameIdFkeyInverseInput: TemplatePermissionPermissionNameIdFkeyInverseInput;
  TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput: TemplatePermissionPermissionNameIdFkeyPermissionNameCreateInput;
  TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput: TemplatePermissionPermissionNameIdFkeyTemplatePermissionCreateInput;
  TemplatePermissionTemplateIdFkeyInput: TemplatePermissionTemplateIdFkeyInput;
  TemplatePermissionTemplateIdFkeyInverseInput: TemplatePermissionTemplateIdFkeyInverseInput;
  TemplatePermissionTemplateIdFkeyTemplateCreateInput: TemplatePermissionTemplateIdFkeyTemplateCreateInput;
  TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput: TemplatePermissionTemplateIdFkeyTemplatePermissionCreateInput;
  TemplatePermissionTemplatePermissionPkeyConnect: TemplatePermissionTemplatePermissionPkeyConnect;
  TemplatePermissionTemplatePermissionPkeyDelete: TemplatePermissionTemplatePermissionPkeyDelete;
  TemplatePermissionsConnection: TemplatePermissionsConnection;
  TemplatePermissionsEdge: TemplatePermissionsEdge;
  TemplateSection: TemplateSection;
  TemplateSectionCondition: TemplateSectionCondition;
  TemplateSectionFilter: TemplateSectionFilter;
  TemplateSectionInput: TemplateSectionInput;
  TemplateSectionNodeIdConnect: TemplateSectionNodeIdConnect;
  TemplateSectionNodeIdDelete: TemplateSectionNodeIdDelete;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyNodeIdUpdate;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionPkeyUpdate;
  TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate: TemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyNodeIdUpdate;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionPkeyUpdate;
  TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate: TemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyUsingTemplateSectionTemplateIdCodeKeyUpdate;
  TemplateSectionPatch: TemplateSectionPatch;
  TemplateSectionTemplateIdFkeyInput: TemplateSectionTemplateIdFkeyInput;
  TemplateSectionTemplateIdFkeyInverseInput: TemplateSectionTemplateIdFkeyInverseInput;
  TemplateSectionTemplateIdFkeyTemplateCreateInput: TemplateSectionTemplateIdFkeyTemplateCreateInput;
  TemplateSectionTemplateIdFkeyTemplateSectionCreateInput: TemplateSectionTemplateIdFkeyTemplateSectionCreateInput;
  TemplateSectionTemplateSectionPkeyConnect: TemplateSectionTemplateSectionPkeyConnect;
  TemplateSectionTemplateSectionPkeyDelete: TemplateSectionTemplateSectionPkeyDelete;
  TemplateSectionTemplateSectionTemplateIdCodeKeyConnect: TemplateSectionTemplateSectionTemplateIdCodeKeyConnect;
  TemplateSectionTemplateSectionTemplateIdCodeKeyDelete: TemplateSectionTemplateSectionTemplateIdCodeKeyDelete;
  TemplateSectionToManyTemplateElementFilter: TemplateSectionToManyTemplateElementFilter;
  TemplateSectionsConnection: TemplateSectionsConnection;
  TemplateSectionsEdge: TemplateSectionsEdge;
  TemplateStage: TemplateStage;
  TemplateStageCondition: TemplateStageCondition;
  TemplateStageFilter: TemplateStageFilter;
  TemplateStageInput: TemplateStageInput;
  TemplateStageNodeIdConnect: TemplateStageNodeIdConnect;
  TemplateStageNodeIdDelete: TemplateStageNodeIdDelete;
  TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate: TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyNodeIdUpdate;
  TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyUsingTemplateStagePkeyUpdate;
  TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate: TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyNodeIdUpdate;
  TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyUsingTemplateStagePkeyUpdate;
  TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate: TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyNodeIdUpdate;
  TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyUsingTemplateStagePkeyUpdate;
  TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate: TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate;
  TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStagePkeyUpdate: TemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStagePkeyUpdate;
  TemplateStagePatch: TemplateStagePatch;
  TemplateStageReviewLevel: TemplateStageReviewLevel;
  TemplateStageReviewLevelCondition: TemplateStageReviewLevelCondition;
  TemplateStageReviewLevelFilter: TemplateStageReviewLevelFilter;
  TemplateStageReviewLevelInput: TemplateStageReviewLevelInput;
  TemplateStageReviewLevelNodeIdConnect: TemplateStageReviewLevelNodeIdConnect;
  TemplateStageReviewLevelNodeIdDelete: TemplateStageReviewLevelNodeIdDelete;
  TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate: TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyNodeIdUpdate;
  TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingTemplateStageReviewLevelPkeyUpdate: TemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyUsingTemplateStageReviewLevelPkeyUpdate;
  TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate: TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyNodeIdUpdate;
  TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStageReviewLevelPkeyUpdate: TemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyUsingTemplateStageReviewLevelPkeyUpdate;
  TemplateStageReviewLevelPatch: TemplateStageReviewLevelPatch;
  TemplateStageReviewLevelStageIdFkeyInput: TemplateStageReviewLevelStageIdFkeyInput;
  TemplateStageReviewLevelStageIdFkeyInverseInput: TemplateStageReviewLevelStageIdFkeyInverseInput;
  TemplateStageReviewLevelStageIdFkeyTemplateStageCreateInput: TemplateStageReviewLevelStageIdFkeyTemplateStageCreateInput;
  TemplateStageReviewLevelStageIdFkeyTemplateStageReviewLevelCreateInput: TemplateStageReviewLevelStageIdFkeyTemplateStageReviewLevelCreateInput;
  TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect: TemplateStageReviewLevelTemplateStageReviewLevelPkeyConnect;
  TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete: TemplateStageReviewLevelTemplateStageReviewLevelPkeyDelete;
  TemplateStageReviewLevelToManyReviewAssignmentFilter: TemplateStageReviewLevelToManyReviewAssignmentFilter;
  TemplateStageReviewLevelsConnection: TemplateStageReviewLevelsConnection;
  TemplateStageReviewLevelsEdge: TemplateStageReviewLevelsEdge;
  TemplateStageTemplateIdFkeyInput: TemplateStageTemplateIdFkeyInput;
  TemplateStageTemplateIdFkeyInverseInput: TemplateStageTemplateIdFkeyInverseInput;
  TemplateStageTemplateIdFkeyTemplateCreateInput: TemplateStageTemplateIdFkeyTemplateCreateInput;
  TemplateStageTemplateIdFkeyTemplateStageCreateInput: TemplateStageTemplateIdFkeyTemplateStageCreateInput;
  TemplateStageTemplateStagePkeyConnect: TemplateStageTemplateStagePkeyConnect;
  TemplateStageTemplateStagePkeyDelete: TemplateStageTemplateStagePkeyDelete;
  TemplateStageToManyApplicationStageHistoryFilter: TemplateStageToManyApplicationStageHistoryFilter;
  TemplateStageToManyReviewAssignmentFilter: TemplateStageToManyReviewAssignmentFilter;
  TemplateStageToManyTemplateStageReviewLevelFilter: TemplateStageToManyTemplateStageReviewLevelFilter;
  TemplateStagesConnection: TemplateStagesConnection;
  TemplateStagesEdge: TemplateStagesEdge;
  TemplateStatusFilter: TemplateStatusFilter;
  TemplateTemplateCategoryIdFkeyInput: TemplateTemplateCategoryIdFkeyInput;
  TemplateTemplateCategoryIdFkeyInverseInput: TemplateTemplateCategoryIdFkeyInverseInput;
  TemplateTemplateCategoryIdFkeyTemplateCategoryCreateInput: TemplateTemplateCategoryIdFkeyTemplateCategoryCreateInput;
  TemplateTemplateCategoryIdFkeyTemplateCreateInput: TemplateTemplateCategoryIdFkeyTemplateCreateInput;
  TemplateTemplateCodeVersionIdKeyConnect: TemplateTemplateCodeVersionIdKeyConnect;
  TemplateTemplateCodeVersionIdKeyDelete: TemplateTemplateCodeVersionIdKeyDelete;
  TemplateTemplatePkeyConnect: TemplateTemplatePkeyConnect;
  TemplateTemplatePkeyDelete: TemplateTemplatePkeyDelete;
  TemplateToManyActionQueueFilter: TemplateToManyActionQueueFilter;
  TemplateToManyApplicationFilter: TemplateToManyApplicationFilter;
  TemplateToManyFileFilter: TemplateToManyFileFilter;
  TemplateToManyReviewAssignmentFilter: TemplateToManyReviewAssignmentFilter;
  TemplateToManyTemplateActionFilter: TemplateToManyTemplateActionFilter;
  TemplateToManyTemplateFilterJoinFilter: TemplateToManyTemplateFilterJoinFilter;
  TemplateToManyTemplatePermissionFilter: TemplateToManyTemplatePermissionFilter;
  TemplateToManyTemplateSectionFilter: TemplateToManyTemplateSectionFilter;
  TemplateToManyTemplateStageFilter: TemplateToManyTemplateStageFilter;
  TemplateToManyTriggerScheduleFilter: TemplateToManyTriggerScheduleFilter;
  TemplatesConnection: TemplatesConnection;
  TemplatesEdge: TemplatesEdge;
  TriggerFilter: TriggerFilter;
  TriggerQueue: TriggerQueue;
  TriggerQueueApplicationIdFkeyApplicationCreateInput: TriggerQueueApplicationIdFkeyApplicationCreateInput;
  TriggerQueueApplicationIdFkeyInput: TriggerQueueApplicationIdFkeyInput;
  TriggerQueueApplicationIdFkeyInverseInput: TriggerQueueApplicationIdFkeyInverseInput;
  TriggerQueueApplicationIdFkeyTriggerQueueCreateInput: TriggerQueueApplicationIdFkeyTriggerQueueCreateInput;
  TriggerQueueCondition: TriggerQueueCondition;
  TriggerQueueFilter: TriggerQueueFilter;
  TriggerQueueInput: TriggerQueueInput;
  TriggerQueueNodeIdConnect: TriggerQueueNodeIdConnect;
  TriggerQueueNodeIdDelete: TriggerQueueNodeIdDelete;
  TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate: TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyNodeIdUpdate;
  TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate: TriggerQueueOnActionQueueForActionQueueTriggerEventFkeyUsingTriggerQueuePkeyUpdate;
  TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate: TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyNodeIdUpdate;
  TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingTriggerQueuePkeyUpdate: TriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyUsingTriggerQueuePkeyUpdate;
  TriggerQueuePatch: TriggerQueuePatch;
  TriggerQueueStatusFilter: TriggerQueueStatusFilter;
  TriggerQueueToManyActionQueueFilter: TriggerQueueToManyActionQueueFilter;
  TriggerQueueTriggerQueuePkeyConnect: TriggerQueueTriggerQueuePkeyConnect;
  TriggerQueueTriggerQueuePkeyDelete: TriggerQueueTriggerQueuePkeyDelete;
  TriggerQueuesConnection: TriggerQueuesConnection;
  TriggerQueuesEdge: TriggerQueuesEdge;
  TriggerSchedule: TriggerSchedule;
  TriggerScheduleApplicationIdFkeyApplicationCreateInput: TriggerScheduleApplicationIdFkeyApplicationCreateInput;
  TriggerScheduleApplicationIdFkeyInput: TriggerScheduleApplicationIdFkeyInput;
  TriggerScheduleApplicationIdFkeyInverseInput: TriggerScheduleApplicationIdFkeyInverseInput;
  TriggerScheduleApplicationIdFkeyTriggerScheduleCreateInput: TriggerScheduleApplicationIdFkeyTriggerScheduleCreateInput;
  TriggerScheduleCondition: TriggerScheduleCondition;
  TriggerScheduleFilter: TriggerScheduleFilter;
  TriggerScheduleInput: TriggerScheduleInput;
  TriggerScheduleNodeIdConnect: TriggerScheduleNodeIdConnect;
  TriggerScheduleNodeIdDelete: TriggerScheduleNodeIdDelete;
  TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate: TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyNodeIdUpdate;
  TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingTriggerSchedulePkeyUpdate: TriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyUsingTriggerSchedulePkeyUpdate;
  TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate: TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyNodeIdUpdate;
  TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTriggerSchedulePkeyUpdate: TriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyUsingTriggerSchedulePkeyUpdate;
  TriggerSchedulePatch: TriggerSchedulePatch;
  TriggerScheduleTemplateIdFkeyInput: TriggerScheduleTemplateIdFkeyInput;
  TriggerScheduleTemplateIdFkeyInverseInput: TriggerScheduleTemplateIdFkeyInverseInput;
  TriggerScheduleTemplateIdFkeyTemplateCreateInput: TriggerScheduleTemplateIdFkeyTemplateCreateInput;
  TriggerScheduleTemplateIdFkeyTriggerScheduleCreateInput: TriggerScheduleTemplateIdFkeyTriggerScheduleCreateInput;
  TriggerScheduleTriggerSchedulePkeyConnect: TriggerScheduleTriggerSchedulePkeyConnect;
  TriggerScheduleTriggerSchedulePkeyDelete: TriggerScheduleTriggerSchedulePkeyDelete;
  TriggerSchedulesConnection: TriggerSchedulesConnection;
  TriggerSchedulesEdge: TriggerSchedulesEdge;
  UiLocationListFilter: UiLocationListFilter;
  UnnestedSection: UnnestedSection;
  UnnestedSectionCondition: UnnestedSectionCondition;
  UnnestedSectionFilter: UnnestedSectionFilter;
  UnnestedSectionsConnection: UnnestedSectionsConnection;
  UnnestedSectionsEdge: UnnestedSectionsEdge;
  UpdateActionPluginByCodeInput: UpdateActionPluginByCodeInput;
  UpdateActionPluginByNodeIdInput: UpdateActionPluginByNodeIdInput;
  UpdateActionPluginInput: UpdateActionPluginInput;
  UpdateActionPluginPayload: Omit<UpdateActionPluginPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateActionQueueByNodeIdInput: UpdateActionQueueByNodeIdInput;
  UpdateActionQueueInput: UpdateActionQueueInput;
  UpdateActionQueuePayload: Omit<UpdateActionQueuePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateActivityLogByNodeIdInput: UpdateActivityLogByNodeIdInput;
  UpdateActivityLogInput: UpdateActivityLogInput;
  UpdateActivityLogPayload: Omit<UpdateActivityLogPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateApplicationByNodeIdInput: UpdateApplicationByNodeIdInput;
  UpdateApplicationByOutcomeRegistrationInput: UpdateApplicationByOutcomeRegistrationInput;
  UpdateApplicationBySerialInput: UpdateApplicationBySerialInput;
  UpdateApplicationInput: UpdateApplicationInput;
  UpdateApplicationNoteByNodeIdInput: UpdateApplicationNoteByNodeIdInput;
  UpdateApplicationNoteInput: UpdateApplicationNoteInput;
  UpdateApplicationNotePayload: Omit<UpdateApplicationNotePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateApplicationPayload: Omit<UpdateApplicationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateApplicationResponseByNodeIdInput: UpdateApplicationResponseByNodeIdInput;
  UpdateApplicationResponseInput: UpdateApplicationResponseInput;
  UpdateApplicationResponsePayload: Omit<UpdateApplicationResponsePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateApplicationReviewerActionByNodeIdInput: UpdateApplicationReviewerActionByNodeIdInput;
  UpdateApplicationReviewerActionByUserIdAndApplicationIdInput: UpdateApplicationReviewerActionByUserIdAndApplicationIdInput;
  UpdateApplicationReviewerActionInput: UpdateApplicationReviewerActionInput;
  UpdateApplicationReviewerActionPayload: Omit<UpdateApplicationReviewerActionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateApplicationStageHistoryByNodeIdInput: UpdateApplicationStageHistoryByNodeIdInput;
  UpdateApplicationStageHistoryInput: UpdateApplicationStageHistoryInput;
  UpdateApplicationStageHistoryPayload: Omit<UpdateApplicationStageHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateApplicationStatusHistoryByNodeIdInput: UpdateApplicationStatusHistoryByNodeIdInput;
  UpdateApplicationStatusHistoryInput: UpdateApplicationStatusHistoryInput;
  UpdateApplicationStatusHistoryPayload: Omit<UpdateApplicationStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateCounterByNameInput: UpdateCounterByNameInput;
  UpdateCounterByNodeIdInput: UpdateCounterByNodeIdInput;
  UpdateCounterInput: UpdateCounterInput;
  UpdateCounterPayload: Omit<UpdateCounterPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataChangelogByNodeIdInput: UpdateDataChangelogByNodeIdInput;
  UpdateDataChangelogInput: UpdateDataChangelogInput;
  UpdateDataChangelogPayload: Omit<UpdateDataChangelogPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableActiveIngredientByNodeIdInput: UpdateDataTableActiveIngredientByNodeIdInput;
  UpdateDataTableActiveIngredientInput: UpdateDataTableActiveIngredientInput;
  UpdateDataTableActiveIngredientPayload: Omit<UpdateDataTableActiveIngredientPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableAdministrationRouteByNodeIdInput: UpdateDataTableAdministrationRouteByNodeIdInput;
  UpdateDataTableAdministrationRouteInput: UpdateDataTableAdministrationRouteInput;
  UpdateDataTableAdministrationRoutePayload: Omit<UpdateDataTableAdministrationRoutePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableAtcCodeByNodeIdInput: UpdateDataTableAtcCodeByNodeIdInput;
  UpdateDataTableAtcCodeInput: UpdateDataTableAtcCodeInput;
  UpdateDataTableAtcCodePayload: Omit<UpdateDataTableAtcCodePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableByNodeIdInput: UpdateDataTableByNodeIdInput;
  UpdateDataTableByTableNameInput: UpdateDataTableByTableNameInput;
  UpdateDataTableContainerByNodeIdInput: UpdateDataTableContainerByNodeIdInput;
  UpdateDataTableContainerInput: UpdateDataTableContainerInput;
  UpdateDataTableContainerPayload: Omit<UpdateDataTableContainerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableCountryByNodeIdInput: UpdateDataTableCountryByNodeIdInput;
  UpdateDataTableCountryInput: UpdateDataTableCountryInput;
  UpdateDataTableCountryPayload: Omit<UpdateDataTableCountryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableDosageFormByNodeIdInput: UpdateDataTableDosageFormByNodeIdInput;
  UpdateDataTableDosageFormGroupByNodeIdInput: UpdateDataTableDosageFormGroupByNodeIdInput;
  UpdateDataTableDosageFormGroupInput: UpdateDataTableDosageFormGroupInput;
  UpdateDataTableDosageFormGroupPayload: Omit<UpdateDataTableDosageFormGroupPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableDosageFormInput: UpdateDataTableDosageFormInput;
  UpdateDataTableDosageFormPayload: Omit<UpdateDataTableDosageFormPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableGenericIngredientByNodeIdInput: UpdateDataTableGenericIngredientByNodeIdInput;
  UpdateDataTableGenericIngredientInput: UpdateDataTableGenericIngredientInput;
  UpdateDataTableGenericIngredientPayload: Omit<UpdateDataTableGenericIngredientPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableInput: UpdateDataTableInput;
  UpdateDataTableManufacturerApplicationJoinByNodeIdInput: UpdateDataTableManufacturerApplicationJoinByNodeIdInput;
  UpdateDataTableManufacturerApplicationJoinInput: UpdateDataTableManufacturerApplicationJoinInput;
  UpdateDataTableManufacturerApplicationJoinPayload: Omit<UpdateDataTableManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableManufacturerByNodeIdInput: UpdateDataTableManufacturerByNodeIdInput;
  UpdateDataTableManufacturerInput: UpdateDataTableManufacturerInput;
  UpdateDataTableManufacturerPayload: Omit<UpdateDataTableManufacturerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput: UpdateDataTableManufacturerRepresentativeApplicationJoinByNodeIdInput;
  UpdateDataTableManufacturerRepresentativeApplicationJoinInput: UpdateDataTableManufacturerRepresentativeApplicationJoinInput;
  UpdateDataTableManufacturerRepresentativeApplicationJoinPayload: Omit<UpdateDataTableManufacturerRepresentativeApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableManufacturerRepresentativeByNodeIdInput: UpdateDataTableManufacturerRepresentativeByNodeIdInput;
  UpdateDataTableManufacturerRepresentativeInput: UpdateDataTableManufacturerRepresentativeInput;
  UpdateDataTableManufacturerRepresentativePayload: Omit<UpdateDataTableManufacturerRepresentativePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTablePayload: Omit<UpdateDataTablePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTablePermitChemicalApplicationJoinByNodeIdInput: UpdateDataTablePermitChemicalApplicationJoinByNodeIdInput;
  UpdateDataTablePermitChemicalApplicationJoinInput: UpdateDataTablePermitChemicalApplicationJoinInput;
  UpdateDataTablePermitChemicalApplicationJoinPayload: Omit<UpdateDataTablePermitChemicalApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTablePermitChemicalByNodeIdInput: UpdateDataTablePermitChemicalByNodeIdInput;
  UpdateDataTablePermitChemicalInput: UpdateDataTablePermitChemicalInput;
  UpdateDataTablePermitChemicalPayload: Omit<UpdateDataTablePermitChemicalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTablePreRegisteredProductsProvisionalByNodeIdInput: UpdateDataTablePreRegisteredProductsProvisionalByNodeIdInput;
  UpdateDataTablePreRegisteredProductsProvisionalInput: UpdateDataTablePreRegisteredProductsProvisionalInput;
  UpdateDataTablePreRegisteredProductsProvisionalPayload: Omit<UpdateDataTablePreRegisteredProductsProvisionalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTablePrequalManufacturerApplicationJoinByNodeIdInput: UpdateDataTablePrequalManufacturerApplicationJoinByNodeIdInput;
  UpdateDataTablePrequalManufacturerApplicationJoinInput: UpdateDataTablePrequalManufacturerApplicationJoinInput;
  UpdateDataTablePrequalManufacturerApplicationJoinPayload: Omit<UpdateDataTablePrequalManufacturerApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTablePrequalManufacturerByNodeIdInput: UpdateDataTablePrequalManufacturerByNodeIdInput;
  UpdateDataTablePrequalManufacturerInput: UpdateDataTablePrequalManufacturerInput;
  UpdateDataTablePrequalManufacturerPayload: Omit<UpdateDataTablePrequalManufacturerPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableProcessingStepByNodeIdInput: UpdateDataTableProcessingStepByNodeIdInput;
  UpdateDataTableProcessingStepInput: UpdateDataTableProcessingStepInput;
  UpdateDataTableProcessingStepPayload: Omit<UpdateDataTableProcessingStepPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableProductApplicationJoinByNodeIdInput: UpdateDataTableProductApplicationJoinByNodeIdInput;
  UpdateDataTableProductApplicationJoinInput: UpdateDataTableProductApplicationJoinInput;
  UpdateDataTableProductApplicationJoinPayload: Omit<UpdateDataTableProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableProductByNodeIdInput: UpdateDataTableProductByNodeIdInput;
  UpdateDataTableProductInput: UpdateDataTableProductInput;
  UpdateDataTableProductPayload: Omit<UpdateDataTableProductPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableProvisionalProductApplicationJoinByNodeIdInput: UpdateDataTableProvisionalProductApplicationJoinByNodeIdInput;
  UpdateDataTableProvisionalProductApplicationJoinInput: UpdateDataTableProvisionalProductApplicationJoinInput;
  UpdateDataTableProvisionalProductApplicationJoinPayload: Omit<UpdateDataTableProvisionalProductApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableProvisionalProductByNodeIdInput: UpdateDataTableProvisionalProductByNodeIdInput;
  UpdateDataTableProvisionalProductInput: UpdateDataTableProvisionalProductInput;
  UpdateDataTableProvisionalProductPayload: Omit<UpdateDataTableProvisionalProductPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableScheduledChemicalByNodeIdInput: UpdateDataTableScheduledChemicalByNodeIdInput;
  UpdateDataTableScheduledChemicalInput: UpdateDataTableScheduledChemicalInput;
  UpdateDataTableScheduledChemicalPayload: Omit<UpdateDataTableScheduledChemicalPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableStorageConditionByNodeIdInput: UpdateDataTableStorageConditionByNodeIdInput;
  UpdateDataTableStorageConditionInput: UpdateDataTableStorageConditionInput;
  UpdateDataTableStorageConditionPayload: Omit<UpdateDataTableStorageConditionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableStorageConditionsSimplifiedByNodeIdInput: UpdateDataTableStorageConditionsSimplifiedByNodeIdInput;
  UpdateDataTableStorageConditionsSimplifiedInput: UpdateDataTableStorageConditionsSimplifiedInput;
  UpdateDataTableStorageConditionsSimplifiedPayload: Omit<UpdateDataTableStorageConditionsSimplifiedPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableUnitsOfProportionByNodeIdInput: UpdateDataTableUnitsOfProportionByNodeIdInput;
  UpdateDataTableUnitsOfProportionInput: UpdateDataTableUnitsOfProportionInput;
  UpdateDataTableUnitsOfProportionPayload: Omit<UpdateDataTableUnitsOfProportionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput: UpdateDataTableWorldHealthOrganisationPqListOfFppByNodeIdInput;
  UpdateDataTableWorldHealthOrganisationPqListOfFppInput: UpdateDataTableWorldHealthOrganisationPqListOfFppInput;
  UpdateDataTableWorldHealthOrganisationPqListOfFppPayload: Omit<UpdateDataTableWorldHealthOrganisationPqListOfFppPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataViewByIdentifierInput: UpdateDataViewByIdentifierInput;
  UpdateDataViewByNodeIdInput: UpdateDataViewByNodeIdInput;
  UpdateDataViewColumnDefinitionByNodeIdInput: UpdateDataViewColumnDefinitionByNodeIdInput;
  UpdateDataViewColumnDefinitionByTableNameAndColumnNameInput: UpdateDataViewColumnDefinitionByTableNameAndColumnNameInput;
  UpdateDataViewColumnDefinitionInput: UpdateDataViewColumnDefinitionInput;
  UpdateDataViewColumnDefinitionPayload: Omit<UpdateDataViewColumnDefinitionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateDataViewInput: UpdateDataViewInput;
  UpdateDataViewPayload: Omit<UpdateDataViewPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateElementTypePluginByNodeIdInput: UpdateElementTypePluginByNodeIdInput;
  UpdateElementTypePluginInput: UpdateElementTypePluginInput;
  UpdateElementTypePluginPayload: Omit<UpdateElementTypePluginPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateFileByNodeIdInput: UpdateFileByNodeIdInput;
  UpdateFileByUniqueIdInput: UpdateFileByUniqueIdInput;
  UpdateFileInput: UpdateFileInput;
  UpdateFilePayload: Omit<UpdateFilePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateFilterByCodeInput: UpdateFilterByCodeInput;
  UpdateFilterByNodeIdInput: UpdateFilterByNodeIdInput;
  UpdateFilterInput: UpdateFilterInput;
  UpdateFilterPayload: Omit<UpdateFilterPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateGrafanaDashboardImageByNodeIdInput: UpdateGrafanaDashboardImageByNodeIdInput;
  UpdateGrafanaDashboardImageInput: UpdateGrafanaDashboardImageInput;
  UpdateGrafanaDashboardImagePayload: Omit<UpdateGrafanaDashboardImagePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateNotificationByNodeIdInput: UpdateNotificationByNodeIdInput;
  UpdateNotificationInput: UpdateNotificationInput;
  UpdateNotificationPayload: Omit<UpdateNotificationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateOrganisationApplicationJoinByNodeIdInput: UpdateOrganisationApplicationJoinByNodeIdInput;
  UpdateOrganisationApplicationJoinInput: UpdateOrganisationApplicationJoinInput;
  UpdateOrganisationApplicationJoinPayload: Omit<UpdateOrganisationApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateOrganisationByNameInput: UpdateOrganisationByNameInput;
  UpdateOrganisationByNodeIdInput: UpdateOrganisationByNodeIdInput;
  UpdateOrganisationByRegistrationInput: UpdateOrganisationByRegistrationInput;
  UpdateOrganisationInput: UpdateOrganisationInput;
  UpdateOrganisationPayload: Omit<UpdateOrganisationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdatePermissionJoinByNodeIdInput: UpdatePermissionJoinByNodeIdInput;
  UpdatePermissionJoinInput: UpdatePermissionJoinInput;
  UpdatePermissionJoinPayload: Omit<UpdatePermissionJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdatePermissionNameByNameInput: UpdatePermissionNameByNameInput;
  UpdatePermissionNameByNodeIdInput: UpdatePermissionNameByNodeIdInput;
  UpdatePermissionNameInput: UpdatePermissionNameInput;
  UpdatePermissionNamePayload: Omit<UpdatePermissionNamePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdatePermissionPolicyByNameInput: UpdatePermissionPolicyByNameInput;
  UpdatePermissionPolicyByNodeIdInput: UpdatePermissionPolicyByNodeIdInput;
  UpdatePermissionPolicyInput: UpdatePermissionPolicyInput;
  UpdatePermissionPolicyPayload: Omit<UpdatePermissionPolicyPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateReviewAssignmentAssignerJoinByNodeIdInput: UpdateReviewAssignmentAssignerJoinByNodeIdInput;
  UpdateReviewAssignmentAssignerJoinInput: UpdateReviewAssignmentAssignerJoinInput;
  UpdateReviewAssignmentAssignerJoinPayload: Omit<UpdateReviewAssignmentAssignerJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateReviewAssignmentByNodeIdInput: UpdateReviewAssignmentByNodeIdInput;
  UpdateReviewAssignmentInput: UpdateReviewAssignmentInput;
  UpdateReviewAssignmentPayload: Omit<UpdateReviewAssignmentPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateReviewByNodeIdInput: UpdateReviewByNodeIdInput;
  UpdateReviewByReviewAssignmentIdInput: UpdateReviewByReviewAssignmentIdInput;
  UpdateReviewDecisionByNodeIdInput: UpdateReviewDecisionByNodeIdInput;
  UpdateReviewDecisionInput: UpdateReviewDecisionInput;
  UpdateReviewDecisionPayload: Omit<UpdateReviewDecisionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateReviewInput: UpdateReviewInput;
  UpdateReviewPayload: Omit<UpdateReviewPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateReviewResponseByNodeIdInput: UpdateReviewResponseByNodeIdInput;
  UpdateReviewResponseInput: UpdateReviewResponseInput;
  UpdateReviewResponsePayload: Omit<UpdateReviewResponsePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateReviewStatusHistoryByNodeIdInput: UpdateReviewStatusHistoryByNodeIdInput;
  UpdateReviewStatusHistoryInput: UpdateReviewStatusHistoryInput;
  UpdateReviewStatusHistoryPayload: Omit<UpdateReviewStatusHistoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateSystemInfoByNodeIdInput: UpdateSystemInfoByNodeIdInput;
  UpdateSystemInfoInput: UpdateSystemInfoInput;
  UpdateSystemInfoPayload: Omit<UpdateSystemInfoPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplateActionByNodeIdInput: UpdateTemplateActionByNodeIdInput;
  UpdateTemplateActionInput: UpdateTemplateActionInput;
  UpdateTemplateActionPayload: Omit<UpdateTemplateActionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplateByCodeAndVersionIdInput: UpdateTemplateByCodeAndVersionIdInput;
  UpdateTemplateByNodeIdInput: UpdateTemplateByNodeIdInput;
  UpdateTemplateCategoryByCodeInput: UpdateTemplateCategoryByCodeInput;
  UpdateTemplateCategoryByNodeIdInput: UpdateTemplateCategoryByNodeIdInput;
  UpdateTemplateCategoryInput: UpdateTemplateCategoryInput;
  UpdateTemplateCategoryPayload: Omit<UpdateTemplateCategoryPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplateElementByNodeIdInput: UpdateTemplateElementByNodeIdInput;
  UpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput: UpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionInput;
  UpdateTemplateElementInput: UpdateTemplateElementInput;
  UpdateTemplateElementPayload: Omit<UpdateTemplateElementPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplateFilterJoinByNodeIdInput: UpdateTemplateFilterJoinByNodeIdInput;
  UpdateTemplateFilterJoinInput: UpdateTemplateFilterJoinInput;
  UpdateTemplateFilterJoinPayload: Omit<UpdateTemplateFilterJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplateInput: UpdateTemplateInput;
  UpdateTemplatePayload: Omit<UpdateTemplatePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplatePermissionByNodeIdInput: UpdateTemplatePermissionByNodeIdInput;
  UpdateTemplatePermissionInput: UpdateTemplatePermissionInput;
  UpdateTemplatePermissionPayload: Omit<UpdateTemplatePermissionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplateSectionByNodeIdInput: UpdateTemplateSectionByNodeIdInput;
  UpdateTemplateSectionByTemplateIdAndCodeInput: UpdateTemplateSectionByTemplateIdAndCodeInput;
  UpdateTemplateSectionInput: UpdateTemplateSectionInput;
  UpdateTemplateSectionPayload: Omit<UpdateTemplateSectionPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplateStageByNodeIdInput: UpdateTemplateStageByNodeIdInput;
  UpdateTemplateStageInput: UpdateTemplateStageInput;
  UpdateTemplateStagePayload: Omit<UpdateTemplateStagePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTemplateStageReviewLevelByNodeIdInput: UpdateTemplateStageReviewLevelByNodeIdInput;
  UpdateTemplateStageReviewLevelInput: UpdateTemplateStageReviewLevelInput;
  UpdateTemplateStageReviewLevelPayload: Omit<UpdateTemplateStageReviewLevelPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTriggerQueueByNodeIdInput: UpdateTriggerQueueByNodeIdInput;
  UpdateTriggerQueueInput: UpdateTriggerQueueInput;
  UpdateTriggerQueuePayload: Omit<UpdateTriggerQueuePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateTriggerScheduleByNodeIdInput: UpdateTriggerScheduleByNodeIdInput;
  UpdateTriggerScheduleInput: UpdateTriggerScheduleInput;
  UpdateTriggerSchedulePayload: Omit<UpdateTriggerSchedulePayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateUserApplicationJoinByNodeIdInput: UpdateUserApplicationJoinByNodeIdInput;
  UpdateUserApplicationJoinInput: UpdateUserApplicationJoinInput;
  UpdateUserApplicationJoinPayload: Omit<UpdateUserApplicationJoinPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateUserOrganisationByNodeIdInput: UpdateUserOrganisationByNodeIdInput;
  UpdateUserOrganisationInput: UpdateUserOrganisationInput;
  UpdateUserOrganisationPayload: Omit<UpdateUserOrganisationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  UpdateVerificationByNodeIdInput: UpdateVerificationByNodeIdInput;
  UpdateVerificationByUniqueIdInput: UpdateVerificationByUniqueIdInput;
  UpdateVerificationInput: UpdateVerificationInput;
  UpdateVerificationPayload: Omit<UpdateVerificationPayload, 'query'> & { query?: Maybe<ResolversParentTypes['Query']> };
  User: User;
  UserApplicationJoin: UserApplicationJoin;
  UserApplicationJoinApplicationIdFkeyApplicationCreateInput: UserApplicationJoinApplicationIdFkeyApplicationCreateInput;
  UserApplicationJoinApplicationIdFkeyInput: UserApplicationJoinApplicationIdFkeyInput;
  UserApplicationJoinApplicationIdFkeyInverseInput: UserApplicationJoinApplicationIdFkeyInverseInput;
  UserApplicationJoinApplicationIdFkeyUserApplicationJoinCreateInput: UserApplicationJoinApplicationIdFkeyUserApplicationJoinCreateInput;
  UserApplicationJoinCondition: UserApplicationJoinCondition;
  UserApplicationJoinFilter: UserApplicationJoinFilter;
  UserApplicationJoinInput: UserApplicationJoinInput;
  UserApplicationJoinNodeIdConnect: UserApplicationJoinNodeIdConnect;
  UserApplicationJoinNodeIdDelete: UserApplicationJoinNodeIdDelete;
  UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate: UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyNodeIdUpdate;
  UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingUserApplicationJoinPkeyUpdate: UserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyUsingUserApplicationJoinPkeyUpdate;
  UserApplicationJoinPatch: UserApplicationJoinPatch;
  UserApplicationJoinUserApplicationJoinPkeyConnect: UserApplicationJoinUserApplicationJoinPkeyConnect;
  UserApplicationJoinUserApplicationJoinPkeyDelete: UserApplicationJoinUserApplicationJoinPkeyDelete;
  UserApplicationJoinsConnection: UserApplicationJoinsConnection;
  UserApplicationJoinsEdge: UserApplicationJoinsEdge;
  UserCondition: UserCondition;
  UserFilter: UserFilter;
  UserInput: UserInput;
  UserList: UserList;
  UserListCondition: UserListCondition;
  UserListFilter: UserListFilter;
  UserListInput: UserListInput;
  UserListOnApplicationForFakePublicApplicationForeignKey0NodeIdUpdate: UserListOnApplicationForFakePublicApplicationForeignKey0NodeIdUpdate;
  UserListOnApplicationNoteForFakePublicApplicationNoteForeignKey0NodeIdUpdate: UserListOnApplicationNoteForFakePublicApplicationNoteForeignKey0NodeIdUpdate;
  UserListOnPermissionJoinForFakePublicPermissionJoinForeignKey0NodeIdUpdate: UserListOnPermissionJoinForFakePublicPermissionJoinForeignKey0NodeIdUpdate;
  UserListOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0NodeIdUpdate: UserListOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0NodeIdUpdate;
  UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0NodeIdUpdate: UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0NodeIdUpdate;
  UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1NodeIdUpdate: UserListOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1NodeIdUpdate;
  UserListOnReviewForFakePublicReviewForeignKey0NodeIdUpdate: UserListOnReviewForFakePublicReviewForeignKey0NodeIdUpdate;
  UserListToManyApplicationFilter: UserListToManyApplicationFilter;
  UserListToManyApplicationNoteFilter: UserListToManyApplicationNoteFilter;
  UserListToManyPermissionJoinFilter: UserListToManyPermissionJoinFilter;
  UserListToManyReviewAssignmentAssignerJoinFilter: UserListToManyReviewAssignmentAssignerJoinFilter;
  UserListToManyReviewAssignmentFilter: UserListToManyReviewAssignmentFilter;
  UserListToManyReviewFilter: UserListToManyReviewFilter;
  UserListsConnection: UserListsConnection;
  UserListsEdge: UserListsEdge;
  UserOnUserOrganisationForFakePublicUserOrganisationForeignKey0NodeIdUpdate: UserOnUserOrganisationForFakePublicUserOrganisationForeignKey0NodeIdUpdate;
  UserOrgJoin: UserOrgJoin;
  UserOrgJoinCondition: UserOrgJoinCondition;
  UserOrgJoinFilter: UserOrgJoinFilter;
  UserOrgJoinsConnection: UserOrgJoinsConnection;
  UserOrgJoinsEdge: UserOrgJoinsEdge;
  UserOrganisation: UserOrganisation;
  UserOrganisationCondition: UserOrganisationCondition;
  UserOrganisationFilter: UserOrganisationFilter;
  UserOrganisationInput: UserOrganisationInput;
  UserOrganisationNodeIdConnect: UserOrganisationNodeIdConnect;
  UserOrganisationNodeIdDelete: UserOrganisationNodeIdDelete;
  UserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0UsingUserOrganisationPkeyUpdate: UserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0UsingUserOrganisationPkeyUpdate;
  UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate: UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyNodeIdUpdate;
  UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate: UserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyUsingUserOrganisationPkeyUpdate;
  UserOrganisationOrganisationIdFkeyInput: UserOrganisationOrganisationIdFkeyInput;
  UserOrganisationOrganisationIdFkeyInverseInput: UserOrganisationOrganisationIdFkeyInverseInput;
  UserOrganisationOrganisationIdFkeyOrganisationCreateInput: UserOrganisationOrganisationIdFkeyOrganisationCreateInput;
  UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput: UserOrganisationOrganisationIdFkeyUserOrganisationCreateInput;
  UserOrganisationPatch: UserOrganisationPatch;
  UserOrganisationUserOrganisationPkeyConnect: UserOrganisationUserOrganisationPkeyConnect;
  UserOrganisationUserOrganisationPkeyDelete: UserOrganisationUserOrganisationPkeyDelete;
  UserOrganisationsConnection: UserOrganisationsConnection;
  UserOrganisationsEdge: UserOrganisationsEdge;
  UserToManyUserOrganisationFilter: UserToManyUserOrganisationFilter;
  UsersConnection: UsersConnection;
  UsersEdge: UsersEdge;
  Verification: Verification;
  VerificationApplicationIdFkeyApplicationCreateInput: VerificationApplicationIdFkeyApplicationCreateInput;
  VerificationApplicationIdFkeyInput: VerificationApplicationIdFkeyInput;
  VerificationApplicationIdFkeyInverseInput: VerificationApplicationIdFkeyInverseInput;
  VerificationApplicationIdFkeyVerificationCreateInput: VerificationApplicationIdFkeyVerificationCreateInput;
  VerificationCondition: VerificationCondition;
  VerificationFilter: VerificationFilter;
  VerificationInput: VerificationInput;
  VerificationNodeIdConnect: VerificationNodeIdConnect;
  VerificationNodeIdDelete: VerificationNodeIdDelete;
  VerificationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate: VerificationOnVerificationForVerificationApplicationIdFkeyNodeIdUpdate;
  VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationPkeyUpdate: VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationPkeyUpdate;
  VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationUniqueIdKeyUpdate: VerificationOnVerificationForVerificationApplicationIdFkeyUsingVerificationUniqueIdKeyUpdate;
  VerificationPatch: VerificationPatch;
  VerificationVerificationPkeyConnect: VerificationVerificationPkeyConnect;
  VerificationVerificationPkeyDelete: VerificationVerificationPkeyDelete;
  VerificationVerificationUniqueIdKeyConnect: VerificationVerificationUniqueIdKeyConnect;
  VerificationVerificationUniqueIdKeyDelete: VerificationVerificationUniqueIdKeyDelete;
  VerificationsConnection: VerificationsConnection;
  VerificationsEdge: VerificationsEdge;
  YesOrNo: Scalars['YesOrNo']['output'];
  YesOrNoFilter: YesOrNoFilter;
  updateActionQueueOnActionQueueForActionQueueApplicationIdFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueApplicationIdFkeyPatch;
  updateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueTemplateIdFkeyPatch;
  updateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch: UpdateActionQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  updateActivityLogOnActivityLogForActivityLogApplicationIdFkeyPatch: UpdateActivityLogOnActivityLogForActivityLogApplicationIdFkeyPatch;
  updateApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
  updateApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyPatch: UpdateApplicationNoteOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
  updateApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0Patch: UpdateApplicationNoteOnApplicationNoteForFakePublicApplicationNoteForeignKey0Patch;
  updateApplicationNoteOnFileForFileApplicationNoteIdFkeyPatch: UpdateApplicationNoteOnFileForFileApplicationNoteIdFkeyPatch;
  updateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch: UpdateApplicationOnActionQueueForActionQueueApplicationIdFkeyPatch;
  updateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch: UpdateApplicationOnActivityLogForActivityLogApplicationIdFkeyPatch;
  updateApplicationOnApplicationForApplicationOrgIdFkeyPatch: UpdateApplicationOnApplicationForApplicationOrgIdFkeyPatch;
  updateApplicationOnApplicationForApplicationTemplateIdFkeyPatch: UpdateApplicationOnApplicationForApplicationTemplateIdFkeyPatch;
  updateApplicationOnApplicationForFakePublicApplicationForeignKey0Patch: UpdateApplicationOnApplicationForFakePublicApplicationForeignKey0Patch;
  updateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch: UpdateApplicationOnApplicationNoteForApplicationNoteApplicationIdFkeyPatch;
  updateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch: UpdateApplicationOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  updateApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch: UpdateApplicationOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
  updateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch: UpdateApplicationOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  updateApplicationOnDataChangelogForDataChangelogApplicationIdFkeyPatch: UpdateApplicationOnDataChangelogForDataChangelogApplicationIdFkeyPatch;
  updateApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch: UpdateApplicationOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch;
  updateApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch: UpdateApplicationOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch;
  updateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch: UpdateApplicationOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch;
  updateApplicationOnFileForFileApplicationSerialFkeyPatch: UpdateApplicationOnFileForFileApplicationSerialFkeyPatch;
  updateApplicationOnNotificationForNotificationApplicationIdFkeyPatch: UpdateApplicationOnNotificationForNotificationApplicationIdFkeyPatch;
  updateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch: UpdateApplicationOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  updateApplicationOnReviewForReviewApplicationIdFkeyPatch: UpdateApplicationOnReviewForReviewApplicationIdFkeyPatch;
  updateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch: UpdateApplicationOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
  updateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch: UpdateApplicationOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
  updateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch: UpdateApplicationOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
  updateApplicationOnVerificationForVerificationApplicationIdFkeyPatch: UpdateApplicationOnVerificationForVerificationApplicationIdFkeyPatch;
  updateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseApplicationIdFkeyPatch;
  updateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch: UpdateApplicationResponseOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  updateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch: UpdateApplicationResponseOnFileForFileApplicationResponseIdFkeyPatch;
  updateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch: UpdateApplicationResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  updateApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch: UpdateApplicationReviewerActionOnApplicationReviewerActionForApplicationReviewerActionApplicationIdFkeyPatch;
  updateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryApplicationIdFkeyPatch;
  updateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  updateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch: UpdateApplicationStageHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  updateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch: UpdateApplicationStatusHistoryOnApplicationStatusHistoryForApplicationStatusHistoryApplicationStageHistoryIdFkeyPatch;
  updateDataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyPatch: UpdateDataChangelogOnDataChangelogForDataChangelogApplicationIdFkeyPatch;
  updateDataChangelogOnDataChangelogForDataChangelogOrgIdFkeyPatch: UpdateDataChangelogOnDataChangelogForDataChangelogOrgIdFkeyPatch;
  updateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch: UpdateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch;
  updateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch: UpdateDataTableManufacturerApplicationJoinOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicationJoinApplicationIdFkeyPatch;
  updateDataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch: UpdateDataTableManufacturerOnDataTableManufacturerApplicationJoinForDataTableManufacturerApplicaDataTableManufacturerIdFkeyPatch;
  updateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch: UpdateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch;
  updateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch: UpdateDataTableManufacturerRepresentativeApplicationJoinOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepresentativeApplApplicationIdFkeyPatch;
  updateDataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch: UpdateDataTableManufacturerRepresentativeOnDataTableManufacturerRepresentativeApplicationJoinForDataTableManufacturerRepreDataTableManufacturerReprFkeyPatch;
  updateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch: UpdateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch;
  updateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch: UpdateDataTablePermitChemicalApplicationJoinOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApplicationJoinApplicationIdFkeyPatch;
  updateDataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch: UpdateDataTablePermitChemicalOnDataTablePermitChemicalApplicationJoinForDataTablePermitChemicalApDataTablePermitChemicalIFkeyPatch;
  updateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch: UpdateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch;
  updateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch: UpdateDataTablePrequalManufacturerApplicationJoinOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturerApplicationApplicationIdFkeyPatch;
  updateDataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch: UpdateDataTablePrequalManufacturerOnDataTablePrequalManufacturerApplicationJoinForDataTablePrequalManufacturDataTablePrequalManufactuFkeyPatch;
  updateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch: UpdateDataTableProductApplicationJoinOnDataTableProductApplicationJoinForDataTableProductApplicationJoinApplicationIdFkeyPatch;
  updateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch: UpdateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch;
  updateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch: UpdateDataTableProvisionalProductApplicationJoinOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProductApplicationApplicationIdFkeyPatch;
  updateDataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch: UpdateDataTableProvisionalProductOnDataTableProvisionalProductApplicationJoinForDataTableProvisionalProducDataTableProvisionalProduFkeyPatch;
  updateFileOnFileForFileApplicationNoteIdFkeyPatch: UpdateFileOnFileForFileApplicationNoteIdFkeyPatch;
  updateFileOnFileForFileApplicationResponseIdFkeyPatch: UpdateFileOnFileForFileApplicationResponseIdFkeyPatch;
  updateFileOnFileForFileApplicationSerialFkeyPatch: UpdateFileOnFileForFileApplicationSerialFkeyPatch;
  updateFileOnFileForFileTemplateIdFkeyPatch: UpdateFileOnFileForFileTemplateIdFkeyPatch;
  updateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch: UpdateFilterOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
  updateNotificationOnNotificationForNotificationApplicationIdFkeyPatch: UpdateNotificationOnNotificationForNotificationApplicationIdFkeyPatch;
  updateNotificationOnNotificationForNotificationReviewIdFkeyPatch: UpdateNotificationOnNotificationForNotificationReviewIdFkeyPatch;
  updateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch: UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinApplicationIdFkeyPatch;
  updateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch: UpdateOrganisationApplicationJoinOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
  updateOrganisationOnApplicationForApplicationOrgIdFkeyPatch: UpdateOrganisationOnApplicationForApplicationOrgIdFkeyPatch;
  updateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch: UpdateOrganisationOnApplicationNoteForApplicationNoteOrgIdFkeyPatch;
  updateOrganisationOnDataChangelogForDataChangelogOrgIdFkeyPatch: UpdateOrganisationOnDataChangelogForDataChangelogOrgIdFkeyPatch;
  updateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch: UpdateOrganisationOnOrganisationApplicationJoinForOrganisationApplicationJoinOrganisationIdFkeyPatch;
  updateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch: UpdateOrganisationOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  updateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch: UpdateOrganisationOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
  updateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch: UpdateOrganisationOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  updateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch: UpdateOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  updatePermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0Patch: UpdatePermissionJoinOnPermissionJoinForFakePublicPermissionJoinForeignKey0Patch;
  updatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinOrganisationIdFkeyPatch;
  updatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch: UpdatePermissionJoinOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  updatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch: UpdatePermissionNameOnPermissionJoinForPermissionJoinPermissionNameIdFkeyPatch;
  updatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch: UpdatePermissionNameOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  updatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch: UpdatePermissionNameOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  updatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch: UpdatePermissionPolicyOnPermissionNameForPermissionNamePermissionPolicyIdFkeyPatch;
  updateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0Patch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForFakePublicReviewAssignmentAssignerJoinForeignKey0Patch;
  updateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinOrganisationIdFkeyPatch;
  updateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentAssignerJoinOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentAssignerJoinForReviewAssignmentAssignerJoinReviewAssignmentIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0Patch: UpdateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey0Patch;
  updateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1Patch: UpdateReviewAssignmentOnReviewAssignmentForFakePublicReviewAssignmentForeignKey1Patch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentApplicationIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentOrganisationIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  updateReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch: UpdateReviewAssignmentOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
  updateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch: UpdateReviewAssignmentOnReviewForReviewReviewAssignmentIdFkeyPatch;
  updateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch: UpdateReviewDecisionOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  updateReviewOnNotificationForNotificationReviewIdFkeyPatch: UpdateReviewOnNotificationForNotificationReviewIdFkeyPatch;
  updateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch: UpdateReviewOnReviewDecisionForReviewDecisionReviewIdFkeyPatch;
  updateReviewOnReviewForFakePublicReviewForeignKey0Patch: UpdateReviewOnReviewForFakePublicReviewForeignKey0Patch;
  updateReviewOnReviewForReviewApplicationIdFkeyPatch: UpdateReviewOnReviewForReviewApplicationIdFkeyPatch;
  updateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch: UpdateReviewOnReviewForReviewReviewAssignmentIdFkeyPatch;
  updateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch: UpdateReviewOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  updateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch: UpdateReviewOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseApplicationResponseIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseOriginalReviewResponseIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseReviewResponseLinkIdFkeyPatch;
  updateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch: UpdateReviewResponseOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  updateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch: UpdateReviewStatusHistoryOnReviewStatusHistoryForReviewStatusHistoryReviewIdFkeyPatch;
  updateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch: UpdateTemplateActionOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  updateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch: UpdateTemplateCategoryOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
  updateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch: UpdateTemplateElementOnApplicationResponseForApplicationResponseTemplateElementIdFkeyPatch;
  updateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch: UpdateTemplateElementOnReviewResponseForReviewResponseTemplateElementIdFkeyPatch;
  updateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch: UpdateTemplateElementOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  updateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch: UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinFilterIdFkeyPatch;
  updateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch: UpdateTemplateFilterJoinOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
  updateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch: UpdateTemplateOnActionQueueForActionQueueTemplateIdFkeyPatch;
  updateTemplateOnApplicationForApplicationTemplateIdFkeyPatch: UpdateTemplateOnApplicationForApplicationTemplateIdFkeyPatch;
  updateTemplateOnFileForFileTemplateIdFkeyPatch: UpdateTemplateOnFileForFileTemplateIdFkeyPatch;
  updateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch: UpdateTemplateOnReviewAssignmentForReviewAssignmentTemplateIdFkeyPatch;
  updateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch: UpdateTemplateOnTemplateActionForTemplateActionTemplateIdFkeyPatch;
  updateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch: UpdateTemplateOnTemplateFilterJoinForTemplateFilterJoinTemplateIdFkeyPatch;
  updateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch: UpdateTemplateOnTemplateForTemplateTemplateCategoryIdFkeyPatch;
  updateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch: UpdateTemplateOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  updateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch: UpdateTemplateOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  updateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch: UpdateTemplateOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  updateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch: UpdateTemplateOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
  updateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionPermissionNameIdFkeyPatch;
  updateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch: UpdateTemplatePermissionOnTemplatePermissionForTemplatePermissionTemplateIdFkeyPatch;
  updateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch: UpdateTemplateSectionOnTemplateElementForTemplateElementSectionIdFkeyPatch;
  updateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch: UpdateTemplateSectionOnTemplateSectionForTemplateSectionTemplateIdFkeyPatch;
  updateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch: UpdateTemplateStageOnApplicationStageHistoryForApplicationStageHistoryStageIdFkeyPatch;
  updateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch: UpdateTemplateStageOnReviewAssignmentForReviewAssignmentStageIdFkeyPatch;
  updateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch: UpdateTemplateStageOnTemplateStageForTemplateStageTemplateIdFkeyPatch;
  updateTemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch: UpdateTemplateStageOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch;
  updateTemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch: UpdateTemplateStageReviewLevelOnReviewAssignmentForReviewAssignmentLevelIdFkeyPatch;
  updateTemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch: UpdateTemplateStageReviewLevelOnTemplateStageReviewLevelForTemplateStageReviewLevelStageIdFkeyPatch;
  updateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch: UpdateTriggerQueueOnActionQueueForActionQueueTriggerEventFkeyPatch;
  updateTriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch: UpdateTriggerQueueOnTriggerQueueForTriggerQueueApplicationIdFkeyPatch;
  updateTriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleApplicationIdFkeyPatch;
  updateTriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch: UpdateTriggerScheduleOnTriggerScheduleForTriggerScheduleTemplateIdFkeyPatch;
  updateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch: UpdateUserApplicationJoinOnUserApplicationJoinForUserApplicationJoinApplicationIdFkeyPatch;
  updateUserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0Patch: UpdateUserOrganisationOnUserOrganisationForFakePublicUserOrganisationForeignKey0Patch;
  updateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch: UpdateUserOrganisationOnUserOrganisationForUserOrganisationOrganisationIdFkeyPatch;
  updateVerificationOnVerificationForVerificationApplicationIdFkeyPatch: UpdateVerificationOnVerificationForVerificationApplicationIdFkeyPatch;
};

export type ActionPluginResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionPlugin'] = ResolversParentTypes['ActionPlugin']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  optionalParameters?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  outputProperties?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  requiredParameters?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionPluginsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionPluginsConnection'] = ResolversParentTypes['ActionPluginsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ActionPluginsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ActionPlugin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionPluginsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionPluginsEdge'] = ResolversParentTypes['ActionPluginsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionQueueResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionQueue'] = ResolversParentTypes['ActionQueue']> = {
  actionCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  conditionExpression?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  errorLog?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  output?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  parameterQueries?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  parametersEvaluated?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  sequence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ActionQueueStatus']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  timeCompleted?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeQueued?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  triggerEvent?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  triggerPayload?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  triggerQueueByTriggerEvent?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionQueuesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionQueuesConnection'] = ResolversParentTypes['ActionQueuesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ActionQueuesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ActionQueue']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActionQueuesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActionQueuesEdge'] = ResolversParentTypes['ActionQueuesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActivityLogResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActivityLog'] = ResolversParentTypes['ActivityLog']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  details?: Resolver<ResolversTypes['JSON'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  recordId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  table?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  type?: Resolver<ResolversTypes['EventType'], ParentType, ContextType>;
  value?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActivityLogsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActivityLogsConnection'] = ResolversParentTypes['ActivityLogsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ActivityLogsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ActivityLog']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ActivityLogsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ActivityLogsEdge'] = ResolversParentTypes['ActivityLogsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ActivityLog']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AllowedSelfAssignableSectionsShapeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AllowedSelfAssignableSectionsShape'] = ResolversParentTypes['AllowedSelfAssignableSectionsShape']> = {
  allowedSections?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reviewAssignmentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AllowedSelfAssignableSectionsShapesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AllowedSelfAssignableSectionsShapesConnection'] = ResolversParentTypes['AllowedSelfAssignableSectionsShapesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AllowedSelfAssignableSectionsShapesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['AllowedSelfAssignableSectionsShape']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AllowedSelfAssignableSectionsShapesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AllowedSelfAssignableSectionsShapesEdge'] = ResolversParentTypes['AllowedSelfAssignableSectionsShapesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['AllowedSelfAssignableSectionsShape']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Application'] = ResolversParentTypes['Application']> = {
  actionQueues?: Resolver<ResolversTypes['ActionQueuesConnection'], ParentType, ContextType, RequireFields<ApplicationActionQueuesArgs, 'orderBy'>>;
  activityLogs?: Resolver<ResolversTypes['ActivityLogsConnection'], ParentType, ContextType, RequireFields<ApplicationActivityLogsArgs, 'orderBy'>>;
  applicationNotes?: Resolver<ResolversTypes['ApplicationNotesConnection'], ParentType, ContextType, RequireFields<ApplicationApplicationNotesArgs, 'orderBy'>>;
  applicationResponses?: Resolver<ResolversTypes['ApplicationResponsesConnection'], ParentType, ContextType, RequireFields<ApplicationApplicationResponsesArgs, 'orderBy'>>;
  applicationReviewerActions?: Resolver<ResolversTypes['ApplicationReviewerActionsConnection'], ParentType, ContextType, RequireFields<ApplicationApplicationReviewerActionsArgs, 'orderBy'>>;
  applicationStageHistories?: Resolver<ResolversTypes['ApplicationStageHistoriesConnection'], ParentType, ContextType, RequireFields<ApplicationApplicationStageHistoriesArgs, 'orderBy'>>;
  assignerList?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  dataChangelogs?: Resolver<ResolversTypes['DataChangelogsConnection'], ParentType, ContextType, RequireFields<ApplicationDataChangelogsArgs, 'orderBy'>>;
  dataTableManufacturerApplicationJoins?: Resolver<ResolversTypes['DataTableManufacturerApplicationJoinsConnection'], ParentType, ContextType, RequireFields<ApplicationDataTableManufacturerApplicationJoinsArgs, 'orderBy'>>;
  dataTableManufacturerRepresentativeApplicationJoins?: Resolver<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoinsConnection'], ParentType, ContextType, RequireFields<ApplicationDataTableManufacturerRepresentativeApplicationJoinsArgs, 'orderBy'>>;
  dataTablePermitChemicalApplicationJoins?: Resolver<ResolversTypes['DataTablePermitChemicalApplicationJoinsConnection'], ParentType, ContextType, RequireFields<ApplicationDataTablePermitChemicalApplicationJoinsArgs, 'orderBy'>>;
  dataTablePrequalManufacturerApplicationJoins?: Resolver<ResolversTypes['DataTablePrequalManufacturerApplicationJoinsConnection'], ParentType, ContextType, RequireFields<ApplicationDataTablePrequalManufacturerApplicationJoinsArgs, 'orderBy'>>;
  dataTableProductApplicationJoins?: Resolver<ResolversTypes['DataTableProductApplicationJoinsConnection'], ParentType, ContextType, RequireFields<ApplicationDataTableProductApplicationJoinsArgs, 'orderBy'>>;
  dataTableProvisionalProductApplicationJoins?: Resolver<ResolversTypes['DataTableProvisionalProductApplicationJoinsConnection'], ParentType, ContextType, RequireFields<ApplicationDataTableProvisionalProductApplicationJoinsArgs, 'orderBy'>>;
  filesByApplicationSerial?: Resolver<ResolversTypes['FilesConnection'], ParentType, ContextType, RequireFields<ApplicationFilesByApplicationSerialArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isConfig?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  notifications?: Resolver<ResolversTypes['NotificationsConnection'], ParentType, ContextType, RequireFields<ApplicationNotificationsArgs, 'orderBy'>>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  organisationApplicationJoins?: Resolver<ResolversTypes['OrganisationApplicationJoinsConnection'], ParentType, ContextType, RequireFields<ApplicationOrganisationApplicationJoinsArgs, 'orderBy'>>;
  outcome?: Resolver<Maybe<ResolversTypes['ApplicationOutcome']>, ParentType, ContextType>;
  outcomeRegistration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewAssignments?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<ApplicationReviewAssignmentsArgs, 'orderBy'>>;
  reviewerList?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reviews?: Resolver<ResolversTypes['ReviewsConnection'], ParentType, ContextType, RequireFields<ApplicationReviewsArgs, 'orderBy'>>;
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sessionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  triggerQueues?: Resolver<ResolversTypes['TriggerQueuesConnection'], ParentType, ContextType, RequireFields<ApplicationTriggerQueuesArgs, 'orderBy'>>;
  triggerSchedules?: Resolver<ResolversTypes['TriggerSchedulesConnection'], ParentType, ContextType, RequireFields<ApplicationTriggerSchedulesArgs, 'orderBy'>>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  userApplicationJoins?: Resolver<ResolversTypes['UserApplicationJoinsConnection'], ParentType, ContextType, RequireFields<ApplicationUserApplicationJoinsArgs, 'orderBy'>>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  verifications?: Resolver<ResolversTypes['VerificationsConnection'], ParentType, ContextType, RequireFields<ApplicationVerificationsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterApplicantConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterApplicantConnection'] = ResolversParentTypes['ApplicationListFilterApplicantConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationListFilterApplicantEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterApplicantEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterApplicantEdge'] = ResolversParentTypes['ApplicationListFilterApplicantEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterAssignerConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterAssignerConnection'] = ResolversParentTypes['ApplicationListFilterAssignerConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationListFilterAssignerEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterAssignerEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterAssignerEdge'] = ResolversParentTypes['ApplicationListFilterAssignerEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterOrganisationConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterOrganisationConnection'] = ResolversParentTypes['ApplicationListFilterOrganisationConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationListFilterOrganisationEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterOrganisationEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterOrganisationEdge'] = ResolversParentTypes['ApplicationListFilterOrganisationEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterReviewerConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterReviewerConnection'] = ResolversParentTypes['ApplicationListFilterReviewerConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationListFilterReviewerEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterReviewerEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterReviewerEdge'] = ResolversParentTypes['ApplicationListFilterReviewerEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterStageConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterStageConnection'] = ResolversParentTypes['ApplicationListFilterStageConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationListFilterStageEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListFilterStageEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListFilterStageEdge'] = ResolversParentTypes['ApplicationListFilterStageEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListShapeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListShape'] = ResolversParentTypes['ApplicationListShape']> = {
  applicant?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicantDeadline?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  assignerAction?: Resolver<Maybe<ResolversTypes['AssignerAction']>, ParentType, ContextType>;
  assigners?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  lastActiveDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  outcome?: Resolver<Maybe<ResolversTypes['ApplicationOutcome']>, ParentType, ContextType>;
  reviewerAction?: Resolver<Maybe<ResolversTypes['ReviewerAction']>, ParentType, ContextType>;
  reviewers?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageColour?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  templateCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListShapesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListShapesConnection'] = ResolversParentTypes['ApplicationListShapesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationListShapesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationListShape']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationListShapesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationListShapesEdge'] = ResolversParentTypes['ApplicationListShapesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationListShape']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationNoteResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationNote'] = ResolversParentTypes['ApplicationNote']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  comment?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  files?: Resolver<ResolversTypes['FilesConnection'], ParentType, ContextType, RequireFields<ApplicationNoteFilesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  orgId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationNotesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationNotesConnection'] = ResolversParentTypes['ApplicationNotesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationNotesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationNote']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationNotesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationNotesEdge'] = ResolversParentTypes['ApplicationNotesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationResponse'] = ResolversParentTypes['ApplicationResponse']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  evaluatedParameters?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  files?: Resolver<ResolversTypes['FilesConnection'], ParentType, ContextType, RequireFields<ApplicationResponseFilesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isValid?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reviewResponses?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ApplicationResponseReviewResponsesArgs, 'orderBy'>>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationResponseStatus']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  templateElementId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeSubmitted?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeUpdated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationResponsesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationResponsesConnection'] = ResolversParentTypes['ApplicationResponsesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationResponsesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationResponse']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationResponsesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationResponsesEdge'] = ResolversParentTypes['ApplicationResponsesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationReviewerActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationReviewerAction'] = ResolversParentTypes['ApplicationReviewerAction']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assignerAction?: Resolver<Maybe<ResolversTypes['AssignerAction']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  reviewerAction?: Resolver<Maybe<ResolversTypes['ReviewerAction']>, ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationReviewerActionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationReviewerActionsConnection'] = ResolversParentTypes['ApplicationReviewerActionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationReviewerActionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationReviewerAction']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationReviewerActionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationReviewerActionsEdge'] = ResolversParentTypes['ApplicationReviewerActionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationReviewerAction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageHistoriesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageHistoriesConnection'] = ResolversParentTypes['ApplicationStageHistoriesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationStageHistoriesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationStageHistory']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageHistoriesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageHistoriesEdge'] = ResolversParentTypes['ApplicationStageHistoriesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageHistoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageHistory'] = ResolversParentTypes['ApplicationStageHistory']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  applicationStatusHistories?: Resolver<ResolversTypes['ApplicationStatusHistoriesConnection'], ParentType, ContextType, RequireFields<ApplicationStageHistoryApplicationStatusHistoriesArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  stageId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusAllResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusAll'] = ResolversParentTypes['ApplicationStageStatusAll']> = {
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  outcome?: Resolver<Maybe<ResolversTypes['ApplicationOutcome']>, ParentType, ContextType>;
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sessionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageColour?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageHistoryTimeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  stageId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageIsCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  statusHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  statusHistoryTimeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  statusIsCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  templateCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusAllsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusAllsConnection'] = ResolversParentTypes['ApplicationStageStatusAllsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationStageStatusAllsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationStageStatusAll']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusAllsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusAllsEdge'] = ResolversParentTypes['ApplicationStageStatusAllsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationStageStatusAll']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusLatestResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusLatest'] = ResolversParentTypes['ApplicationStageStatusLatest']> = {
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  outcome?: Resolver<Maybe<ResolversTypes['ApplicationOutcome']>, ParentType, ContextType>;
  serial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sessionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageColour?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  stageHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageHistoryTimeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  stageId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageIsCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  statusHistoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  statusHistoryTimeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  statusIsCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  templateCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusLatestsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusLatestsConnection'] = ResolversParentTypes['ApplicationStageStatusLatestsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationStageStatusLatestsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationStageStatusLatest']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStageStatusLatestsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStageStatusLatestsEdge'] = ResolversParentTypes['ApplicationStageStatusLatestsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationStageStatusLatest']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStatusHistoriesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStatusHistoriesConnection'] = ResolversParentTypes['ApplicationStatusHistoriesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationStatusHistoriesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ApplicationStatusHistory']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStatusHistoriesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStatusHistoriesEdge'] = ResolversParentTypes['ApplicationStatusHistoriesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationStatusHistoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationStatusHistory'] = ResolversParentTypes['ApplicationStatusHistory']> = {
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStageHistoryId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ApplicationStatus']>, ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationsConnection'] = ResolversParentTypes['ApplicationsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ApplicationsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Application']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ApplicationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ApplicationsEdge'] = ResolversParentTypes['ApplicationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignedQuestionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignedQuestionEdge'] = ResolversParentTypes['AssignedQuestionEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['AssignedQuestionsRecord']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignedQuestionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignedQuestionsConnection'] = ResolversParentTypes['AssignedQuestionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AssignedQuestionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['AssignedQuestionsRecord']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignedQuestionsRecordResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignedQuestionsRecord'] = ResolversParentTypes['AssignedQuestionsRecord']> = {
  decision?: Resolver<Maybe<ResolversTypes['ReviewResponseDecision']>, ParentType, ContextType>;
  isLastestReview?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isOptional?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  responseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewAssignmentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewResponseCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewResponseStatus?: Resolver<Maybe<ResolversTypes['ReviewResponseStatus']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignedSectionsByStageAndLevelResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignedSectionsByStageAndLevel'] = ResolversParentTypes['AssignedSectionsByStageAndLevel']> = {
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  assignedInProgressSections?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  assignedSectionForLevel?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  assignerId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  levelNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignedSectionsByStageAndLevelsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignedSectionsByStageAndLevelsConnection'] = ResolversParentTypes['AssignedSectionsByStageAndLevelsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AssignedSectionsByStageAndLevelsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['AssignedSectionsByStageAndLevel']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignedSectionsByStageAndLevelsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignedSectionsByStageAndLevelsEdge'] = ResolversParentTypes['AssignedSectionsByStageAndLevelsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['AssignedSectionsByStageAndLevel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignerListConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignerListConnection'] = ResolversParentTypes['AssignerListConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AssignerListEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['AssignerListRecord']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignerListEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignerListEdge'] = ResolversParentTypes['AssignerListEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['AssignerListRecord']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignerListRecordResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignerListRecord'] = ResolversParentTypes['AssignerListRecord']> = {
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  assignerAction?: Resolver<Maybe<ResolversTypes['AssignerAction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignmentListConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignmentListConnection'] = ResolversParentTypes['AssignmentListConnection']> = {
  edges?: Resolver<Array<ResolversTypes['AssignmentListEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['AssignmentListRecord']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignmentListEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignmentListEdge'] = ResolversParentTypes['AssignmentListEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['AssignmentListRecord']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type AssignmentListRecordResolvers<ContextType = any, ParentType extends ResolversParentTypes['AssignmentListRecord'] = ResolversParentTypes['AssignmentListRecord']> = {
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  assigners?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reviewers?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface BigIntScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['BigInt'], any> {
  name: 'BigInt';
}

export interface CharacterDataScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['CharacterData'], any> {
  name: 'CharacterData';
}

export type ConstraintsInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConstraintsInfo'] = ResolversParentTypes['ConstraintsInfo']> = {
  constraintType?: Resolver<Maybe<ResolversTypes['CharacterData']>, ParentType, ContextType>;
  fromColumnName?: Resolver<Maybe<ResolversTypes['SqlIdentifier']>, ParentType, ContextType>;
  fromTableName?: Resolver<Maybe<ResolversTypes['SqlIdentifier']>, ParentType, ContextType>;
  toColumnName?: Resolver<Maybe<ResolversTypes['SqlIdentifier']>, ParentType, ContextType>;
  toTableName?: Resolver<Maybe<ResolversTypes['SqlIdentifier']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConstraintsInfosConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConstraintsInfosConnection'] = ResolversParentTypes['ConstraintsInfosConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ConstraintsInfosEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ConstraintsInfo']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ConstraintsInfosEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ConstraintsInfosEdge'] = ResolversParentTypes['ConstraintsInfosEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ConstraintsInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CounterResolvers<ContextType = any, ParentType extends ResolversParentTypes['Counter'] = ResolversParentTypes['Counter']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountersConnection'] = ResolversParentTypes['CountersConnection']> = {
  edges?: Resolver<Array<ResolversTypes['CountersEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Counter']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CountersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['CountersEdge'] = ResolversParentTypes['CountersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateActionPluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateActionPluginPayload'] = ResolversParentTypes['CreateActionPluginPayload']> = {
  actionPlugin?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType>;
  actionPluginEdge?: Resolver<Maybe<ResolversTypes['ActionPluginsEdge']>, ParentType, ContextType, RequireFields<CreateActionPluginPayloadActionPluginEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateActionQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateActionQueuePayload'] = ResolversParentTypes['CreateActionQueuePayload']> = {
  actionQueue?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType>;
  actionQueueEdge?: Resolver<Maybe<ResolversTypes['ActionQueuesEdge']>, ParentType, ContextType, RequireFields<CreateActionQueuePayloadActionQueueEdgeArgs, 'orderBy'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  triggerQueueByTriggerEvent?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateActivityLogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateActivityLogPayload'] = ResolversParentTypes['CreateActivityLogPayload']> = {
  activityLog?: Resolver<Maybe<ResolversTypes['ActivityLog']>, ParentType, ContextType>;
  activityLogEdge?: Resolver<Maybe<ResolversTypes['ActivityLogsEdge']>, ParentType, ContextType, RequireFields<CreateActivityLogPayloadActivityLogEdgeArgs, 'orderBy'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateAllowedSelfAssignableSectionsShapePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateAllowedSelfAssignableSectionsShapePayload'] = ResolversParentTypes['CreateAllowedSelfAssignableSectionsShapePayload']> = {
  allowedSelfAssignableSectionsShape?: Resolver<Maybe<ResolversTypes['AllowedSelfAssignableSectionsShape']>, ParentType, ContextType>;
  allowedSelfAssignableSectionsShapeEdge?: Resolver<Maybe<ResolversTypes['AllowedSelfAssignableSectionsShapesEdge']>, ParentType, ContextType, RequireFields<CreateAllowedSelfAssignableSectionsShapePayloadAllowedSelfAssignableSectionsShapeEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationListShapePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationListShapePayload'] = ResolversParentTypes['CreateApplicationListShapePayload']> = {
  applicationListShape?: Resolver<Maybe<ResolversTypes['ApplicationListShape']>, ParentType, ContextType>;
  applicationListShapeEdge?: Resolver<Maybe<ResolversTypes['ApplicationListShapesEdge']>, ParentType, ContextType, RequireFields<CreateApplicationListShapePayloadApplicationListShapeEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationNotePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationNotePayload'] = ResolversParentTypes['CreateApplicationNotePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationNote?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType>;
  applicationNoteEdge?: Resolver<Maybe<ResolversTypes['ApplicationNotesEdge']>, ParentType, ContextType, RequireFields<CreateApplicationNotePayloadApplicationNoteEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationPayload'] = ResolversParentTypes['CreateApplicationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationEdge?: Resolver<Maybe<ResolversTypes['ApplicationsEdge']>, ParentType, ContextType, RequireFields<CreateApplicationPayloadApplicationEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationResponsePayload'] = ResolversParentTypes['CreateApplicationResponsePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  applicationResponseEdge?: Resolver<Maybe<ResolversTypes['ApplicationResponsesEdge']>, ParentType, ContextType, RequireFields<CreateApplicationResponsePayloadApplicationResponseEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationReviewerActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationReviewerActionPayload'] = ResolversParentTypes['CreateApplicationReviewerActionPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationReviewerAction?: Resolver<Maybe<ResolversTypes['ApplicationReviewerAction']>, ParentType, ContextType>;
  applicationReviewerActionEdge?: Resolver<Maybe<ResolversTypes['ApplicationReviewerActionsEdge']>, ParentType, ContextType, RequireFields<CreateApplicationReviewerActionPayloadApplicationReviewerActionEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationStageHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationStageHistoryPayload'] = ResolversParentTypes['CreateApplicationStageHistoryPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStageHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStageHistoriesEdge']>, ParentType, ContextType, RequireFields<CreateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateApplicationStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateApplicationStatusHistoryPayload'] = ResolversParentTypes['CreateApplicationStatusHistoryPayload']> = {
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStatusHistory?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType>;
  applicationStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<CreateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateCounterPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateCounterPayload'] = ResolversParentTypes['CreateCounterPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
  counterEdge?: Resolver<Maybe<ResolversTypes['CountersEdge']>, ParentType, ContextType, RequireFields<CreateCounterPayloadCounterEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataChangelogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataChangelogPayload'] = ResolversParentTypes['CreateDataChangelogPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataChangelog?: Resolver<Maybe<ResolversTypes['DataChangelog']>, ParentType, ContextType>;
  dataChangelogEdge?: Resolver<Maybe<ResolversTypes['DataChangelogsEdge']>, ParentType, ContextType, RequireFields<CreateDataChangelogPayloadDataChangelogEdgeArgs, 'orderBy'>>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableActiveIngredientPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableActiveIngredientPayload'] = ResolversParentTypes['CreateDataTableActiveIngredientPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableActiveIngredient?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredient']>, ParentType, ContextType>;
  dataTableActiveIngredientEdge?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredientsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableAdministrationRoutePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableAdministrationRoutePayload'] = ResolversParentTypes['CreateDataTableAdministrationRoutePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableAdministrationRoute?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoute']>, ParentType, ContextType>;
  dataTableAdministrationRouteEdge?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoutesEdge']>, ParentType, ContextType, RequireFields<CreateDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableAtcCodePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableAtcCodePayload'] = ResolversParentTypes['CreateDataTableAtcCodePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableAtcCode?: Resolver<Maybe<ResolversTypes['DataTableAtcCode']>, ParentType, ContextType>;
  dataTableAtcCodeEdge?: Resolver<Maybe<ResolversTypes['DataTableAtcCodesEdge']>, ParentType, ContextType, RequireFields<CreateDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableContainerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableContainerPayload'] = ResolversParentTypes['CreateDataTableContainerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableContainer?: Resolver<Maybe<ResolversTypes['DataTableContainer']>, ParentType, ContextType>;
  dataTableContainerEdge?: Resolver<Maybe<ResolversTypes['DataTableContainersEdge']>, ParentType, ContextType, RequireFields<CreateDataTableContainerPayloadDataTableContainerEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableCountryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableCountryPayload'] = ResolversParentTypes['CreateDataTableCountryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableCountry?: Resolver<Maybe<ResolversTypes['DataTableCountry']>, ParentType, ContextType>;
  dataTableCountryEdge?: Resolver<Maybe<ResolversTypes['DataTableCountriesEdge']>, ParentType, ContextType, RequireFields<CreateDataTableCountryPayloadDataTableCountryEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableDosageFormGroupPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableDosageFormGroupPayload'] = ResolversParentTypes['CreateDataTableDosageFormGroupPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableDosageFormGroup?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroup']>, ParentType, ContextType>;
  dataTableDosageFormGroupEdge?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroupsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableDosageFormGroupPayloadDataTableDosageFormGroupEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableDosageFormPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableDosageFormPayload'] = ResolversParentTypes['CreateDataTableDosageFormPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableDosageForm?: Resolver<Maybe<ResolversTypes['DataTableDosageForm']>, ParentType, ContextType>;
  dataTableDosageFormEdge?: Resolver<Maybe<ResolversTypes['DataTableDosageFormsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableDosageFormPayloadDataTableDosageFormEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableGenericIngredientPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableGenericIngredientPayload'] = ResolversParentTypes['CreateDataTableGenericIngredientPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableGenericIngredient?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredient']>, ParentType, ContextType>;
  dataTableGenericIngredientEdge?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredientsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableManufacturerApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableManufacturerApplicationJoinPayload'] = ResolversParentTypes['CreateDataTableManufacturerApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturer?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType>;
  dataTableManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoin']>, ParentType, ContextType>;
  dataTableManufacturerApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableManufacturerApplicationJoinPayloadDataTableManufacturerApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableManufacturerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableManufacturerPayload'] = ResolversParentTypes['CreateDataTableManufacturerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturer?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType>;
  dataTableManufacturerEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturersEdge']>, ParentType, ContextType, RequireFields<CreateDataTableManufacturerPayloadDataTableManufacturerEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableManufacturerRepresentativeApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableManufacturerRepresentativeApplicationJoinPayload'] = ResolversParentTypes['CreateDataTableManufacturerRepresentativeApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoin']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableManufacturerRepresentativeApplicationJoinPayloadDataTableManufacturerRepresentativeApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableManufacturerRepresentativePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableManufacturerRepresentativePayload'] = ResolversParentTypes['CreateDataTableManufacturerRepresentativePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativesEdge']>, ParentType, ContextType, RequireFields<CreateDataTableManufacturerRepresentativePayloadDataTableManufacturerRepresentativeEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTablePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTablePayload'] = ResolversParentTypes['CreateDataTablePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTable?: Resolver<Maybe<ResolversTypes['DataTable']>, ParentType, ContextType>;
  dataTableEdge?: Resolver<Maybe<ResolversTypes['DataTablesEdge']>, ParentType, ContextType, RequireFields<CreateDataTablePayloadDataTableEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTablePermitChemicalApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTablePermitChemicalApplicationJoinPayload'] = ResolversParentTypes['CreateDataTablePermitChemicalApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType>;
  dataTablePermitChemicalApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoin']>, ParentType, ContextType>;
  dataTablePermitChemicalApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<CreateDataTablePermitChemicalApplicationJoinPayloadDataTablePermitChemicalApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTablePermitChemicalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTablePermitChemicalPayload'] = ResolversParentTypes['CreateDataTablePermitChemicalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType>;
  dataTablePermitChemicalEdge?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalsEdge']>, ParentType, ContextType, RequireFields<CreateDataTablePermitChemicalPayloadDataTablePermitChemicalEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTablePreRegisteredProductsProvisionalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTablePreRegisteredProductsProvisionalPayload'] = ResolversParentTypes['CreateDataTablePreRegisteredProductsProvisionalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePreRegisteredProductsProvisional?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisional']>, ParentType, ContextType>;
  dataTablePreRegisteredProductsProvisionalEdge?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisionalsEdge']>, ParentType, ContextType, RequireFields<CreateDataTablePreRegisteredProductsProvisionalPayloadDataTablePreRegisteredProductsProvisionalEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTablePrequalManufacturerApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTablePrequalManufacturerApplicationJoinPayload'] = ResolversParentTypes['CreateDataTablePrequalManufacturerApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType>;
  dataTablePrequalManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoin']>, ParentType, ContextType>;
  dataTablePrequalManufacturerApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<CreateDataTablePrequalManufacturerApplicationJoinPayloadDataTablePrequalManufacturerApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTablePrequalManufacturerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTablePrequalManufacturerPayload'] = ResolversParentTypes['CreateDataTablePrequalManufacturerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType>;
  dataTablePrequalManufacturerEdge?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturersEdge']>, ParentType, ContextType, RequireFields<CreateDataTablePrequalManufacturerPayloadDataTablePrequalManufacturerEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableProcessingStepPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableProcessingStepPayload'] = ResolversParentTypes['CreateDataTableProcessingStepPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProcessingStep?: Resolver<Maybe<ResolversTypes['DataTableProcessingStep']>, ParentType, ContextType>;
  dataTableProcessingStepEdge?: Resolver<Maybe<ResolversTypes['DataTableProcessingStepsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableProductApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableProductApplicationJoinPayload'] = ResolversParentTypes['CreateDataTableProductApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoin']>, ParentType, ContextType>;
  dataTableProductApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableProductPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableProductPayload'] = ResolversParentTypes['CreateDataTableProductPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProduct?: Resolver<Maybe<ResolversTypes['DataTableProduct']>, ParentType, ContextType>;
  dataTableProductEdge?: Resolver<Maybe<ResolversTypes['DataTableProductsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableProductPayloadDataTableProductEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableProvisionalProductApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableProvisionalProductApplicationJoinPayload'] = ResolversParentTypes['CreateDataTableProvisionalProductApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType>;
  dataTableProvisionalProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoin']>, ParentType, ContextType>;
  dataTableProvisionalProductApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableProvisionalProductApplicationJoinPayloadDataTableProvisionalProductApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableProvisionalProductPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableProvisionalProductPayload'] = ResolversParentTypes['CreateDataTableProvisionalProductPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType>;
  dataTableProvisionalProductEdge?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableProvisionalProductPayloadDataTableProvisionalProductEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableScheduledChemicalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableScheduledChemicalPayload'] = ResolversParentTypes['CreateDataTableScheduledChemicalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableScheduledChemical?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemical']>, ParentType, ContextType>;
  dataTableScheduledChemicalEdge?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemicalsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableScheduledChemicalPayloadDataTableScheduledChemicalEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableStorageConditionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableStorageConditionPayload'] = ResolversParentTypes['CreateDataTableStorageConditionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableStorageCondition?: Resolver<Maybe<ResolversTypes['DataTableStorageCondition']>, ParentType, ContextType>;
  dataTableStorageConditionEdge?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableStorageConditionsSimplifiedPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableStorageConditionsSimplifiedPayload'] = ResolversParentTypes['CreateDataTableStorageConditionsSimplifiedPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableStorageConditionsSimplified?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplified']>, ParentType, ContextType>;
  dataTableStorageConditionsSimplifiedEdge?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplifiedsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableStorageConditionsSimplifiedPayloadDataTableStorageConditionsSimplifiedEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableUnitsOfProportionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableUnitsOfProportionPayload'] = ResolversParentTypes['CreateDataTableUnitsOfProportionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableUnitsOfProportion?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportion']>, ParentType, ContextType>;
  dataTableUnitsOfProportionEdge?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportionsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataTableWorldHealthOrganisationPqListOfFppPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataTableWorldHealthOrganisationPqListOfFppPayload'] = ResolversParentTypes['CreateDataTableWorldHealthOrganisationPqListOfFppPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableWorldHealthOrganisationPqListOfFpp?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFpp']>, ParentType, ContextType>;
  dataTableWorldHealthOrganisationPqListOfFppEdge?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFppsEdge']>, ParentType, ContextType, RequireFields<CreateDataTableWorldHealthOrganisationPqListOfFppPayloadDataTableWorldHealthOrganisationPqListOfFppEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataViewColumnDefinitionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataViewColumnDefinitionPayload'] = ResolversParentTypes['CreateDataViewColumnDefinitionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataViewColumnDefinition?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinition']>, ParentType, ContextType>;
  dataViewColumnDefinitionEdge?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinitionsEdge']>, ParentType, ContextType, RequireFields<CreateDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateDataViewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateDataViewPayload'] = ResolversParentTypes['CreateDataViewPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataView?: Resolver<Maybe<ResolversTypes['DataView']>, ParentType, ContextType>;
  dataViewEdge?: Resolver<Maybe<ResolversTypes['DataViewsEdge']>, ParentType, ContextType, RequireFields<CreateDataViewPayloadDataViewEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateElementTypePluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateElementTypePluginPayload'] = ResolversParentTypes['CreateElementTypePluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elementTypePlugin?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType>;
  elementTypePluginEdge?: Resolver<Maybe<ResolversTypes['ElementTypePluginsEdge']>, ParentType, ContextType, RequireFields<CreateElementTypePluginPayloadElementTypePluginEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFilePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFilePayload'] = ResolversParentTypes['CreateFilePayload']> = {
  applicationByApplicationSerial?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationNote?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  fileEdge?: Resolver<Maybe<ResolversTypes['FilesEdge']>, ParentType, ContextType, RequireFields<CreateFilePayloadFileEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateFilterPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateFilterPayload'] = ResolversParentTypes['CreateFilterPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filter?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType>;
  filterEdge?: Resolver<Maybe<ResolversTypes['FiltersEdge']>, ParentType, ContextType, RequireFields<CreateFilterPayloadFilterEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateGrafanaDashboardImagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateGrafanaDashboardImagePayload'] = ResolversParentTypes['CreateGrafanaDashboardImagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grafanaDashboardImage?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImage']>, ParentType, ContextType>;
  grafanaDashboardImageEdge?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImagesEdge']>, ParentType, ContextType, RequireFields<CreateGrafanaDashboardImagePayloadGrafanaDashboardImageEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateNotificationPayload'] = ResolversParentTypes['CreateNotificationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<CreateNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateOrganisationApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOrganisationApplicationJoinPayload'] = ResolversParentTypes['CreateOrganisationApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationApplicationJoin?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoin']>, ParentType, ContextType>;
  organisationApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<CreateOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateOrganisationPayload'] = ResolversParentTypes['CreateOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationEdge?: Resolver<Maybe<ResolversTypes['OrganisationsEdge']>, ParentType, ContextType, RequireFields<CreateOrganisationPayloadOrganisationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePermissionJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePermissionJoinPayload'] = ResolversParentTypes['CreatePermissionJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  permissionJoin?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType>;
  permissionJoinEdge?: Resolver<Maybe<ResolversTypes['PermissionJoinsEdge']>, ParentType, ContextType, RequireFields<CreatePermissionJoinPayloadPermissionJoinEdgeArgs, 'orderBy'>>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePermissionNamePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePermissionNamePayload'] = ResolversParentTypes['CreatePermissionNamePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  permissionNameEdge?: Resolver<Maybe<ResolversTypes['PermissionNamesEdge']>, ParentType, ContextType, RequireFields<CreatePermissionNamePayloadPermissionNameEdgeArgs, 'orderBy'>>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreatePermissionPolicyPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreatePermissionPolicyPayload'] = ResolversParentTypes['CreatePermissionPolicyPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  permissionPolicyEdge?: Resolver<Maybe<ResolversTypes['PermissionPoliciesEdge']>, ParentType, ContextType, RequireFields<CreatePermissionPolicyPayloadPermissionPolicyEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewAssignmentAssignedSectionsShapePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewAssignmentAssignedSectionsShapePayload'] = ResolversParentTypes['CreateReviewAssignmentAssignedSectionsShapePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignmentAssignedSectionsShape?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignedSectionsShape']>, ParentType, ContextType>;
  reviewAssignmentAssignedSectionsShapeEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignedSectionsShapesEdge']>, ParentType, ContextType, RequireFields<CreateReviewAssignmentAssignedSectionsShapePayloadReviewAssignmentAssignedSectionsShapeEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewAssignmentAssignerJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewAssignmentAssignerJoinPayload'] = ResolversParentTypes['CreateReviewAssignmentAssignerJoinPayload']> = {
  assigner?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewAssignmentAssignerJoin?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoin']>, ParentType, ContextType>;
  reviewAssignmentAssignerJoinEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoinsEdge']>, ParentType, ContextType, RequireFields<CreateReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewAssignmentPayload'] = ResolversParentTypes['CreateReviewAssignmentPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  assigner?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentsEdge']>, ParentType, ContextType, RequireFields<CreateReviewAssignmentPayloadReviewAssignmentEdgeArgs, 'orderBy'>>;
  reviewer?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewDecisionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewDecisionPayload'] = ResolversParentTypes['CreateReviewDecisionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  reviewDecisionEdge?: Resolver<Maybe<ResolversTypes['ReviewDecisionsEdge']>, ParentType, ContextType, RequireFields<CreateReviewDecisionPayloadReviewDecisionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewPayload'] = ResolversParentTypes['CreateReviewPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<CreateReviewPayloadReviewEdgeArgs, 'orderBy'>>;
  reviewer?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewResponsePayload'] = ResolversParentTypes['CreateReviewResponsePayload']> = {
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  originalReviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  reviewResponseEdge?: Resolver<Maybe<ResolversTypes['ReviewResponsesEdge']>, ParentType, ContextType, RequireFields<CreateReviewResponsePayloadReviewResponseEdgeArgs, 'orderBy'>>;
  reviewResponseLink?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateReviewStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateReviewStatusHistoryPayload'] = ResolversParentTypes['CreateReviewStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewStatusHistory?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType>;
  reviewStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ReviewStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<CreateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateSystemInfoPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateSystemInfoPayload'] = ResolversParentTypes['CreateSystemInfoPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  systemInfo?: Resolver<Maybe<ResolversTypes['SystemInfo']>, ParentType, ContextType>;
  systemInfoEdge?: Resolver<Maybe<ResolversTypes['SystemInfosEdge']>, ParentType, ContextType, RequireFields<CreateSystemInfoPayloadSystemInfoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateActionPayload'] = ResolversParentTypes['CreateTemplateActionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateAction?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType>;
  templateActionEdge?: Resolver<Maybe<ResolversTypes['TemplateActionsEdge']>, ParentType, ContextType, RequireFields<CreateTemplateActionPayloadTemplateActionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateCategoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateCategoryPayload'] = ResolversParentTypes['CreateTemplateCategoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateCategory?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType>;
  templateCategoryEdge?: Resolver<Maybe<ResolversTypes['TemplateCategoriesEdge']>, ParentType, ContextType, RequireFields<CreateTemplateCategoryPayloadTemplateCategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateElementPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateElementPayload'] = ResolversParentTypes['CreateTemplateElementPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  templateElementEdge?: Resolver<Maybe<ResolversTypes['TemplateElementsEdge']>, ParentType, ContextType, RequireFields<CreateTemplateElementPayloadTemplateElementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateFilterJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateFilterJoinPayload'] = ResolversParentTypes['CreateTemplateFilterJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filter?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateFilterJoin?: Resolver<Maybe<ResolversTypes['TemplateFilterJoin']>, ParentType, ContextType>;
  templateFilterJoinEdge?: Resolver<Maybe<ResolversTypes['TemplateFilterJoinsEdge']>, ParentType, ContextType, RequireFields<CreateTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplatePayload'] = ResolversParentTypes['CreateTemplatePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateCategory?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<CreateTemplatePayloadTemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplatePermissionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplatePermissionPayload'] = ResolversParentTypes['CreateTemplatePermissionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templatePermission?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType>;
  templatePermissionEdge?: Resolver<Maybe<ResolversTypes['TemplatePermissionsEdge']>, ParentType, ContextType, RequireFields<CreateTemplatePermissionPayloadTemplatePermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateSectionPayload'] = ResolversParentTypes['CreateTemplateSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateSectionEdge?: Resolver<Maybe<ResolversTypes['TemplateSectionsEdge']>, ParentType, ContextType, RequireFields<CreateTemplateSectionPayloadTemplateSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateStagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateStagePayload'] = ResolversParentTypes['CreateTemplateStagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateStage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  templateStageEdge?: Resolver<Maybe<ResolversTypes['TemplateStagesEdge']>, ParentType, ContextType, RequireFields<CreateTemplateStagePayloadTemplateStageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTemplateStageReviewLevelPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTemplateStageReviewLevelPayload'] = ResolversParentTypes['CreateTemplateStageReviewLevelPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  templateStageReviewLevel?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType>;
  templateStageReviewLevelEdge?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevelsEdge']>, ParentType, ContextType, RequireFields<CreateTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTriggerQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTriggerQueuePayload'] = ResolversParentTypes['CreateTriggerQueuePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueue?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  triggerQueueEdge?: Resolver<Maybe<ResolversTypes['TriggerQueuesEdge']>, ParentType, ContextType, RequireFields<CreateTriggerQueuePayloadTriggerQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateTriggerSchedulePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateTriggerSchedulePayload'] = ResolversParentTypes['CreateTriggerSchedulePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  triggerSchedule?: Resolver<Maybe<ResolversTypes['TriggerSchedule']>, ParentType, ContextType>;
  triggerScheduleEdge?: Resolver<Maybe<ResolversTypes['TriggerSchedulesEdge']>, ParentType, ContextType, RequireFields<CreateTriggerSchedulePayloadTriggerScheduleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserApplicationJoinPayload'] = ResolversParentTypes['CreateUserApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userApplicationJoin?: Resolver<Maybe<ResolversTypes['UserApplicationJoin']>, ParentType, ContextType>;
  userApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['UserApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<CreateUserApplicationJoinPayloadUserApplicationJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserListPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserListPayload'] = ResolversParentTypes['CreateUserListPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userList?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  userListEdge?: Resolver<Maybe<ResolversTypes['UserListsEdge']>, ParentType, ContextType, RequireFields<CreateUserListPayloadUserListEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserOrganisationPayload'] = ResolversParentTypes['CreateUserOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userOrganisation?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType>;
  userOrganisationEdge?: Resolver<Maybe<ResolversTypes['UserOrganisationsEdge']>, ParentType, ContextType, RequireFields<CreateUserOrganisationPayloadUserOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateUserPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateUserPayload'] = ResolversParentTypes['CreateUserPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userEdge?: Resolver<Maybe<ResolversTypes['UsersEdge']>, ParentType, ContextType, RequireFields<CreateUserPayloadUserEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type CreateVerificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['CreateVerificationPayload'] = ResolversParentTypes['CreateVerificationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  verification?: Resolver<Maybe<ResolversTypes['Verification']>, ParentType, ContextType>;
  verificationEdge?: Resolver<Maybe<ResolversTypes['VerificationsEdge']>, ParentType, ContextType, RequireFields<CreateVerificationPayloadVerificationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface CursorScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Cursor'], any> {
  name: 'Cursor';
}

export type DataChangelogResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataChangelog'] = ResolversParentTypes['DataChangelog']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTable?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  newData?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  oldData?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  recordId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  updateType?: Resolver<ResolversTypes['ChangelogType'], ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataChangelogsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataChangelogsConnection'] = ResolversParentTypes['DataChangelogsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataChangelogsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataChangelog']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataChangelogsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataChangelogsEdge'] = ResolversParentTypes['DataChangelogsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataChangelog']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTable'] = ResolversParentTypes['DataTable']> = {
  dataViewCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fieldMap?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isLookupTable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  tableName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableActiveIngredientResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableActiveIngredient'] = ResolversParentTypes['DataTableActiveIngredient']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  latina?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableActiveIngredientsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableActiveIngredientsConnection'] = ResolversParentTypes['DataTableActiveIngredientsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableActiveIngredientsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableActiveIngredient']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableActiveIngredientsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableActiveIngredientsEdge'] = ResolversParentTypes['DataTableActiveIngredientsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredient']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableAdministrationRouteResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableAdministrationRoute'] = ResolversParentTypes['DataTableAdministrationRoute']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  longDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableAdministrationRoutesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableAdministrationRoutesConnection'] = ResolversParentTypes['DataTableAdministrationRoutesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableAdministrationRoutesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableAdministrationRoute']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableAdministrationRoutesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableAdministrationRoutesEdge'] = ResolversParentTypes['DataTableAdministrationRoutesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoute']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableAtcCodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableAtcCode'] = ResolversParentTypes['DataTableAtcCode']> = {
  atcCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  whoAtcId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableAtcCodesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableAtcCodesConnection'] = ResolversParentTypes['DataTableAtcCodesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableAtcCodesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableAtcCode']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableAtcCodesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableAtcCodesEdge'] = ResolversParentTypes['DataTableAtcCodesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableAtcCode']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableContainerResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableContainer'] = ResolversParentTypes['DataTableContainer']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  longDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableContainersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableContainersConnection'] = ResolversParentTypes['DataTableContainersConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableContainersEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableContainer']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableContainersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableContainersEdge'] = ResolversParentTypes['DataTableContainersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableContainer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableCountriesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableCountriesConnection'] = ResolversParentTypes['DataTableCountriesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableCountriesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableCountry']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableCountriesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableCountriesEdge'] = ResolversParentTypes['DataTableCountriesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableCountry']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableCountryResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableCountry'] = ResolversParentTypes['DataTableCountry']> = {
  flag?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nameCommon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nameOfficial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  whoSraPics?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableDosageFormResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableDosageForm'] = ResolversParentTypes['DataTableDosageForm']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  longDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableDosageFormGroupResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableDosageFormGroup'] = ResolversParentTypes['DataTableDosageFormGroup']> = {
  dosageFormGroups?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableDosageFormGroupsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableDosageFormGroupsConnection'] = ResolversParentTypes['DataTableDosageFormGroupsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableDosageFormGroupsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableDosageFormGroup']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableDosageFormGroupsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableDosageFormGroupsEdge'] = ResolversParentTypes['DataTableDosageFormGroupsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroup']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableDosageFormsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableDosageFormsConnection'] = ResolversParentTypes['DataTableDosageFormsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableDosageFormsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableDosageForm']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableDosageFormsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableDosageFormsEdge'] = ResolversParentTypes['DataTableDosageFormsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableDosageForm']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableGenericIngredientResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableGenericIngredient'] = ResolversParentTypes['DataTableGenericIngredient']> = {
  atcCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  category?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  productEn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productFr?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  whoAtcId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableGenericIngredientsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableGenericIngredientsConnection'] = ResolversParentTypes['DataTableGenericIngredientsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableGenericIngredientsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableGenericIngredient']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableGenericIngredientsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableGenericIngredientsEdge'] = ResolversParentTypes['DataTableGenericIngredientsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredient']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturer'] = ResolversParentTypes['DataTableManufacturer']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturerApplicationJoins?: Resolver<ResolversTypes['DataTableManufacturerApplicationJoinsConnection'], ParentType, ContextType, RequireFields<DataTableManufacturerDataTableManufacturerApplicationJoinsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isAdditional?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  manufacturer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerApplicationJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerApplicationJoin'] = ResolversParentTypes['DataTableManufacturerApplicationJoin']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  dataTableManufacturer?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType>;
  dataTableManufacturerId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerApplicationJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerApplicationJoinsConnection'] = ResolversParentTypes['DataTableManufacturerApplicationJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableManufacturerApplicationJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableManufacturerApplicationJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerApplicationJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerApplicationJoinsEdge'] = ResolversParentTypes['DataTableManufacturerApplicationJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerRepresentativeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerRepresentative'] = ResolversParentTypes['DataTableManufacturerRepresentative']> = {
  additionalCertifications?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicantId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  companyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  companyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeApplicationJoins?: Resolver<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoinsConnection'], ParentType, ContextType, RequireFields<DataTableManufacturerRepresentativeDataTableManufacturerRepresentativeApplicationJoinsArgs, 'orderBy'>>;
  evaluationNotes?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gmpByWhoCertificate?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  gmpCertificate?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  gmpCountry1?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gmpCountry2?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gmpCountry3?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gmpDetails?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  gmpExpiry1?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  gmpExpiry2?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  gmpExpiry3?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  gmpScope?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  letterOfAuthorization?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  manufacturerDatabaseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  manufacturerRegistrationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturingCompanies?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  manufacturingLicence?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  prequalificationDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerRepresentativeApplicationJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerRepresentativeApplicationJoin'] = ResolversParentTypes['DataTableManufacturerRepresentativeApplicationJoin']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  dataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerRepresentativeApplicationJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerRepresentativeApplicationJoinsConnection'] = ResolversParentTypes['DataTableManufacturerRepresentativeApplicationJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerRepresentativeApplicationJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerRepresentativeApplicationJoinsEdge'] = ResolversParentTypes['DataTableManufacturerRepresentativeApplicationJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerRepresentativesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerRepresentativesConnection'] = ResolversParentTypes['DataTableManufacturerRepresentativesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableManufacturerRepresentativesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturerRepresentativesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturerRepresentativesEdge'] = ResolversParentTypes['DataTableManufacturerRepresentativesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturersConnection'] = ResolversParentTypes['DataTableManufacturersConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableManufacturersEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableManufacturer']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableManufacturersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableManufacturersEdge'] = ResolversParentTypes['DataTableManufacturersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePermitChemicalResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePermitChemical'] = ResolversParentTypes['DataTablePermitChemical']> = {
  chemicals?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  chemicalsFilterData?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  companyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  companyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePermitChemicalApplicationJoins?: Resolver<ResolversTypes['DataTablePermitChemicalApplicationJoinsConnection'], ParentType, ContextType, RequireFields<DataTablePermitChemicalDataTablePermitChemicalApplicationJoinsArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  permitNo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  registrationDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePermitChemicalApplicationJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePermitChemicalApplicationJoin'] = ResolversParentTypes['DataTablePermitChemicalApplicationJoin']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  dataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType>;
  dataTablePermitChemicalId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePermitChemicalApplicationJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePermitChemicalApplicationJoinsConnection'] = ResolversParentTypes['DataTablePermitChemicalApplicationJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTablePermitChemicalApplicationJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePermitChemicalApplicationJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePermitChemicalApplicationJoinsEdge'] = ResolversParentTypes['DataTablePermitChemicalApplicationJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePermitChemicalsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePermitChemicalsConnection'] = ResolversParentTypes['DataTablePermitChemicalsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTablePermitChemicalsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTablePermitChemical']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePermitChemicalsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePermitChemicalsEdge'] = ResolversParentTypes['DataTablePermitChemicalsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePreRegisteredProductsProvisionalResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePreRegisteredProductsProvisional'] = ResolversParentTypes['DataTablePreRegisteredProductsProvisional']> = {
  activeIngredients?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  activeIngredientsResponse?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  authority?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  componentsOriginal?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  containerType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dosageForm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  effectiveDate?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  indications?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturers?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  manufacturersResponse?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  multipleFormulations?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  packSizes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  packSizesResponse?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  productIdOriginal?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productIdUnique?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  routeOfAdministration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shelfLife?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  storageConditions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tradeName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePreRegisteredProductsProvisionalsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePreRegisteredProductsProvisionalsConnection'] = ResolversParentTypes['DataTablePreRegisteredProductsProvisionalsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTablePreRegisteredProductsProvisionalsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisional']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePreRegisteredProductsProvisionalsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePreRegisteredProductsProvisionalsEdge'] = ResolversParentTypes['DataTablePreRegisteredProductsProvisionalsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisional']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePrequalManufacturerResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePrequalManufacturer'] = ResolversParentTypes['DataTablePrequalManufacturer']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePrequalManufacturerApplicationJoins?: Resolver<ResolversTypes['DataTablePrequalManufacturerApplicationJoinsConnection'], ParentType, ContextType, RequireFields<DataTablePrequalManufacturerDataTablePrequalManufacturerApplicationJoinsArgs, 'orderBy'>>;
  dateIssued?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gmpDetails?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  gmpScope?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  lookupId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  manufacturerId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturingLicence?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  permitNo?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prequalificationDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePrequalManufacturerApplicationJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePrequalManufacturerApplicationJoin'] = ResolversParentTypes['DataTablePrequalManufacturerApplicationJoin']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  dataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType>;
  dataTablePrequalManufacturerId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePrequalManufacturerApplicationJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePrequalManufacturerApplicationJoinsConnection'] = ResolversParentTypes['DataTablePrequalManufacturerApplicationJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTablePrequalManufacturerApplicationJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePrequalManufacturerApplicationJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePrequalManufacturerApplicationJoinsEdge'] = ResolversParentTypes['DataTablePrequalManufacturerApplicationJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePrequalManufacturersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePrequalManufacturersConnection'] = ResolversParentTypes['DataTablePrequalManufacturersConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTablePrequalManufacturersEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTablePrequalManufacturer']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablePrequalManufacturersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablePrequalManufacturersEdge'] = ResolversParentTypes['DataTablePrequalManufacturersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProcessingStepResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProcessingStep'] = ResolversParentTypes['DataTableProcessingStep']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  processingStep?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProcessingStepsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProcessingStepsConnection'] = ResolversParentTypes['DataTableProcessingStepsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableProcessingStepsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableProcessingStep']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProcessingStepsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProcessingStepsEdge'] = ResolversParentTypes['DataTableProcessingStepsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableProcessingStep']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProductResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProduct'] = ResolversParentTypes['DataTableProduct']> = {
  activeIngredientsManufacturers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  activeSubstances?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  administrationUnit?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  atcCategory?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  atcCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  companyAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  companyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  companyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  companyPhone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  componentFormulation?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dosageForm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dosageFormDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiryDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  finishedProductManufacturers?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  formulations?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  importerAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nationalMedicalClassification?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  packagingDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packagingSizes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  primaryContainer?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  productOrigin?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  proposedIndications?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  registrationDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  registrationSerial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  routeOfAdministration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shelfLife?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sra?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  storageTemperature?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProductApplicationJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProductApplicationJoin'] = ResolversParentTypes['DataTableProductApplicationJoin']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  dataTableProductId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProductApplicationJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProductApplicationJoinsConnection'] = ResolversParentTypes['DataTableProductApplicationJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableProductApplicationJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableProductApplicationJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProductApplicationJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProductApplicationJoinsEdge'] = ResolversParentTypes['DataTableProductApplicationJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProductsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProductsConnection'] = ResolversParentTypes['DataTableProductsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableProductsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableProduct']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProductsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProductsEdge'] = ResolversParentTypes['DataTableProductsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableProduct']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProvisionalProductResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProvisionalProduct'] = ResolversParentTypes['DataTableProvisionalProduct']> = {
  activeIngredients?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  activeIngredientsFilterData?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicantId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  approval?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  atcCode?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  companyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  companyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProvisionalProductApplicationJoins?: Resolver<ResolversTypes['DataTableProvisionalProductApplicationJoinsConnection'], ParentType, ContextType, RequireFields<DataTableProvisionalProductDataTableProvisionalProductApplicationJoinsArgs, 'orderBy'>>;
  dosageForm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  evaluationComment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  expiryDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  gmpCertificate?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  gmpDetails?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  letterOfAuthorisation?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  loaSource?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  manufacturerPrequalified?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  manufacturers?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  manufacturersFilterData?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  medicalProductClassification?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  originalId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packagingSizes?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  packagingSizesFilterData?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  packagingSizesForm?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  pharmacopeia?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  prequalified?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  prodRegCertificate?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  productId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  registeredIn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  registrationDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  registrationSerial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  routeOfAdministration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  shelfLife?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sponsorName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  storageConditions?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tradeName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProvisionalProductApplicationJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProvisionalProductApplicationJoin'] = ResolversParentTypes['DataTableProvisionalProductApplicationJoin']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  dataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType>;
  dataTableProvisionalProductId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProvisionalProductApplicationJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProvisionalProductApplicationJoinsConnection'] = ResolversParentTypes['DataTableProvisionalProductApplicationJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableProvisionalProductApplicationJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProvisionalProductApplicationJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProvisionalProductApplicationJoinsEdge'] = ResolversParentTypes['DataTableProvisionalProductApplicationJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProvisionalProductsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProvisionalProductsConnection'] = ResolversParentTypes['DataTableProvisionalProductsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableProvisionalProductsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableProvisionalProduct']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableProvisionalProductsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableProvisionalProductsEdge'] = ResolversParentTypes['DataTableProvisionalProductsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableScheduledChemicalResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableScheduledChemical'] = ResolversParentTypes['DataTableScheduledChemical']> = {
  chemical?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  schedule?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableScheduledChemicalsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableScheduledChemicalsConnection'] = ResolversParentTypes['DataTableScheduledChemicalsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableScheduledChemicalsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableScheduledChemical']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableScheduledChemicalsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableScheduledChemicalsEdge'] = ResolversParentTypes['DataTableScheduledChemicalsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemical']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableStorageConditionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableStorageCondition'] = ResolversParentTypes['DataTableStorageCondition']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  longDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableStorageConditionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableStorageConditionsConnection'] = ResolversParentTypes['DataTableStorageConditionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableStorageConditionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableStorageCondition']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableStorageConditionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableStorageConditionsEdge'] = ResolversParentTypes['DataTableStorageConditionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableStorageCondition']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableStorageConditionsSimplifiedResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableStorageConditionsSimplified'] = ResolversParentTypes['DataTableStorageConditionsSimplified']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  portugueseName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableStorageConditionsSimplifiedsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableStorageConditionsSimplifiedsConnection'] = ResolversParentTypes['DataTableStorageConditionsSimplifiedsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableStorageConditionsSimplifiedsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableStorageConditionsSimplified']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableStorageConditionsSimplifiedsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableStorageConditionsSimplifiedsEdge'] = ResolversParentTypes['DataTableStorageConditionsSimplifiedsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplified']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableUnitsOfProportionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableUnitsOfProportion'] = ResolversParentTypes['DataTableUnitsOfProportion']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  longDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  shortDescription?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableUnitsOfProportionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableUnitsOfProportionsConnection'] = ResolversParentTypes['DataTableUnitsOfProportionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableUnitsOfProportionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableUnitsOfProportion']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableUnitsOfProportionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableUnitsOfProportionsEdge'] = ResolversParentTypes['DataTableUnitsOfProportionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportion']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableWorldHealthOrganisationPqListOfFppResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableWorldHealthOrganisationPqListOfFpp'] = ResolversParentTypes['DataTableWorldHealthOrganisationPqListOfFpp']> = {
  applicant?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  basisOfAlternativeListing?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  basisOfListing?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dosageForm?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  innDosageFormAndStrength?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  productType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  therapeuticArea?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  whoReferenceNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableWorldHealthOrganisationPqListOfFppsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableWorldHealthOrganisationPqListOfFppsConnection'] = ResolversParentTypes['DataTableWorldHealthOrganisationPqListOfFppsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFppsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFpp']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTableWorldHealthOrganisationPqListOfFppsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTableWorldHealthOrganisationPqListOfFppsEdge'] = ResolversParentTypes['DataTableWorldHealthOrganisationPqListOfFppsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFpp']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablesConnection'] = ResolversParentTypes['DataTablesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataTablesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataTable']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataTablesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataTablesEdge'] = ResolversParentTypes['DataTablesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataTable']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataViewResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataView'] = ResolversParentTypes['DataView']> = {
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  defaultFilterString?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  defaultSortColumn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  detailViewExcludeColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  detailViewHeaderColumn?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  detailViewIncludeColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  enabled?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  filterExcludeColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  filterIncludeColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  identifier?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  menuName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  permissionNames?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  rawDataExcludeColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  rawDataIncludeColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  rowRestrictions?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  showLinkedApplications?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  submenu?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tableName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  tableSearchColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  tableViewExcludeColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  tableViewIncludeColumns?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataViewColumnDefinitionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataViewColumnDefinition'] = ResolversParentTypes['DataViewColumnDefinition']> = {
  additionalFormatting?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  columnName?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  elementParameters?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  elementTypePluginCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filterDataType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filterExpression?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  filterParameters?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  hideIfNull?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  sortColumn?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tableName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  valueExpression?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataViewColumnDefinitionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataViewColumnDefinitionsConnection'] = ResolversParentTypes['DataViewColumnDefinitionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataViewColumnDefinitionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataViewColumnDefinition']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataViewColumnDefinitionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataViewColumnDefinitionsEdge'] = ResolversParentTypes['DataViewColumnDefinitionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinition']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataViewsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataViewsConnection'] = ResolversParentTypes['DataViewsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['DataViewsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['DataView']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DataViewsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['DataViewsEdge'] = ResolversParentTypes['DataViewsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['DataView']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface DateScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Date'], any> {
  name: 'Date';
}

export interface DatetimeScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['Datetime'], any> {
  name: 'Datetime';
}

export type DeleteActionPluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteActionPluginPayload'] = ResolversParentTypes['DeleteActionPluginPayload']> = {
  actionPlugin?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType>;
  actionPluginEdge?: Resolver<Maybe<ResolversTypes['ActionPluginsEdge']>, ParentType, ContextType, RequireFields<DeleteActionPluginPayloadActionPluginEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedActionPluginNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteActionQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteActionQueuePayload'] = ResolversParentTypes['DeleteActionQueuePayload']> = {
  actionQueue?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType>;
  actionQueueEdge?: Resolver<Maybe<ResolversTypes['ActionQueuesEdge']>, ParentType, ContextType, RequireFields<DeleteActionQueuePayloadActionQueueEdgeArgs, 'orderBy'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedActionQueueNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  triggerQueueByTriggerEvent?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteActivityLogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteActivityLogPayload'] = ResolversParentTypes['DeleteActivityLogPayload']> = {
  activityLog?: Resolver<Maybe<ResolversTypes['ActivityLog']>, ParentType, ContextType>;
  activityLogEdge?: Resolver<Maybe<ResolversTypes['ActivityLogsEdge']>, ParentType, ContextType, RequireFields<DeleteActivityLogPayloadActivityLogEdgeArgs, 'orderBy'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedActivityLogNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationNotePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationNotePayload'] = ResolversParentTypes['DeleteApplicationNotePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationNote?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType>;
  applicationNoteEdge?: Resolver<Maybe<ResolversTypes['ApplicationNotesEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationNotePayloadApplicationNoteEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedApplicationNoteNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationPayload'] = ResolversParentTypes['DeleteApplicationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationEdge?: Resolver<Maybe<ResolversTypes['ApplicationsEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationPayloadApplicationEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedApplicationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationResponsePayload'] = ResolversParentTypes['DeleteApplicationResponsePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  applicationResponseEdge?: Resolver<Maybe<ResolversTypes['ApplicationResponsesEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationResponsePayloadApplicationResponseEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedApplicationResponseNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationReviewerActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationReviewerActionPayload'] = ResolversParentTypes['DeleteApplicationReviewerActionPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationReviewerAction?: Resolver<Maybe<ResolversTypes['ApplicationReviewerAction']>, ParentType, ContextType>;
  applicationReviewerActionEdge?: Resolver<Maybe<ResolversTypes['ApplicationReviewerActionsEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationReviewerActionPayloadApplicationReviewerActionEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedApplicationReviewerActionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationStageHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationStageHistoryPayload'] = ResolversParentTypes['DeleteApplicationStageHistoryPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStageHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStageHistoriesEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedApplicationStageHistoryNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteApplicationStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteApplicationStatusHistoryPayload'] = ResolversParentTypes['DeleteApplicationStatusHistoryPayload']> = {
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStatusHistory?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType>;
  applicationStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<DeleteApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedApplicationStatusHistoryNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteCounterPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteCounterPayload'] = ResolversParentTypes['DeleteCounterPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
  counterEdge?: Resolver<Maybe<ResolversTypes['CountersEdge']>, ParentType, ContextType, RequireFields<DeleteCounterPayloadCounterEdgeArgs, 'orderBy'>>;
  deletedCounterNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataChangelogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataChangelogPayload'] = ResolversParentTypes['DeleteDataChangelogPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataChangelog?: Resolver<Maybe<ResolversTypes['DataChangelog']>, ParentType, ContextType>;
  dataChangelogEdge?: Resolver<Maybe<ResolversTypes['DataChangelogsEdge']>, ParentType, ContextType, RequireFields<DeleteDataChangelogPayloadDataChangelogEdgeArgs, 'orderBy'>>;
  deletedDataChangelogNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableActiveIngredientPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableActiveIngredientPayload'] = ResolversParentTypes['DeleteDataTableActiveIngredientPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableActiveIngredient?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredient']>, ParentType, ContextType>;
  dataTableActiveIngredientEdge?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredientsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs, 'orderBy'>>;
  deletedDataTableActiveIngredientNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableAdministrationRoutePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableAdministrationRoutePayload'] = ResolversParentTypes['DeleteDataTableAdministrationRoutePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableAdministrationRoute?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoute']>, ParentType, ContextType>;
  dataTableAdministrationRouteEdge?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoutesEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs, 'orderBy'>>;
  deletedDataTableAdministrationRouteNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableAtcCodePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableAtcCodePayload'] = ResolversParentTypes['DeleteDataTableAtcCodePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableAtcCode?: Resolver<Maybe<ResolversTypes['DataTableAtcCode']>, ParentType, ContextType>;
  dataTableAtcCodeEdge?: Resolver<Maybe<ResolversTypes['DataTableAtcCodesEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs, 'orderBy'>>;
  deletedDataTableAtcCodeNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableContainerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableContainerPayload'] = ResolversParentTypes['DeleteDataTableContainerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableContainer?: Resolver<Maybe<ResolversTypes['DataTableContainer']>, ParentType, ContextType>;
  dataTableContainerEdge?: Resolver<Maybe<ResolversTypes['DataTableContainersEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableContainerPayloadDataTableContainerEdgeArgs, 'orderBy'>>;
  deletedDataTableContainerNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableCountryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableCountryPayload'] = ResolversParentTypes['DeleteDataTableCountryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableCountry?: Resolver<Maybe<ResolversTypes['DataTableCountry']>, ParentType, ContextType>;
  dataTableCountryEdge?: Resolver<Maybe<ResolversTypes['DataTableCountriesEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableCountryPayloadDataTableCountryEdgeArgs, 'orderBy'>>;
  deletedDataTableCountryNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableDosageFormGroupPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableDosageFormGroupPayload'] = ResolversParentTypes['DeleteDataTableDosageFormGroupPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableDosageFormGroup?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroup']>, ParentType, ContextType>;
  dataTableDosageFormGroupEdge?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroupsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableDosageFormGroupPayloadDataTableDosageFormGroupEdgeArgs, 'orderBy'>>;
  deletedDataTableDosageFormGroupNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableDosageFormPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableDosageFormPayload'] = ResolversParentTypes['DeleteDataTableDosageFormPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableDosageForm?: Resolver<Maybe<ResolversTypes['DataTableDosageForm']>, ParentType, ContextType>;
  dataTableDosageFormEdge?: Resolver<Maybe<ResolversTypes['DataTableDosageFormsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableDosageFormPayloadDataTableDosageFormEdgeArgs, 'orderBy'>>;
  deletedDataTableDosageFormNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableGenericIngredientPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableGenericIngredientPayload'] = ResolversParentTypes['DeleteDataTableGenericIngredientPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableGenericIngredient?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredient']>, ParentType, ContextType>;
  dataTableGenericIngredientEdge?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredientsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs, 'orderBy'>>;
  deletedDataTableGenericIngredientNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableManufacturerApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableManufacturerApplicationJoinPayload'] = ResolversParentTypes['DeleteDataTableManufacturerApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturer?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType>;
  dataTableManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoin']>, ParentType, ContextType>;
  dataTableManufacturerApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableManufacturerApplicationJoinPayloadDataTableManufacturerApplicationJoinEdgeArgs, 'orderBy'>>;
  deletedDataTableManufacturerApplicationJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableManufacturerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableManufacturerPayload'] = ResolversParentTypes['DeleteDataTableManufacturerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturer?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType>;
  dataTableManufacturerEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturersEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableManufacturerPayloadDataTableManufacturerEdgeArgs, 'orderBy'>>;
  deletedDataTableManufacturerNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableManufacturerRepresentativeApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableManufacturerRepresentativeApplicationJoinPayload'] = ResolversParentTypes['DeleteDataTableManufacturerRepresentativeApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoin']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableManufacturerRepresentativeApplicationJoinPayloadDataTableManufacturerRepresentativeApplicationJoinEdgeArgs, 'orderBy'>>;
  deletedDataTableManufacturerRepresentativeApplicationJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableManufacturerRepresentativePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableManufacturerRepresentativePayload'] = ResolversParentTypes['DeleteDataTableManufacturerRepresentativePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativesEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableManufacturerRepresentativePayloadDataTableManufacturerRepresentativeEdgeArgs, 'orderBy'>>;
  deletedDataTableManufacturerRepresentativeNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTablePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTablePayload'] = ResolversParentTypes['DeleteDataTablePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTable?: Resolver<Maybe<ResolversTypes['DataTable']>, ParentType, ContextType>;
  dataTableEdge?: Resolver<Maybe<ResolversTypes['DataTablesEdge']>, ParentType, ContextType, RequireFields<DeleteDataTablePayloadDataTableEdgeArgs, 'orderBy'>>;
  deletedDataTableNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTablePermitChemicalApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTablePermitChemicalApplicationJoinPayload'] = ResolversParentTypes['DeleteDataTablePermitChemicalApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType>;
  dataTablePermitChemicalApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoin']>, ParentType, ContextType>;
  dataTablePermitChemicalApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTablePermitChemicalApplicationJoinPayloadDataTablePermitChemicalApplicationJoinEdgeArgs, 'orderBy'>>;
  deletedDataTablePermitChemicalApplicationJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTablePermitChemicalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTablePermitChemicalPayload'] = ResolversParentTypes['DeleteDataTablePermitChemicalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType>;
  dataTablePermitChemicalEdge?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTablePermitChemicalPayloadDataTablePermitChemicalEdgeArgs, 'orderBy'>>;
  deletedDataTablePermitChemicalNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTablePreRegisteredProductsProvisionalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTablePreRegisteredProductsProvisionalPayload'] = ResolversParentTypes['DeleteDataTablePreRegisteredProductsProvisionalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePreRegisteredProductsProvisional?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisional']>, ParentType, ContextType>;
  dataTablePreRegisteredProductsProvisionalEdge?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisionalsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTablePreRegisteredProductsProvisionalPayloadDataTablePreRegisteredProductsProvisionalEdgeArgs, 'orderBy'>>;
  deletedDataTablePreRegisteredProductsProvisionalNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTablePrequalManufacturerApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTablePrequalManufacturerApplicationJoinPayload'] = ResolversParentTypes['DeleteDataTablePrequalManufacturerApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType>;
  dataTablePrequalManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoin']>, ParentType, ContextType>;
  dataTablePrequalManufacturerApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTablePrequalManufacturerApplicationJoinPayloadDataTablePrequalManufacturerApplicationJoinEdgeArgs, 'orderBy'>>;
  deletedDataTablePrequalManufacturerApplicationJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTablePrequalManufacturerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTablePrequalManufacturerPayload'] = ResolversParentTypes['DeleteDataTablePrequalManufacturerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType>;
  dataTablePrequalManufacturerEdge?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturersEdge']>, ParentType, ContextType, RequireFields<DeleteDataTablePrequalManufacturerPayloadDataTablePrequalManufacturerEdgeArgs, 'orderBy'>>;
  deletedDataTablePrequalManufacturerNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableProcessingStepPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableProcessingStepPayload'] = ResolversParentTypes['DeleteDataTableProcessingStepPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProcessingStep?: Resolver<Maybe<ResolversTypes['DataTableProcessingStep']>, ParentType, ContextType>;
  dataTableProcessingStepEdge?: Resolver<Maybe<ResolversTypes['DataTableProcessingStepsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs, 'orderBy'>>;
  deletedDataTableProcessingStepNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableProductApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableProductApplicationJoinPayload'] = ResolversParentTypes['DeleteDataTableProductApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoin']>, ParentType, ContextType>;
  dataTableProductApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs, 'orderBy'>>;
  deletedDataTableProductApplicationJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableProductPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableProductPayload'] = ResolversParentTypes['DeleteDataTableProductPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProduct?: Resolver<Maybe<ResolversTypes['DataTableProduct']>, ParentType, ContextType>;
  dataTableProductEdge?: Resolver<Maybe<ResolversTypes['DataTableProductsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableProductPayloadDataTableProductEdgeArgs, 'orderBy'>>;
  deletedDataTableProductNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableProvisionalProductApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableProvisionalProductApplicationJoinPayload'] = ResolversParentTypes['DeleteDataTableProvisionalProductApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType>;
  dataTableProvisionalProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoin']>, ParentType, ContextType>;
  dataTableProvisionalProductApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableProvisionalProductApplicationJoinPayloadDataTableProvisionalProductApplicationJoinEdgeArgs, 'orderBy'>>;
  deletedDataTableProvisionalProductApplicationJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableProvisionalProductPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableProvisionalProductPayload'] = ResolversParentTypes['DeleteDataTableProvisionalProductPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType>;
  dataTableProvisionalProductEdge?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableProvisionalProductPayloadDataTableProvisionalProductEdgeArgs, 'orderBy'>>;
  deletedDataTableProvisionalProductNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableScheduledChemicalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableScheduledChemicalPayload'] = ResolversParentTypes['DeleteDataTableScheduledChemicalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableScheduledChemical?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemical']>, ParentType, ContextType>;
  dataTableScheduledChemicalEdge?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemicalsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableScheduledChemicalPayloadDataTableScheduledChemicalEdgeArgs, 'orderBy'>>;
  deletedDataTableScheduledChemicalNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableStorageConditionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableStorageConditionPayload'] = ResolversParentTypes['DeleteDataTableStorageConditionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableStorageCondition?: Resolver<Maybe<ResolversTypes['DataTableStorageCondition']>, ParentType, ContextType>;
  dataTableStorageConditionEdge?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs, 'orderBy'>>;
  deletedDataTableStorageConditionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableStorageConditionsSimplifiedPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableStorageConditionsSimplifiedPayload'] = ResolversParentTypes['DeleteDataTableStorageConditionsSimplifiedPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableStorageConditionsSimplified?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplified']>, ParentType, ContextType>;
  dataTableStorageConditionsSimplifiedEdge?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplifiedsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableStorageConditionsSimplifiedPayloadDataTableStorageConditionsSimplifiedEdgeArgs, 'orderBy'>>;
  deletedDataTableStorageConditionsSimplifiedNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableUnitsOfProportionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableUnitsOfProportionPayload'] = ResolversParentTypes['DeleteDataTableUnitsOfProportionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableUnitsOfProportion?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportion']>, ParentType, ContextType>;
  dataTableUnitsOfProportionEdge?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportionsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs, 'orderBy'>>;
  deletedDataTableUnitsOfProportionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataTableWorldHealthOrganisationPqListOfFppPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataTableWorldHealthOrganisationPqListOfFppPayload'] = ResolversParentTypes['DeleteDataTableWorldHealthOrganisationPqListOfFppPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableWorldHealthOrganisationPqListOfFpp?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFpp']>, ParentType, ContextType>;
  dataTableWorldHealthOrganisationPqListOfFppEdge?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFppsEdge']>, ParentType, ContextType, RequireFields<DeleteDataTableWorldHealthOrganisationPqListOfFppPayloadDataTableWorldHealthOrganisationPqListOfFppEdgeArgs, 'orderBy'>>;
  deletedDataTableWorldHealthOrganisationPqListOfFppNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataViewColumnDefinitionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataViewColumnDefinitionPayload'] = ResolversParentTypes['DeleteDataViewColumnDefinitionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataViewColumnDefinition?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinition']>, ParentType, ContextType>;
  dataViewColumnDefinitionEdge?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinitionsEdge']>, ParentType, ContextType, RequireFields<DeleteDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs, 'orderBy'>>;
  deletedDataViewColumnDefinitionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteDataViewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteDataViewPayload'] = ResolversParentTypes['DeleteDataViewPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataView?: Resolver<Maybe<ResolversTypes['DataView']>, ParentType, ContextType>;
  dataViewEdge?: Resolver<Maybe<ResolversTypes['DataViewsEdge']>, ParentType, ContextType, RequireFields<DeleteDataViewPayloadDataViewEdgeArgs, 'orderBy'>>;
  deletedDataViewNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteElementTypePluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteElementTypePluginPayload'] = ResolversParentTypes['DeleteElementTypePluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedElementTypePluginNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  elementTypePlugin?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType>;
  elementTypePluginEdge?: Resolver<Maybe<ResolversTypes['ElementTypePluginsEdge']>, ParentType, ContextType, RequireFields<DeleteElementTypePluginPayloadElementTypePluginEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteFilePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteFilePayload'] = ResolversParentTypes['DeleteFilePayload']> = {
  applicationByApplicationSerial?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationNote?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedFileNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  fileEdge?: Resolver<Maybe<ResolversTypes['FilesEdge']>, ParentType, ContextType, RequireFields<DeleteFilePayloadFileEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteFilterPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteFilterPayload'] = ResolversParentTypes['DeleteFilterPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedFilterNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  filter?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType>;
  filterEdge?: Resolver<Maybe<ResolversTypes['FiltersEdge']>, ParentType, ContextType, RequireFields<DeleteFilterPayloadFilterEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteGrafanaDashboardImagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteGrafanaDashboardImagePayload'] = ResolversParentTypes['DeleteGrafanaDashboardImagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedGrafanaDashboardImageNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  grafanaDashboardImage?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImage']>, ParentType, ContextType>;
  grafanaDashboardImageEdge?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImagesEdge']>, ParentType, ContextType, RequireFields<DeleteGrafanaDashboardImagePayloadGrafanaDashboardImageEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteNotificationPayload'] = ResolversParentTypes['DeleteNotificationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedNotificationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<DeleteNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteOrganisationApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteOrganisationApplicationJoinPayload'] = ResolversParentTypes['DeleteOrganisationApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedOrganisationApplicationJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationApplicationJoin?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoin']>, ParentType, ContextType>;
  organisationApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteOrganisationPayload'] = ResolversParentTypes['DeleteOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedOrganisationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationEdge?: Resolver<Maybe<ResolversTypes['OrganisationsEdge']>, ParentType, ContextType, RequireFields<DeleteOrganisationPayloadOrganisationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePermissionJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePermissionJoinPayload'] = ResolversParentTypes['DeletePermissionJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedPermissionJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  permissionJoin?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType>;
  permissionJoinEdge?: Resolver<Maybe<ResolversTypes['PermissionJoinsEdge']>, ParentType, ContextType, RequireFields<DeletePermissionJoinPayloadPermissionJoinEdgeArgs, 'orderBy'>>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePermissionNamePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePermissionNamePayload'] = ResolversParentTypes['DeletePermissionNamePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedPermissionNameNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  permissionNameEdge?: Resolver<Maybe<ResolversTypes['PermissionNamesEdge']>, ParentType, ContextType, RequireFields<DeletePermissionNamePayloadPermissionNameEdgeArgs, 'orderBy'>>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeletePermissionPolicyPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeletePermissionPolicyPayload'] = ResolversParentTypes['DeletePermissionPolicyPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedPermissionPolicyNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  permissionPolicyEdge?: Resolver<Maybe<ResolversTypes['PermissionPoliciesEdge']>, ParentType, ContextType, RequireFields<DeletePermissionPolicyPayloadPermissionPolicyEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewAssignmentAssignerJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewAssignmentAssignerJoinPayload'] = ResolversParentTypes['DeleteReviewAssignmentAssignerJoinPayload']> = {
  assigner?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedReviewAssignmentAssignerJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewAssignmentAssignerJoin?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoin']>, ParentType, ContextType>;
  reviewAssignmentAssignerJoinEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewAssignmentPayload'] = ResolversParentTypes['DeleteReviewAssignmentPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  assigner?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedReviewAssignmentNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewAssignmentPayloadReviewAssignmentEdgeArgs, 'orderBy'>>;
  reviewer?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewDecisionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewDecisionPayload'] = ResolversParentTypes['DeleteReviewDecisionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedReviewDecisionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  reviewDecisionEdge?: Resolver<Maybe<ResolversTypes['ReviewDecisionsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewDecisionPayloadReviewDecisionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewPayload'] = ResolversParentTypes['DeleteReviewPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedReviewNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<DeleteReviewPayloadReviewEdgeArgs, 'orderBy'>>;
  reviewer?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewResponsePayload'] = ResolversParentTypes['DeleteReviewResponsePayload']> = {
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedReviewResponseNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  originalReviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  reviewResponseEdge?: Resolver<Maybe<ResolversTypes['ReviewResponsesEdge']>, ParentType, ContextType, RequireFields<DeleteReviewResponsePayloadReviewResponseEdgeArgs, 'orderBy'>>;
  reviewResponseLink?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteReviewStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteReviewStatusHistoryPayload'] = ResolversParentTypes['DeleteReviewStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedReviewStatusHistoryNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewStatusHistory?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType>;
  reviewStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ReviewStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<DeleteReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteSystemInfoPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteSystemInfoPayload'] = ResolversParentTypes['DeleteSystemInfoPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedSystemInfoNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  systemInfo?: Resolver<Maybe<ResolversTypes['SystemInfo']>, ParentType, ContextType>;
  systemInfoEdge?: Resolver<Maybe<ResolversTypes['SystemInfosEdge']>, ParentType, ContextType, RequireFields<DeleteSystemInfoPayloadSystemInfoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateActionPayload'] = ResolversParentTypes['DeleteTemplateActionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplateActionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateAction?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType>;
  templateActionEdge?: Resolver<Maybe<ResolversTypes['TemplateActionsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateActionPayloadTemplateActionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateCategoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateCategoryPayload'] = ResolversParentTypes['DeleteTemplateCategoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplateCategoryNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateCategory?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType>;
  templateCategoryEdge?: Resolver<Maybe<ResolversTypes['TemplateCategoriesEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateCategoryPayloadTemplateCategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateElementPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateElementPayload'] = ResolversParentTypes['DeleteTemplateElementPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplateElementNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  templateElementEdge?: Resolver<Maybe<ResolversTypes['TemplateElementsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateElementPayloadTemplateElementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateFilterJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateFilterJoinPayload'] = ResolversParentTypes['DeleteTemplateFilterJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplateFilterJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  filter?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateFilterJoin?: Resolver<Maybe<ResolversTypes['TemplateFilterJoin']>, ParentType, ContextType>;
  templateFilterJoinEdge?: Resolver<Maybe<ResolversTypes['TemplateFilterJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplatePayload'] = ResolversParentTypes['DeleteTemplatePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplateNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateCategory?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<DeleteTemplatePayloadTemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplatePermissionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplatePermissionPayload'] = ResolversParentTypes['DeleteTemplatePermissionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplatePermissionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templatePermission?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType>;
  templatePermissionEdge?: Resolver<Maybe<ResolversTypes['TemplatePermissionsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplatePermissionPayloadTemplatePermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateSectionPayload'] = ResolversParentTypes['DeleteTemplateSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplateSectionNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateSectionEdge?: Resolver<Maybe<ResolversTypes['TemplateSectionsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateSectionPayloadTemplateSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateStagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateStagePayload'] = ResolversParentTypes['DeleteTemplateStagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplateStageNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateStage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  templateStageEdge?: Resolver<Maybe<ResolversTypes['TemplateStagesEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateStagePayloadTemplateStageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTemplateStageReviewLevelPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTemplateStageReviewLevelPayload'] = ResolversParentTypes['DeleteTemplateStageReviewLevelPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTemplateStageReviewLevelNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  templateStageReviewLevel?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType>;
  templateStageReviewLevelEdge?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevelsEdge']>, ParentType, ContextType, RequireFields<DeleteTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTriggerQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTriggerQueuePayload'] = ResolversParentTypes['DeleteTriggerQueuePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTriggerQueueNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueue?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  triggerQueueEdge?: Resolver<Maybe<ResolversTypes['TriggerQueuesEdge']>, ParentType, ContextType, RequireFields<DeleteTriggerQueuePayloadTriggerQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteTriggerSchedulePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteTriggerSchedulePayload'] = ResolversParentTypes['DeleteTriggerSchedulePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedTriggerScheduleNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  triggerSchedule?: Resolver<Maybe<ResolversTypes['TriggerSchedule']>, ParentType, ContextType>;
  triggerScheduleEdge?: Resolver<Maybe<ResolversTypes['TriggerSchedulesEdge']>, ParentType, ContextType, RequireFields<DeleteTriggerSchedulePayloadTriggerScheduleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteUserApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteUserApplicationJoinPayload'] = ResolversParentTypes['DeleteUserApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedUserApplicationJoinNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userApplicationJoin?: Resolver<Maybe<ResolversTypes['UserApplicationJoin']>, ParentType, ContextType>;
  userApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['UserApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<DeleteUserApplicationJoinPayloadUserApplicationJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteUserOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteUserOrganisationPayload'] = ResolversParentTypes['DeleteUserOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedUserOrganisationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userOrganisation?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType>;
  userOrganisationEdge?: Resolver<Maybe<ResolversTypes['UserOrganisationsEdge']>, ParentType, ContextType, RequireFields<DeleteUserOrganisationPayloadUserOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteVerificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteVerificationPayload'] = ResolversParentTypes['DeleteVerificationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  deletedVerificationNodeId?: Resolver<Maybe<ResolversTypes['ID']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  verification?: Resolver<Maybe<ResolversTypes['Verification']>, ParentType, ContextType>;
  verificationEdge?: Resolver<Maybe<ResolversTypes['VerificationsEdge']>, ParentType, ContextType, RequireFields<DeleteVerificationPayloadVerificationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type DeleteWholeApplicationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['DeleteWholeApplicationPayload'] = ResolversParentTypes['DeleteWholeApplicationPayload']> = {
  boolean?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElementTypePluginResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElementTypePlugin'] = ResolversParentTypes['ElementTypePlugin']> = {
  category?: Resolver<Maybe<ResolversTypes['TemplateElementCategory']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  configComponentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  displayComponentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  path?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  requiredParameters?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElementTypePluginsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElementTypePluginsConnection'] = ResolversParentTypes['ElementTypePluginsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ElementTypePluginsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ElementTypePlugin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ElementTypePluginsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ElementTypePluginsEdge'] = ResolversParentTypes['ElementTypePluginsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FileResolvers<ContextType = any, ParentType extends ResolversParentTypes['File'] = ResolversParentTypes['File']> = {
  applicationByApplicationSerial?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationNote?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType>;
  applicationNoteId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  applicationResponseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  applicationSerial?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  archivePath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filePath?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  fileSize?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isExternalReferenceDoc?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isInternalReferenceDoc?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  isOutputDoc?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  mimetype?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  originalFilename?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  submitted?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  thumbnailPath?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  toBeDeleted?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  uniqueId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilesConnection'] = ResolversParentTypes['FilesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['FilesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['File']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FilesEdge'] = ResolversParentTypes['FilesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FilterResolvers<ContextType = any, ParentType extends ResolversParentTypes['Filter'] = ResolversParentTypes['Filter']> = {
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  templateFilterJoins?: Resolver<ResolversTypes['TemplateFilterJoinsConnection'], ParentType, ContextType, RequireFields<FilterTemplateFilterJoinsArgs, 'orderBy'>>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userRole?: Resolver<Maybe<ResolversTypes['PermissionPolicyType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FiltersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['FiltersConnection'] = ResolversParentTypes['FiltersConnection']> = {
  edges?: Resolver<Array<ResolversTypes['FiltersEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Filter']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type FiltersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['FiltersEdge'] = ResolversParentTypes['FiltersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrafanaDashboardImageResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrafanaDashboardImage'] = ResolversParentTypes['GrafanaDashboardImage']> = {
  data?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  updatedDate?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrafanaDashboardImagesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrafanaDashboardImagesConnection'] = ResolversParentTypes['GrafanaDashboardImagesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['GrafanaDashboardImagesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['GrafanaDashboardImage']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type GrafanaDashboardImagesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['GrafanaDashboardImagesEdge'] = ResolversParentTypes['GrafanaDashboardImagesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface JsonScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['JSON'], any> {
  name: 'JSON';
}

export type MutationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Mutation'] = ResolversParentTypes['Mutation']> = {
  createActionPlugin?: Resolver<Maybe<ResolversTypes['CreateActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationCreateActionPluginArgs, 'input'>>;
  createActionQueue?: Resolver<Maybe<ResolversTypes['CreateActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationCreateActionQueueArgs, 'input'>>;
  createActivityLog?: Resolver<Maybe<ResolversTypes['CreateActivityLogPayload']>, ParentType, ContextType, RequireFields<MutationCreateActivityLogArgs, 'input'>>;
  createAllowedSelfAssignableSectionsShape?: Resolver<Maybe<ResolversTypes['CreateAllowedSelfAssignableSectionsShapePayload']>, ParentType, ContextType, RequireFields<MutationCreateAllowedSelfAssignableSectionsShapeArgs, 'input'>>;
  createApplication?: Resolver<Maybe<ResolversTypes['CreateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationArgs, 'input'>>;
  createApplicationListShape?: Resolver<Maybe<ResolversTypes['CreateApplicationListShapePayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationListShapeArgs, 'input'>>;
  createApplicationNote?: Resolver<Maybe<ResolversTypes['CreateApplicationNotePayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationNoteArgs, 'input'>>;
  createApplicationResponse?: Resolver<Maybe<ResolversTypes['CreateApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationResponseArgs, 'input'>>;
  createApplicationReviewerAction?: Resolver<Maybe<ResolversTypes['CreateApplicationReviewerActionPayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationReviewerActionArgs, 'input'>>;
  createApplicationStageHistory?: Resolver<Maybe<ResolversTypes['CreateApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationStageHistoryArgs, 'input'>>;
  createApplicationStatusHistory?: Resolver<Maybe<ResolversTypes['CreateApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationCreateApplicationStatusHistoryArgs, 'input'>>;
  createCounter?: Resolver<Maybe<ResolversTypes['CreateCounterPayload']>, ParentType, ContextType, RequireFields<MutationCreateCounterArgs, 'input'>>;
  createDataChangelog?: Resolver<Maybe<ResolversTypes['CreateDataChangelogPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataChangelogArgs, 'input'>>;
  createDataTable?: Resolver<Maybe<ResolversTypes['CreateDataTablePayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableArgs, 'input'>>;
  createDataTableActiveIngredient?: Resolver<Maybe<ResolversTypes['CreateDataTableActiveIngredientPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableActiveIngredientArgs, 'input'>>;
  createDataTableAdministrationRoute?: Resolver<Maybe<ResolversTypes['CreateDataTableAdministrationRoutePayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableAdministrationRouteArgs, 'input'>>;
  createDataTableAtcCode?: Resolver<Maybe<ResolversTypes['CreateDataTableAtcCodePayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableAtcCodeArgs, 'input'>>;
  createDataTableContainer?: Resolver<Maybe<ResolversTypes['CreateDataTableContainerPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableContainerArgs, 'input'>>;
  createDataTableCountry?: Resolver<Maybe<ResolversTypes['CreateDataTableCountryPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableCountryArgs, 'input'>>;
  createDataTableDosageForm?: Resolver<Maybe<ResolversTypes['CreateDataTableDosageFormPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableDosageFormArgs, 'input'>>;
  createDataTableDosageFormGroup?: Resolver<Maybe<ResolversTypes['CreateDataTableDosageFormGroupPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableDosageFormGroupArgs, 'input'>>;
  createDataTableGenericIngredient?: Resolver<Maybe<ResolversTypes['CreateDataTableGenericIngredientPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableGenericIngredientArgs, 'input'>>;
  createDataTableManufacturer?: Resolver<Maybe<ResolversTypes['CreateDataTableManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableManufacturerArgs, 'input'>>;
  createDataTableManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['CreateDataTableManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableManufacturerApplicationJoinArgs, 'input'>>;
  createDataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['CreateDataTableManufacturerRepresentativePayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableManufacturerRepresentativeArgs, 'input'>>;
  createDataTableManufacturerRepresentativeApplicationJoin?: Resolver<Maybe<ResolversTypes['CreateDataTableManufacturerRepresentativeApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableManufacturerRepresentativeApplicationJoinArgs, 'input'>>;
  createDataTablePermitChemical?: Resolver<Maybe<ResolversTypes['CreateDataTablePermitChemicalPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTablePermitChemicalArgs, 'input'>>;
  createDataTablePermitChemicalApplicationJoin?: Resolver<Maybe<ResolversTypes['CreateDataTablePermitChemicalApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTablePermitChemicalApplicationJoinArgs, 'input'>>;
  createDataTablePreRegisteredProductsProvisional?: Resolver<Maybe<ResolversTypes['CreateDataTablePreRegisteredProductsProvisionalPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTablePreRegisteredProductsProvisionalArgs, 'input'>>;
  createDataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['CreateDataTablePrequalManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTablePrequalManufacturerArgs, 'input'>>;
  createDataTablePrequalManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['CreateDataTablePrequalManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTablePrequalManufacturerApplicationJoinArgs, 'input'>>;
  createDataTableProcessingStep?: Resolver<Maybe<ResolversTypes['CreateDataTableProcessingStepPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableProcessingStepArgs, 'input'>>;
  createDataTableProduct?: Resolver<Maybe<ResolversTypes['CreateDataTableProductPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableProductArgs, 'input'>>;
  createDataTableProductApplicationJoin?: Resolver<Maybe<ResolversTypes['CreateDataTableProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableProductApplicationJoinArgs, 'input'>>;
  createDataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['CreateDataTableProvisionalProductPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableProvisionalProductArgs, 'input'>>;
  createDataTableProvisionalProductApplicationJoin?: Resolver<Maybe<ResolversTypes['CreateDataTableProvisionalProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableProvisionalProductApplicationJoinArgs, 'input'>>;
  createDataTableScheduledChemical?: Resolver<Maybe<ResolversTypes['CreateDataTableScheduledChemicalPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableScheduledChemicalArgs, 'input'>>;
  createDataTableStorageCondition?: Resolver<Maybe<ResolversTypes['CreateDataTableStorageConditionPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableStorageConditionArgs, 'input'>>;
  createDataTableStorageConditionsSimplified?: Resolver<Maybe<ResolversTypes['CreateDataTableStorageConditionsSimplifiedPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableStorageConditionsSimplifiedArgs, 'input'>>;
  createDataTableUnitsOfProportion?: Resolver<Maybe<ResolversTypes['CreateDataTableUnitsOfProportionPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableUnitsOfProportionArgs, 'input'>>;
  createDataTableWorldHealthOrganisationPqListOfFpp?: Resolver<Maybe<ResolversTypes['CreateDataTableWorldHealthOrganisationPqListOfFppPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataTableWorldHealthOrganisationPqListOfFppArgs, 'input'>>;
  createDataView?: Resolver<Maybe<ResolversTypes['CreateDataViewPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataViewArgs, 'input'>>;
  createDataViewColumnDefinition?: Resolver<Maybe<ResolversTypes['CreateDataViewColumnDefinitionPayload']>, ParentType, ContextType, RequireFields<MutationCreateDataViewColumnDefinitionArgs, 'input'>>;
  createElementTypePlugin?: Resolver<Maybe<ResolversTypes['CreateElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationCreateElementTypePluginArgs, 'input'>>;
  createFile?: Resolver<Maybe<ResolversTypes['CreateFilePayload']>, ParentType, ContextType, RequireFields<MutationCreateFileArgs, 'input'>>;
  createFilter?: Resolver<Maybe<ResolversTypes['CreateFilterPayload']>, ParentType, ContextType, RequireFields<MutationCreateFilterArgs, 'input'>>;
  createGrafanaDashboardImage?: Resolver<Maybe<ResolversTypes['CreateGrafanaDashboardImagePayload']>, ParentType, ContextType, RequireFields<MutationCreateGrafanaDashboardImageArgs, 'input'>>;
  createNotification?: Resolver<Maybe<ResolversTypes['CreateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationCreateNotificationArgs, 'input'>>;
  createOrganisation?: Resolver<Maybe<ResolversTypes['CreateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationCreateOrganisationArgs, 'input'>>;
  createOrganisationApplicationJoin?: Resolver<Maybe<ResolversTypes['CreateOrganisationApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateOrganisationApplicationJoinArgs, 'input'>>;
  createPermissionJoin?: Resolver<Maybe<ResolversTypes['CreatePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreatePermissionJoinArgs, 'input'>>;
  createPermissionName?: Resolver<Maybe<ResolversTypes['CreatePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationCreatePermissionNameArgs, 'input'>>;
  createPermissionPolicy?: Resolver<Maybe<ResolversTypes['CreatePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationCreatePermissionPolicyArgs, 'input'>>;
  createReview?: Resolver<Maybe<ResolversTypes['CreateReviewPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewArgs, 'input'>>;
  createReviewAssignment?: Resolver<Maybe<ResolversTypes['CreateReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewAssignmentArgs, 'input'>>;
  createReviewAssignmentAssignedSectionsShape?: Resolver<Maybe<ResolversTypes['CreateReviewAssignmentAssignedSectionsShapePayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewAssignmentAssignedSectionsShapeArgs, 'input'>>;
  createReviewAssignmentAssignerJoin?: Resolver<Maybe<ResolversTypes['CreateReviewAssignmentAssignerJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewAssignmentAssignerJoinArgs, 'input'>>;
  createReviewDecision?: Resolver<Maybe<ResolversTypes['CreateReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewDecisionArgs, 'input'>>;
  createReviewResponse?: Resolver<Maybe<ResolversTypes['CreateReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewResponseArgs, 'input'>>;
  createReviewStatusHistory?: Resolver<Maybe<ResolversTypes['CreateReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationCreateReviewStatusHistoryArgs, 'input'>>;
  createSystemInfo?: Resolver<Maybe<ResolversTypes['CreateSystemInfoPayload']>, ParentType, ContextType, RequireFields<MutationCreateSystemInfoArgs, 'input'>>;
  createTemplate?: Resolver<Maybe<ResolversTypes['CreateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateArgs, 'input'>>;
  createTemplateAction?: Resolver<Maybe<ResolversTypes['CreateTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateActionArgs, 'input'>>;
  createTemplateCategory?: Resolver<Maybe<ResolversTypes['CreateTemplateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateCategoryArgs, 'input'>>;
  createTemplateElement?: Resolver<Maybe<ResolversTypes['CreateTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateElementArgs, 'input'>>;
  createTemplateFilterJoin?: Resolver<Maybe<ResolversTypes['CreateTemplateFilterJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateFilterJoinArgs, 'input'>>;
  createTemplatePermission?: Resolver<Maybe<ResolversTypes['CreateTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplatePermissionArgs, 'input'>>;
  createTemplateSection?: Resolver<Maybe<ResolversTypes['CreateTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateSectionArgs, 'input'>>;
  createTemplateStage?: Resolver<Maybe<ResolversTypes['CreateTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateStageArgs, 'input'>>;
  createTemplateStageReviewLevel?: Resolver<Maybe<ResolversTypes['CreateTemplateStageReviewLevelPayload']>, ParentType, ContextType, RequireFields<MutationCreateTemplateStageReviewLevelArgs, 'input'>>;
  createTriggerQueue?: Resolver<Maybe<ResolversTypes['CreateTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationCreateTriggerQueueArgs, 'input'>>;
  createTriggerSchedule?: Resolver<Maybe<ResolversTypes['CreateTriggerSchedulePayload']>, ParentType, ContextType, RequireFields<MutationCreateTriggerScheduleArgs, 'input'>>;
  createUser?: Resolver<Maybe<ResolversTypes['CreateUserPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserArgs, 'input'>>;
  createUserApplicationJoin?: Resolver<Maybe<ResolversTypes['CreateUserApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserApplicationJoinArgs, 'input'>>;
  createUserList?: Resolver<Maybe<ResolversTypes['CreateUserListPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserListArgs, 'input'>>;
  createUserOrganisation?: Resolver<Maybe<ResolversTypes['CreateUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationCreateUserOrganisationArgs, 'input'>>;
  createVerification?: Resolver<Maybe<ResolversTypes['CreateVerificationPayload']>, ParentType, ContextType, RequireFields<MutationCreateVerificationArgs, 'input'>>;
  deleteActionPlugin?: Resolver<Maybe<ResolversTypes['DeleteActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionPluginArgs, 'input'>>;
  deleteActionPluginByCode?: Resolver<Maybe<ResolversTypes['DeleteActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionPluginByCodeArgs, 'input'>>;
  deleteActionPluginByNodeId?: Resolver<Maybe<ResolversTypes['DeleteActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionPluginByNodeIdArgs, 'input'>>;
  deleteActionQueue?: Resolver<Maybe<ResolversTypes['DeleteActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionQueueArgs, 'input'>>;
  deleteActionQueueByNodeId?: Resolver<Maybe<ResolversTypes['DeleteActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationDeleteActionQueueByNodeIdArgs, 'input'>>;
  deleteActivityLog?: Resolver<Maybe<ResolversTypes['DeleteActivityLogPayload']>, ParentType, ContextType, RequireFields<MutationDeleteActivityLogArgs, 'input'>>;
  deleteActivityLogByNodeId?: Resolver<Maybe<ResolversTypes['DeleteActivityLogPayload']>, ParentType, ContextType, RequireFields<MutationDeleteActivityLogByNodeIdArgs, 'input'>>;
  deleteApplication?: Resolver<Maybe<ResolversTypes['DeleteApplicationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationArgs, 'input'>>;
  deleteApplicationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationByNodeIdArgs, 'input'>>;
  deleteApplicationByOutcomeRegistration?: Resolver<Maybe<ResolversTypes['DeleteApplicationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationByOutcomeRegistrationArgs, 'input'>>;
  deleteApplicationBySerial?: Resolver<Maybe<ResolversTypes['DeleteApplicationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationBySerialArgs, 'input'>>;
  deleteApplicationNote?: Resolver<Maybe<ResolversTypes['DeleteApplicationNotePayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationNoteArgs, 'input'>>;
  deleteApplicationNoteByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationNotePayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationNoteByNodeIdArgs, 'input'>>;
  deleteApplicationResponse?: Resolver<Maybe<ResolversTypes['DeleteApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationResponseArgs, 'input'>>;
  deleteApplicationResponseByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationResponseByNodeIdArgs, 'input'>>;
  deleteApplicationReviewerAction?: Resolver<Maybe<ResolversTypes['DeleteApplicationReviewerActionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationReviewerActionArgs, 'input'>>;
  deleteApplicationReviewerActionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationReviewerActionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationReviewerActionByNodeIdArgs, 'input'>>;
  deleteApplicationReviewerActionByUserIdAndApplicationId?: Resolver<Maybe<ResolversTypes['DeleteApplicationReviewerActionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationReviewerActionByUserIdAndApplicationIdArgs, 'input'>>;
  deleteApplicationStageHistory?: Resolver<Maybe<ResolversTypes['DeleteApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationStageHistoryArgs, 'input'>>;
  deleteApplicationStageHistoryByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationStageHistoryByNodeIdArgs, 'input'>>;
  deleteApplicationStatusHistory?: Resolver<Maybe<ResolversTypes['DeleteApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationStatusHistoryArgs, 'input'>>;
  deleteApplicationStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['DeleteApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteApplicationStatusHistoryByNodeIdArgs, 'input'>>;
  deleteCounter?: Resolver<Maybe<ResolversTypes['DeleteCounterPayload']>, ParentType, ContextType, RequireFields<MutationDeleteCounterArgs, 'input'>>;
  deleteCounterByName?: Resolver<Maybe<ResolversTypes['DeleteCounterPayload']>, ParentType, ContextType, RequireFields<MutationDeleteCounterByNameArgs, 'input'>>;
  deleteCounterByNodeId?: Resolver<Maybe<ResolversTypes['DeleteCounterPayload']>, ParentType, ContextType, RequireFields<MutationDeleteCounterByNodeIdArgs, 'input'>>;
  deleteDataChangelog?: Resolver<Maybe<ResolversTypes['DeleteDataChangelogPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataChangelogArgs, 'input'>>;
  deleteDataChangelogByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataChangelogPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataChangelogByNodeIdArgs, 'input'>>;
  deleteDataTable?: Resolver<Maybe<ResolversTypes['DeleteDataTablePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableArgs, 'input'>>;
  deleteDataTableActiveIngredient?: Resolver<Maybe<ResolversTypes['DeleteDataTableActiveIngredientPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableActiveIngredientArgs, 'input'>>;
  deleteDataTableActiveIngredientByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableActiveIngredientPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableActiveIngredientByNodeIdArgs, 'input'>>;
  deleteDataTableAdministrationRoute?: Resolver<Maybe<ResolversTypes['DeleteDataTableAdministrationRoutePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableAdministrationRouteArgs, 'input'>>;
  deleteDataTableAdministrationRouteByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableAdministrationRoutePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableAdministrationRouteByNodeIdArgs, 'input'>>;
  deleteDataTableAtcCode?: Resolver<Maybe<ResolversTypes['DeleteDataTableAtcCodePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableAtcCodeArgs, 'input'>>;
  deleteDataTableAtcCodeByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableAtcCodePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableAtcCodeByNodeIdArgs, 'input'>>;
  deleteDataTableByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTablePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableByNodeIdArgs, 'input'>>;
  deleteDataTableByTableName?: Resolver<Maybe<ResolversTypes['DeleteDataTablePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableByTableNameArgs, 'input'>>;
  deleteDataTableContainer?: Resolver<Maybe<ResolversTypes['DeleteDataTableContainerPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableContainerArgs, 'input'>>;
  deleteDataTableContainerByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableContainerPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableContainerByNodeIdArgs, 'input'>>;
  deleteDataTableCountry?: Resolver<Maybe<ResolversTypes['DeleteDataTableCountryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableCountryArgs, 'input'>>;
  deleteDataTableCountryByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableCountryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableCountryByNodeIdArgs, 'input'>>;
  deleteDataTableDosageForm?: Resolver<Maybe<ResolversTypes['DeleteDataTableDosageFormPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableDosageFormArgs, 'input'>>;
  deleteDataTableDosageFormByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableDosageFormPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableDosageFormByNodeIdArgs, 'input'>>;
  deleteDataTableDosageFormGroup?: Resolver<Maybe<ResolversTypes['DeleteDataTableDosageFormGroupPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableDosageFormGroupArgs, 'input'>>;
  deleteDataTableDosageFormGroupByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableDosageFormGroupPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableDosageFormGroupByNodeIdArgs, 'input'>>;
  deleteDataTableGenericIngredient?: Resolver<Maybe<ResolversTypes['DeleteDataTableGenericIngredientPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableGenericIngredientArgs, 'input'>>;
  deleteDataTableGenericIngredientByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableGenericIngredientPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableGenericIngredientByNodeIdArgs, 'input'>>;
  deleteDataTableManufacturer?: Resolver<Maybe<ResolversTypes['DeleteDataTableManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableManufacturerArgs, 'input'>>;
  deleteDataTableManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DeleteDataTableManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableManufacturerApplicationJoinArgs, 'input'>>;
  deleteDataTableManufacturerApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableManufacturerApplicationJoinByNodeIdArgs, 'input'>>;
  deleteDataTableManufacturerByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableManufacturerByNodeIdArgs, 'input'>>;
  deleteDataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DeleteDataTableManufacturerRepresentativePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableManufacturerRepresentativeArgs, 'input'>>;
  deleteDataTableManufacturerRepresentativeApplicationJoin?: Resolver<Maybe<ResolversTypes['DeleteDataTableManufacturerRepresentativeApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableManufacturerRepresentativeApplicationJoinArgs, 'input'>>;
  deleteDataTableManufacturerRepresentativeApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableManufacturerRepresentativeApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableManufacturerRepresentativeApplicationJoinByNodeIdArgs, 'input'>>;
  deleteDataTableManufacturerRepresentativeByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableManufacturerRepresentativePayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableManufacturerRepresentativeByNodeIdArgs, 'input'>>;
  deleteDataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DeleteDataTablePermitChemicalPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePermitChemicalArgs, 'input'>>;
  deleteDataTablePermitChemicalApplicationJoin?: Resolver<Maybe<ResolversTypes['DeleteDataTablePermitChemicalApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePermitChemicalApplicationJoinArgs, 'input'>>;
  deleteDataTablePermitChemicalApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTablePermitChemicalApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePermitChemicalApplicationJoinByNodeIdArgs, 'input'>>;
  deleteDataTablePermitChemicalByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTablePermitChemicalPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePermitChemicalByNodeIdArgs, 'input'>>;
  deleteDataTablePreRegisteredProductsProvisional?: Resolver<Maybe<ResolversTypes['DeleteDataTablePreRegisteredProductsProvisionalPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePreRegisteredProductsProvisionalArgs, 'input'>>;
  deleteDataTablePreRegisteredProductsProvisionalByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTablePreRegisteredProductsProvisionalPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePreRegisteredProductsProvisionalByNodeIdArgs, 'input'>>;
  deleteDataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DeleteDataTablePrequalManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePrequalManufacturerArgs, 'input'>>;
  deleteDataTablePrequalManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DeleteDataTablePrequalManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePrequalManufacturerApplicationJoinArgs, 'input'>>;
  deleteDataTablePrequalManufacturerApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTablePrequalManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePrequalManufacturerApplicationJoinByNodeIdArgs, 'input'>>;
  deleteDataTablePrequalManufacturerByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTablePrequalManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTablePrequalManufacturerByNodeIdArgs, 'input'>>;
  deleteDataTableProcessingStep?: Resolver<Maybe<ResolversTypes['DeleteDataTableProcessingStepPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProcessingStepArgs, 'input'>>;
  deleteDataTableProcessingStepByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableProcessingStepPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProcessingStepByNodeIdArgs, 'input'>>;
  deleteDataTableProduct?: Resolver<Maybe<ResolversTypes['DeleteDataTableProductPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProductArgs, 'input'>>;
  deleteDataTableProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DeleteDataTableProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProductApplicationJoinArgs, 'input'>>;
  deleteDataTableProductApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProductApplicationJoinByNodeIdArgs, 'input'>>;
  deleteDataTableProductByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableProductPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProductByNodeIdArgs, 'input'>>;
  deleteDataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DeleteDataTableProvisionalProductPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProvisionalProductArgs, 'input'>>;
  deleteDataTableProvisionalProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DeleteDataTableProvisionalProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProvisionalProductApplicationJoinArgs, 'input'>>;
  deleteDataTableProvisionalProductApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableProvisionalProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProvisionalProductApplicationJoinByNodeIdArgs, 'input'>>;
  deleteDataTableProvisionalProductByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableProvisionalProductPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableProvisionalProductByNodeIdArgs, 'input'>>;
  deleteDataTableScheduledChemical?: Resolver<Maybe<ResolversTypes['DeleteDataTableScheduledChemicalPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableScheduledChemicalArgs, 'input'>>;
  deleteDataTableScheduledChemicalByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableScheduledChemicalPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableScheduledChemicalByNodeIdArgs, 'input'>>;
  deleteDataTableStorageCondition?: Resolver<Maybe<ResolversTypes['DeleteDataTableStorageConditionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableStorageConditionArgs, 'input'>>;
  deleteDataTableStorageConditionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableStorageConditionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableStorageConditionByNodeIdArgs, 'input'>>;
  deleteDataTableStorageConditionsSimplified?: Resolver<Maybe<ResolversTypes['DeleteDataTableStorageConditionsSimplifiedPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableStorageConditionsSimplifiedArgs, 'input'>>;
  deleteDataTableStorageConditionsSimplifiedByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableStorageConditionsSimplifiedPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableStorageConditionsSimplifiedByNodeIdArgs, 'input'>>;
  deleteDataTableUnitsOfProportion?: Resolver<Maybe<ResolversTypes['DeleteDataTableUnitsOfProportionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableUnitsOfProportionArgs, 'input'>>;
  deleteDataTableUnitsOfProportionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableUnitsOfProportionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableUnitsOfProportionByNodeIdArgs, 'input'>>;
  deleteDataTableWorldHealthOrganisationPqListOfFpp?: Resolver<Maybe<ResolversTypes['DeleteDataTableWorldHealthOrganisationPqListOfFppPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableWorldHealthOrganisationPqListOfFppArgs, 'input'>>;
  deleteDataTableWorldHealthOrganisationPqListOfFppByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataTableWorldHealthOrganisationPqListOfFppPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataTableWorldHealthOrganisationPqListOfFppByNodeIdArgs, 'input'>>;
  deleteDataView?: Resolver<Maybe<ResolversTypes['DeleteDataViewPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataViewArgs, 'input'>>;
  deleteDataViewByIdentifier?: Resolver<Maybe<ResolversTypes['DeleteDataViewPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataViewByIdentifierArgs, 'input'>>;
  deleteDataViewByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataViewPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataViewByNodeIdArgs, 'input'>>;
  deleteDataViewColumnDefinition?: Resolver<Maybe<ResolversTypes['DeleteDataViewColumnDefinitionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataViewColumnDefinitionArgs, 'input'>>;
  deleteDataViewColumnDefinitionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteDataViewColumnDefinitionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataViewColumnDefinitionByNodeIdArgs, 'input'>>;
  deleteDataViewColumnDefinitionByTableNameAndColumnName?: Resolver<Maybe<ResolversTypes['DeleteDataViewColumnDefinitionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteDataViewColumnDefinitionByTableNameAndColumnNameArgs, 'input'>>;
  deleteElementTypePlugin?: Resolver<Maybe<ResolversTypes['DeleteElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteElementTypePluginArgs, 'input'>>;
  deleteElementTypePluginByNodeId?: Resolver<Maybe<ResolversTypes['DeleteElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationDeleteElementTypePluginByNodeIdArgs, 'input'>>;
  deleteFile?: Resolver<Maybe<ResolversTypes['DeleteFilePayload']>, ParentType, ContextType, RequireFields<MutationDeleteFileArgs, 'input'>>;
  deleteFileByNodeId?: Resolver<Maybe<ResolversTypes['DeleteFilePayload']>, ParentType, ContextType, RequireFields<MutationDeleteFileByNodeIdArgs, 'input'>>;
  deleteFileByUniqueId?: Resolver<Maybe<ResolversTypes['DeleteFilePayload']>, ParentType, ContextType, RequireFields<MutationDeleteFileByUniqueIdArgs, 'input'>>;
  deleteFilter?: Resolver<Maybe<ResolversTypes['DeleteFilterPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFilterArgs, 'input'>>;
  deleteFilterByCode?: Resolver<Maybe<ResolversTypes['DeleteFilterPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFilterByCodeArgs, 'input'>>;
  deleteFilterByNodeId?: Resolver<Maybe<ResolversTypes['DeleteFilterPayload']>, ParentType, ContextType, RequireFields<MutationDeleteFilterByNodeIdArgs, 'input'>>;
  deleteGrafanaDashboardImage?: Resolver<Maybe<ResolversTypes['DeleteGrafanaDashboardImagePayload']>, ParentType, ContextType, RequireFields<MutationDeleteGrafanaDashboardImageArgs, 'input'>>;
  deleteGrafanaDashboardImageByNodeId?: Resolver<Maybe<ResolversTypes['DeleteGrafanaDashboardImagePayload']>, ParentType, ContextType, RequireFields<MutationDeleteGrafanaDashboardImageByNodeIdArgs, 'input'>>;
  deleteNotification?: Resolver<Maybe<ResolversTypes['DeleteNotificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteNotificationArgs, 'input'>>;
  deleteNotificationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteNotificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteNotificationByNodeIdArgs, 'input'>>;
  deleteOrganisation?: Resolver<Maybe<ResolversTypes['DeleteOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationArgs, 'input'>>;
  deleteOrganisationApplicationJoin?: Resolver<Maybe<ResolversTypes['DeleteOrganisationApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationApplicationJoinArgs, 'input'>>;
  deleteOrganisationApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteOrganisationApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationApplicationJoinByNodeIdArgs, 'input'>>;
  deleteOrganisationByName?: Resolver<Maybe<ResolversTypes['DeleteOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationByNameArgs, 'input'>>;
  deleteOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationByNodeIdArgs, 'input'>>;
  deleteOrganisationByRegistration?: Resolver<Maybe<ResolversTypes['DeleteOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteOrganisationByRegistrationArgs, 'input'>>;
  deletePermissionJoin?: Resolver<Maybe<ResolversTypes['DeletePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionJoinArgs, 'input'>>;
  deletePermissionJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeletePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionJoinByNodeIdArgs, 'input'>>;
  deletePermissionName?: Resolver<Maybe<ResolversTypes['DeletePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionNameArgs, 'input'>>;
  deletePermissionNameByName?: Resolver<Maybe<ResolversTypes['DeletePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionNameByNameArgs, 'input'>>;
  deletePermissionNameByNodeId?: Resolver<Maybe<ResolversTypes['DeletePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionNameByNodeIdArgs, 'input'>>;
  deletePermissionPolicy?: Resolver<Maybe<ResolversTypes['DeletePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionPolicyArgs, 'input'>>;
  deletePermissionPolicyByName?: Resolver<Maybe<ResolversTypes['DeletePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionPolicyByNameArgs, 'input'>>;
  deletePermissionPolicyByNodeId?: Resolver<Maybe<ResolversTypes['DeletePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationDeletePermissionPolicyByNodeIdArgs, 'input'>>;
  deleteReview?: Resolver<Maybe<ResolversTypes['DeleteReviewPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewArgs, 'input'>>;
  deleteReviewAssignment?: Resolver<Maybe<ResolversTypes['DeleteReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewAssignmentArgs, 'input'>>;
  deleteReviewAssignmentAssignerJoin?: Resolver<Maybe<ResolversTypes['DeleteReviewAssignmentAssignerJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewAssignmentAssignerJoinArgs, 'input'>>;
  deleteReviewAssignmentAssignerJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewAssignmentAssignerJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewAssignmentAssignerJoinByNodeIdArgs, 'input'>>;
  deleteReviewAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewAssignmentByNodeIdArgs, 'input'>>;
  deleteReviewByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewByNodeIdArgs, 'input'>>;
  deleteReviewByReviewAssignmentId?: Resolver<Maybe<ResolversTypes['DeleteReviewPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewByReviewAssignmentIdArgs, 'input'>>;
  deleteReviewDecision?: Resolver<Maybe<ResolversTypes['DeleteReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewDecisionArgs, 'input'>>;
  deleteReviewDecisionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewDecisionByNodeIdArgs, 'input'>>;
  deleteReviewResponse?: Resolver<Maybe<ResolversTypes['DeleteReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewResponseArgs, 'input'>>;
  deleteReviewResponseByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewResponseByNodeIdArgs, 'input'>>;
  deleteReviewStatusHistory?: Resolver<Maybe<ResolversTypes['DeleteReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewStatusHistoryArgs, 'input'>>;
  deleteReviewStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['DeleteReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteReviewStatusHistoryByNodeIdArgs, 'input'>>;
  deleteSystemInfo?: Resolver<Maybe<ResolversTypes['DeleteSystemInfoPayload']>, ParentType, ContextType, RequireFields<MutationDeleteSystemInfoArgs, 'input'>>;
  deleteSystemInfoByNodeId?: Resolver<Maybe<ResolversTypes['DeleteSystemInfoPayload']>, ParentType, ContextType, RequireFields<MutationDeleteSystemInfoByNodeIdArgs, 'input'>>;
  deleteTemplate?: Resolver<Maybe<ResolversTypes['DeleteTemplatePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateArgs, 'input'>>;
  deleteTemplateAction?: Resolver<Maybe<ResolversTypes['DeleteTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateActionArgs, 'input'>>;
  deleteTemplateActionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateActionByNodeIdArgs, 'input'>>;
  deleteTemplateByCodeAndVersionId?: Resolver<Maybe<ResolversTypes['DeleteTemplatePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateByCodeAndVersionIdArgs, 'input'>>;
  deleteTemplateByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplatePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateByNodeIdArgs, 'input'>>;
  deleteTemplateCategory?: Resolver<Maybe<ResolversTypes['DeleteTemplateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateCategoryArgs, 'input'>>;
  deleteTemplateCategoryByCode?: Resolver<Maybe<ResolversTypes['DeleteTemplateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateCategoryByCodeArgs, 'input'>>;
  deleteTemplateCategoryByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateCategoryByNodeIdArgs, 'input'>>;
  deleteTemplateElement?: Resolver<Maybe<ResolversTypes['DeleteTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateElementArgs, 'input'>>;
  deleteTemplateElementByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateElementByNodeIdArgs, 'input'>>;
  deleteTemplateElementByTemplateCodeAndCodeAndTemplateVersion?: Resolver<Maybe<ResolversTypes['DeleteTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs, 'input'>>;
  deleteTemplateFilterJoin?: Resolver<Maybe<ResolversTypes['DeleteTemplateFilterJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateFilterJoinArgs, 'input'>>;
  deleteTemplateFilterJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateFilterJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateFilterJoinByNodeIdArgs, 'input'>>;
  deleteTemplatePermission?: Resolver<Maybe<ResolversTypes['DeleteTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplatePermissionArgs, 'input'>>;
  deleteTemplatePermissionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplatePermissionByNodeIdArgs, 'input'>>;
  deleteTemplateSection?: Resolver<Maybe<ResolversTypes['DeleteTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateSectionArgs, 'input'>>;
  deleteTemplateSectionByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateSectionByNodeIdArgs, 'input'>>;
  deleteTemplateSectionByTemplateIdAndCode?: Resolver<Maybe<ResolversTypes['DeleteTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateSectionByTemplateIdAndCodeArgs, 'input'>>;
  deleteTemplateStage?: Resolver<Maybe<ResolversTypes['DeleteTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateStageArgs, 'input'>>;
  deleteTemplateStageByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateStageByNodeIdArgs, 'input'>>;
  deleteTemplateStageReviewLevel?: Resolver<Maybe<ResolversTypes['DeleteTemplateStageReviewLevelPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateStageReviewLevelArgs, 'input'>>;
  deleteTemplateStageReviewLevelByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTemplateStageReviewLevelPayload']>, ParentType, ContextType, RequireFields<MutationDeleteTemplateStageReviewLevelByNodeIdArgs, 'input'>>;
  deleteTriggerQueue?: Resolver<Maybe<ResolversTypes['DeleteTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTriggerQueueArgs, 'input'>>;
  deleteTriggerQueueByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTriggerQueueByNodeIdArgs, 'input'>>;
  deleteTriggerSchedule?: Resolver<Maybe<ResolversTypes['DeleteTriggerSchedulePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTriggerScheduleArgs, 'input'>>;
  deleteTriggerScheduleByNodeId?: Resolver<Maybe<ResolversTypes['DeleteTriggerSchedulePayload']>, ParentType, ContextType, RequireFields<MutationDeleteTriggerScheduleByNodeIdArgs, 'input'>>;
  deleteUserApplicationJoin?: Resolver<Maybe<ResolversTypes['DeleteUserApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserApplicationJoinArgs, 'input'>>;
  deleteUserApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DeleteUserApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserApplicationJoinByNodeIdArgs, 'input'>>;
  deleteUserOrganisation?: Resolver<Maybe<ResolversTypes['DeleteUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserOrganisationArgs, 'input'>>;
  deleteUserOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteUserOrganisationByNodeIdArgs, 'input'>>;
  deleteVerification?: Resolver<Maybe<ResolversTypes['DeleteVerificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteVerificationArgs, 'input'>>;
  deleteVerificationByNodeId?: Resolver<Maybe<ResolversTypes['DeleteVerificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteVerificationByNodeIdArgs, 'input'>>;
  deleteVerificationByUniqueId?: Resolver<Maybe<ResolversTypes['DeleteVerificationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteVerificationByUniqueIdArgs, 'input'>>;
  deleteWholeApplication?: Resolver<Maybe<ResolversTypes['DeleteWholeApplicationPayload']>, ParentType, ContextType, RequireFields<MutationDeleteWholeApplicationArgs, 'input'>>;
  updateActionPlugin?: Resolver<Maybe<ResolversTypes['UpdateActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionPluginArgs, 'input'>>;
  updateActionPluginByCode?: Resolver<Maybe<ResolversTypes['UpdateActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionPluginByCodeArgs, 'input'>>;
  updateActionPluginByNodeId?: Resolver<Maybe<ResolversTypes['UpdateActionPluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionPluginByNodeIdArgs, 'input'>>;
  updateActionQueue?: Resolver<Maybe<ResolversTypes['UpdateActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionQueueArgs, 'input'>>;
  updateActionQueueByNodeId?: Resolver<Maybe<ResolversTypes['UpdateActionQueuePayload']>, ParentType, ContextType, RequireFields<MutationUpdateActionQueueByNodeIdArgs, 'input'>>;
  updateActivityLog?: Resolver<Maybe<ResolversTypes['UpdateActivityLogPayload']>, ParentType, ContextType, RequireFields<MutationUpdateActivityLogArgs, 'input'>>;
  updateActivityLogByNodeId?: Resolver<Maybe<ResolversTypes['UpdateActivityLogPayload']>, ParentType, ContextType, RequireFields<MutationUpdateActivityLogByNodeIdArgs, 'input'>>;
  updateApplication?: Resolver<Maybe<ResolversTypes['UpdateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationArgs, 'input'>>;
  updateApplicationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationByNodeIdArgs, 'input'>>;
  updateApplicationByOutcomeRegistration?: Resolver<Maybe<ResolversTypes['UpdateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationByOutcomeRegistrationArgs, 'input'>>;
  updateApplicationBySerial?: Resolver<Maybe<ResolversTypes['UpdateApplicationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationBySerialArgs, 'input'>>;
  updateApplicationNote?: Resolver<Maybe<ResolversTypes['UpdateApplicationNotePayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationNoteArgs, 'input'>>;
  updateApplicationNoteByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationNotePayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationNoteByNodeIdArgs, 'input'>>;
  updateApplicationResponse?: Resolver<Maybe<ResolversTypes['UpdateApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationResponseArgs, 'input'>>;
  updateApplicationResponseByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationResponsePayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationResponseByNodeIdArgs, 'input'>>;
  updateApplicationReviewerAction?: Resolver<Maybe<ResolversTypes['UpdateApplicationReviewerActionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationReviewerActionArgs, 'input'>>;
  updateApplicationReviewerActionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationReviewerActionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationReviewerActionByNodeIdArgs, 'input'>>;
  updateApplicationReviewerActionByUserIdAndApplicationId?: Resolver<Maybe<ResolversTypes['UpdateApplicationReviewerActionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationReviewerActionByUserIdAndApplicationIdArgs, 'input'>>;
  updateApplicationStageHistory?: Resolver<Maybe<ResolversTypes['UpdateApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationStageHistoryArgs, 'input'>>;
  updateApplicationStageHistoryByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationStageHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationStageHistoryByNodeIdArgs, 'input'>>;
  updateApplicationStatusHistory?: Resolver<Maybe<ResolversTypes['UpdateApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationStatusHistoryArgs, 'input'>>;
  updateApplicationStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['UpdateApplicationStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateApplicationStatusHistoryByNodeIdArgs, 'input'>>;
  updateCounter?: Resolver<Maybe<ResolversTypes['UpdateCounterPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCounterArgs, 'input'>>;
  updateCounterByName?: Resolver<Maybe<ResolversTypes['UpdateCounterPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCounterByNameArgs, 'input'>>;
  updateCounterByNodeId?: Resolver<Maybe<ResolversTypes['UpdateCounterPayload']>, ParentType, ContextType, RequireFields<MutationUpdateCounterByNodeIdArgs, 'input'>>;
  updateDataChangelog?: Resolver<Maybe<ResolversTypes['UpdateDataChangelogPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataChangelogArgs, 'input'>>;
  updateDataChangelogByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataChangelogPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataChangelogByNodeIdArgs, 'input'>>;
  updateDataTable?: Resolver<Maybe<ResolversTypes['UpdateDataTablePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableArgs, 'input'>>;
  updateDataTableActiveIngredient?: Resolver<Maybe<ResolversTypes['UpdateDataTableActiveIngredientPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableActiveIngredientArgs, 'input'>>;
  updateDataTableActiveIngredientByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableActiveIngredientPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableActiveIngredientByNodeIdArgs, 'input'>>;
  updateDataTableAdministrationRoute?: Resolver<Maybe<ResolversTypes['UpdateDataTableAdministrationRoutePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableAdministrationRouteArgs, 'input'>>;
  updateDataTableAdministrationRouteByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableAdministrationRoutePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableAdministrationRouteByNodeIdArgs, 'input'>>;
  updateDataTableAtcCode?: Resolver<Maybe<ResolversTypes['UpdateDataTableAtcCodePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableAtcCodeArgs, 'input'>>;
  updateDataTableAtcCodeByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableAtcCodePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableAtcCodeByNodeIdArgs, 'input'>>;
  updateDataTableByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTablePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableByNodeIdArgs, 'input'>>;
  updateDataTableByTableName?: Resolver<Maybe<ResolversTypes['UpdateDataTablePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableByTableNameArgs, 'input'>>;
  updateDataTableContainer?: Resolver<Maybe<ResolversTypes['UpdateDataTableContainerPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableContainerArgs, 'input'>>;
  updateDataTableContainerByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableContainerPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableContainerByNodeIdArgs, 'input'>>;
  updateDataTableCountry?: Resolver<Maybe<ResolversTypes['UpdateDataTableCountryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableCountryArgs, 'input'>>;
  updateDataTableCountryByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableCountryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableCountryByNodeIdArgs, 'input'>>;
  updateDataTableDosageForm?: Resolver<Maybe<ResolversTypes['UpdateDataTableDosageFormPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableDosageFormArgs, 'input'>>;
  updateDataTableDosageFormByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableDosageFormPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableDosageFormByNodeIdArgs, 'input'>>;
  updateDataTableDosageFormGroup?: Resolver<Maybe<ResolversTypes['UpdateDataTableDosageFormGroupPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableDosageFormGroupArgs, 'input'>>;
  updateDataTableDosageFormGroupByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableDosageFormGroupPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableDosageFormGroupByNodeIdArgs, 'input'>>;
  updateDataTableGenericIngredient?: Resolver<Maybe<ResolversTypes['UpdateDataTableGenericIngredientPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableGenericIngredientArgs, 'input'>>;
  updateDataTableGenericIngredientByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableGenericIngredientPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableGenericIngredientByNodeIdArgs, 'input'>>;
  updateDataTableManufacturer?: Resolver<Maybe<ResolversTypes['UpdateDataTableManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableManufacturerArgs, 'input'>>;
  updateDataTableManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['UpdateDataTableManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableManufacturerApplicationJoinArgs, 'input'>>;
  updateDataTableManufacturerApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableManufacturerApplicationJoinByNodeIdArgs, 'input'>>;
  updateDataTableManufacturerByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableManufacturerByNodeIdArgs, 'input'>>;
  updateDataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['UpdateDataTableManufacturerRepresentativePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableManufacturerRepresentativeArgs, 'input'>>;
  updateDataTableManufacturerRepresentativeApplicationJoin?: Resolver<Maybe<ResolversTypes['UpdateDataTableManufacturerRepresentativeApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableManufacturerRepresentativeApplicationJoinArgs, 'input'>>;
  updateDataTableManufacturerRepresentativeApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableManufacturerRepresentativeApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableManufacturerRepresentativeApplicationJoinByNodeIdArgs, 'input'>>;
  updateDataTableManufacturerRepresentativeByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableManufacturerRepresentativePayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableManufacturerRepresentativeByNodeIdArgs, 'input'>>;
  updateDataTablePermitChemical?: Resolver<Maybe<ResolversTypes['UpdateDataTablePermitChemicalPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePermitChemicalArgs, 'input'>>;
  updateDataTablePermitChemicalApplicationJoin?: Resolver<Maybe<ResolversTypes['UpdateDataTablePermitChemicalApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePermitChemicalApplicationJoinArgs, 'input'>>;
  updateDataTablePermitChemicalApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTablePermitChemicalApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePermitChemicalApplicationJoinByNodeIdArgs, 'input'>>;
  updateDataTablePermitChemicalByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTablePermitChemicalPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePermitChemicalByNodeIdArgs, 'input'>>;
  updateDataTablePreRegisteredProductsProvisional?: Resolver<Maybe<ResolversTypes['UpdateDataTablePreRegisteredProductsProvisionalPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePreRegisteredProductsProvisionalArgs, 'input'>>;
  updateDataTablePreRegisteredProductsProvisionalByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTablePreRegisteredProductsProvisionalPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePreRegisteredProductsProvisionalByNodeIdArgs, 'input'>>;
  updateDataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['UpdateDataTablePrequalManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePrequalManufacturerArgs, 'input'>>;
  updateDataTablePrequalManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['UpdateDataTablePrequalManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePrequalManufacturerApplicationJoinArgs, 'input'>>;
  updateDataTablePrequalManufacturerApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTablePrequalManufacturerApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePrequalManufacturerApplicationJoinByNodeIdArgs, 'input'>>;
  updateDataTablePrequalManufacturerByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTablePrequalManufacturerPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTablePrequalManufacturerByNodeIdArgs, 'input'>>;
  updateDataTableProcessingStep?: Resolver<Maybe<ResolversTypes['UpdateDataTableProcessingStepPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProcessingStepArgs, 'input'>>;
  updateDataTableProcessingStepByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableProcessingStepPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProcessingStepByNodeIdArgs, 'input'>>;
  updateDataTableProduct?: Resolver<Maybe<ResolversTypes['UpdateDataTableProductPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProductArgs, 'input'>>;
  updateDataTableProductApplicationJoin?: Resolver<Maybe<ResolversTypes['UpdateDataTableProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProductApplicationJoinArgs, 'input'>>;
  updateDataTableProductApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProductApplicationJoinByNodeIdArgs, 'input'>>;
  updateDataTableProductByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableProductPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProductByNodeIdArgs, 'input'>>;
  updateDataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['UpdateDataTableProvisionalProductPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProvisionalProductArgs, 'input'>>;
  updateDataTableProvisionalProductApplicationJoin?: Resolver<Maybe<ResolversTypes['UpdateDataTableProvisionalProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProvisionalProductApplicationJoinArgs, 'input'>>;
  updateDataTableProvisionalProductApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableProvisionalProductApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProvisionalProductApplicationJoinByNodeIdArgs, 'input'>>;
  updateDataTableProvisionalProductByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableProvisionalProductPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableProvisionalProductByNodeIdArgs, 'input'>>;
  updateDataTableScheduledChemical?: Resolver<Maybe<ResolversTypes['UpdateDataTableScheduledChemicalPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableScheduledChemicalArgs, 'input'>>;
  updateDataTableScheduledChemicalByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableScheduledChemicalPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableScheduledChemicalByNodeIdArgs, 'input'>>;
  updateDataTableStorageCondition?: Resolver<Maybe<ResolversTypes['UpdateDataTableStorageConditionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableStorageConditionArgs, 'input'>>;
  updateDataTableStorageConditionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableStorageConditionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableStorageConditionByNodeIdArgs, 'input'>>;
  updateDataTableStorageConditionsSimplified?: Resolver<Maybe<ResolversTypes['UpdateDataTableStorageConditionsSimplifiedPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableStorageConditionsSimplifiedArgs, 'input'>>;
  updateDataTableStorageConditionsSimplifiedByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableStorageConditionsSimplifiedPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableStorageConditionsSimplifiedByNodeIdArgs, 'input'>>;
  updateDataTableUnitsOfProportion?: Resolver<Maybe<ResolversTypes['UpdateDataTableUnitsOfProportionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableUnitsOfProportionArgs, 'input'>>;
  updateDataTableUnitsOfProportionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableUnitsOfProportionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableUnitsOfProportionByNodeIdArgs, 'input'>>;
  updateDataTableWorldHealthOrganisationPqListOfFpp?: Resolver<Maybe<ResolversTypes['UpdateDataTableWorldHealthOrganisationPqListOfFppPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableWorldHealthOrganisationPqListOfFppArgs, 'input'>>;
  updateDataTableWorldHealthOrganisationPqListOfFppByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataTableWorldHealthOrganisationPqListOfFppPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataTableWorldHealthOrganisationPqListOfFppByNodeIdArgs, 'input'>>;
  updateDataView?: Resolver<Maybe<ResolversTypes['UpdateDataViewPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataViewArgs, 'input'>>;
  updateDataViewByIdentifier?: Resolver<Maybe<ResolversTypes['UpdateDataViewPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataViewByIdentifierArgs, 'input'>>;
  updateDataViewByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataViewPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataViewByNodeIdArgs, 'input'>>;
  updateDataViewColumnDefinition?: Resolver<Maybe<ResolversTypes['UpdateDataViewColumnDefinitionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataViewColumnDefinitionArgs, 'input'>>;
  updateDataViewColumnDefinitionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateDataViewColumnDefinitionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataViewColumnDefinitionByNodeIdArgs, 'input'>>;
  updateDataViewColumnDefinitionByTableNameAndColumnName?: Resolver<Maybe<ResolversTypes['UpdateDataViewColumnDefinitionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateDataViewColumnDefinitionByTableNameAndColumnNameArgs, 'input'>>;
  updateElementTypePlugin?: Resolver<Maybe<ResolversTypes['UpdateElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateElementTypePluginArgs, 'input'>>;
  updateElementTypePluginByNodeId?: Resolver<Maybe<ResolversTypes['UpdateElementTypePluginPayload']>, ParentType, ContextType, RequireFields<MutationUpdateElementTypePluginByNodeIdArgs, 'input'>>;
  updateFile?: Resolver<Maybe<ResolversTypes['UpdateFilePayload']>, ParentType, ContextType, RequireFields<MutationUpdateFileArgs, 'input'>>;
  updateFileByNodeId?: Resolver<Maybe<ResolversTypes['UpdateFilePayload']>, ParentType, ContextType, RequireFields<MutationUpdateFileByNodeIdArgs, 'input'>>;
  updateFileByUniqueId?: Resolver<Maybe<ResolversTypes['UpdateFilePayload']>, ParentType, ContextType, RequireFields<MutationUpdateFileByUniqueIdArgs, 'input'>>;
  updateFilter?: Resolver<Maybe<ResolversTypes['UpdateFilterPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFilterArgs, 'input'>>;
  updateFilterByCode?: Resolver<Maybe<ResolversTypes['UpdateFilterPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFilterByCodeArgs, 'input'>>;
  updateFilterByNodeId?: Resolver<Maybe<ResolversTypes['UpdateFilterPayload']>, ParentType, ContextType, RequireFields<MutationUpdateFilterByNodeIdArgs, 'input'>>;
  updateGrafanaDashboardImage?: Resolver<Maybe<ResolversTypes['UpdateGrafanaDashboardImagePayload']>, ParentType, ContextType, RequireFields<MutationUpdateGrafanaDashboardImageArgs, 'input'>>;
  updateGrafanaDashboardImageByNodeId?: Resolver<Maybe<ResolversTypes['UpdateGrafanaDashboardImagePayload']>, ParentType, ContextType, RequireFields<MutationUpdateGrafanaDashboardImageByNodeIdArgs, 'input'>>;
  updateNotification?: Resolver<Maybe<ResolversTypes['UpdateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateNotificationArgs, 'input'>>;
  updateNotificationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateNotificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateNotificationByNodeIdArgs, 'input'>>;
  updateOrganisation?: Resolver<Maybe<ResolversTypes['UpdateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationArgs, 'input'>>;
  updateOrganisationApplicationJoin?: Resolver<Maybe<ResolversTypes['UpdateOrganisationApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationApplicationJoinArgs, 'input'>>;
  updateOrganisationApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateOrganisationApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationApplicationJoinByNodeIdArgs, 'input'>>;
  updateOrganisationByName?: Resolver<Maybe<ResolversTypes['UpdateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationByNameArgs, 'input'>>;
  updateOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationByNodeIdArgs, 'input'>>;
  updateOrganisationByRegistration?: Resolver<Maybe<ResolversTypes['UpdateOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateOrganisationByRegistrationArgs, 'input'>>;
  updatePermissionJoin?: Resolver<Maybe<ResolversTypes['UpdatePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionJoinArgs, 'input'>>;
  updatePermissionJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdatePermissionJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionJoinByNodeIdArgs, 'input'>>;
  updatePermissionName?: Resolver<Maybe<ResolversTypes['UpdatePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionNameArgs, 'input'>>;
  updatePermissionNameByName?: Resolver<Maybe<ResolversTypes['UpdatePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionNameByNameArgs, 'input'>>;
  updatePermissionNameByNodeId?: Resolver<Maybe<ResolversTypes['UpdatePermissionNamePayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionNameByNodeIdArgs, 'input'>>;
  updatePermissionPolicy?: Resolver<Maybe<ResolversTypes['UpdatePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionPolicyArgs, 'input'>>;
  updatePermissionPolicyByName?: Resolver<Maybe<ResolversTypes['UpdatePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionPolicyByNameArgs, 'input'>>;
  updatePermissionPolicyByNodeId?: Resolver<Maybe<ResolversTypes['UpdatePermissionPolicyPayload']>, ParentType, ContextType, RequireFields<MutationUpdatePermissionPolicyByNodeIdArgs, 'input'>>;
  updateReview?: Resolver<Maybe<ResolversTypes['UpdateReviewPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewArgs, 'input'>>;
  updateReviewAssignment?: Resolver<Maybe<ResolversTypes['UpdateReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewAssignmentArgs, 'input'>>;
  updateReviewAssignmentAssignerJoin?: Resolver<Maybe<ResolversTypes['UpdateReviewAssignmentAssignerJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewAssignmentAssignerJoinArgs, 'input'>>;
  updateReviewAssignmentAssignerJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewAssignmentAssignerJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewAssignmentAssignerJoinByNodeIdArgs, 'input'>>;
  updateReviewAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewAssignmentPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewAssignmentByNodeIdArgs, 'input'>>;
  updateReviewByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewByNodeIdArgs, 'input'>>;
  updateReviewByReviewAssignmentId?: Resolver<Maybe<ResolversTypes['UpdateReviewPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewByReviewAssignmentIdArgs, 'input'>>;
  updateReviewDecision?: Resolver<Maybe<ResolversTypes['UpdateReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewDecisionArgs, 'input'>>;
  updateReviewDecisionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewDecisionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewDecisionByNodeIdArgs, 'input'>>;
  updateReviewResponse?: Resolver<Maybe<ResolversTypes['UpdateReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewResponseArgs, 'input'>>;
  updateReviewResponseByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewResponsePayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewResponseByNodeIdArgs, 'input'>>;
  updateReviewStatusHistory?: Resolver<Maybe<ResolversTypes['UpdateReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewStatusHistoryArgs, 'input'>>;
  updateReviewStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['UpdateReviewStatusHistoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateReviewStatusHistoryByNodeIdArgs, 'input'>>;
  updateSystemInfo?: Resolver<Maybe<ResolversTypes['UpdateSystemInfoPayload']>, ParentType, ContextType, RequireFields<MutationUpdateSystemInfoArgs, 'input'>>;
  updateSystemInfoByNodeId?: Resolver<Maybe<ResolversTypes['UpdateSystemInfoPayload']>, ParentType, ContextType, RequireFields<MutationUpdateSystemInfoByNodeIdArgs, 'input'>>;
  updateTemplate?: Resolver<Maybe<ResolversTypes['UpdateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateArgs, 'input'>>;
  updateTemplateAction?: Resolver<Maybe<ResolversTypes['UpdateTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateActionArgs, 'input'>>;
  updateTemplateActionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateActionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateActionByNodeIdArgs, 'input'>>;
  updateTemplateByCodeAndVersionId?: Resolver<Maybe<ResolversTypes['UpdateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateByCodeAndVersionIdArgs, 'input'>>;
  updateTemplateByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplatePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateByNodeIdArgs, 'input'>>;
  updateTemplateCategory?: Resolver<Maybe<ResolversTypes['UpdateTemplateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateCategoryArgs, 'input'>>;
  updateTemplateCategoryByCode?: Resolver<Maybe<ResolversTypes['UpdateTemplateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateCategoryByCodeArgs, 'input'>>;
  updateTemplateCategoryByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateCategoryPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateCategoryByNodeIdArgs, 'input'>>;
  updateTemplateElement?: Resolver<Maybe<ResolversTypes['UpdateTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateElementArgs, 'input'>>;
  updateTemplateElementByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateElementByNodeIdArgs, 'input'>>;
  updateTemplateElementByTemplateCodeAndCodeAndTemplateVersion?: Resolver<Maybe<ResolversTypes['UpdateTemplateElementPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs, 'input'>>;
  updateTemplateFilterJoin?: Resolver<Maybe<ResolversTypes['UpdateTemplateFilterJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateFilterJoinArgs, 'input'>>;
  updateTemplateFilterJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateFilterJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateFilterJoinByNodeIdArgs, 'input'>>;
  updateTemplatePermission?: Resolver<Maybe<ResolversTypes['UpdateTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplatePermissionArgs, 'input'>>;
  updateTemplatePermissionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplatePermissionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplatePermissionByNodeIdArgs, 'input'>>;
  updateTemplateSection?: Resolver<Maybe<ResolversTypes['UpdateTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateSectionArgs, 'input'>>;
  updateTemplateSectionByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateSectionByNodeIdArgs, 'input'>>;
  updateTemplateSectionByTemplateIdAndCode?: Resolver<Maybe<ResolversTypes['UpdateTemplateSectionPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateSectionByTemplateIdAndCodeArgs, 'input'>>;
  updateTemplateStage?: Resolver<Maybe<ResolversTypes['UpdateTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateStageArgs, 'input'>>;
  updateTemplateStageByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateStagePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateStageByNodeIdArgs, 'input'>>;
  updateTemplateStageReviewLevel?: Resolver<Maybe<ResolversTypes['UpdateTemplateStageReviewLevelPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateStageReviewLevelArgs, 'input'>>;
  updateTemplateStageReviewLevelByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTemplateStageReviewLevelPayload']>, ParentType, ContextType, RequireFields<MutationUpdateTemplateStageReviewLevelByNodeIdArgs, 'input'>>;
  updateTriggerQueue?: Resolver<Maybe<ResolversTypes['UpdateTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTriggerQueueArgs, 'input'>>;
  updateTriggerQueueByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTriggerQueuePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTriggerQueueByNodeIdArgs, 'input'>>;
  updateTriggerSchedule?: Resolver<Maybe<ResolversTypes['UpdateTriggerSchedulePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTriggerScheduleArgs, 'input'>>;
  updateTriggerScheduleByNodeId?: Resolver<Maybe<ResolversTypes['UpdateTriggerSchedulePayload']>, ParentType, ContextType, RequireFields<MutationUpdateTriggerScheduleByNodeIdArgs, 'input'>>;
  updateUserApplicationJoin?: Resolver<Maybe<ResolversTypes['UpdateUserApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserApplicationJoinArgs, 'input'>>;
  updateUserApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UpdateUserApplicationJoinPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserApplicationJoinByNodeIdArgs, 'input'>>;
  updateUserOrganisation?: Resolver<Maybe<ResolversTypes['UpdateUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserOrganisationArgs, 'input'>>;
  updateUserOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateUserOrganisationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateUserOrganisationByNodeIdArgs, 'input'>>;
  updateVerification?: Resolver<Maybe<ResolversTypes['UpdateVerificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateVerificationArgs, 'input'>>;
  updateVerificationByNodeId?: Resolver<Maybe<ResolversTypes['UpdateVerificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateVerificationByNodeIdArgs, 'input'>>;
  updateVerificationByUniqueId?: Resolver<Maybe<ResolversTypes['UpdateVerificationPayload']>, ParentType, ContextType, RequireFields<MutationUpdateVerificationByUniqueIdArgs, 'input'>>;
};

export type NodeResolvers<ContextType = any, ParentType extends ResolversParentTypes['Node'] = ResolversParentTypes['Node']> = {
  __resolveType: TypeResolveFn<'ActionPlugin' | 'ActionQueue' | 'ActivityLog' | 'Application' | 'ApplicationNote' | 'ApplicationResponse' | 'ApplicationReviewerAction' | 'ApplicationStageHistory' | 'ApplicationStatusHistory' | 'Counter' | 'DataChangelog' | 'DataTable' | 'DataTableActiveIngredient' | 'DataTableAdministrationRoute' | 'DataTableAtcCode' | 'DataTableContainer' | 'DataTableCountry' | 'DataTableDosageForm' | 'DataTableDosageFormGroup' | 'DataTableGenericIngredient' | 'DataTableManufacturer' | 'DataTableManufacturerApplicationJoin' | 'DataTableManufacturerRepresentative' | 'DataTableManufacturerRepresentativeApplicationJoin' | 'DataTablePermitChemical' | 'DataTablePermitChemicalApplicationJoin' | 'DataTablePreRegisteredProductsProvisional' | 'DataTablePrequalManufacturer' | 'DataTablePrequalManufacturerApplicationJoin' | 'DataTableProcessingStep' | 'DataTableProduct' | 'DataTableProductApplicationJoin' | 'DataTableProvisionalProduct' | 'DataTableProvisionalProductApplicationJoin' | 'DataTableScheduledChemical' | 'DataTableStorageCondition' | 'DataTableStorageConditionsSimplified' | 'DataTableUnitsOfProportion' | 'DataTableWorldHealthOrganisationPqListOfFpp' | 'DataView' | 'DataViewColumnDefinition' | 'ElementTypePlugin' | 'File' | 'Filter' | 'GrafanaDashboardImage' | 'Notification' | 'Organisation' | 'OrganisationApplicationJoin' | 'PermissionJoin' | 'PermissionName' | 'PermissionPolicy' | 'Query' | 'Review' | 'ReviewAssignment' | 'ReviewAssignmentAssignerJoin' | 'ReviewDecision' | 'ReviewResponse' | 'ReviewStatusHistory' | 'SystemInfo' | 'Template' | 'TemplateAction' | 'TemplateCategory' | 'TemplateElement' | 'TemplateFilterJoin' | 'TemplatePermission' | 'TemplateSection' | 'TemplateStage' | 'TemplateStageReviewLevel' | 'TriggerQueue' | 'TriggerSchedule' | 'UserApplicationJoin' | 'UserOrganisation' | 'Verification', ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
};

export type NotificationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Notification'] = ResolversParentTypes['Notification']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  attachments?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  emailRecipients?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  emailSent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  emailServerLog?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isRead?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  subject?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationsConnection'] = ResolversParentTypes['NotificationsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['NotificationsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Notification']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type NotificationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['NotificationsEdge'] = ResolversParentTypes['NotificationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Organisation'] = ResolversParentTypes['Organisation']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  applicationNotesByOrgId?: Resolver<ResolversTypes['ApplicationNotesConnection'], ParentType, ContextType, RequireFields<OrganisationApplicationNotesByOrgIdArgs, 'orderBy'>>;
  applicationsByOrgId?: Resolver<ResolversTypes['ApplicationsConnection'], ParentType, ContextType, RequireFields<OrganisationApplicationsByOrgIdArgs, 'orderBy'>>;
  businessCertificate?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  contactEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  contactPhone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataChangelogsByOrgId?: Resolver<ResolversTypes['DataChangelogsConnection'], ParentType, ContextType, RequireFields<OrganisationDataChangelogsByOrgIdArgs, 'orderBy'>>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isChemicalImporter?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isSponsorCompany?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isSystemOrg?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  license?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  localAgentBusinessAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  localAgentEmail?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  localAgentName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  localAgentPhoneNumber?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  logoUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organisationApplicationJoins?: Resolver<ResolversTypes['OrganisationApplicationJoinsConnection'], ParentType, ContextType, RequireFields<OrganisationOrganisationApplicationJoinsArgs, 'orderBy'>>;
  otherDocuments?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  permissionJoins?: Resolver<ResolversTypes['PermissionJoinsConnection'], ParentType, ContextType, RequireFields<OrganisationPermissionJoinsArgs, 'orderBy'>>;
  postalAddress?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  province?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  registration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  registrationDocumentation?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  reviewAssignmentAssignerJoins?: Resolver<ResolversTypes['ReviewAssignmentAssignerJoinsConnection'], ParentType, ContextType, RequireFields<OrganisationReviewAssignmentAssignerJoinsArgs, 'orderBy'>>;
  reviewAssignments?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<OrganisationReviewAssignmentsArgs, 'orderBy'>>;
  subType?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tinLetter?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  userOrganisations?: Resolver<ResolversTypes['UserOrganisationsConnection'], ParentType, ContextType, RequireFields<OrganisationUserOrganisationsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationApplicationJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganisationApplicationJoin'] = ResolversParentTypes['OrganisationApplicationJoin']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationApplicationJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganisationApplicationJoinsConnection'] = ResolversParentTypes['OrganisationApplicationJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['OrganisationApplicationJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['OrganisationApplicationJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationApplicationJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganisationApplicationJoinsEdge'] = ResolversParentTypes['OrganisationApplicationJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganisationsConnection'] = ResolversParentTypes['OrganisationsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['OrganisationsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Organisation']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type OrganisationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['OrganisationsEdge'] = ResolversParentTypes['OrganisationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PageInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['PageInfo'] = ResolversParentTypes['PageInfo']> = {
  endCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  hasNextPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  hasPreviousPage?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  startCursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionFlattenedResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionFlattened'] = ResolversParentTypes['PermissionFlattened']> = {
  organisationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  permissionPolicyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionFlattenedsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionFlattenedsConnection'] = ResolversParentTypes['PermissionFlattenedsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PermissionFlattenedsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['PermissionFlattened']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionFlattenedsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionFlattenedsEdge'] = ResolversParentTypes['PermissionFlattenedsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PermissionFlattened']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionJoin'] = ResolversParentTypes['PermissionJoin']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  permissionNameId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionJoinsConnection'] = ResolversParentTypes['PermissionJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PermissionJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['PermissionJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionJoinsEdge'] = ResolversParentTypes['PermissionJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionNameResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionName'] = ResolversParentTypes['PermissionName']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isSystemOrgPermission?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  permissionJoins?: Resolver<ResolversTypes['PermissionJoinsConnection'], ParentType, ContextType, RequireFields<PermissionNamePermissionJoinsArgs, 'orderBy'>>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  permissionPolicyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templatePermissions?: Resolver<ResolversTypes['TemplatePermissionsConnection'], ParentType, ContextType, RequireFields<PermissionNameTemplatePermissionsArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionNamesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionNamesConnection'] = ResolversParentTypes['PermissionNamesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PermissionNamesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['PermissionName']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionNamesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionNamesEdge'] = ResolversParentTypes['PermissionNamesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionPoliciesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionPoliciesConnection'] = ResolversParentTypes['PermissionPoliciesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PermissionPoliciesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['PermissionPolicy']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionPoliciesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionPoliciesEdge'] = ResolversParentTypes['PermissionPoliciesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionPolicyResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionPolicy'] = ResolversParentTypes['PermissionPolicy']> = {
  defaultRestrictions?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isAdmin?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  permissionNames?: Resolver<ResolversTypes['PermissionNamesConnection'], ParentType, ContextType, RequireFields<PermissionPolicyPermissionNamesArgs, 'orderBy'>>;
  rules?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  type?: Resolver<Maybe<ResolversTypes['PermissionPolicyType']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionsAllResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionsAll'] = ResolversParentTypes['PermissionsAll']> = {
  allowedSections?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  canMakeFinalDecision?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  canSelfAssign?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isAdmin?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isSystemOrgPermission?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isUserCategory?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  orgName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionJoinId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionNameId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  permissionPolicyId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  permissionPolicyRules?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  permissionType?: Resolver<Maybe<ResolversTypes['PermissionPolicyType']>, ParentType, ContextType>;
  policyName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  restrictions?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  reviewLevel?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templatePermissionId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionsAllsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionsAllsConnection'] = ResolversParentTypes['PermissionsAllsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PermissionsAllsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['PermissionsAll']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PermissionsAllsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PermissionsAllsEdge'] = ResolversParentTypes['PermissionsAllsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PermissionsAll']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PostgresRowLevelResolvers<ContextType = any, ParentType extends ResolversParentTypes['PostgresRowLevel'] = ResolversParentTypes['PostgresRowLevel']> = {
  cmd?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissive?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  policyname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  qual?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  roles?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  schemaname?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  tablename?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  withCheck?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PostgresRowLevelsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['PostgresRowLevelsConnection'] = ResolversParentTypes['PostgresRowLevelsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['PostgresRowLevelsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['PostgresRowLevel']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type PostgresRowLevelsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['PostgresRowLevelsEdge'] = ResolversParentTypes['PostgresRowLevelsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['PostgresRowLevel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type QueryResolvers<ContextType = any, ParentType extends ResolversParentTypes['Query'] = ResolversParentTypes['Query']> = {
  actionPlugin?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType, RequireFields<QueryActionPluginArgs, 'id'>>;
  actionPluginByCode?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType, RequireFields<QueryActionPluginByCodeArgs, 'code'>>;
  actionPluginByNodeId?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType, RequireFields<QueryActionPluginByNodeIdArgs, 'nodeId'>>;
  actionPlugins?: Resolver<Maybe<ResolversTypes['ActionPluginsConnection']>, ParentType, ContextType, RequireFields<QueryActionPluginsArgs, 'orderBy'>>;
  actionQueue?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType, RequireFields<QueryActionQueueArgs, 'id'>>;
  actionQueueByNodeId?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType, RequireFields<QueryActionQueueByNodeIdArgs, 'nodeId'>>;
  actionQueues?: Resolver<Maybe<ResolversTypes['ActionQueuesConnection']>, ParentType, ContextType, RequireFields<QueryActionQueuesArgs, 'orderBy'>>;
  activityLog?: Resolver<Maybe<ResolversTypes['ActivityLog']>, ParentType, ContextType, RequireFields<QueryActivityLogArgs, 'id'>>;
  activityLogByNodeId?: Resolver<Maybe<ResolversTypes['ActivityLog']>, ParentType, ContextType, RequireFields<QueryActivityLogByNodeIdArgs, 'nodeId'>>;
  activityLogs?: Resolver<Maybe<ResolversTypes['ActivityLogsConnection']>, ParentType, ContextType, RequireFields<QueryActivityLogsArgs, 'orderBy'>>;
  allowedSelfAssignableSections?: Resolver<Maybe<ResolversTypes['AllowedSelfAssignableSectionsShapesConnection']>, ParentType, ContextType, Partial<QueryAllowedSelfAssignableSectionsArgs>>;
  allowedSelfAssignableSectionsShapes?: Resolver<Maybe<ResolversTypes['AllowedSelfAssignableSectionsShapesConnection']>, ParentType, ContextType, RequireFields<QueryAllowedSelfAssignableSectionsShapesArgs, 'orderBy'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType, RequireFields<QueryApplicationArgs, 'id'>>;
  applicationByNodeId?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType, RequireFields<QueryApplicationByNodeIdArgs, 'nodeId'>>;
  applicationByOutcomeRegistration?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType, RequireFields<QueryApplicationByOutcomeRegistrationArgs, 'outcomeRegistration'>>;
  applicationBySerial?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType, RequireFields<QueryApplicationBySerialArgs, 'serial'>>;
  applicationList?: Resolver<Maybe<ResolversTypes['ApplicationListShapesConnection']>, ParentType, ContextType, Partial<QueryApplicationListArgs>>;
  applicationListFilterApplicant?: Resolver<Maybe<ResolversTypes['ApplicationListFilterApplicantConnection']>, ParentType, ContextType, Partial<QueryApplicationListFilterApplicantArgs>>;
  applicationListFilterAssigner?: Resolver<Maybe<ResolversTypes['ApplicationListFilterAssignerConnection']>, ParentType, ContextType, Partial<QueryApplicationListFilterAssignerArgs>>;
  applicationListFilterOrganisation?: Resolver<Maybe<ResolversTypes['ApplicationListFilterOrganisationConnection']>, ParentType, ContextType, Partial<QueryApplicationListFilterOrganisationArgs>>;
  applicationListFilterReviewer?: Resolver<Maybe<ResolversTypes['ApplicationListFilterReviewerConnection']>, ParentType, ContextType, Partial<QueryApplicationListFilterReviewerArgs>>;
  applicationListFilterStage?: Resolver<Maybe<ResolversTypes['ApplicationListFilterStageConnection']>, ParentType, ContextType, Partial<QueryApplicationListFilterStageArgs>>;
  applicationListShapes?: Resolver<Maybe<ResolversTypes['ApplicationListShapesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationListShapesArgs, 'orderBy'>>;
  applicationNote?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType, RequireFields<QueryApplicationNoteArgs, 'id'>>;
  applicationNoteByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType, RequireFields<QueryApplicationNoteByNodeIdArgs, 'nodeId'>>;
  applicationNotes?: Resolver<Maybe<ResolversTypes['ApplicationNotesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationNotesArgs, 'orderBy'>>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType, RequireFields<QueryApplicationResponseArgs, 'id'>>;
  applicationResponseByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType, RequireFields<QueryApplicationResponseByNodeIdArgs, 'nodeId'>>;
  applicationResponses?: Resolver<Maybe<ResolversTypes['ApplicationResponsesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationResponsesArgs, 'orderBy'>>;
  applicationReviewerAction?: Resolver<Maybe<ResolversTypes['ApplicationReviewerAction']>, ParentType, ContextType, RequireFields<QueryApplicationReviewerActionArgs, 'id'>>;
  applicationReviewerActionByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationReviewerAction']>, ParentType, ContextType, RequireFields<QueryApplicationReviewerActionByNodeIdArgs, 'nodeId'>>;
  applicationReviewerActionByUserIdAndApplicationId?: Resolver<Maybe<ResolversTypes['ApplicationReviewerAction']>, ParentType, ContextType, RequireFields<QueryApplicationReviewerActionByUserIdAndApplicationIdArgs, 'applicationId' | 'userId'>>;
  applicationReviewerActions?: Resolver<Maybe<ResolversTypes['ApplicationReviewerActionsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationReviewerActionsArgs, 'orderBy'>>;
  applicationStageHistories?: Resolver<Maybe<ResolversTypes['ApplicationStageHistoriesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationStageHistoriesArgs, 'orderBy'>>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType, RequireFields<QueryApplicationStageHistoryArgs, 'id'>>;
  applicationStageHistoryByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType, RequireFields<QueryApplicationStageHistoryByNodeIdArgs, 'nodeId'>>;
  applicationStageStatusAlls?: Resolver<Maybe<ResolversTypes['ApplicationStageStatusAllsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationStageStatusAllsArgs, 'orderBy'>>;
  applicationStageStatusLatests?: Resolver<Maybe<ResolversTypes['ApplicationStageStatusLatestsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationStageStatusLatestsArgs, 'orderBy'>>;
  applicationStatusHistories?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistoriesConnection']>, ParentType, ContextType, RequireFields<QueryApplicationStatusHistoriesArgs, 'orderBy'>>;
  applicationStatusHistory?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType, RequireFields<QueryApplicationStatusHistoryArgs, 'id'>>;
  applicationStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType, RequireFields<QueryApplicationStatusHistoryByNodeIdArgs, 'nodeId'>>;
  applications?: Resolver<Maybe<ResolversTypes['ApplicationsConnection']>, ParentType, ContextType, RequireFields<QueryApplicationsArgs, 'orderBy'>>;
  assignableQuestionsCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, Partial<QueryAssignableQuestionsCountArgs>>;
  assignedQuestions?: Resolver<Maybe<ResolversTypes['AssignedQuestionsConnection']>, ParentType, ContextType, Partial<QueryAssignedQuestionsArgs>>;
  assignedQuestionsCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, Partial<QueryAssignedQuestionsCountArgs>>;
  assignedSectionsByStageAndLevels?: Resolver<Maybe<ResolversTypes['AssignedSectionsByStageAndLevelsConnection']>, ParentType, ContextType, RequireFields<QueryAssignedSectionsByStageAndLevelsArgs, 'orderBy'>>;
  assignerList?: Resolver<Maybe<ResolversTypes['AssignerListConnection']>, ParentType, ContextType, Partial<QueryAssignerListArgs>>;
  assignmentList?: Resolver<Maybe<ResolversTypes['AssignmentListConnection']>, ParentType, ContextType, Partial<QueryAssignmentListArgs>>;
  constraintsInfos?: Resolver<Maybe<ResolversTypes['ConstraintsInfosConnection']>, ParentType, ContextType, RequireFields<QueryConstraintsInfosArgs, 'orderBy'>>;
  counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, RequireFields<QueryCounterArgs, 'id'>>;
  counterByName?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, RequireFields<QueryCounterByNameArgs, 'name'>>;
  counterByNodeId?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType, RequireFields<QueryCounterByNodeIdArgs, 'nodeId'>>;
  counters?: Resolver<Maybe<ResolversTypes['CountersConnection']>, ParentType, ContextType, RequireFields<QueryCountersArgs, 'orderBy'>>;
  dataChangelog?: Resolver<Maybe<ResolversTypes['DataChangelog']>, ParentType, ContextType, RequireFields<QueryDataChangelogArgs, 'id'>>;
  dataChangelogByNodeId?: Resolver<Maybe<ResolversTypes['DataChangelog']>, ParentType, ContextType, RequireFields<QueryDataChangelogByNodeIdArgs, 'nodeId'>>;
  dataChangelogs?: Resolver<Maybe<ResolversTypes['DataChangelogsConnection']>, ParentType, ContextType, RequireFields<QueryDataChangelogsArgs, 'orderBy'>>;
  dataTable?: Resolver<Maybe<ResolversTypes['DataTable']>, ParentType, ContextType, RequireFields<QueryDataTableArgs, 'id'>>;
  dataTableActiveIngredient?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredient']>, ParentType, ContextType, RequireFields<QueryDataTableActiveIngredientArgs, 'id'>>;
  dataTableActiveIngredientByNodeId?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredient']>, ParentType, ContextType, RequireFields<QueryDataTableActiveIngredientByNodeIdArgs, 'nodeId'>>;
  dataTableActiveIngredients?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredientsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableActiveIngredientsArgs, 'orderBy'>>;
  dataTableAdministrationRoute?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoute']>, ParentType, ContextType, RequireFields<QueryDataTableAdministrationRouteArgs, 'id'>>;
  dataTableAdministrationRouteByNodeId?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoute']>, ParentType, ContextType, RequireFields<QueryDataTableAdministrationRouteByNodeIdArgs, 'nodeId'>>;
  dataTableAdministrationRoutes?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoutesConnection']>, ParentType, ContextType, RequireFields<QueryDataTableAdministrationRoutesArgs, 'orderBy'>>;
  dataTableAtcCode?: Resolver<Maybe<ResolversTypes['DataTableAtcCode']>, ParentType, ContextType, RequireFields<QueryDataTableAtcCodeArgs, 'id'>>;
  dataTableAtcCodeByNodeId?: Resolver<Maybe<ResolversTypes['DataTableAtcCode']>, ParentType, ContextType, RequireFields<QueryDataTableAtcCodeByNodeIdArgs, 'nodeId'>>;
  dataTableAtcCodes?: Resolver<Maybe<ResolversTypes['DataTableAtcCodesConnection']>, ParentType, ContextType, RequireFields<QueryDataTableAtcCodesArgs, 'orderBy'>>;
  dataTableByNodeId?: Resolver<Maybe<ResolversTypes['DataTable']>, ParentType, ContextType, RequireFields<QueryDataTableByNodeIdArgs, 'nodeId'>>;
  dataTableByTableName?: Resolver<Maybe<ResolversTypes['DataTable']>, ParentType, ContextType, RequireFields<QueryDataTableByTableNameArgs, 'tableName'>>;
  dataTableContainer?: Resolver<Maybe<ResolversTypes['DataTableContainer']>, ParentType, ContextType, RequireFields<QueryDataTableContainerArgs, 'id'>>;
  dataTableContainerByNodeId?: Resolver<Maybe<ResolversTypes['DataTableContainer']>, ParentType, ContextType, RequireFields<QueryDataTableContainerByNodeIdArgs, 'nodeId'>>;
  dataTableContainers?: Resolver<Maybe<ResolversTypes['DataTableContainersConnection']>, ParentType, ContextType, RequireFields<QueryDataTableContainersArgs, 'orderBy'>>;
  dataTableCountries?: Resolver<Maybe<ResolversTypes['DataTableCountriesConnection']>, ParentType, ContextType, RequireFields<QueryDataTableCountriesArgs, 'orderBy'>>;
  dataTableCountry?: Resolver<Maybe<ResolversTypes['DataTableCountry']>, ParentType, ContextType, RequireFields<QueryDataTableCountryArgs, 'id'>>;
  dataTableCountryByNodeId?: Resolver<Maybe<ResolversTypes['DataTableCountry']>, ParentType, ContextType, RequireFields<QueryDataTableCountryByNodeIdArgs, 'nodeId'>>;
  dataTableDosageForm?: Resolver<Maybe<ResolversTypes['DataTableDosageForm']>, ParentType, ContextType, RequireFields<QueryDataTableDosageFormArgs, 'id'>>;
  dataTableDosageFormByNodeId?: Resolver<Maybe<ResolversTypes['DataTableDosageForm']>, ParentType, ContextType, RequireFields<QueryDataTableDosageFormByNodeIdArgs, 'nodeId'>>;
  dataTableDosageFormGroup?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroup']>, ParentType, ContextType, RequireFields<QueryDataTableDosageFormGroupArgs, 'id'>>;
  dataTableDosageFormGroupByNodeId?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroup']>, ParentType, ContextType, RequireFields<QueryDataTableDosageFormGroupByNodeIdArgs, 'nodeId'>>;
  dataTableDosageFormGroups?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroupsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableDosageFormGroupsArgs, 'orderBy'>>;
  dataTableDosageForms?: Resolver<Maybe<ResolversTypes['DataTableDosageFormsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableDosageFormsArgs, 'orderBy'>>;
  dataTableGenericIngredient?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredient']>, ParentType, ContextType, RequireFields<QueryDataTableGenericIngredientArgs, 'id'>>;
  dataTableGenericIngredientByNodeId?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredient']>, ParentType, ContextType, RequireFields<QueryDataTableGenericIngredientByNodeIdArgs, 'nodeId'>>;
  dataTableGenericIngredients?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredientsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableGenericIngredientsArgs, 'orderBy'>>;
  dataTableManufacturer?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerArgs, 'id'>>;
  dataTableManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerApplicationJoinArgs, 'id'>>;
  dataTableManufacturerApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerApplicationJoinByNodeIdArgs, 'nodeId'>>;
  dataTableManufacturerApplicationJoins?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoinsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerApplicationJoinsArgs, 'orderBy'>>;
  dataTableManufacturerByNodeId?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerByNodeIdArgs, 'nodeId'>>;
  dataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerRepresentativeArgs, 'id'>>;
  dataTableManufacturerRepresentativeApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerRepresentativeApplicationJoinArgs, 'id'>>;
  dataTableManufacturerRepresentativeApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerRepresentativeApplicationJoinByNodeIdArgs, 'nodeId'>>;
  dataTableManufacturerRepresentativeApplicationJoins?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoinsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerRepresentativeApplicationJoinsArgs, 'orderBy'>>;
  dataTableManufacturerRepresentativeByNodeId?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerRepresentativeByNodeIdArgs, 'nodeId'>>;
  dataTableManufacturerRepresentatives?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativesConnection']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturerRepresentativesArgs, 'orderBy'>>;
  dataTableManufacturers?: Resolver<Maybe<ResolversTypes['DataTableManufacturersConnection']>, ParentType, ContextType, RequireFields<QueryDataTableManufacturersArgs, 'orderBy'>>;
  dataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType, RequireFields<QueryDataTablePermitChemicalArgs, 'id'>>;
  dataTablePermitChemicalApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTablePermitChemicalApplicationJoinArgs, 'id'>>;
  dataTablePermitChemicalApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTablePermitChemicalApplicationJoinByNodeIdArgs, 'nodeId'>>;
  dataTablePermitChemicalApplicationJoins?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoinsConnection']>, ParentType, ContextType, RequireFields<QueryDataTablePermitChemicalApplicationJoinsArgs, 'orderBy'>>;
  dataTablePermitChemicalByNodeId?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType, RequireFields<QueryDataTablePermitChemicalByNodeIdArgs, 'nodeId'>>;
  dataTablePermitChemicals?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalsConnection']>, ParentType, ContextType, RequireFields<QueryDataTablePermitChemicalsArgs, 'orderBy'>>;
  dataTablePreRegisteredProductsProvisional?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisional']>, ParentType, ContextType, RequireFields<QueryDataTablePreRegisteredProductsProvisionalArgs, 'id'>>;
  dataTablePreRegisteredProductsProvisionalByNodeId?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisional']>, ParentType, ContextType, RequireFields<QueryDataTablePreRegisteredProductsProvisionalByNodeIdArgs, 'nodeId'>>;
  dataTablePreRegisteredProductsProvisionals?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisionalsConnection']>, ParentType, ContextType, RequireFields<QueryDataTablePreRegisteredProductsProvisionalsArgs, 'orderBy'>>;
  dataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType, RequireFields<QueryDataTablePrequalManufacturerArgs, 'id'>>;
  dataTablePrequalManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTablePrequalManufacturerApplicationJoinArgs, 'id'>>;
  dataTablePrequalManufacturerApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTablePrequalManufacturerApplicationJoinByNodeIdArgs, 'nodeId'>>;
  dataTablePrequalManufacturerApplicationJoins?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoinsConnection']>, ParentType, ContextType, RequireFields<QueryDataTablePrequalManufacturerApplicationJoinsArgs, 'orderBy'>>;
  dataTablePrequalManufacturerByNodeId?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType, RequireFields<QueryDataTablePrequalManufacturerByNodeIdArgs, 'nodeId'>>;
  dataTablePrequalManufacturers?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturersConnection']>, ParentType, ContextType, RequireFields<QueryDataTablePrequalManufacturersArgs, 'orderBy'>>;
  dataTableProcessingStep?: Resolver<Maybe<ResolversTypes['DataTableProcessingStep']>, ParentType, ContextType, RequireFields<QueryDataTableProcessingStepArgs, 'id'>>;
  dataTableProcessingStepByNodeId?: Resolver<Maybe<ResolversTypes['DataTableProcessingStep']>, ParentType, ContextType, RequireFields<QueryDataTableProcessingStepByNodeIdArgs, 'nodeId'>>;
  dataTableProcessingSteps?: Resolver<Maybe<ResolversTypes['DataTableProcessingStepsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableProcessingStepsArgs, 'orderBy'>>;
  dataTableProduct?: Resolver<Maybe<ResolversTypes['DataTableProduct']>, ParentType, ContextType, RequireFields<QueryDataTableProductArgs, 'id'>>;
  dataTableProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTableProductApplicationJoinArgs, 'id'>>;
  dataTableProductApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTableProductApplicationJoinByNodeIdArgs, 'nodeId'>>;
  dataTableProductApplicationJoins?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoinsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableProductApplicationJoinsArgs, 'orderBy'>>;
  dataTableProductByNodeId?: Resolver<Maybe<ResolversTypes['DataTableProduct']>, ParentType, ContextType, RequireFields<QueryDataTableProductByNodeIdArgs, 'nodeId'>>;
  dataTableProducts?: Resolver<Maybe<ResolversTypes['DataTableProductsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableProductsArgs, 'orderBy'>>;
  dataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType, RequireFields<QueryDataTableProvisionalProductArgs, 'id'>>;
  dataTableProvisionalProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTableProvisionalProductApplicationJoinArgs, 'id'>>;
  dataTableProvisionalProductApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoin']>, ParentType, ContextType, RequireFields<QueryDataTableProvisionalProductApplicationJoinByNodeIdArgs, 'nodeId'>>;
  dataTableProvisionalProductApplicationJoins?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoinsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableProvisionalProductApplicationJoinsArgs, 'orderBy'>>;
  dataTableProvisionalProductByNodeId?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType, RequireFields<QueryDataTableProvisionalProductByNodeIdArgs, 'nodeId'>>;
  dataTableProvisionalProducts?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableProvisionalProductsArgs, 'orderBy'>>;
  dataTableScheduledChemical?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemical']>, ParentType, ContextType, RequireFields<QueryDataTableScheduledChemicalArgs, 'id'>>;
  dataTableScheduledChemicalByNodeId?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemical']>, ParentType, ContextType, RequireFields<QueryDataTableScheduledChemicalByNodeIdArgs, 'nodeId'>>;
  dataTableScheduledChemicals?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemicalsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableScheduledChemicalsArgs, 'orderBy'>>;
  dataTableStorageCondition?: Resolver<Maybe<ResolversTypes['DataTableStorageCondition']>, ParentType, ContextType, RequireFields<QueryDataTableStorageConditionArgs, 'id'>>;
  dataTableStorageConditionByNodeId?: Resolver<Maybe<ResolversTypes['DataTableStorageCondition']>, ParentType, ContextType, RequireFields<QueryDataTableStorageConditionByNodeIdArgs, 'nodeId'>>;
  dataTableStorageConditions?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableStorageConditionsArgs, 'orderBy'>>;
  dataTableStorageConditionsSimplified?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplified']>, ParentType, ContextType, RequireFields<QueryDataTableStorageConditionsSimplifiedArgs, 'id'>>;
  dataTableStorageConditionsSimplifiedByNodeId?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplified']>, ParentType, ContextType, RequireFields<QueryDataTableStorageConditionsSimplifiedByNodeIdArgs, 'nodeId'>>;
  dataTableStorageConditionsSimplifieds?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplifiedsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableStorageConditionsSimplifiedsArgs, 'orderBy'>>;
  dataTableUnitsOfProportion?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportion']>, ParentType, ContextType, RequireFields<QueryDataTableUnitsOfProportionArgs, 'id'>>;
  dataTableUnitsOfProportionByNodeId?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportion']>, ParentType, ContextType, RequireFields<QueryDataTableUnitsOfProportionByNodeIdArgs, 'nodeId'>>;
  dataTableUnitsOfProportions?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportionsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableUnitsOfProportionsArgs, 'orderBy'>>;
  dataTableWorldHealthOrganisationPqListOfFpp?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFpp']>, ParentType, ContextType, RequireFields<QueryDataTableWorldHealthOrganisationPqListOfFppArgs, 'id'>>;
  dataTableWorldHealthOrganisationPqListOfFppByNodeId?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFpp']>, ParentType, ContextType, RequireFields<QueryDataTableWorldHealthOrganisationPqListOfFppByNodeIdArgs, 'nodeId'>>;
  dataTableWorldHealthOrganisationPqListOfFpps?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFppsConnection']>, ParentType, ContextType, RequireFields<QueryDataTableWorldHealthOrganisationPqListOfFppsArgs, 'orderBy'>>;
  dataTables?: Resolver<Maybe<ResolversTypes['DataTablesConnection']>, ParentType, ContextType, RequireFields<QueryDataTablesArgs, 'orderBy'>>;
  dataView?: Resolver<Maybe<ResolversTypes['DataView']>, ParentType, ContextType, RequireFields<QueryDataViewArgs, 'id'>>;
  dataViewByIdentifier?: Resolver<Maybe<ResolversTypes['DataView']>, ParentType, ContextType, RequireFields<QueryDataViewByIdentifierArgs, 'identifier'>>;
  dataViewByNodeId?: Resolver<Maybe<ResolversTypes['DataView']>, ParentType, ContextType, RequireFields<QueryDataViewByNodeIdArgs, 'nodeId'>>;
  dataViewColumnDefinition?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinition']>, ParentType, ContextType, RequireFields<QueryDataViewColumnDefinitionArgs, 'id'>>;
  dataViewColumnDefinitionByNodeId?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinition']>, ParentType, ContextType, RequireFields<QueryDataViewColumnDefinitionByNodeIdArgs, 'nodeId'>>;
  dataViewColumnDefinitionByTableNameAndColumnName?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinition']>, ParentType, ContextType, RequireFields<QueryDataViewColumnDefinitionByTableNameAndColumnNameArgs, 'columnName' | 'tableName'>>;
  dataViewColumnDefinitions?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinitionsConnection']>, ParentType, ContextType, RequireFields<QueryDataViewColumnDefinitionsArgs, 'orderBy'>>;
  dataViews?: Resolver<Maybe<ResolversTypes['DataViewsConnection']>, ParentType, ContextType, RequireFields<QueryDataViewsArgs, 'orderBy'>>;
  elementTypePlugin?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType, RequireFields<QueryElementTypePluginArgs, 'code'>>;
  elementTypePluginByNodeId?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType, RequireFields<QueryElementTypePluginByNodeIdArgs, 'nodeId'>>;
  elementTypePlugins?: Resolver<Maybe<ResolversTypes['ElementTypePluginsConnection']>, ParentType, ContextType, RequireFields<QueryElementTypePluginsArgs, 'orderBy'>>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<QueryFileArgs, 'id'>>;
  fileByNodeId?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<QueryFileByNodeIdArgs, 'nodeId'>>;
  fileByUniqueId?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType, RequireFields<QueryFileByUniqueIdArgs, 'uniqueId'>>;
  files?: Resolver<Maybe<ResolversTypes['FilesConnection']>, ParentType, ContextType, RequireFields<QueryFilesArgs, 'orderBy'>>;
  filter?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType, RequireFields<QueryFilterArgs, 'id'>>;
  filterByCode?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType, RequireFields<QueryFilterByCodeArgs, 'code'>>;
  filterByNodeId?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType, RequireFields<QueryFilterByNodeIdArgs, 'nodeId'>>;
  filters?: Resolver<Maybe<ResolversTypes['FiltersConnection']>, ParentType, ContextType, RequireFields<QueryFiltersArgs, 'orderBy'>>;
  grafanaDashboardImage?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImage']>, ParentType, ContextType, RequireFields<QueryGrafanaDashboardImageArgs, 'id' | 'name'>>;
  grafanaDashboardImageByNodeId?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImage']>, ParentType, ContextType, RequireFields<QueryGrafanaDashboardImageByNodeIdArgs, 'nodeId'>>;
  grafanaDashboardImages?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImagesConnection']>, ParentType, ContextType, RequireFields<QueryGrafanaDashboardImagesArgs, 'orderBy'>>;
  jwtGetBigint?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, Partial<QueryJwtGetBigintArgs>>;
  jwtGetBoolean?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType, Partial<QueryJwtGetBooleanArgs>>;
  jwtGetText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType, Partial<QueryJwtGetTextArgs>>;
  node?: Resolver<Maybe<ResolversTypes['Node']>, ParentType, ContextType, RequireFields<QueryNodeArgs, 'nodeId'>>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType, RequireFields<QueryNotificationArgs, 'id'>>;
  notificationByNodeId?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType, RequireFields<QueryNotificationByNodeIdArgs, 'nodeId'>>;
  notifications?: Resolver<Maybe<ResolversTypes['NotificationsConnection']>, ParentType, ContextType, RequireFields<QueryNotificationsArgs, 'orderBy'>>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType, RequireFields<QueryOrganisationArgs, 'id'>>;
  organisationApplicationJoin?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoin']>, ParentType, ContextType, RequireFields<QueryOrganisationApplicationJoinArgs, 'id'>>;
  organisationApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoin']>, ParentType, ContextType, RequireFields<QueryOrganisationApplicationJoinByNodeIdArgs, 'nodeId'>>;
  organisationApplicationJoins?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoinsConnection']>, ParentType, ContextType, RequireFields<QueryOrganisationApplicationJoinsArgs, 'orderBy'>>;
  organisationByName?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType, RequireFields<QueryOrganisationByNameArgs, 'name'>>;
  organisationByNodeId?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType, RequireFields<QueryOrganisationByNodeIdArgs, 'nodeId'>>;
  organisationByRegistration?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType, RequireFields<QueryOrganisationByRegistrationArgs, 'registration'>>;
  organisations?: Resolver<Maybe<ResolversTypes['OrganisationsConnection']>, ParentType, ContextType, RequireFields<QueryOrganisationsArgs, 'orderBy'>>;
  permissionFlatteneds?: Resolver<Maybe<ResolversTypes['PermissionFlattenedsConnection']>, ParentType, ContextType, RequireFields<QueryPermissionFlattenedsArgs, 'orderBy'>>;
  permissionJoin?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType, RequireFields<QueryPermissionJoinArgs, 'id'>>;
  permissionJoinByNodeId?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType, RequireFields<QueryPermissionJoinByNodeIdArgs, 'nodeId'>>;
  permissionJoins?: Resolver<Maybe<ResolversTypes['PermissionJoinsConnection']>, ParentType, ContextType, RequireFields<QueryPermissionJoinsArgs, 'orderBy'>>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType, RequireFields<QueryPermissionNameArgs, 'id'>>;
  permissionNameByName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType, RequireFields<QueryPermissionNameByNameArgs, 'name'>>;
  permissionNameByNodeId?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType, RequireFields<QueryPermissionNameByNodeIdArgs, 'nodeId'>>;
  permissionNames?: Resolver<Maybe<ResolversTypes['PermissionNamesConnection']>, ParentType, ContextType, RequireFields<QueryPermissionNamesArgs, 'orderBy'>>;
  permissionPolicies?: Resolver<Maybe<ResolversTypes['PermissionPoliciesConnection']>, ParentType, ContextType, RequireFields<QueryPermissionPoliciesArgs, 'orderBy'>>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType, RequireFields<QueryPermissionPolicyArgs, 'id'>>;
  permissionPolicyByName?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType, RequireFields<QueryPermissionPolicyByNameArgs, 'name'>>;
  permissionPolicyByNodeId?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType, RequireFields<QueryPermissionPolicyByNodeIdArgs, 'nodeId'>>;
  permissionsAlls?: Resolver<Maybe<ResolversTypes['PermissionsAllsConnection']>, ParentType, ContextType, RequireFields<QueryPermissionsAllsArgs, 'orderBy'>>;
  postgresRowLevels?: Resolver<Maybe<ResolversTypes['PostgresRowLevelsConnection']>, ParentType, ContextType, RequireFields<QueryPostgresRowLevelsArgs, 'orderBy'>>;
  query?: Resolver<ResolversTypes['Query'], ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<QueryReviewArgs, 'id'>>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentArgs, 'id'>>;
  reviewAssignmentAssignedSections?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignedSectionsShapesConnection']>, ParentType, ContextType, Partial<QueryReviewAssignmentAssignedSectionsArgs>>;
  reviewAssignmentAssignedSectionsShapes?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignedSectionsShapesConnection']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentAssignedSectionsShapesArgs, 'orderBy'>>;
  reviewAssignmentAssignerJoin?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoin']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentAssignerJoinArgs, 'id'>>;
  reviewAssignmentAssignerJoinByNodeId?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoin']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentAssignerJoinByNodeIdArgs, 'nodeId'>>;
  reviewAssignmentAssignerJoins?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoinsConnection']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentAssignerJoinsArgs, 'orderBy'>>;
  reviewAssignmentByNodeId?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentByNodeIdArgs, 'nodeId'>>;
  reviewAssignments?: Resolver<Maybe<ResolversTypes['ReviewAssignmentsConnection']>, ParentType, ContextType, RequireFields<QueryReviewAssignmentsArgs, 'orderBy'>>;
  reviewByNodeId?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<QueryReviewByNodeIdArgs, 'nodeId'>>;
  reviewByReviewAssignmentId?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType, RequireFields<QueryReviewByReviewAssignmentIdArgs, 'reviewAssignmentId'>>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType, RequireFields<QueryReviewDecisionArgs, 'id'>>;
  reviewDecisionByNodeId?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType, RequireFields<QueryReviewDecisionByNodeIdArgs, 'nodeId'>>;
  reviewDecisions?: Resolver<Maybe<ResolversTypes['ReviewDecisionsConnection']>, ParentType, ContextType, RequireFields<QueryReviewDecisionsArgs, 'orderBy'>>;
  reviewList?: Resolver<Maybe<ResolversTypes['ReviewListConnection']>, ParentType, ContextType, Partial<QueryReviewListArgs>>;
  reviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType, RequireFields<QueryReviewResponseArgs, 'id'>>;
  reviewResponseByNodeId?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType, RequireFields<QueryReviewResponseByNodeIdArgs, 'nodeId'>>;
  reviewResponses?: Resolver<Maybe<ResolversTypes['ReviewResponsesConnection']>, ParentType, ContextType, RequireFields<QueryReviewResponsesArgs, 'orderBy'>>;
  reviewStatusHistories?: Resolver<Maybe<ResolversTypes['ReviewStatusHistoriesConnection']>, ParentType, ContextType, RequireFields<QueryReviewStatusHistoriesArgs, 'orderBy'>>;
  reviewStatusHistory?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType, RequireFields<QueryReviewStatusHistoryArgs, 'id'>>;
  reviewStatusHistoryByNodeId?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType, RequireFields<QueryReviewStatusHistoryByNodeIdArgs, 'nodeId'>>;
  reviewableQuestions?: Resolver<Maybe<ResolversTypes['ReviewableQuestionsConnection']>, ParentType, ContextType, Partial<QueryReviewableQuestionsArgs>>;
  reviewableQuestionsCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, Partial<QueryReviewableQuestionsCountArgs>>;
  reviews?: Resolver<Maybe<ResolversTypes['ReviewsConnection']>, ParentType, ContextType, RequireFields<QueryReviewsArgs, 'orderBy'>>;
  schemaColumns?: Resolver<Maybe<ResolversTypes['SchemaColumnsConnection']>, ParentType, ContextType, RequireFields<QuerySchemaColumnsArgs, 'orderBy'>>;
  singleApplicationDetail?: Resolver<Maybe<ResolversTypes['SingleApplicationDetailConnection']>, ParentType, ContextType, Partial<QuerySingleApplicationDetailArgs>>;
  submittedAssignedQuestionsCount?: Resolver<Maybe<ResolversTypes['BigInt']>, ParentType, ContextType, Partial<QuerySubmittedAssignedQuestionsCountArgs>>;
  systemInfo?: Resolver<Maybe<ResolversTypes['SystemInfo']>, ParentType, ContextType, RequireFields<QuerySystemInfoArgs, 'id'>>;
  systemInfoByNodeId?: Resolver<Maybe<ResolversTypes['SystemInfo']>, ParentType, ContextType, RequireFields<QuerySystemInfoByNodeIdArgs, 'nodeId'>>;
  systemInfos?: Resolver<Maybe<ResolversTypes['SystemInfosConnection']>, ParentType, ContextType, RequireFields<QuerySystemInfosArgs, 'orderBy'>>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType, RequireFields<QueryTemplateArgs, 'id'>>;
  templateAction?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType, RequireFields<QueryTemplateActionArgs, 'id'>>;
  templateActionByNodeId?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType, RequireFields<QueryTemplateActionByNodeIdArgs, 'nodeId'>>;
  templateActions?: Resolver<Maybe<ResolversTypes['TemplateActionsConnection']>, ParentType, ContextType, RequireFields<QueryTemplateActionsArgs, 'orderBy'>>;
  templateByCodeAndVersionId?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType, RequireFields<QueryTemplateByCodeAndVersionIdArgs, 'code' | 'versionId'>>;
  templateByNodeId?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType, RequireFields<QueryTemplateByNodeIdArgs, 'nodeId'>>;
  templateCategories?: Resolver<Maybe<ResolversTypes['TemplateCategoriesConnection']>, ParentType, ContextType, RequireFields<QueryTemplateCategoriesArgs, 'orderBy'>>;
  templateCategory?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType, RequireFields<QueryTemplateCategoryArgs, 'id'>>;
  templateCategoryByCode?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType, RequireFields<QueryTemplateCategoryByCodeArgs, 'code'>>;
  templateCategoryByNodeId?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType, RequireFields<QueryTemplateCategoryByNodeIdArgs, 'nodeId'>>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType, RequireFields<QueryTemplateElementArgs, 'id'>>;
  templateElementByNodeId?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType, RequireFields<QueryTemplateElementByNodeIdArgs, 'nodeId'>>;
  templateElementByTemplateCodeAndCodeAndTemplateVersion?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType, RequireFields<QueryTemplateElementByTemplateCodeAndCodeAndTemplateVersionArgs, 'code' | 'templateCode' | 'templateVersion'>>;
  templateElements?: Resolver<Maybe<ResolversTypes['TemplateElementsConnection']>, ParentType, ContextType, RequireFields<QueryTemplateElementsArgs, 'orderBy'>>;
  templateFilterJoin?: Resolver<Maybe<ResolversTypes['TemplateFilterJoin']>, ParentType, ContextType, RequireFields<QueryTemplateFilterJoinArgs, 'id'>>;
  templateFilterJoinByNodeId?: Resolver<Maybe<ResolversTypes['TemplateFilterJoin']>, ParentType, ContextType, RequireFields<QueryTemplateFilterJoinByNodeIdArgs, 'nodeId'>>;
  templateFilterJoins?: Resolver<Maybe<ResolversTypes['TemplateFilterJoinsConnection']>, ParentType, ContextType, RequireFields<QueryTemplateFilterJoinsArgs, 'orderBy'>>;
  templatePermission?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType, RequireFields<QueryTemplatePermissionArgs, 'id'>>;
  templatePermissionByNodeId?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType, RequireFields<QueryTemplatePermissionByNodeIdArgs, 'nodeId'>>;
  templatePermissions?: Resolver<Maybe<ResolversTypes['TemplatePermissionsConnection']>, ParentType, ContextType, RequireFields<QueryTemplatePermissionsArgs, 'orderBy'>>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType, RequireFields<QueryTemplateSectionArgs, 'id'>>;
  templateSectionByNodeId?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType, RequireFields<QueryTemplateSectionByNodeIdArgs, 'nodeId'>>;
  templateSectionByTemplateIdAndCode?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType, RequireFields<QueryTemplateSectionByTemplateIdAndCodeArgs, 'code' | 'templateId'>>;
  templateSections?: Resolver<Maybe<ResolversTypes['TemplateSectionsConnection']>, ParentType, ContextType, RequireFields<QueryTemplateSectionsArgs, 'orderBy'>>;
  templateStage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType, RequireFields<QueryTemplateStageArgs, 'id'>>;
  templateStageByNodeId?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType, RequireFields<QueryTemplateStageByNodeIdArgs, 'nodeId'>>;
  templateStageReviewLevel?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType, RequireFields<QueryTemplateStageReviewLevelArgs, 'id'>>;
  templateStageReviewLevelByNodeId?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType, RequireFields<QueryTemplateStageReviewLevelByNodeIdArgs, 'nodeId'>>;
  templateStageReviewLevels?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevelsConnection']>, ParentType, ContextType, RequireFields<QueryTemplateStageReviewLevelsArgs, 'orderBy'>>;
  templateStages?: Resolver<Maybe<ResolversTypes['TemplateStagesConnection']>, ParentType, ContextType, RequireFields<QueryTemplateStagesArgs, 'orderBy'>>;
  templates?: Resolver<Maybe<ResolversTypes['TemplatesConnection']>, ParentType, ContextType, RequireFields<QueryTemplatesArgs, 'orderBy'>>;
  triggerQueue?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType, RequireFields<QueryTriggerQueueArgs, 'id'>>;
  triggerQueueByNodeId?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType, RequireFields<QueryTriggerQueueByNodeIdArgs, 'nodeId'>>;
  triggerQueues?: Resolver<Maybe<ResolversTypes['TriggerQueuesConnection']>, ParentType, ContextType, RequireFields<QueryTriggerQueuesArgs, 'orderBy'>>;
  triggerSchedule?: Resolver<Maybe<ResolversTypes['TriggerSchedule']>, ParentType, ContextType, RequireFields<QueryTriggerScheduleArgs, 'id'>>;
  triggerScheduleByNodeId?: Resolver<Maybe<ResolversTypes['TriggerSchedule']>, ParentType, ContextType, RequireFields<QueryTriggerScheduleByNodeIdArgs, 'nodeId'>>;
  triggerSchedules?: Resolver<Maybe<ResolversTypes['TriggerSchedulesConnection']>, ParentType, ContextType, RequireFields<QueryTriggerSchedulesArgs, 'orderBy'>>;
  unnestedSections?: Resolver<Maybe<ResolversTypes['UnnestedSectionsConnection']>, ParentType, ContextType, RequireFields<QueryUnnestedSectionsArgs, 'orderBy'>>;
  userApplicationJoin?: Resolver<Maybe<ResolversTypes['UserApplicationJoin']>, ParentType, ContextType, RequireFields<QueryUserApplicationJoinArgs, 'id'>>;
  userApplicationJoinByNodeId?: Resolver<Maybe<ResolversTypes['UserApplicationJoin']>, ParentType, ContextType, RequireFields<QueryUserApplicationJoinByNodeIdArgs, 'nodeId'>>;
  userApplicationJoins?: Resolver<Maybe<ResolversTypes['UserApplicationJoinsConnection']>, ParentType, ContextType, RequireFields<QueryUserApplicationJoinsArgs, 'orderBy'>>;
  userLists?: Resolver<Maybe<ResolversTypes['UserListsConnection']>, ParentType, ContextType, RequireFields<QueryUserListsArgs, 'orderBy'>>;
  userOrgJoins?: Resolver<Maybe<ResolversTypes['UserOrgJoinsConnection']>, ParentType, ContextType, RequireFields<QueryUserOrgJoinsArgs, 'orderBy'>>;
  userOrganisation?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType, RequireFields<QueryUserOrganisationArgs, 'id'>>;
  userOrganisationByNodeId?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType, RequireFields<QueryUserOrganisationByNodeIdArgs, 'nodeId'>>;
  userOrganisations?: Resolver<Maybe<ResolversTypes['UserOrganisationsConnection']>, ParentType, ContextType, RequireFields<QueryUserOrganisationsArgs, 'orderBy'>>;
  users?: Resolver<Maybe<ResolversTypes['UsersConnection']>, ParentType, ContextType, RequireFields<QueryUsersArgs, 'orderBy'>>;
  verification?: Resolver<Maybe<ResolversTypes['Verification']>, ParentType, ContextType, RequireFields<QueryVerificationArgs, 'id'>>;
  verificationByNodeId?: Resolver<Maybe<ResolversTypes['Verification']>, ParentType, ContextType, RequireFields<QueryVerificationByNodeIdArgs, 'nodeId'>>;
  verificationByUniqueId?: Resolver<Maybe<ResolversTypes['Verification']>, ParentType, ContextType, RequireFields<QueryVerificationByUniqueIdArgs, 'uniqueId'>>;
  verifications?: Resolver<Maybe<ResolversTypes['VerificationsConnection']>, ParentType, ContextType, RequireFields<QueryVerificationsArgs, 'orderBy'>>;
};

export type ReviewResolvers<ContextType = any, ParentType extends ResolversParentTypes['Review'] = ResolversParentTypes['Review']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isFinalDecision?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isLastLevel?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isLastStage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isLocked?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  latestDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  levelNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  notifications?: Resolver<ResolversTypes['NotificationsConnection'], ParentType, ContextType, RequireFields<ReviewNotificationsArgs, 'orderBy'>>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewAssignmentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewDecisions?: Resolver<ResolversTypes['ReviewDecisionsConnection'], ParentType, ContextType, RequireFields<ReviewReviewDecisionsArgs, 'orderBy'>>;
  reviewResponses?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ReviewReviewResponsesArgs, 'orderBy'>>;
  reviewStatusHistories?: Resolver<ResolversTypes['ReviewStatusHistoriesConnection'], ParentType, ContextType, RequireFields<ReviewReviewStatusHistoriesArgs, 'orderBy'>>;
  reviewer?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  reviewerId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ReviewStatus']>, ParentType, ContextType>;
  timeStageCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeStatusCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignment'] = ResolversParentTypes['ReviewAssignment']> = {
  allowedSections?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  assignedSections?: Resolver<Array<Maybe<ResolversTypes['String']>>, ParentType, ContextType>;
  assigner?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  assignerId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  availableSections?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isFinalDecision?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isLastLevel?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isLastStage?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isSelfAssignable?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType>;
  levelId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  levelNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewAssignmentAssignerJoins?: Resolver<ResolversTypes['ReviewAssignmentAssignerJoinsConnection'], ParentType, ContextType, RequireFields<ReviewAssignmentReviewAssignmentAssignerJoinsArgs, 'orderBy'>>;
  reviewer?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  reviewerId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  reviews?: Resolver<ResolversTypes['ReviewsConnection'], ParentType, ContextType, RequireFields<ReviewAssignmentReviewsArgs, 'orderBy'>>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  stageId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<ResolversTypes['ReviewAssignmentStatus'], ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timeStageCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeUpdated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentAssignedSectionsShapeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentAssignedSectionsShape'] = ResolversParentTypes['ReviewAssignmentAssignedSectionsShape']> = {
  assignedSections?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reviewAssignmentId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentAssignedSectionsShapesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentAssignedSectionsShapesConnection'] = ResolversParentTypes['ReviewAssignmentAssignedSectionsShapesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewAssignmentAssignedSectionsShapesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewAssignmentAssignedSectionsShape']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentAssignedSectionsShapesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentAssignedSectionsShapesEdge'] = ResolversParentTypes['ReviewAssignmentAssignedSectionsShapesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignedSectionsShape']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentAssignerJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentAssignerJoin'] = ResolversParentTypes['ReviewAssignmentAssignerJoin']> = {
  assigner?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  assignerId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewAssignmentId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentAssignerJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentAssignerJoinsConnection'] = ResolversParentTypes['ReviewAssignmentAssignerJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewAssignmentAssignerJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewAssignmentAssignerJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentAssignerJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentAssignerJoinsEdge'] = ResolversParentTypes['ReviewAssignmentAssignerJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentsConnection'] = ResolversParentTypes['ReviewAssignmentsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewAssignmentsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewAssignment']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewAssignmentsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewAssignmentsEdge'] = ResolversParentTypes['ReviewAssignmentsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDecisionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewDecision'] = ResolversParentTypes['ReviewDecision']> = {
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  decision?: Resolver<Maybe<ResolversTypes['Decision']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  timeUpdated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDecisionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewDecisionsConnection'] = ResolversParentTypes['ReviewDecisionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewDecisionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewDecision']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewDecisionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewDecisionsEdge'] = ResolversParentTypes['ReviewDecisionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewListConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewListConnection'] = ResolversParentTypes['ReviewListConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewListEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewListRecord']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewListEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewListEdge'] = ResolversParentTypes['ReviewListEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewListRecord']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewListRecordResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewListRecord'] = ResolversParentTypes['ReviewListRecord']> = {
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewerAction?: Resolver<Maybe<ResolversTypes['ReviewerAction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewResponseResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewResponse'] = ResolversParentTypes['ReviewResponse']> = {
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  applicationResponseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  comment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  decision?: Resolver<Maybe<ResolversTypes['ReviewResponseDecision']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isLatestReview?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isLatestReviewSubmission?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  isVisibleToApplicant?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  originalReviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  originalReviewResponseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  recommendedApplicantVisibility?: Resolver<Maybe<ResolversTypes['ReviewResponseRecommendedApplicantVisibility']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewResponseLink?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  reviewResponseLinkId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewResponsesByOriginalReviewResponseId?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ReviewResponseReviewResponsesByOriginalReviewResponseIdArgs, 'orderBy'>>;
  reviewResponsesByReviewResponseLinkId?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<ReviewResponseReviewResponsesByReviewResponseLinkIdArgs, 'orderBy'>>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ReviewResponseStatus']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  templateElementId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeSubmitted?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeUpdated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewResponsesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewResponsesConnection'] = ResolversParentTypes['ReviewResponsesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewResponsesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewResponse']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewResponsesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewResponsesEdge'] = ResolversParentTypes['ReviewResponsesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewStatusHistoriesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewStatusHistoriesConnection'] = ResolversParentTypes['ReviewStatusHistoriesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewStatusHistoriesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewStatusHistory']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewStatusHistoriesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewStatusHistoriesEdge'] = ResolversParentTypes['ReviewStatusHistoriesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewStatusHistoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewStatusHistory'] = ResolversParentTypes['ReviewStatusHistory']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isCurrent?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['ReviewStatus']>, ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewableQuestionEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewableQuestionEdge'] = ResolversParentTypes['ReviewableQuestionEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['ReviewableQuestionsRecord']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewableQuestionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewableQuestionsConnection'] = ResolversParentTypes['ReviewableQuestionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewableQuestionEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['ReviewableQuestionsRecord']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewableQuestionsRecordResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewableQuestionsRecord'] = ResolversParentTypes['ReviewableQuestionsRecord']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isOptional?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  responseId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  responseValue?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  reviewability?: Resolver<Maybe<ResolversTypes['Reviewability']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewsConnection'] = ResolversParentTypes['ReviewsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['ReviewsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Review']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type ReviewsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['ReviewsEdge'] = ResolversParentTypes['ReviewsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaColumnResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaColumn'] = ResolversParentTypes['SchemaColumn']> = {
  columnName?: Resolver<Maybe<ResolversTypes['SqlIdentifier']>, ParentType, ContextType>;
  constraintType?: Resolver<Maybe<ResolversTypes['CharacterData']>, ParentType, ContextType>;
  dataType?: Resolver<Maybe<ResolversTypes['CharacterData']>, ParentType, ContextType>;
  fkToColumnName?: Resolver<Maybe<ResolversTypes['SqlIdentifier']>, ParentType, ContextType>;
  fkToTableName?: Resolver<Maybe<ResolversTypes['SqlIdentifier']>, ParentType, ContextType>;
  isGenerated?: Resolver<Maybe<ResolversTypes['CharacterData']>, ParentType, ContextType>;
  isNullable?: Resolver<Maybe<ResolversTypes['YesOrNo']>, ParentType, ContextType>;
  subDataType?: Resolver<Maybe<ResolversTypes['CharacterData']>, ParentType, ContextType>;
  tableName?: Resolver<Maybe<ResolversTypes['SqlIdentifier']>, ParentType, ContextType>;
  tableType?: Resolver<Maybe<ResolversTypes['CharacterData']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaColumnsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaColumnsConnection'] = ResolversParentTypes['SchemaColumnsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['SchemaColumnsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['SchemaColumn']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SchemaColumnsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SchemaColumnsEdge'] = ResolversParentTypes['SchemaColumnsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SchemaColumn']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SingleApplicationDetailConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SingleApplicationDetailConnection'] = ResolversParentTypes['SingleApplicationDetailConnection']> = {
  edges?: Resolver<Array<ResolversTypes['SingleApplicationDetailEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['SingleApplicationDetailRecord']>>, ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SingleApplicationDetailEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SingleApplicationDetailEdge'] = ResolversParentTypes['SingleApplicationDetailEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SingleApplicationDetailRecord']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SingleApplicationDetailRecordResolvers<ContextType = any, ParentType extends ResolversParentTypes['SingleApplicationDetailRecord'] = ResolversParentTypes['SingleApplicationDetailRecord']> = {
  assignerAction?: Resolver<Maybe<ResolversTypes['AssignerAction']>, ParentType, ContextType>;
  assigners?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  reviewerAction?: Resolver<Maybe<ResolversTypes['ReviewerAction']>, ParentType, ContextType>;
  reviewers?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface SqlIdentifierScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['SqlIdentifier'], any> {
  name: 'SqlIdentifier';
}

export type SystemInfoResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemInfo'] = ResolversParentTypes['SystemInfo']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  value?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SystemInfosConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemInfosConnection'] = ResolversParentTypes['SystemInfosConnection']> = {
  edges?: Resolver<Array<ResolversTypes['SystemInfosEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['SystemInfo']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type SystemInfosEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['SystemInfosEdge'] = ResolversParentTypes['SystemInfosEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['SystemInfo']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateResolvers<ContextType = any, ParentType extends ResolversParentTypes['Template'] = ResolversParentTypes['Template']> = {
  actionQueues?: Resolver<ResolversTypes['ActionQueuesConnection'], ParentType, ContextType, RequireFields<TemplateActionQueuesArgs, 'orderBy'>>;
  applications?: Resolver<ResolversTypes['ApplicationsConnection'], ParentType, ContextType, RequireFields<TemplateApplicationsArgs, 'orderBy'>>;
  canApplicantMakeChanges?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  dashboardRestrictions?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  files?: Resolver<ResolversTypes['FilesConnection'], ParentType, ContextType, RequireFields<TemplateFilesArgs, 'orderBy'>>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isLinear?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  name?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  namePlural?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parentVersionId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewAssignments?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<TemplateReviewAssignmentsArgs, 'orderBy'>>;
  serialPattern?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  startMessage?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['TemplateStatus']>, ParentType, ContextType>;
  submissionMessage?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  templateActions?: Resolver<ResolversTypes['TemplateActionsConnection'], ParentType, ContextType, RequireFields<TemplateTemplateActionsArgs, 'orderBy'>>;
  templateCategory?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType>;
  templateCategoryId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templateFilterJoins?: Resolver<ResolversTypes['TemplateFilterJoinsConnection'], ParentType, ContextType, RequireFields<TemplateTemplateFilterJoinsArgs, 'orderBy'>>;
  templatePermissions?: Resolver<ResolversTypes['TemplatePermissionsConnection'], ParentType, ContextType, RequireFields<TemplateTemplatePermissionsArgs, 'orderBy'>>;
  templateSections?: Resolver<ResolversTypes['TemplateSectionsConnection'], ParentType, ContextType, RequireFields<TemplateTemplateSectionsArgs, 'orderBy'>>;
  templateStages?: Resolver<ResolversTypes['TemplateStagesConnection'], ParentType, ContextType, RequireFields<TemplateTemplateStagesArgs, 'orderBy'>>;
  triggerSchedules?: Resolver<ResolversTypes['TriggerSchedulesConnection'], ParentType, ContextType, RequireFields<TemplateTriggerSchedulesArgs, 'orderBy'>>;
  versionComment?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  versionHistory?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  versionId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  versionTimestamp?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateActionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateAction'] = ResolversParentTypes['TemplateAction']> = {
  actionCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  condition?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  eventCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parameterQueries?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  parametersQueriesString?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  sequence?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateActionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateActionsConnection'] = ResolversParentTypes['TemplateActionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplateActionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateAction']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateActionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateActionsEdge'] = ResolversParentTypes['TemplateActionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateCategoriesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateCategoriesConnection'] = ResolversParentTypes['TemplateCategoriesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplateCategoriesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateCategory']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateCategoriesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateCategoriesEdge'] = ResolversParentTypes['TemplateCategoriesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateCategoryResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateCategory'] = ResolversParentTypes['TemplateCategory']> = {
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  icon?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isSubmenu?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  priority?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  templates?: Resolver<ResolversTypes['TemplatesConnection'], ParentType, ContextType, RequireFields<TemplateCategoryTemplatesArgs, 'orderBy'>>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  uiLocation?: Resolver<Maybe<Array<Maybe<ResolversTypes['UiLocation']>>>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateElementResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateElement'] = ResolversParentTypes['TemplateElement']> = {
  applicationResponses?: Resolver<ResolversTypes['ApplicationResponsesConnection'], ParentType, ContextType, RequireFields<TemplateElementApplicationResponsesArgs, 'orderBy'>>;
  category?: Resolver<Maybe<ResolversTypes['TemplateElementCategory']>, ParentType, ContextType>;
  code?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  elementTypePluginCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  helpText?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  initialValue?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  isEditable?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  isRequired?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  parameters?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  parametersString?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  reviewResponses?: Resolver<ResolversTypes['ReviewResponsesConnection'], ParentType, ContextType, RequireFields<TemplateElementReviewResponsesArgs, 'orderBy'>>;
  reviewability?: Resolver<ResolversTypes['Reviewability'], ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  sectionId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  templateCode?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  templateVersion?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  validation?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  validationMessage?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  visibilityCondition?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateElementsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateElementsConnection'] = ResolversParentTypes['TemplateElementsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplateElementsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateElement']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateElementsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateElementsEdge'] = ResolversParentTypes['TemplateElementsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateFilterJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateFilterJoin'] = ResolversParentTypes['TemplateFilterJoin']> = {
  filter?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType>;
  filterId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateFilterJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateFilterJoinsConnection'] = ResolversParentTypes['TemplateFilterJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplateFilterJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateFilterJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateFilterJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateFilterJoinsEdge'] = ResolversParentTypes['TemplateFilterJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateFilterJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatePermissionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatePermission'] = ResolversParentTypes['TemplatePermission']> = {
  allowedSections?: Resolver<Maybe<Array<Maybe<ResolversTypes['String']>>>, ParentType, ContextType>;
  canMakeFinalDecision?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  canSelfAssign?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  levelNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  permissionNameId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  restrictions?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  stageNumber?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatePermissionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatePermissionsConnection'] = ResolversParentTypes['TemplatePermissionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplatePermissionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplatePermission']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatePermissionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatePermissionsEdge'] = ResolversParentTypes['TemplatePermissionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateSectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateSection'] = ResolversParentTypes['TemplateSection']> = {
  code?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  index?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateElementsBySectionId?: Resolver<ResolversTypes['TemplateElementsConnection'], ParentType, ContextType, RequireFields<TemplateSectionTemplateElementsBySectionIdArgs, 'orderBy'>>;
  templateId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateSectionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateSectionsConnection'] = ResolversParentTypes['TemplateSectionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplateSectionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateSection']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateSectionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateSectionsEdge'] = ResolversParentTypes['TemplateSectionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStageResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStage'] = ResolversParentTypes['TemplateStage']> = {
  applicationStageHistoriesByStageId?: Resolver<ResolversTypes['ApplicationStageHistoriesConnection'], ParentType, ContextType, RequireFields<TemplateStageApplicationStageHistoriesByStageIdArgs, 'orderBy'>>;
  colour?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  number?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  reviewAssignmentsByStageId?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<TemplateStageReviewAssignmentsByStageIdArgs, 'orderBy'>>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  templateStageReviewLevelsByStageId?: Resolver<ResolversTypes['TemplateStageReviewLevelsConnection'], ParentType, ContextType, RequireFields<TemplateStageTemplateStageReviewLevelsByStageIdArgs, 'orderBy'>>;
  title?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStageReviewLevelResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStageReviewLevel'] = ResolversParentTypes['TemplateStageReviewLevel']> = {
  description?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  name?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  number?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  reviewAssignmentsByLevelId?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<TemplateStageReviewLevelReviewAssignmentsByLevelIdArgs, 'orderBy'>>;
  singleReviewerAllSections?: Resolver<ResolversTypes['Boolean'], ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  stageId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStageReviewLevelsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStageReviewLevelsConnection'] = ResolversParentTypes['TemplateStageReviewLevelsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplateStageReviewLevelsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateStageReviewLevel']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStageReviewLevelsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStageReviewLevelsEdge'] = ResolversParentTypes['TemplateStageReviewLevelsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStagesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStagesConnection'] = ResolversParentTypes['TemplateStagesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplateStagesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TemplateStage']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplateStagesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplateStagesEdge'] = ResolversParentTypes['TemplateStagesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatesConnection'] = ResolversParentTypes['TemplatesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TemplatesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Template']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TemplatesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TemplatesEdge'] = ResolversParentTypes['TemplatesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerQueueResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerQueue'] = ResolversParentTypes['TriggerQueue']> = {
  actionQueuesByTriggerEvent?: Resolver<ResolversTypes['ActionQueuesConnection'], ParentType, ContextType, RequireFields<TriggerQueueActionQueuesByTriggerEventArgs, 'orderBy'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  data?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  eventCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  log?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  recordId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  status?: Resolver<Maybe<ResolversTypes['TriggerQueueStatus']>, ParentType, ContextType>;
  table?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  timestamp?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  triggerType?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerQueuesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerQueuesConnection'] = ResolversParentTypes['TriggerQueuesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TriggerQueuesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TriggerQueue']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerQueuesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerQueuesEdge'] = ResolversParentTypes['TriggerQueuesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerScheduleResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerSchedule'] = ResolversParentTypes['TriggerSchedule']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  data?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  editorUserId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  eventCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isActive?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  timeScheduled?: Resolver<ResolversTypes['Datetime'], ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerSchedulesConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerSchedulesConnection'] = ResolversParentTypes['TriggerSchedulesConnection']> = {
  edges?: Resolver<Array<ResolversTypes['TriggerSchedulesEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['TriggerSchedule']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type TriggerSchedulesEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['TriggerSchedulesEdge'] = ResolversParentTypes['TriggerSchedulesEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['TriggerSchedule']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnnestedSectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UnnestedSection'] = ResolversParentTypes['UnnestedSection']> = {
  id?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnnestedSectionsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UnnestedSectionsConnection'] = ResolversParentTypes['UnnestedSectionsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UnnestedSectionsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['UnnestedSection']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UnnestedSectionsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UnnestedSectionsEdge'] = ResolversParentTypes['UnnestedSectionsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UnnestedSection']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateActionPluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateActionPluginPayload'] = ResolversParentTypes['UpdateActionPluginPayload']> = {
  actionPlugin?: Resolver<Maybe<ResolversTypes['ActionPlugin']>, ParentType, ContextType>;
  actionPluginEdge?: Resolver<Maybe<ResolversTypes['ActionPluginsEdge']>, ParentType, ContextType, RequireFields<UpdateActionPluginPayloadActionPluginEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateActionQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateActionQueuePayload'] = ResolversParentTypes['UpdateActionQueuePayload']> = {
  actionQueue?: Resolver<Maybe<ResolversTypes['ActionQueue']>, ParentType, ContextType>;
  actionQueueEdge?: Resolver<Maybe<ResolversTypes['ActionQueuesEdge']>, ParentType, ContextType, RequireFields<UpdateActionQueuePayloadActionQueueEdgeArgs, 'orderBy'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  triggerQueueByTriggerEvent?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateActivityLogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateActivityLogPayload'] = ResolversParentTypes['UpdateActivityLogPayload']> = {
  activityLog?: Resolver<Maybe<ResolversTypes['ActivityLog']>, ParentType, ContextType>;
  activityLogEdge?: Resolver<Maybe<ResolversTypes['ActivityLogsEdge']>, ParentType, ContextType, RequireFields<UpdateActivityLogPayloadActivityLogEdgeArgs, 'orderBy'>>;
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationNotePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationNotePayload'] = ResolversParentTypes['UpdateApplicationNotePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationNote?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType>;
  applicationNoteEdge?: Resolver<Maybe<ResolversTypes['ApplicationNotesEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationNotePayloadApplicationNoteEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationPayload'] = ResolversParentTypes['UpdateApplicationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationEdge?: Resolver<Maybe<ResolversTypes['ApplicationsEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationPayloadApplicationEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationResponsePayload'] = ResolversParentTypes['UpdateApplicationResponsePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  applicationResponseEdge?: Resolver<Maybe<ResolversTypes['ApplicationResponsesEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationResponsePayloadApplicationResponseEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationReviewerActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationReviewerActionPayload'] = ResolversParentTypes['UpdateApplicationReviewerActionPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationReviewerAction?: Resolver<Maybe<ResolversTypes['ApplicationReviewerAction']>, ParentType, ContextType>;
  applicationReviewerActionEdge?: Resolver<Maybe<ResolversTypes['ApplicationReviewerActionsEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationReviewerActionPayloadApplicationReviewerActionEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationStageHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationStageHistoryPayload'] = ResolversParentTypes['UpdateApplicationStageHistoryPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStageHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStageHistoriesEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationStageHistoryPayloadApplicationStageHistoryEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateApplicationStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateApplicationStatusHistoryPayload'] = ResolversParentTypes['UpdateApplicationStatusHistoryPayload']> = {
  applicationStageHistory?: Resolver<Maybe<ResolversTypes['ApplicationStageHistory']>, ParentType, ContextType>;
  applicationStatusHistory?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistory']>, ParentType, ContextType>;
  applicationStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ApplicationStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<UpdateApplicationStatusHistoryPayloadApplicationStatusHistoryEdgeArgs, 'orderBy'>>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateCounterPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateCounterPayload'] = ResolversParentTypes['UpdateCounterPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  counter?: Resolver<Maybe<ResolversTypes['Counter']>, ParentType, ContextType>;
  counterEdge?: Resolver<Maybe<ResolversTypes['CountersEdge']>, ParentType, ContextType, RequireFields<UpdateCounterPayloadCounterEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataChangelogPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataChangelogPayload'] = ResolversParentTypes['UpdateDataChangelogPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataChangelog?: Resolver<Maybe<ResolversTypes['DataChangelog']>, ParentType, ContextType>;
  dataChangelogEdge?: Resolver<Maybe<ResolversTypes['DataChangelogsEdge']>, ParentType, ContextType, RequireFields<UpdateDataChangelogPayloadDataChangelogEdgeArgs, 'orderBy'>>;
  org?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableActiveIngredientPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableActiveIngredientPayload'] = ResolversParentTypes['UpdateDataTableActiveIngredientPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableActiveIngredient?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredient']>, ParentType, ContextType>;
  dataTableActiveIngredientEdge?: Resolver<Maybe<ResolversTypes['DataTableActiveIngredientsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableActiveIngredientPayloadDataTableActiveIngredientEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableAdministrationRoutePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableAdministrationRoutePayload'] = ResolversParentTypes['UpdateDataTableAdministrationRoutePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableAdministrationRoute?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoute']>, ParentType, ContextType>;
  dataTableAdministrationRouteEdge?: Resolver<Maybe<ResolversTypes['DataTableAdministrationRoutesEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableAdministrationRoutePayloadDataTableAdministrationRouteEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableAtcCodePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableAtcCodePayload'] = ResolversParentTypes['UpdateDataTableAtcCodePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableAtcCode?: Resolver<Maybe<ResolversTypes['DataTableAtcCode']>, ParentType, ContextType>;
  dataTableAtcCodeEdge?: Resolver<Maybe<ResolversTypes['DataTableAtcCodesEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableAtcCodePayloadDataTableAtcCodeEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableContainerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableContainerPayload'] = ResolversParentTypes['UpdateDataTableContainerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableContainer?: Resolver<Maybe<ResolversTypes['DataTableContainer']>, ParentType, ContextType>;
  dataTableContainerEdge?: Resolver<Maybe<ResolversTypes['DataTableContainersEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableContainerPayloadDataTableContainerEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableCountryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableCountryPayload'] = ResolversParentTypes['UpdateDataTableCountryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableCountry?: Resolver<Maybe<ResolversTypes['DataTableCountry']>, ParentType, ContextType>;
  dataTableCountryEdge?: Resolver<Maybe<ResolversTypes['DataTableCountriesEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableCountryPayloadDataTableCountryEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableDosageFormGroupPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableDosageFormGroupPayload'] = ResolversParentTypes['UpdateDataTableDosageFormGroupPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableDosageFormGroup?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroup']>, ParentType, ContextType>;
  dataTableDosageFormGroupEdge?: Resolver<Maybe<ResolversTypes['DataTableDosageFormGroupsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableDosageFormGroupPayloadDataTableDosageFormGroupEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableDosageFormPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableDosageFormPayload'] = ResolversParentTypes['UpdateDataTableDosageFormPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableDosageForm?: Resolver<Maybe<ResolversTypes['DataTableDosageForm']>, ParentType, ContextType>;
  dataTableDosageFormEdge?: Resolver<Maybe<ResolversTypes['DataTableDosageFormsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableDosageFormPayloadDataTableDosageFormEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableGenericIngredientPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableGenericIngredientPayload'] = ResolversParentTypes['UpdateDataTableGenericIngredientPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableGenericIngredient?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredient']>, ParentType, ContextType>;
  dataTableGenericIngredientEdge?: Resolver<Maybe<ResolversTypes['DataTableGenericIngredientsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableGenericIngredientPayloadDataTableGenericIngredientEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableManufacturerApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableManufacturerApplicationJoinPayload'] = ResolversParentTypes['UpdateDataTableManufacturerApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturer?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType>;
  dataTableManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoin']>, ParentType, ContextType>;
  dataTableManufacturerApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableManufacturerApplicationJoinPayloadDataTableManufacturerApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableManufacturerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableManufacturerPayload'] = ResolversParentTypes['UpdateDataTableManufacturerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturer?: Resolver<Maybe<ResolversTypes['DataTableManufacturer']>, ParentType, ContextType>;
  dataTableManufacturerEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturersEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableManufacturerPayloadDataTableManufacturerEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableManufacturerRepresentativeApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableManufacturerRepresentativeApplicationJoinPayload'] = ResolversParentTypes['UpdateDataTableManufacturerRepresentativeApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoin']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativeApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableManufacturerRepresentativeApplicationJoinPayloadDataTableManufacturerRepresentativeApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableManufacturerRepresentativePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableManufacturerRepresentativePayload'] = ResolversParentTypes['UpdateDataTableManufacturerRepresentativePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableManufacturerRepresentative?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentative']>, ParentType, ContextType>;
  dataTableManufacturerRepresentativeEdge?: Resolver<Maybe<ResolversTypes['DataTableManufacturerRepresentativesEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableManufacturerRepresentativePayloadDataTableManufacturerRepresentativeEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTablePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTablePayload'] = ResolversParentTypes['UpdateDataTablePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTable?: Resolver<Maybe<ResolversTypes['DataTable']>, ParentType, ContextType>;
  dataTableEdge?: Resolver<Maybe<ResolversTypes['DataTablesEdge']>, ParentType, ContextType, RequireFields<UpdateDataTablePayloadDataTableEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTablePermitChemicalApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTablePermitChemicalApplicationJoinPayload'] = ResolversParentTypes['UpdateDataTablePermitChemicalApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType>;
  dataTablePermitChemicalApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoin']>, ParentType, ContextType>;
  dataTablePermitChemicalApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTablePermitChemicalApplicationJoinPayloadDataTablePermitChemicalApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTablePermitChemicalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTablePermitChemicalPayload'] = ResolversParentTypes['UpdateDataTablePermitChemicalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePermitChemical?: Resolver<Maybe<ResolversTypes['DataTablePermitChemical']>, ParentType, ContextType>;
  dataTablePermitChemicalEdge?: Resolver<Maybe<ResolversTypes['DataTablePermitChemicalsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTablePermitChemicalPayloadDataTablePermitChemicalEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTablePreRegisteredProductsProvisionalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTablePreRegisteredProductsProvisionalPayload'] = ResolversParentTypes['UpdateDataTablePreRegisteredProductsProvisionalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePreRegisteredProductsProvisional?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisional']>, ParentType, ContextType>;
  dataTablePreRegisteredProductsProvisionalEdge?: Resolver<Maybe<ResolversTypes['DataTablePreRegisteredProductsProvisionalsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTablePreRegisteredProductsProvisionalPayloadDataTablePreRegisteredProductsProvisionalEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTablePrequalManufacturerApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTablePrequalManufacturerApplicationJoinPayload'] = ResolversParentTypes['UpdateDataTablePrequalManufacturerApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType>;
  dataTablePrequalManufacturerApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoin']>, ParentType, ContextType>;
  dataTablePrequalManufacturerApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturerApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTablePrequalManufacturerApplicationJoinPayloadDataTablePrequalManufacturerApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTablePrequalManufacturerPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTablePrequalManufacturerPayload'] = ResolversParentTypes['UpdateDataTablePrequalManufacturerPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTablePrequalManufacturer?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturer']>, ParentType, ContextType>;
  dataTablePrequalManufacturerEdge?: Resolver<Maybe<ResolversTypes['DataTablePrequalManufacturersEdge']>, ParentType, ContextType, RequireFields<UpdateDataTablePrequalManufacturerPayloadDataTablePrequalManufacturerEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableProcessingStepPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableProcessingStepPayload'] = ResolversParentTypes['UpdateDataTableProcessingStepPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProcessingStep?: Resolver<Maybe<ResolversTypes['DataTableProcessingStep']>, ParentType, ContextType>;
  dataTableProcessingStepEdge?: Resolver<Maybe<ResolversTypes['DataTableProcessingStepsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableProcessingStepPayloadDataTableProcessingStepEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableProductApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableProductApplicationJoinPayload'] = ResolversParentTypes['UpdateDataTableProductApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoin']>, ParentType, ContextType>;
  dataTableProductApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableProductApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableProductApplicationJoinPayloadDataTableProductApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableProductPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableProductPayload'] = ResolversParentTypes['UpdateDataTableProductPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProduct?: Resolver<Maybe<ResolversTypes['DataTableProduct']>, ParentType, ContextType>;
  dataTableProductEdge?: Resolver<Maybe<ResolversTypes['DataTableProductsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableProductPayloadDataTableProductEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableProvisionalProductApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableProvisionalProductApplicationJoinPayload'] = ResolversParentTypes['UpdateDataTableProvisionalProductApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType>;
  dataTableProvisionalProductApplicationJoin?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoin']>, ParentType, ContextType>;
  dataTableProvisionalProductApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableProvisionalProductApplicationJoinPayloadDataTableProvisionalProductApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableProvisionalProductPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableProvisionalProductPayload'] = ResolversParentTypes['UpdateDataTableProvisionalProductPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableProvisionalProduct?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProduct']>, ParentType, ContextType>;
  dataTableProvisionalProductEdge?: Resolver<Maybe<ResolversTypes['DataTableProvisionalProductsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableProvisionalProductPayloadDataTableProvisionalProductEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableScheduledChemicalPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableScheduledChemicalPayload'] = ResolversParentTypes['UpdateDataTableScheduledChemicalPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableScheduledChemical?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemical']>, ParentType, ContextType>;
  dataTableScheduledChemicalEdge?: Resolver<Maybe<ResolversTypes['DataTableScheduledChemicalsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableScheduledChemicalPayloadDataTableScheduledChemicalEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableStorageConditionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableStorageConditionPayload'] = ResolversParentTypes['UpdateDataTableStorageConditionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableStorageCondition?: Resolver<Maybe<ResolversTypes['DataTableStorageCondition']>, ParentType, ContextType>;
  dataTableStorageConditionEdge?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableStorageConditionPayloadDataTableStorageConditionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableStorageConditionsSimplifiedPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableStorageConditionsSimplifiedPayload'] = ResolversParentTypes['UpdateDataTableStorageConditionsSimplifiedPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableStorageConditionsSimplified?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplified']>, ParentType, ContextType>;
  dataTableStorageConditionsSimplifiedEdge?: Resolver<Maybe<ResolversTypes['DataTableStorageConditionsSimplifiedsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableStorageConditionsSimplifiedPayloadDataTableStorageConditionsSimplifiedEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableUnitsOfProportionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableUnitsOfProportionPayload'] = ResolversParentTypes['UpdateDataTableUnitsOfProportionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableUnitsOfProportion?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportion']>, ParentType, ContextType>;
  dataTableUnitsOfProportionEdge?: Resolver<Maybe<ResolversTypes['DataTableUnitsOfProportionsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableUnitsOfProportionPayloadDataTableUnitsOfProportionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataTableWorldHealthOrganisationPqListOfFppPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataTableWorldHealthOrganisationPqListOfFppPayload'] = ResolversParentTypes['UpdateDataTableWorldHealthOrganisationPqListOfFppPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataTableWorldHealthOrganisationPqListOfFpp?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFpp']>, ParentType, ContextType>;
  dataTableWorldHealthOrganisationPqListOfFppEdge?: Resolver<Maybe<ResolversTypes['DataTableWorldHealthOrganisationPqListOfFppsEdge']>, ParentType, ContextType, RequireFields<UpdateDataTableWorldHealthOrganisationPqListOfFppPayloadDataTableWorldHealthOrganisationPqListOfFppEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataViewColumnDefinitionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataViewColumnDefinitionPayload'] = ResolversParentTypes['UpdateDataViewColumnDefinitionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataViewColumnDefinition?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinition']>, ParentType, ContextType>;
  dataViewColumnDefinitionEdge?: Resolver<Maybe<ResolversTypes['DataViewColumnDefinitionsEdge']>, ParentType, ContextType, RequireFields<UpdateDataViewColumnDefinitionPayloadDataViewColumnDefinitionEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateDataViewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateDataViewPayload'] = ResolversParentTypes['UpdateDataViewPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dataView?: Resolver<Maybe<ResolversTypes['DataView']>, ParentType, ContextType>;
  dataViewEdge?: Resolver<Maybe<ResolversTypes['DataViewsEdge']>, ParentType, ContextType, RequireFields<UpdateDataViewPayloadDataViewEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateElementTypePluginPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateElementTypePluginPayload'] = ResolversParentTypes['UpdateElementTypePluginPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  elementTypePlugin?: Resolver<Maybe<ResolversTypes['ElementTypePlugin']>, ParentType, ContextType>;
  elementTypePluginEdge?: Resolver<Maybe<ResolversTypes['ElementTypePluginsEdge']>, ParentType, ContextType, RequireFields<UpdateElementTypePluginPayloadElementTypePluginEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateFilePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateFilePayload'] = ResolversParentTypes['UpdateFilePayload']> = {
  applicationByApplicationSerial?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationNote?: Resolver<Maybe<ResolversTypes['ApplicationNote']>, ParentType, ContextType>;
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  file?: Resolver<Maybe<ResolversTypes['File']>, ParentType, ContextType>;
  fileEdge?: Resolver<Maybe<ResolversTypes['FilesEdge']>, ParentType, ContextType, RequireFields<UpdateFilePayloadFileEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateFilterPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateFilterPayload'] = ResolversParentTypes['UpdateFilterPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filter?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType>;
  filterEdge?: Resolver<Maybe<ResolversTypes['FiltersEdge']>, ParentType, ContextType, RequireFields<UpdateFilterPayloadFilterEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateGrafanaDashboardImagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateGrafanaDashboardImagePayload'] = ResolversParentTypes['UpdateGrafanaDashboardImagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  grafanaDashboardImage?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImage']>, ParentType, ContextType>;
  grafanaDashboardImageEdge?: Resolver<Maybe<ResolversTypes['GrafanaDashboardImagesEdge']>, ParentType, ContextType, RequireFields<UpdateGrafanaDashboardImagePayloadGrafanaDashboardImageEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateNotificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateNotificationPayload'] = ResolversParentTypes['UpdateNotificationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  notification?: Resolver<Maybe<ResolversTypes['Notification']>, ParentType, ContextType>;
  notificationEdge?: Resolver<Maybe<ResolversTypes['NotificationsEdge']>, ParentType, ContextType, RequireFields<UpdateNotificationPayloadNotificationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrganisationApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateOrganisationApplicationJoinPayload'] = ResolversParentTypes['UpdateOrganisationApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationApplicationJoin?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoin']>, ParentType, ContextType>;
  organisationApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['OrganisationApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateOrganisationApplicationJoinPayloadOrganisationApplicationJoinEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateOrganisationPayload'] = ResolversParentTypes['UpdateOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationEdge?: Resolver<Maybe<ResolversTypes['OrganisationsEdge']>, ParentType, ContextType, RequireFields<UpdateOrganisationPayloadOrganisationEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePermissionJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePermissionJoinPayload'] = ResolversParentTypes['UpdatePermissionJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  permissionJoin?: Resolver<Maybe<ResolversTypes['PermissionJoin']>, ParentType, ContextType>;
  permissionJoinEdge?: Resolver<Maybe<ResolversTypes['PermissionJoinsEdge']>, ParentType, ContextType, RequireFields<UpdatePermissionJoinPayloadPermissionJoinEdgeArgs, 'orderBy'>>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePermissionNamePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePermissionNamePayload'] = ResolversParentTypes['UpdatePermissionNamePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  permissionNameEdge?: Resolver<Maybe<ResolversTypes['PermissionNamesEdge']>, ParentType, ContextType, RequireFields<UpdatePermissionNamePayloadPermissionNameEdgeArgs, 'orderBy'>>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdatePermissionPolicyPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdatePermissionPolicyPayload'] = ResolversParentTypes['UpdatePermissionPolicyPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionPolicy?: Resolver<Maybe<ResolversTypes['PermissionPolicy']>, ParentType, ContextType>;
  permissionPolicyEdge?: Resolver<Maybe<ResolversTypes['PermissionPoliciesEdge']>, ParentType, ContextType, RequireFields<UpdatePermissionPolicyPayloadPermissionPolicyEdgeArgs, 'orderBy'>>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewAssignmentAssignerJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewAssignmentAssignerJoinPayload'] = ResolversParentTypes['UpdateReviewAssignmentAssignerJoinPayload']> = {
  assigner?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewAssignmentAssignerJoin?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoin']>, ParentType, ContextType>;
  reviewAssignmentAssignerJoinEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentAssignerJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewAssignmentAssignerJoinPayloadReviewAssignmentAssignerJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewAssignmentPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewAssignmentPayload'] = ResolversParentTypes['UpdateReviewAssignmentPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  assigner?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  level?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewAssignmentEdge?: Resolver<Maybe<ResolversTypes['ReviewAssignmentsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewAssignmentPayloadReviewAssignmentEdgeArgs, 'orderBy'>>;
  reviewer?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewDecisionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewDecisionPayload'] = ResolversParentTypes['UpdateReviewDecisionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewDecision?: Resolver<Maybe<ResolversTypes['ReviewDecision']>, ParentType, ContextType>;
  reviewDecisionEdge?: Resolver<Maybe<ResolversTypes['ReviewDecisionsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewDecisionPayloadReviewDecisionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewPayload'] = ResolversParentTypes['UpdateReviewPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewAssignment?: Resolver<Maybe<ResolversTypes['ReviewAssignment']>, ParentType, ContextType>;
  reviewEdge?: Resolver<Maybe<ResolversTypes['ReviewsEdge']>, ParentType, ContextType, RequireFields<UpdateReviewPayloadReviewEdgeArgs, 'orderBy'>>;
  reviewer?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewResponsePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewResponsePayload'] = ResolversParentTypes['UpdateReviewResponsePayload']> = {
  applicationResponse?: Resolver<Maybe<ResolversTypes['ApplicationResponse']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  originalReviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewResponse?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  reviewResponseEdge?: Resolver<Maybe<ResolversTypes['ReviewResponsesEdge']>, ParentType, ContextType, RequireFields<UpdateReviewResponsePayloadReviewResponseEdgeArgs, 'orderBy'>>;
  reviewResponseLink?: Resolver<Maybe<ResolversTypes['ReviewResponse']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateReviewStatusHistoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateReviewStatusHistoryPayload'] = ResolversParentTypes['UpdateReviewStatusHistoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  review?: Resolver<Maybe<ResolversTypes['Review']>, ParentType, ContextType>;
  reviewStatusHistory?: Resolver<Maybe<ResolversTypes['ReviewStatusHistory']>, ParentType, ContextType>;
  reviewStatusHistoryEdge?: Resolver<Maybe<ResolversTypes['ReviewStatusHistoriesEdge']>, ParentType, ContextType, RequireFields<UpdateReviewStatusHistoryPayloadReviewStatusHistoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateSystemInfoPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateSystemInfoPayload'] = ResolversParentTypes['UpdateSystemInfoPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  systemInfo?: Resolver<Maybe<ResolversTypes['SystemInfo']>, ParentType, ContextType>;
  systemInfoEdge?: Resolver<Maybe<ResolversTypes['SystemInfosEdge']>, ParentType, ContextType, RequireFields<UpdateSystemInfoPayloadSystemInfoEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateActionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateActionPayload'] = ResolversParentTypes['UpdateTemplateActionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateAction?: Resolver<Maybe<ResolversTypes['TemplateAction']>, ParentType, ContextType>;
  templateActionEdge?: Resolver<Maybe<ResolversTypes['TemplateActionsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateActionPayloadTemplateActionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateCategoryPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateCategoryPayload'] = ResolversParentTypes['UpdateTemplateCategoryPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  templateCategory?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType>;
  templateCategoryEdge?: Resolver<Maybe<ResolversTypes['TemplateCategoriesEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateCategoryPayloadTemplateCategoryEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateElementPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateElementPayload'] = ResolversParentTypes['UpdateTemplateElementPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  section?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateElement?: Resolver<Maybe<ResolversTypes['TemplateElement']>, ParentType, ContextType>;
  templateElementEdge?: Resolver<Maybe<ResolversTypes['TemplateElementsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateElementPayloadTemplateElementEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateFilterJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateFilterJoinPayload'] = ResolversParentTypes['UpdateTemplateFilterJoinPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  filter?: Resolver<Maybe<ResolversTypes['Filter']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateFilterJoin?: Resolver<Maybe<ResolversTypes['TemplateFilterJoin']>, ParentType, ContextType>;
  templateFilterJoinEdge?: Resolver<Maybe<ResolversTypes['TemplateFilterJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateFilterJoinPayloadTemplateFilterJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplatePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplatePayload'] = ResolversParentTypes['UpdateTemplatePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateCategory?: Resolver<Maybe<ResolversTypes['TemplateCategory']>, ParentType, ContextType>;
  templateEdge?: Resolver<Maybe<ResolversTypes['TemplatesEdge']>, ParentType, ContextType, RequireFields<UpdateTemplatePayloadTemplateEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplatePermissionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplatePermissionPayload'] = ResolversParentTypes['UpdateTemplatePermissionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionName?: Resolver<Maybe<ResolversTypes['PermissionName']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templatePermission?: Resolver<Maybe<ResolversTypes['TemplatePermission']>, ParentType, ContextType>;
  templatePermissionEdge?: Resolver<Maybe<ResolversTypes['TemplatePermissionsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplatePermissionPayloadTemplatePermissionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateSectionPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateSectionPayload'] = ResolversParentTypes['UpdateTemplateSectionPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateSection?: Resolver<Maybe<ResolversTypes['TemplateSection']>, ParentType, ContextType>;
  templateSectionEdge?: Resolver<Maybe<ResolversTypes['TemplateSectionsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateSectionPayloadTemplateSectionEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateStagePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateStagePayload'] = ResolversParentTypes['UpdateTemplateStagePayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  templateStage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  templateStageEdge?: Resolver<Maybe<ResolversTypes['TemplateStagesEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateStagePayloadTemplateStageEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTemplateStageReviewLevelPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTemplateStageReviewLevelPayload'] = ResolversParentTypes['UpdateTemplateStageReviewLevelPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  stage?: Resolver<Maybe<ResolversTypes['TemplateStage']>, ParentType, ContextType>;
  templateStageReviewLevel?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevel']>, ParentType, ContextType>;
  templateStageReviewLevelEdge?: Resolver<Maybe<ResolversTypes['TemplateStageReviewLevelsEdge']>, ParentType, ContextType, RequireFields<UpdateTemplateStageReviewLevelPayloadTemplateStageReviewLevelEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTriggerQueuePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTriggerQueuePayload'] = ResolversParentTypes['UpdateTriggerQueuePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  triggerQueue?: Resolver<Maybe<ResolversTypes['TriggerQueue']>, ParentType, ContextType>;
  triggerQueueEdge?: Resolver<Maybe<ResolversTypes['TriggerQueuesEdge']>, ParentType, ContextType, RequireFields<UpdateTriggerQueuePayloadTriggerQueueEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateTriggerSchedulePayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateTriggerSchedulePayload'] = ResolversParentTypes['UpdateTriggerSchedulePayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  template?: Resolver<Maybe<ResolversTypes['Template']>, ParentType, ContextType>;
  triggerSchedule?: Resolver<Maybe<ResolversTypes['TriggerSchedule']>, ParentType, ContextType>;
  triggerScheduleEdge?: Resolver<Maybe<ResolversTypes['TriggerSchedulesEdge']>, ParentType, ContextType, RequireFields<UpdateTriggerSchedulePayloadTriggerScheduleEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserApplicationJoinPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateUserApplicationJoinPayload'] = ResolversParentTypes['UpdateUserApplicationJoinPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  userApplicationJoin?: Resolver<Maybe<ResolversTypes['UserApplicationJoin']>, ParentType, ContextType>;
  userApplicationJoinEdge?: Resolver<Maybe<ResolversTypes['UserApplicationJoinsEdge']>, ParentType, ContextType, RequireFields<UpdateUserApplicationJoinPayloadUserApplicationJoinEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateUserOrganisationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateUserOrganisationPayload'] = ResolversParentTypes['UpdateUserOrganisationPayload']> = {
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userOrganisation?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType>;
  userOrganisationEdge?: Resolver<Maybe<ResolversTypes['UserOrganisationsEdge']>, ParentType, ContextType, RequireFields<UpdateUserOrganisationPayloadUserOrganisationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UpdateVerificationPayloadResolvers<ContextType = any, ParentType extends ResolversParentTypes['UpdateVerificationPayload'] = ResolversParentTypes['UpdateVerificationPayload']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  clientMutationId?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  query?: Resolver<Maybe<ResolversTypes['Query']>, ParentType, ContextType>;
  verification?: Resolver<Maybe<ResolversTypes['Verification']>, ParentType, ContextType>;
  verificationEdge?: Resolver<Maybe<ResolversTypes['VerificationsEdge']>, ParentType, ContextType, RequireFields<UpdateVerificationPayloadVerificationEdgeArgs, 'orderBy'>>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserResolvers<ContextType = any, ParentType extends ResolversParentTypes['User'] = ResolversParentTypes['User']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  country?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateOfBirth?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  passwordHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  phone?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userOrganisations?: Resolver<ResolversTypes['UserOrganisationsConnection'], ParentType, ContextType, RequireFields<UserUserOrganisationsArgs, 'orderBy'>>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserApplicationJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserApplicationJoin'] = ResolversParentTypes['UserApplicationJoin']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserApplicationJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserApplicationJoinsConnection'] = ResolversParentTypes['UserApplicationJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserApplicationJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['UserApplicationJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserApplicationJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserApplicationJoinsEdge'] = ResolversParentTypes['UserApplicationJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserApplicationJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserList'] = ResolversParentTypes['UserList']> = {
  applicationNotesByUserId?: Resolver<ResolversTypes['ApplicationNotesConnection'], ParentType, ContextType, RequireFields<UserListApplicationNotesByUserIdArgs, 'orderBy'>>;
  applicationsByUserId?: Resolver<ResolversTypes['ApplicationsConnection'], ParentType, ContextType, RequireFields<UserListApplicationsByUserIdArgs, 'orderBy'>>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  fullName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  permissionJoinsByUserId?: Resolver<ResolversTypes['PermissionJoinsConnection'], ParentType, ContextType, RequireFields<UserListPermissionJoinsByUserIdArgs, 'orderBy'>>;
  reviewAssignmentAssignerJoinsByAssignerId?: Resolver<ResolversTypes['ReviewAssignmentAssignerJoinsConnection'], ParentType, ContextType, RequireFields<UserListReviewAssignmentAssignerJoinsByAssignerIdArgs, 'orderBy'>>;
  reviewAssignmentsByAssignerId?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<UserListReviewAssignmentsByAssignerIdArgs, 'orderBy'>>;
  reviewedReviewAssignments?: Resolver<ResolversTypes['ReviewAssignmentsConnection'], ParentType, ContextType, RequireFields<UserListReviewedReviewAssignmentsArgs, 'orderBy'>>;
  reviewedReviews?: Resolver<ResolversTypes['ReviewsConnection'], ParentType, ContextType, RequireFields<UserListReviewedReviewsArgs, 'orderBy'>>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserListsConnection'] = ResolversParentTypes['UserListsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserListsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['UserList']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserListsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserListsEdge'] = ResolversParentTypes['UserListsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserList']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrgJoinResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrgJoin'] = ResolversParentTypes['UserOrgJoin']> = {
  address?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  dateOfBirth?: Resolver<Maybe<ResolversTypes['Date']>, ParentType, ContextType>;
  email?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  firstName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  isSystemOrg?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  lastName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  logoUrl?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  orgId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  orgName?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  passwordHash?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  registration?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  userId?: Resolver<Maybe<ResolversTypes['Int']>, ParentType, ContextType>;
  userRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  username?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrgJoinsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrgJoinsConnection'] = ResolversParentTypes['UserOrgJoinsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserOrgJoinsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['UserOrgJoin']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrgJoinsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrgJoinsEdge'] = ResolversParentTypes['UserOrgJoinsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserOrgJoin']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrganisationResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrganisation'] = ResolversParentTypes['UserOrganisation']> = {
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  organisation?: Resolver<Maybe<ResolversTypes['Organisation']>, ParentType, ContextType>;
  organisationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  user?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  userId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  userRole?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrganisationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrganisationsConnection'] = ResolversParentTypes['UserOrganisationsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UserOrganisationsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['UserOrganisation']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UserOrganisationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UserOrganisationsEdge'] = ResolversParentTypes['UserOrganisationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['UserOrganisation']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UsersConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsersConnection'] = ResolversParentTypes['UsersConnection']> = {
  edges?: Resolver<Array<ResolversTypes['UsersEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['User']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type UsersEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['UsersEdge'] = ResolversParentTypes['UsersEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['User']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VerificationResolvers<ContextType = any, ParentType extends ResolversParentTypes['Verification'] = ResolversParentTypes['Verification']> = {
  application?: Resolver<Maybe<ResolversTypes['Application']>, ParentType, ContextType>;
  applicationId?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  data?: Resolver<Maybe<ResolversTypes['JSON']>, ParentType, ContextType>;
  eventCode?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  id?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  isVerified?: Resolver<Maybe<ResolversTypes['Boolean']>, ParentType, ContextType>;
  message?: Resolver<Maybe<ResolversTypes['String']>, ParentType, ContextType>;
  nodeId?: Resolver<ResolversTypes['ID'], ParentType, ContextType>;
  timeCreated?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  timeExpired?: Resolver<Maybe<ResolversTypes['Datetime']>, ParentType, ContextType>;
  trigger?: Resolver<Maybe<ResolversTypes['Trigger']>, ParentType, ContextType>;
  uniqueId?: Resolver<ResolversTypes['String'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VerificationsConnectionResolvers<ContextType = any, ParentType extends ResolversParentTypes['VerificationsConnection'] = ResolversParentTypes['VerificationsConnection']> = {
  edges?: Resolver<Array<ResolversTypes['VerificationsEdge']>, ParentType, ContextType>;
  nodes?: Resolver<Array<Maybe<ResolversTypes['Verification']>>, ParentType, ContextType>;
  pageInfo?: Resolver<ResolversTypes['PageInfo'], ParentType, ContextType>;
  totalCount?: Resolver<ResolversTypes['Int'], ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export type VerificationsEdgeResolvers<ContextType = any, ParentType extends ResolversParentTypes['VerificationsEdge'] = ResolversParentTypes['VerificationsEdge']> = {
  cursor?: Resolver<Maybe<ResolversTypes['Cursor']>, ParentType, ContextType>;
  node?: Resolver<Maybe<ResolversTypes['Verification']>, ParentType, ContextType>;
  __isTypeOf?: IsTypeOfResolverFn<ParentType, ContextType>;
};

export interface YesOrNoScalarConfig extends GraphQLScalarTypeConfig<ResolversTypes['YesOrNo'], any> {
  name: 'YesOrNo';
}

export type Resolvers<ContextType = any> = {
  ActionPlugin?: ActionPluginResolvers<ContextType>;
  ActionPluginsConnection?: ActionPluginsConnectionResolvers<ContextType>;
  ActionPluginsEdge?: ActionPluginsEdgeResolvers<ContextType>;
  ActionQueue?: ActionQueueResolvers<ContextType>;
  ActionQueuesConnection?: ActionQueuesConnectionResolvers<ContextType>;
  ActionQueuesEdge?: ActionQueuesEdgeResolvers<ContextType>;
  ActivityLog?: ActivityLogResolvers<ContextType>;
  ActivityLogsConnection?: ActivityLogsConnectionResolvers<ContextType>;
  ActivityLogsEdge?: ActivityLogsEdgeResolvers<ContextType>;
  AllowedSelfAssignableSectionsShape?: AllowedSelfAssignableSectionsShapeResolvers<ContextType>;
  AllowedSelfAssignableSectionsShapesConnection?: AllowedSelfAssignableSectionsShapesConnectionResolvers<ContextType>;
  AllowedSelfAssignableSectionsShapesEdge?: AllowedSelfAssignableSectionsShapesEdgeResolvers<ContextType>;
  Application?: ApplicationResolvers<ContextType>;
  ApplicationListFilterApplicantConnection?: ApplicationListFilterApplicantConnectionResolvers<ContextType>;
  ApplicationListFilterApplicantEdge?: ApplicationListFilterApplicantEdgeResolvers<ContextType>;
  ApplicationListFilterAssignerConnection?: ApplicationListFilterAssignerConnectionResolvers<ContextType>;
  ApplicationListFilterAssignerEdge?: ApplicationListFilterAssignerEdgeResolvers<ContextType>;
  ApplicationListFilterOrganisationConnection?: ApplicationListFilterOrganisationConnectionResolvers<ContextType>;
  ApplicationListFilterOrganisationEdge?: ApplicationListFilterOrganisationEdgeResolvers<ContextType>;
  ApplicationListFilterReviewerConnection?: ApplicationListFilterReviewerConnectionResolvers<ContextType>;
  ApplicationListFilterReviewerEdge?: ApplicationListFilterReviewerEdgeResolvers<ContextType>;
  ApplicationListFilterStageConnection?: ApplicationListFilterStageConnectionResolvers<ContextType>;
  ApplicationListFilterStageEdge?: ApplicationListFilterStageEdgeResolvers<ContextType>;
  ApplicationListShape?: ApplicationListShapeResolvers<ContextType>;
  ApplicationListShapesConnection?: ApplicationListShapesConnectionResolvers<ContextType>;
  ApplicationListShapesEdge?: ApplicationListShapesEdgeResolvers<ContextType>;
  ApplicationNote?: ApplicationNoteResolvers<ContextType>;
  ApplicationNotesConnection?: ApplicationNotesConnectionResolvers<ContextType>;
  ApplicationNotesEdge?: ApplicationNotesEdgeResolvers<ContextType>;
  ApplicationResponse?: ApplicationResponseResolvers<ContextType>;
  ApplicationResponsesConnection?: ApplicationResponsesConnectionResolvers<ContextType>;
  ApplicationResponsesEdge?: ApplicationResponsesEdgeResolvers<ContextType>;
  ApplicationReviewerAction?: ApplicationReviewerActionResolvers<ContextType>;
  ApplicationReviewerActionsConnection?: ApplicationReviewerActionsConnectionResolvers<ContextType>;
  ApplicationReviewerActionsEdge?: ApplicationReviewerActionsEdgeResolvers<ContextType>;
  ApplicationStageHistoriesConnection?: ApplicationStageHistoriesConnectionResolvers<ContextType>;
  ApplicationStageHistoriesEdge?: ApplicationStageHistoriesEdgeResolvers<ContextType>;
  ApplicationStageHistory?: ApplicationStageHistoryResolvers<ContextType>;
  ApplicationStageStatusAll?: ApplicationStageStatusAllResolvers<ContextType>;
  ApplicationStageStatusAllsConnection?: ApplicationStageStatusAllsConnectionResolvers<ContextType>;
  ApplicationStageStatusAllsEdge?: ApplicationStageStatusAllsEdgeResolvers<ContextType>;
  ApplicationStageStatusLatest?: ApplicationStageStatusLatestResolvers<ContextType>;
  ApplicationStageStatusLatestsConnection?: ApplicationStageStatusLatestsConnectionResolvers<ContextType>;
  ApplicationStageStatusLatestsEdge?: ApplicationStageStatusLatestsEdgeResolvers<ContextType>;
  ApplicationStatusHistoriesConnection?: ApplicationStatusHistoriesConnectionResolvers<ContextType>;
  ApplicationStatusHistoriesEdge?: ApplicationStatusHistoriesEdgeResolvers<ContextType>;
  ApplicationStatusHistory?: ApplicationStatusHistoryResolvers<ContextType>;
  ApplicationsConnection?: ApplicationsConnectionResolvers<ContextType>;
  ApplicationsEdge?: ApplicationsEdgeResolvers<ContextType>;
  AssignedQuestionEdge?: AssignedQuestionEdgeResolvers<ContextType>;
  AssignedQuestionsConnection?: AssignedQuestionsConnectionResolvers<ContextType>;
  AssignedQuestionsRecord?: AssignedQuestionsRecordResolvers<ContextType>;
  AssignedSectionsByStageAndLevel?: AssignedSectionsByStageAndLevelResolvers<ContextType>;
  AssignedSectionsByStageAndLevelsConnection?: AssignedSectionsByStageAndLevelsConnectionResolvers<ContextType>;
  AssignedSectionsByStageAndLevelsEdge?: AssignedSectionsByStageAndLevelsEdgeResolvers<ContextType>;
  AssignerListConnection?: AssignerListConnectionResolvers<ContextType>;
  AssignerListEdge?: AssignerListEdgeResolvers<ContextType>;
  AssignerListRecord?: AssignerListRecordResolvers<ContextType>;
  AssignmentListConnection?: AssignmentListConnectionResolvers<ContextType>;
  AssignmentListEdge?: AssignmentListEdgeResolvers<ContextType>;
  AssignmentListRecord?: AssignmentListRecordResolvers<ContextType>;
  BigInt?: GraphQLScalarType;
  CharacterData?: GraphQLScalarType;
  ConstraintsInfo?: ConstraintsInfoResolvers<ContextType>;
  ConstraintsInfosConnection?: ConstraintsInfosConnectionResolvers<ContextType>;
  ConstraintsInfosEdge?: ConstraintsInfosEdgeResolvers<ContextType>;
  Counter?: CounterResolvers<ContextType>;
  CountersConnection?: CountersConnectionResolvers<ContextType>;
  CountersEdge?: CountersEdgeResolvers<ContextType>;
  CreateActionPluginPayload?: CreateActionPluginPayloadResolvers<ContextType>;
  CreateActionQueuePayload?: CreateActionQueuePayloadResolvers<ContextType>;
  CreateActivityLogPayload?: CreateActivityLogPayloadResolvers<ContextType>;
  CreateAllowedSelfAssignableSectionsShapePayload?: CreateAllowedSelfAssignableSectionsShapePayloadResolvers<ContextType>;
  CreateApplicationListShapePayload?: CreateApplicationListShapePayloadResolvers<ContextType>;
  CreateApplicationNotePayload?: CreateApplicationNotePayloadResolvers<ContextType>;
  CreateApplicationPayload?: CreateApplicationPayloadResolvers<ContextType>;
  CreateApplicationResponsePayload?: CreateApplicationResponsePayloadResolvers<ContextType>;
  CreateApplicationReviewerActionPayload?: CreateApplicationReviewerActionPayloadResolvers<ContextType>;
  CreateApplicationStageHistoryPayload?: CreateApplicationStageHistoryPayloadResolvers<ContextType>;
  CreateApplicationStatusHistoryPayload?: CreateApplicationStatusHistoryPayloadResolvers<ContextType>;
  CreateCounterPayload?: CreateCounterPayloadResolvers<ContextType>;
  CreateDataChangelogPayload?: CreateDataChangelogPayloadResolvers<ContextType>;
  CreateDataTableActiveIngredientPayload?: CreateDataTableActiveIngredientPayloadResolvers<ContextType>;
  CreateDataTableAdministrationRoutePayload?: CreateDataTableAdministrationRoutePayloadResolvers<ContextType>;
  CreateDataTableAtcCodePayload?: CreateDataTableAtcCodePayloadResolvers<ContextType>;
  CreateDataTableContainerPayload?: CreateDataTableContainerPayloadResolvers<ContextType>;
  CreateDataTableCountryPayload?: CreateDataTableCountryPayloadResolvers<ContextType>;
  CreateDataTableDosageFormGroupPayload?: CreateDataTableDosageFormGroupPayloadResolvers<ContextType>;
  CreateDataTableDosageFormPayload?: CreateDataTableDosageFormPayloadResolvers<ContextType>;
  CreateDataTableGenericIngredientPayload?: CreateDataTableGenericIngredientPayloadResolvers<ContextType>;
  CreateDataTableManufacturerApplicationJoinPayload?: CreateDataTableManufacturerApplicationJoinPayloadResolvers<ContextType>;
  CreateDataTableManufacturerPayload?: CreateDataTableManufacturerPayloadResolvers<ContextType>;
  CreateDataTableManufacturerRepresentativeApplicationJoinPayload?: CreateDataTableManufacturerRepresentativeApplicationJoinPayloadResolvers<ContextType>;
  CreateDataTableManufacturerRepresentativePayload?: CreateDataTableManufacturerRepresentativePayloadResolvers<ContextType>;
  CreateDataTablePayload?: CreateDataTablePayloadResolvers<ContextType>;
  CreateDataTablePermitChemicalApplicationJoinPayload?: CreateDataTablePermitChemicalApplicationJoinPayloadResolvers<ContextType>;
  CreateDataTablePermitChemicalPayload?: CreateDataTablePermitChemicalPayloadResolvers<ContextType>;
  CreateDataTablePreRegisteredProductsProvisionalPayload?: CreateDataTablePreRegisteredProductsProvisionalPayloadResolvers<ContextType>;
  CreateDataTablePrequalManufacturerApplicationJoinPayload?: CreateDataTablePrequalManufacturerApplicationJoinPayloadResolvers<ContextType>;
  CreateDataTablePrequalManufacturerPayload?: CreateDataTablePrequalManufacturerPayloadResolvers<ContextType>;
  CreateDataTableProcessingStepPayload?: CreateDataTableProcessingStepPayloadResolvers<ContextType>;
  CreateDataTableProductApplicationJoinPayload?: CreateDataTableProductApplicationJoinPayloadResolvers<ContextType>;
  CreateDataTableProductPayload?: CreateDataTableProductPayloadResolvers<ContextType>;
  CreateDataTableProvisionalProductApplicationJoinPayload?: CreateDataTableProvisionalProductApplicationJoinPayloadResolvers<ContextType>;
  CreateDataTableProvisionalProductPayload?: CreateDataTableProvisionalProductPayloadResolvers<ContextType>;
  CreateDataTableScheduledChemicalPayload?: CreateDataTableScheduledChemicalPayloadResolvers<ContextType>;
  CreateDataTableStorageConditionPayload?: CreateDataTableStorageConditionPayloadResolvers<ContextType>;
  CreateDataTableStorageConditionsSimplifiedPayload?: CreateDataTableStorageConditionsSimplifiedPayloadResolvers<ContextType>;
  CreateDataTableUnitsOfProportionPayload?: CreateDataTableUnitsOfProportionPayloadResolvers<ContextType>;
  CreateDataTableWorldHealthOrganisationPqListOfFppPayload?: CreateDataTableWorldHealthOrganisationPqListOfFppPayloadResolvers<ContextType>;
  CreateDataViewColumnDefinitionPayload?: CreateDataViewColumnDefinitionPayloadResolvers<ContextType>;
  CreateDataViewPayload?: CreateDataViewPayloadResolvers<ContextType>;
  CreateElementTypePluginPayload?: CreateElementTypePluginPayloadResolvers<ContextType>;
  CreateFilePayload?: CreateFilePayloadResolvers<ContextType>;
  CreateFilterPayload?: CreateFilterPayloadResolvers<ContextType>;
  CreateGrafanaDashboardImagePayload?: CreateGrafanaDashboardImagePayloadResolvers<ContextType>;
  CreateNotificationPayload?: CreateNotificationPayloadResolvers<ContextType>;
  CreateOrganisationApplicationJoinPayload?: CreateOrganisationApplicationJoinPayloadResolvers<ContextType>;
  CreateOrganisationPayload?: CreateOrganisationPayloadResolvers<ContextType>;
  CreatePermissionJoinPayload?: CreatePermissionJoinPayloadResolvers<ContextType>;
  CreatePermissionNamePayload?: CreatePermissionNamePayloadResolvers<ContextType>;
  CreatePermissionPolicyPayload?: CreatePermissionPolicyPayloadResolvers<ContextType>;
  CreateReviewAssignmentAssignedSectionsShapePayload?: CreateReviewAssignmentAssignedSectionsShapePayloadResolvers<ContextType>;
  CreateReviewAssignmentAssignerJoinPayload?: CreateReviewAssignmentAssignerJoinPayloadResolvers<ContextType>;
  CreateReviewAssignmentPayload?: CreateReviewAssignmentPayloadResolvers<ContextType>;
  CreateReviewDecisionPayload?: CreateReviewDecisionPayloadResolvers<ContextType>;
  CreateReviewPayload?: CreateReviewPayloadResolvers<ContextType>;
  CreateReviewResponsePayload?: CreateReviewResponsePayloadResolvers<ContextType>;
  CreateReviewStatusHistoryPayload?: CreateReviewStatusHistoryPayloadResolvers<ContextType>;
  CreateSystemInfoPayload?: CreateSystemInfoPayloadResolvers<ContextType>;
  CreateTemplateActionPayload?: CreateTemplateActionPayloadResolvers<ContextType>;
  CreateTemplateCategoryPayload?: CreateTemplateCategoryPayloadResolvers<ContextType>;
  CreateTemplateElementPayload?: CreateTemplateElementPayloadResolvers<ContextType>;
  CreateTemplateFilterJoinPayload?: CreateTemplateFilterJoinPayloadResolvers<ContextType>;
  CreateTemplatePayload?: CreateTemplatePayloadResolvers<ContextType>;
  CreateTemplatePermissionPayload?: CreateTemplatePermissionPayloadResolvers<ContextType>;
  CreateTemplateSectionPayload?: CreateTemplateSectionPayloadResolvers<ContextType>;
  CreateTemplateStagePayload?: CreateTemplateStagePayloadResolvers<ContextType>;
  CreateTemplateStageReviewLevelPayload?: CreateTemplateStageReviewLevelPayloadResolvers<ContextType>;
  CreateTriggerQueuePayload?: CreateTriggerQueuePayloadResolvers<ContextType>;
  CreateTriggerSchedulePayload?: CreateTriggerSchedulePayloadResolvers<ContextType>;
  CreateUserApplicationJoinPayload?: CreateUserApplicationJoinPayloadResolvers<ContextType>;
  CreateUserListPayload?: CreateUserListPayloadResolvers<ContextType>;
  CreateUserOrganisationPayload?: CreateUserOrganisationPayloadResolvers<ContextType>;
  CreateUserPayload?: CreateUserPayloadResolvers<ContextType>;
  CreateVerificationPayload?: CreateVerificationPayloadResolvers<ContextType>;
  Cursor?: GraphQLScalarType;
  DataChangelog?: DataChangelogResolvers<ContextType>;
  DataChangelogsConnection?: DataChangelogsConnectionResolvers<ContextType>;
  DataChangelogsEdge?: DataChangelogsEdgeResolvers<ContextType>;
  DataTable?: DataTableResolvers<ContextType>;
  DataTableActiveIngredient?: DataTableActiveIngredientResolvers<ContextType>;
  DataTableActiveIngredientsConnection?: DataTableActiveIngredientsConnectionResolvers<ContextType>;
  DataTableActiveIngredientsEdge?: DataTableActiveIngredientsEdgeResolvers<ContextType>;
  DataTableAdministrationRoute?: DataTableAdministrationRouteResolvers<ContextType>;
  DataTableAdministrationRoutesConnection?: DataTableAdministrationRoutesConnectionResolvers<ContextType>;
  DataTableAdministrationRoutesEdge?: DataTableAdministrationRoutesEdgeResolvers<ContextType>;
  DataTableAtcCode?: DataTableAtcCodeResolvers<ContextType>;
  DataTableAtcCodesConnection?: DataTableAtcCodesConnectionResolvers<ContextType>;
  DataTableAtcCodesEdge?: DataTableAtcCodesEdgeResolvers<ContextType>;
  DataTableContainer?: DataTableContainerResolvers<ContextType>;
  DataTableContainersConnection?: DataTableContainersConnectionResolvers<ContextType>;
  DataTableContainersEdge?: DataTableContainersEdgeResolvers<ContextType>;
  DataTableCountriesConnection?: DataTableCountriesConnectionResolvers<ContextType>;
  DataTableCountriesEdge?: DataTableCountriesEdgeResolvers<ContextType>;
  DataTableCountry?: DataTableCountryResolvers<ContextType>;
  DataTableDosageForm?: DataTableDosageFormResolvers<ContextType>;
  DataTableDosageFormGroup?: DataTableDosageFormGroupResolvers<ContextType>;
  DataTableDosageFormGroupsConnection?: DataTableDosageFormGroupsConnectionResolvers<ContextType>;
  DataTableDosageFormGroupsEdge?: DataTableDosageFormGroupsEdgeResolvers<ContextType>;
  DataTableDosageFormsConnection?: DataTableDosageFormsConnectionResolvers<ContextType>;
  DataTableDosageFormsEdge?: DataTableDosageFormsEdgeResolvers<ContextType>;
  DataTableGenericIngredient?: DataTableGenericIngredientResolvers<ContextType>;
  DataTableGenericIngredientsConnection?: DataTableGenericIngredientsConnectionResolvers<ContextType>;
  DataTableGenericIngredientsEdge?: DataTableGenericIngredientsEdgeResolvers<ContextType>;
  DataTableManufacturer?: DataTableManufacturerResolvers<ContextType>;
  DataTableManufacturerApplicationJoin?: DataTableManufacturerApplicationJoinResolvers<ContextType>;
  DataTableManufacturerApplicationJoinsConnection?: DataTableManufacturerApplicationJoinsConnectionResolvers<ContextType>;
  DataTableManufacturerApplicationJoinsEdge?: DataTableManufacturerApplicationJoinsEdgeResolvers<ContextType>;
  DataTableManufacturerRepresentative?: DataTableManufacturerRepresentativeResolvers<ContextType>;
  DataTableManufacturerRepresentativeApplicationJoin?: DataTableManufacturerRepresentativeApplicationJoinResolvers<ContextType>;
  DataTableManufacturerRepresentativeApplicationJoinsConnection?: DataTableManufacturerRepresentativeApplicationJoinsConnectionResolvers<ContextType>;
  DataTableManufacturerRepresentativeApplicationJoinsEdge?: DataTableManufacturerRepresentativeApplicationJoinsEdgeResolvers<ContextType>;
  DataTableManufacturerRepresentativesConnection?: DataTableManufacturerRepresentativesConnectionResolvers<ContextType>;
  DataTableManufacturerRepresentativesEdge?: DataTableManufacturerRepresentativesEdgeResolvers<ContextType>;
  DataTableManufacturersConnection?: DataTableManufacturersConnectionResolvers<ContextType>;
  DataTableManufacturersEdge?: DataTableManufacturersEdgeResolvers<ContextType>;
  DataTablePermitChemical?: DataTablePermitChemicalResolvers<ContextType>;
  DataTablePermitChemicalApplicationJoin?: DataTablePermitChemicalApplicationJoinResolvers<ContextType>;
  DataTablePermitChemicalApplicationJoinsConnection?: DataTablePermitChemicalApplicationJoinsConnectionResolvers<ContextType>;
  DataTablePermitChemicalApplicationJoinsEdge?: DataTablePermitChemicalApplicationJoinsEdgeResolvers<ContextType>;
  DataTablePermitChemicalsConnection?: DataTablePermitChemicalsConnectionResolvers<ContextType>;
  DataTablePermitChemicalsEdge?: DataTablePermitChemicalsEdgeResolvers<ContextType>;
  DataTablePreRegisteredProductsProvisional?: DataTablePreRegisteredProductsProvisionalResolvers<ContextType>;
  DataTablePreRegisteredProductsProvisionalsConnection?: DataTablePreRegisteredProductsProvisionalsConnectionResolvers<ContextType>;
  DataTablePreRegisteredProductsProvisionalsEdge?: DataTablePreRegisteredProductsProvisionalsEdgeResolvers<ContextType>;
  DataTablePrequalManufacturer?: DataTablePrequalManufacturerResolvers<ContextType>;
  DataTablePrequalManufacturerApplicationJoin?: DataTablePrequalManufacturerApplicationJoinResolvers<ContextType>;
  DataTablePrequalManufacturerApplicationJoinsConnection?: DataTablePrequalManufacturerApplicationJoinsConnectionResolvers<ContextType>;
  DataTablePrequalManufacturerApplicationJoinsEdge?: DataTablePrequalManufacturerApplicationJoinsEdgeResolvers<ContextType>;
  DataTablePrequalManufacturersConnection?: DataTablePrequalManufacturersConnectionResolvers<ContextType>;
  DataTablePrequalManufacturersEdge?: DataTablePrequalManufacturersEdgeResolvers<ContextType>;
  DataTableProcessingStep?: DataTableProcessingStepResolvers<ContextType>;
  DataTableProcessingStepsConnection?: DataTableProcessingStepsConnectionResolvers<ContextType>;
  DataTableProcessingStepsEdge?: DataTableProcessingStepsEdgeResolvers<ContextType>;
  DataTableProduct?: DataTableProductResolvers<ContextType>;
  DataTableProductApplicationJoin?: DataTableProductApplicationJoinResolvers<ContextType>;
  DataTableProductApplicationJoinsConnection?: DataTableProductApplicationJoinsConnectionResolvers<ContextType>;
  DataTableProductApplicationJoinsEdge?: DataTableProductApplicationJoinsEdgeResolvers<ContextType>;
  DataTableProductsConnection?: DataTableProductsConnectionResolvers<ContextType>;
  DataTableProductsEdge?: DataTableProductsEdgeResolvers<ContextType>;
  DataTableProvisionalProduct?: DataTableProvisionalProductResolvers<ContextType>;
  DataTableProvisionalProductApplicationJoin?: DataTableProvisionalProductApplicationJoinResolvers<ContextType>;
  DataTableProvisionalProductApplicationJoinsConnection?: DataTableProvisionalProductApplicationJoinsConnectionResolvers<ContextType>;
  DataTableProvisionalProductApplicationJoinsEdge?: DataTableProvisionalProductApplicationJoinsEdgeResolvers<ContextType>;
  DataTableProvisionalProductsConnection?: DataTableProvisionalProductsConnectionResolvers<ContextType>;
  DataTableProvisionalProductsEdge?: DataTableProvisionalProductsEdgeResolvers<ContextType>;
  DataTableScheduledChemical?: DataTableScheduledChemicalResolvers<ContextType>;
  DataTableScheduledChemicalsConnection?: DataTableScheduledChemicalsConnectionResolvers<ContextType>;
  DataTableScheduledChemicalsEdge?: DataTableScheduledChemicalsEdgeResolvers<ContextType>;
  DataTableStorageCondition?: DataTableStorageConditionResolvers<ContextType>;
  DataTableStorageConditionsConnection?: DataTableStorageConditionsConnectionResolvers<ContextType>;
  DataTableStorageConditionsEdge?: DataTableStorageConditionsEdgeResolvers<ContextType>;
  DataTableStorageConditionsSimplified?: DataTableStorageConditionsSimplifiedResolvers<ContextType>;
  DataTableStorageConditionsSimplifiedsConnection?: DataTableStorageConditionsSimplifiedsConnectionResolvers<ContextType>;
  DataTableStorageConditionsSimplifiedsEdge?: DataTableStorageConditionsSimplifiedsEdgeResolvers<ContextType>;
  DataTableUnitsOfProportion?: DataTableUnitsOfProportionResolvers<ContextType>;
  DataTableUnitsOfProportionsConnection?: DataTableUnitsOfProportionsConnectionResolvers<ContextType>;
  DataTableUnitsOfProportionsEdge?: DataTableUnitsOfProportionsEdgeResolvers<ContextType>;
  DataTableWorldHealthOrganisationPqListOfFpp?: DataTableWorldHealthOrganisationPqListOfFppResolvers<ContextType>;
  DataTableWorldHealthOrganisationPqListOfFppsConnection?: DataTableWorldHealthOrganisationPqListOfFppsConnectionResolvers<ContextType>;
  DataTableWorldHealthOrganisationPqListOfFppsEdge?: DataTableWorldHealthOrganisationPqListOfFppsEdgeResolvers<ContextType>;
  DataTablesConnection?: DataTablesConnectionResolvers<ContextType>;
  DataTablesEdge?: DataTablesEdgeResolvers<ContextType>;
  DataView?: DataViewResolvers<ContextType>;
  DataViewColumnDefinition?: DataViewColumnDefinitionResolvers<ContextType>;
  DataViewColumnDefinitionsConnection?: DataViewColumnDefinitionsConnectionResolvers<ContextType>;
  DataViewColumnDefinitionsEdge?: DataViewColumnDefinitionsEdgeResolvers<ContextType>;
  DataViewsConnection?: DataViewsConnectionResolvers<ContextType>;
  DataViewsEdge?: DataViewsEdgeResolvers<ContextType>;
  Date?: GraphQLScalarType;
  Datetime?: GraphQLScalarType;
  DeleteActionPluginPayload?: DeleteActionPluginPayloadResolvers<ContextType>;
  DeleteActionQueuePayload?: DeleteActionQueuePayloadResolvers<ContextType>;
  DeleteActivityLogPayload?: DeleteActivityLogPayloadResolvers<ContextType>;
  DeleteApplicationNotePayload?: DeleteApplicationNotePayloadResolvers<ContextType>;
  DeleteApplicationPayload?: DeleteApplicationPayloadResolvers<ContextType>;
  DeleteApplicationResponsePayload?: DeleteApplicationResponsePayloadResolvers<ContextType>;
  DeleteApplicationReviewerActionPayload?: DeleteApplicationReviewerActionPayloadResolvers<ContextType>;
  DeleteApplicationStageHistoryPayload?: DeleteApplicationStageHistoryPayloadResolvers<ContextType>;
  DeleteApplicationStatusHistoryPayload?: DeleteApplicationStatusHistoryPayloadResolvers<ContextType>;
  DeleteCounterPayload?: DeleteCounterPayloadResolvers<ContextType>;
  DeleteDataChangelogPayload?: DeleteDataChangelogPayloadResolvers<ContextType>;
  DeleteDataTableActiveIngredientPayload?: DeleteDataTableActiveIngredientPayloadResolvers<ContextType>;
  DeleteDataTableAdministrationRoutePayload?: DeleteDataTableAdministrationRoutePayloadResolvers<ContextType>;
  DeleteDataTableAtcCodePayload?: DeleteDataTableAtcCodePayloadResolvers<ContextType>;
  DeleteDataTableContainerPayload?: DeleteDataTableContainerPayloadResolvers<ContextType>;
  DeleteDataTableCountryPayload?: DeleteDataTableCountryPayloadResolvers<ContextType>;
  DeleteDataTableDosageFormGroupPayload?: DeleteDataTableDosageFormGroupPayloadResolvers<ContextType>;
  DeleteDataTableDosageFormPayload?: DeleteDataTableDosageFormPayloadResolvers<ContextType>;
  DeleteDataTableGenericIngredientPayload?: DeleteDataTableGenericIngredientPayloadResolvers<ContextType>;
  DeleteDataTableManufacturerApplicationJoinPayload?: DeleteDataTableManufacturerApplicationJoinPayloadResolvers<ContextType>;
  DeleteDataTableManufacturerPayload?: DeleteDataTableManufacturerPayloadResolvers<ContextType>;
  DeleteDataTableManufacturerRepresentativeApplicationJoinPayload?: DeleteDataTableManufacturerRepresentativeApplicationJoinPayloadResolvers<ContextType>;
  DeleteDataTableManufacturerRepresentativePayload?: DeleteDataTableManufacturerRepresentativePayloadResolvers<ContextType>;
  DeleteDataTablePayload?: DeleteDataTablePayloadResolvers<ContextType>;
  DeleteDataTablePermitChemicalApplicationJoinPayload?: DeleteDataTablePermitChemicalApplicationJoinPayloadResolvers<ContextType>;
  DeleteDataTablePermitChemicalPayload?: DeleteDataTablePermitChemicalPayloadResolvers<ContextType>;
  DeleteDataTablePreRegisteredProductsProvisionalPayload?: DeleteDataTablePreRegisteredProductsProvisionalPayloadResolvers<ContextType>;
  DeleteDataTablePrequalManufacturerApplicationJoinPayload?: DeleteDataTablePrequalManufacturerApplicationJoinPayloadResolvers<ContextType>;
  DeleteDataTablePrequalManufacturerPayload?: DeleteDataTablePrequalManufacturerPayloadResolvers<ContextType>;
  DeleteDataTableProcessingStepPayload?: DeleteDataTableProcessingStepPayloadResolvers<ContextType>;
  DeleteDataTableProductApplicationJoinPayload?: DeleteDataTableProductApplicationJoinPayloadResolvers<ContextType>;
  DeleteDataTableProductPayload?: DeleteDataTableProductPayloadResolvers<ContextType>;
  DeleteDataTableProvisionalProductApplicationJoinPayload?: DeleteDataTableProvisionalProductApplicationJoinPayloadResolvers<ContextType>;
  DeleteDataTableProvisionalProductPayload?: DeleteDataTableProvisionalProductPayloadResolvers<ContextType>;
  DeleteDataTableScheduledChemicalPayload?: DeleteDataTableScheduledChemicalPayloadResolvers<ContextType>;
  DeleteDataTableStorageConditionPayload?: DeleteDataTableStorageConditionPayloadResolvers<ContextType>;
  DeleteDataTableStorageConditionsSimplifiedPayload?: DeleteDataTableStorageConditionsSimplifiedPayloadResolvers<ContextType>;
  DeleteDataTableUnitsOfProportionPayload?: DeleteDataTableUnitsOfProportionPayloadResolvers<ContextType>;
  DeleteDataTableWorldHealthOrganisationPqListOfFppPayload?: DeleteDataTableWorldHealthOrganisationPqListOfFppPayloadResolvers<ContextType>;
  DeleteDataViewColumnDefinitionPayload?: DeleteDataViewColumnDefinitionPayloadResolvers<ContextType>;
  DeleteDataViewPayload?: DeleteDataViewPayloadResolvers<ContextType>;
  DeleteElementTypePluginPayload?: DeleteElementTypePluginPayloadResolvers<ContextType>;
  DeleteFilePayload?: DeleteFilePayloadResolvers<ContextType>;
  DeleteFilterPayload?: DeleteFilterPayloadResolvers<ContextType>;
  DeleteGrafanaDashboardImagePayload?: DeleteGrafanaDashboardImagePayloadResolvers<ContextType>;
  DeleteNotificationPayload?: DeleteNotificationPayloadResolvers<ContextType>;
  DeleteOrganisationApplicationJoinPayload?: DeleteOrganisationApplicationJoinPayloadResolvers<ContextType>;
  DeleteOrganisationPayload?: DeleteOrganisationPayloadResolvers<ContextType>;
  DeletePermissionJoinPayload?: DeletePermissionJoinPayloadResolvers<ContextType>;
  DeletePermissionNamePayload?: DeletePermissionNamePayloadResolvers<ContextType>;
  DeletePermissionPolicyPayload?: DeletePermissionPolicyPayloadResolvers<ContextType>;
  DeleteReviewAssignmentAssignerJoinPayload?: DeleteReviewAssignmentAssignerJoinPayloadResolvers<ContextType>;
  DeleteReviewAssignmentPayload?: DeleteReviewAssignmentPayloadResolvers<ContextType>;
  DeleteReviewDecisionPayload?: DeleteReviewDecisionPayloadResolvers<ContextType>;
  DeleteReviewPayload?: DeleteReviewPayloadResolvers<ContextType>;
  DeleteReviewResponsePayload?: DeleteReviewResponsePayloadResolvers<ContextType>;
  DeleteReviewStatusHistoryPayload?: DeleteReviewStatusHistoryPayloadResolvers<ContextType>;
  DeleteSystemInfoPayload?: DeleteSystemInfoPayloadResolvers<ContextType>;
  DeleteTemplateActionPayload?: DeleteTemplateActionPayloadResolvers<ContextType>;
  DeleteTemplateCategoryPayload?: DeleteTemplateCategoryPayloadResolvers<ContextType>;
  DeleteTemplateElementPayload?: DeleteTemplateElementPayloadResolvers<ContextType>;
  DeleteTemplateFilterJoinPayload?: DeleteTemplateFilterJoinPayloadResolvers<ContextType>;
  DeleteTemplatePayload?: DeleteTemplatePayloadResolvers<ContextType>;
  DeleteTemplatePermissionPayload?: DeleteTemplatePermissionPayloadResolvers<ContextType>;
  DeleteTemplateSectionPayload?: DeleteTemplateSectionPayloadResolvers<ContextType>;
  DeleteTemplateStagePayload?: DeleteTemplateStagePayloadResolvers<ContextType>;
  DeleteTemplateStageReviewLevelPayload?: DeleteTemplateStageReviewLevelPayloadResolvers<ContextType>;
  DeleteTriggerQueuePayload?: DeleteTriggerQueuePayloadResolvers<ContextType>;
  DeleteTriggerSchedulePayload?: DeleteTriggerSchedulePayloadResolvers<ContextType>;
  DeleteUserApplicationJoinPayload?: DeleteUserApplicationJoinPayloadResolvers<ContextType>;
  DeleteUserOrganisationPayload?: DeleteUserOrganisationPayloadResolvers<ContextType>;
  DeleteVerificationPayload?: DeleteVerificationPayloadResolvers<ContextType>;
  DeleteWholeApplicationPayload?: DeleteWholeApplicationPayloadResolvers<ContextType>;
  ElementTypePlugin?: ElementTypePluginResolvers<ContextType>;
  ElementTypePluginsConnection?: ElementTypePluginsConnectionResolvers<ContextType>;
  ElementTypePluginsEdge?: ElementTypePluginsEdgeResolvers<ContextType>;
  File?: FileResolvers<ContextType>;
  FilesConnection?: FilesConnectionResolvers<ContextType>;
  FilesEdge?: FilesEdgeResolvers<ContextType>;
  Filter?: FilterResolvers<ContextType>;
  FiltersConnection?: FiltersConnectionResolvers<ContextType>;
  FiltersEdge?: FiltersEdgeResolvers<ContextType>;
  GrafanaDashboardImage?: GrafanaDashboardImageResolvers<ContextType>;
  GrafanaDashboardImagesConnection?: GrafanaDashboardImagesConnectionResolvers<ContextType>;
  GrafanaDashboardImagesEdge?: GrafanaDashboardImagesEdgeResolvers<ContextType>;
  JSON?: GraphQLScalarType;
  Mutation?: MutationResolvers<ContextType>;
  Node?: NodeResolvers<ContextType>;
  Notification?: NotificationResolvers<ContextType>;
  NotificationsConnection?: NotificationsConnectionResolvers<ContextType>;
  NotificationsEdge?: NotificationsEdgeResolvers<ContextType>;
  Organisation?: OrganisationResolvers<ContextType>;
  OrganisationApplicationJoin?: OrganisationApplicationJoinResolvers<ContextType>;
  OrganisationApplicationJoinsConnection?: OrganisationApplicationJoinsConnectionResolvers<ContextType>;
  OrganisationApplicationJoinsEdge?: OrganisationApplicationJoinsEdgeResolvers<ContextType>;
  OrganisationsConnection?: OrganisationsConnectionResolvers<ContextType>;
  OrganisationsEdge?: OrganisationsEdgeResolvers<ContextType>;
  PageInfo?: PageInfoResolvers<ContextType>;
  PermissionFlattened?: PermissionFlattenedResolvers<ContextType>;
  PermissionFlattenedsConnection?: PermissionFlattenedsConnectionResolvers<ContextType>;
  PermissionFlattenedsEdge?: PermissionFlattenedsEdgeResolvers<ContextType>;
  PermissionJoin?: PermissionJoinResolvers<ContextType>;
  PermissionJoinsConnection?: PermissionJoinsConnectionResolvers<ContextType>;
  PermissionJoinsEdge?: PermissionJoinsEdgeResolvers<ContextType>;
  PermissionName?: PermissionNameResolvers<ContextType>;
  PermissionNamesConnection?: PermissionNamesConnectionResolvers<ContextType>;
  PermissionNamesEdge?: PermissionNamesEdgeResolvers<ContextType>;
  PermissionPoliciesConnection?: PermissionPoliciesConnectionResolvers<ContextType>;
  PermissionPoliciesEdge?: PermissionPoliciesEdgeResolvers<ContextType>;
  PermissionPolicy?: PermissionPolicyResolvers<ContextType>;
  PermissionsAll?: PermissionsAllResolvers<ContextType>;
  PermissionsAllsConnection?: PermissionsAllsConnectionResolvers<ContextType>;
  PermissionsAllsEdge?: PermissionsAllsEdgeResolvers<ContextType>;
  PostgresRowLevel?: PostgresRowLevelResolvers<ContextType>;
  PostgresRowLevelsConnection?: PostgresRowLevelsConnectionResolvers<ContextType>;
  PostgresRowLevelsEdge?: PostgresRowLevelsEdgeResolvers<ContextType>;
  Query?: QueryResolvers<ContextType>;
  Review?: ReviewResolvers<ContextType>;
  ReviewAssignment?: ReviewAssignmentResolvers<ContextType>;
  ReviewAssignmentAssignedSectionsShape?: ReviewAssignmentAssignedSectionsShapeResolvers<ContextType>;
  ReviewAssignmentAssignedSectionsShapesConnection?: ReviewAssignmentAssignedSectionsShapesConnectionResolvers<ContextType>;
  ReviewAssignmentAssignedSectionsShapesEdge?: ReviewAssignmentAssignedSectionsShapesEdgeResolvers<ContextType>;
  ReviewAssignmentAssignerJoin?: ReviewAssignmentAssignerJoinResolvers<ContextType>;
  ReviewAssignmentAssignerJoinsConnection?: ReviewAssignmentAssignerJoinsConnectionResolvers<ContextType>;
  ReviewAssignmentAssignerJoinsEdge?: ReviewAssignmentAssignerJoinsEdgeResolvers<ContextType>;
  ReviewAssignmentsConnection?: ReviewAssignmentsConnectionResolvers<ContextType>;
  ReviewAssignmentsEdge?: ReviewAssignmentsEdgeResolvers<ContextType>;
  ReviewDecision?: ReviewDecisionResolvers<ContextType>;
  ReviewDecisionsConnection?: ReviewDecisionsConnectionResolvers<ContextType>;
  ReviewDecisionsEdge?: ReviewDecisionsEdgeResolvers<ContextType>;
  ReviewListConnection?: ReviewListConnectionResolvers<ContextType>;
  ReviewListEdge?: ReviewListEdgeResolvers<ContextType>;
  ReviewListRecord?: ReviewListRecordResolvers<ContextType>;
  ReviewResponse?: ReviewResponseResolvers<ContextType>;
  ReviewResponsesConnection?: ReviewResponsesConnectionResolvers<ContextType>;
  ReviewResponsesEdge?: ReviewResponsesEdgeResolvers<ContextType>;
  ReviewStatusHistoriesConnection?: ReviewStatusHistoriesConnectionResolvers<ContextType>;
  ReviewStatusHistoriesEdge?: ReviewStatusHistoriesEdgeResolvers<ContextType>;
  ReviewStatusHistory?: ReviewStatusHistoryResolvers<ContextType>;
  ReviewableQuestionEdge?: ReviewableQuestionEdgeResolvers<ContextType>;
  ReviewableQuestionsConnection?: ReviewableQuestionsConnectionResolvers<ContextType>;
  ReviewableQuestionsRecord?: ReviewableQuestionsRecordResolvers<ContextType>;
  ReviewsConnection?: ReviewsConnectionResolvers<ContextType>;
  ReviewsEdge?: ReviewsEdgeResolvers<ContextType>;
  SchemaColumn?: SchemaColumnResolvers<ContextType>;
  SchemaColumnsConnection?: SchemaColumnsConnectionResolvers<ContextType>;
  SchemaColumnsEdge?: SchemaColumnsEdgeResolvers<ContextType>;
  SingleApplicationDetailConnection?: SingleApplicationDetailConnectionResolvers<ContextType>;
  SingleApplicationDetailEdge?: SingleApplicationDetailEdgeResolvers<ContextType>;
  SingleApplicationDetailRecord?: SingleApplicationDetailRecordResolvers<ContextType>;
  SqlIdentifier?: GraphQLScalarType;
  SystemInfo?: SystemInfoResolvers<ContextType>;
  SystemInfosConnection?: SystemInfosConnectionResolvers<ContextType>;
  SystemInfosEdge?: SystemInfosEdgeResolvers<ContextType>;
  Template?: TemplateResolvers<ContextType>;
  TemplateAction?: TemplateActionResolvers<ContextType>;
  TemplateActionsConnection?: TemplateActionsConnectionResolvers<ContextType>;
  TemplateActionsEdge?: TemplateActionsEdgeResolvers<ContextType>;
  TemplateCategoriesConnection?: TemplateCategoriesConnectionResolvers<ContextType>;
  TemplateCategoriesEdge?: TemplateCategoriesEdgeResolvers<ContextType>;
  TemplateCategory?: TemplateCategoryResolvers<ContextType>;
  TemplateElement?: TemplateElementResolvers<ContextType>;
  TemplateElementsConnection?: TemplateElementsConnectionResolvers<ContextType>;
  TemplateElementsEdge?: TemplateElementsEdgeResolvers<ContextType>;
  TemplateFilterJoin?: TemplateFilterJoinResolvers<ContextType>;
  TemplateFilterJoinsConnection?: TemplateFilterJoinsConnectionResolvers<ContextType>;
  TemplateFilterJoinsEdge?: TemplateFilterJoinsEdgeResolvers<ContextType>;
  TemplatePermission?: TemplatePermissionResolvers<ContextType>;
  TemplatePermissionsConnection?: TemplatePermissionsConnectionResolvers<ContextType>;
  TemplatePermissionsEdge?: TemplatePermissionsEdgeResolvers<ContextType>;
  TemplateSection?: TemplateSectionResolvers<ContextType>;
  TemplateSectionsConnection?: TemplateSectionsConnectionResolvers<ContextType>;
  TemplateSectionsEdge?: TemplateSectionsEdgeResolvers<ContextType>;
  TemplateStage?: TemplateStageResolvers<ContextType>;
  TemplateStageReviewLevel?: TemplateStageReviewLevelResolvers<ContextType>;
  TemplateStageReviewLevelsConnection?: TemplateStageReviewLevelsConnectionResolvers<ContextType>;
  TemplateStageReviewLevelsEdge?: TemplateStageReviewLevelsEdgeResolvers<ContextType>;
  TemplateStagesConnection?: TemplateStagesConnectionResolvers<ContextType>;
  TemplateStagesEdge?: TemplateStagesEdgeResolvers<ContextType>;
  TemplatesConnection?: TemplatesConnectionResolvers<ContextType>;
  TemplatesEdge?: TemplatesEdgeResolvers<ContextType>;
  TriggerQueue?: TriggerQueueResolvers<ContextType>;
  TriggerQueuesConnection?: TriggerQueuesConnectionResolvers<ContextType>;
  TriggerQueuesEdge?: TriggerQueuesEdgeResolvers<ContextType>;
  TriggerSchedule?: TriggerScheduleResolvers<ContextType>;
  TriggerSchedulesConnection?: TriggerSchedulesConnectionResolvers<ContextType>;
  TriggerSchedulesEdge?: TriggerSchedulesEdgeResolvers<ContextType>;
  UnnestedSection?: UnnestedSectionResolvers<ContextType>;
  UnnestedSectionsConnection?: UnnestedSectionsConnectionResolvers<ContextType>;
  UnnestedSectionsEdge?: UnnestedSectionsEdgeResolvers<ContextType>;
  UpdateActionPluginPayload?: UpdateActionPluginPayloadResolvers<ContextType>;
  UpdateActionQueuePayload?: UpdateActionQueuePayloadResolvers<ContextType>;
  UpdateActivityLogPayload?: UpdateActivityLogPayloadResolvers<ContextType>;
  UpdateApplicationNotePayload?: UpdateApplicationNotePayloadResolvers<ContextType>;
  UpdateApplicationPayload?: UpdateApplicationPayloadResolvers<ContextType>;
  UpdateApplicationResponsePayload?: UpdateApplicationResponsePayloadResolvers<ContextType>;
  UpdateApplicationReviewerActionPayload?: UpdateApplicationReviewerActionPayloadResolvers<ContextType>;
  UpdateApplicationStageHistoryPayload?: UpdateApplicationStageHistoryPayloadResolvers<ContextType>;
  UpdateApplicationStatusHistoryPayload?: UpdateApplicationStatusHistoryPayloadResolvers<ContextType>;
  UpdateCounterPayload?: UpdateCounterPayloadResolvers<ContextType>;
  UpdateDataChangelogPayload?: UpdateDataChangelogPayloadResolvers<ContextType>;
  UpdateDataTableActiveIngredientPayload?: UpdateDataTableActiveIngredientPayloadResolvers<ContextType>;
  UpdateDataTableAdministrationRoutePayload?: UpdateDataTableAdministrationRoutePayloadResolvers<ContextType>;
  UpdateDataTableAtcCodePayload?: UpdateDataTableAtcCodePayloadResolvers<ContextType>;
  UpdateDataTableContainerPayload?: UpdateDataTableContainerPayloadResolvers<ContextType>;
  UpdateDataTableCountryPayload?: UpdateDataTableCountryPayloadResolvers<ContextType>;
  UpdateDataTableDosageFormGroupPayload?: UpdateDataTableDosageFormGroupPayloadResolvers<ContextType>;
  UpdateDataTableDosageFormPayload?: UpdateDataTableDosageFormPayloadResolvers<ContextType>;
  UpdateDataTableGenericIngredientPayload?: UpdateDataTableGenericIngredientPayloadResolvers<ContextType>;
  UpdateDataTableManufacturerApplicationJoinPayload?: UpdateDataTableManufacturerApplicationJoinPayloadResolvers<ContextType>;
  UpdateDataTableManufacturerPayload?: UpdateDataTableManufacturerPayloadResolvers<ContextType>;
  UpdateDataTableManufacturerRepresentativeApplicationJoinPayload?: UpdateDataTableManufacturerRepresentativeApplicationJoinPayloadResolvers<ContextType>;
  UpdateDataTableManufacturerRepresentativePayload?: UpdateDataTableManufacturerRepresentativePayloadResolvers<ContextType>;
  UpdateDataTablePayload?: UpdateDataTablePayloadResolvers<ContextType>;
  UpdateDataTablePermitChemicalApplicationJoinPayload?: UpdateDataTablePermitChemicalApplicationJoinPayloadResolvers<ContextType>;
  UpdateDataTablePermitChemicalPayload?: UpdateDataTablePermitChemicalPayloadResolvers<ContextType>;
  UpdateDataTablePreRegisteredProductsProvisionalPayload?: UpdateDataTablePreRegisteredProductsProvisionalPayloadResolvers<ContextType>;
  UpdateDataTablePrequalManufacturerApplicationJoinPayload?: UpdateDataTablePrequalManufacturerApplicationJoinPayloadResolvers<ContextType>;
  UpdateDataTablePrequalManufacturerPayload?: UpdateDataTablePrequalManufacturerPayloadResolvers<ContextType>;
  UpdateDataTableProcessingStepPayload?: UpdateDataTableProcessingStepPayloadResolvers<ContextType>;
  UpdateDataTableProductApplicationJoinPayload?: UpdateDataTableProductApplicationJoinPayloadResolvers<ContextType>;
  UpdateDataTableProductPayload?: UpdateDataTableProductPayloadResolvers<ContextType>;
  UpdateDataTableProvisionalProductApplicationJoinPayload?: UpdateDataTableProvisionalProductApplicationJoinPayloadResolvers<ContextType>;
  UpdateDataTableProvisionalProductPayload?: UpdateDataTableProvisionalProductPayloadResolvers<ContextType>;
  UpdateDataTableScheduledChemicalPayload?: UpdateDataTableScheduledChemicalPayloadResolvers<ContextType>;
  UpdateDataTableStorageConditionPayload?: UpdateDataTableStorageConditionPayloadResolvers<ContextType>;
  UpdateDataTableStorageConditionsSimplifiedPayload?: UpdateDataTableStorageConditionsSimplifiedPayloadResolvers<ContextType>;
  UpdateDataTableUnitsOfProportionPayload?: UpdateDataTableUnitsOfProportionPayloadResolvers<ContextType>;
  UpdateDataTableWorldHealthOrganisationPqListOfFppPayload?: UpdateDataTableWorldHealthOrganisationPqListOfFppPayloadResolvers<ContextType>;
  UpdateDataViewColumnDefinitionPayload?: UpdateDataViewColumnDefinitionPayloadResolvers<ContextType>;
  UpdateDataViewPayload?: UpdateDataViewPayloadResolvers<ContextType>;
  UpdateElementTypePluginPayload?: UpdateElementTypePluginPayloadResolvers<ContextType>;
  UpdateFilePayload?: UpdateFilePayloadResolvers<ContextType>;
  UpdateFilterPayload?: UpdateFilterPayloadResolvers<ContextType>;
  UpdateGrafanaDashboardImagePayload?: UpdateGrafanaDashboardImagePayloadResolvers<ContextType>;
  UpdateNotificationPayload?: UpdateNotificationPayloadResolvers<ContextType>;
  UpdateOrganisationApplicationJoinPayload?: UpdateOrganisationApplicationJoinPayloadResolvers<ContextType>;
  UpdateOrganisationPayload?: UpdateOrganisationPayloadResolvers<ContextType>;
  UpdatePermissionJoinPayload?: UpdatePermissionJoinPayloadResolvers<ContextType>;
  UpdatePermissionNamePayload?: UpdatePermissionNamePayloadResolvers<ContextType>;
  UpdatePermissionPolicyPayload?: UpdatePermissionPolicyPayloadResolvers<ContextType>;
  UpdateReviewAssignmentAssignerJoinPayload?: UpdateReviewAssignmentAssignerJoinPayloadResolvers<ContextType>;
  UpdateReviewAssignmentPayload?: UpdateReviewAssignmentPayloadResolvers<ContextType>;
  UpdateReviewDecisionPayload?: UpdateReviewDecisionPayloadResolvers<ContextType>;
  UpdateReviewPayload?: UpdateReviewPayloadResolvers<ContextType>;
  UpdateReviewResponsePayload?: UpdateReviewResponsePayloadResolvers<ContextType>;
  UpdateReviewStatusHistoryPayload?: UpdateReviewStatusHistoryPayloadResolvers<ContextType>;
  UpdateSystemInfoPayload?: UpdateSystemInfoPayloadResolvers<ContextType>;
  UpdateTemplateActionPayload?: UpdateTemplateActionPayloadResolvers<ContextType>;
  UpdateTemplateCategoryPayload?: UpdateTemplateCategoryPayloadResolvers<ContextType>;
  UpdateTemplateElementPayload?: UpdateTemplateElementPayloadResolvers<ContextType>;
  UpdateTemplateFilterJoinPayload?: UpdateTemplateFilterJoinPayloadResolvers<ContextType>;
  UpdateTemplatePayload?: UpdateTemplatePayloadResolvers<ContextType>;
  UpdateTemplatePermissionPayload?: UpdateTemplatePermissionPayloadResolvers<ContextType>;
  UpdateTemplateSectionPayload?: UpdateTemplateSectionPayloadResolvers<ContextType>;
  UpdateTemplateStagePayload?: UpdateTemplateStagePayloadResolvers<ContextType>;
  UpdateTemplateStageReviewLevelPayload?: UpdateTemplateStageReviewLevelPayloadResolvers<ContextType>;
  UpdateTriggerQueuePayload?: UpdateTriggerQueuePayloadResolvers<ContextType>;
  UpdateTriggerSchedulePayload?: UpdateTriggerSchedulePayloadResolvers<ContextType>;
  UpdateUserApplicationJoinPayload?: UpdateUserApplicationJoinPayloadResolvers<ContextType>;
  UpdateUserOrganisationPayload?: UpdateUserOrganisationPayloadResolvers<ContextType>;
  UpdateVerificationPayload?: UpdateVerificationPayloadResolvers<ContextType>;
  User?: UserResolvers<ContextType>;
  UserApplicationJoin?: UserApplicationJoinResolvers<ContextType>;
  UserApplicationJoinsConnection?: UserApplicationJoinsConnectionResolvers<ContextType>;
  UserApplicationJoinsEdge?: UserApplicationJoinsEdgeResolvers<ContextType>;
  UserList?: UserListResolvers<ContextType>;
  UserListsConnection?: UserListsConnectionResolvers<ContextType>;
  UserListsEdge?: UserListsEdgeResolvers<ContextType>;
  UserOrgJoin?: UserOrgJoinResolvers<ContextType>;
  UserOrgJoinsConnection?: UserOrgJoinsConnectionResolvers<ContextType>;
  UserOrgJoinsEdge?: UserOrgJoinsEdgeResolvers<ContextType>;
  UserOrganisation?: UserOrganisationResolvers<ContextType>;
  UserOrganisationsConnection?: UserOrganisationsConnectionResolvers<ContextType>;
  UserOrganisationsEdge?: UserOrganisationsEdgeResolvers<ContextType>;
  UsersConnection?: UsersConnectionResolvers<ContextType>;
  UsersEdge?: UsersEdgeResolvers<ContextType>;
  Verification?: VerificationResolvers<ContextType>;
  VerificationsConnection?: VerificationsConnectionResolvers<ContextType>;
  VerificationsEdge?: VerificationsEdgeResolvers<ContextType>;
  YesOrNo?: GraphQLScalarType;
};

