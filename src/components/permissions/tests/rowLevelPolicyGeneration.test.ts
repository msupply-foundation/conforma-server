import { getSqlConditionFromJSON } from '../helpersUtilities'
import { compileRowLevelPolicies, modifyValueInObject } from '../rowLevelPolicyHelpers'

//. Tests to quickly check what is generated by row level policy helpers

// Run these test with "yarn test rowLevelPolicyGeneration"

const sqlGenerationTestData = [{ json: { user_id: 1 }, sql: 'user_id = 1' }]
sqlGenerationTestData.forEach(({ json, sql }: any) => {
  test(`Checking generation of SQL condition`, () => {
    return expect(getSqlConditionFromJSON(json)).toEqual(sql)
  })
})

const preCheck = `COALESCE(current_setting('jwt.claims.pp1', true),'') != ''`
const userId = `COALESCE(nullif(current_setting('jwt.claims.userId', true),''),'0')::integer`
const rowLevelPolicyCompileTestData = [
  {
    json: { application: { view: { user_id: 'jwtUserDetails_bigint_userId' } } },
    policies: [
      `
    CREATE POLICY "view_pp1" ON "application" 
    FOR SELECT USING (${preCheck} AND user_id = ${userId})`,
    ],
  },

  {
    json: {
      review: {
        view: {
          application_id: {
            $in: {
              $select: {
                $from: 'review_assignment',
                $where: {
                  reviewer_id: 'jwtUserDetails_bigint_userId',
                },
                application_id: true,
              },
            },
          },
        },
      },
    },
    policies: [
      `
    CREATE OR REPLACE VIEW private.review_assignment WITH (security_invoker = false) AS select * from review_assignment`,
      `
    CREATE POLICY "view_pp1" ON "review" 
    FOR SELECT USING (${preCheck} AND application_id IN (SELECT application_id FROM private.review_assignment WHERE reviewer_id = ${userId}))`,
    ],
  },
]
rowLevelPolicyCompileTestData.forEach(
  ({ json, policies }: { json: object; policies: string[] }) => {
    test(`Checking generation of row policy SQL condition`, () => {
      return expect(
        compileRowLevelPolicies('pp1', json).map((r) => r.replace(/[ \n]/g, ''))
      ).toEqual(policies.map((r) => r.replace(/[ \n]/g, '')))
    })
  }
)

test(`Check modify in object`, () => {
  return expect(
    modifyValueInObject(
      {
        something: { $from: 'yow' },
        somethingElse: { nested: [], alsoNested: { $from: 'hi' } },
      },
      (key, value) => key == '$from' && typeof value == 'string',
      (value) => `private.${value}`
    )
  ).toEqual({
    something: { $from: 'private.yow' },
    somethingElse: { nested: [], alsoNested: { $from: 'private.hi' } },
  })
})
